; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLKGGCJO@LcOpen@			; `string'
PUBLIC	??_C@_06GJPHNGFG@LcRead@			; `string'
PUBLIC	??_C@_0O@CBBNAKKC@LcReadScatter@		; `string'
PUBLIC	??_C@_07MBHEMNEL@LcWrite@			; `string'
PUBLIC	??_C@_0P@DAJMPOFM@LcWriteScatter@		; `string'
PUBLIC	??_C@_0M@HBBFEIGD@LcGetOption@			; `string'
PUBLIC	??_C@_0M@FPFAGJPB@LcSetOption@			; `string'
PUBLIC	??_C@_09DCHLEDFD@LcCommand@			; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A@				; `string'
PUBLIC	??_C@_03HDGGCCPD@X86@				; `string'
PUBLIC	??_C@_06IDLKBMKC@X86PAE@			; `string'
PUBLIC	??_C@_03ELMOGNHL@X64@				; `string'
PUBLIC	??_C@_05DKFIPBAL@ARM64@				; `string'
PUBLIC	??_C@_04PCJGBDOP@Zero@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_07LNBDIIPN@Standby@			; `string'
PUBLIC	??_C@_07PFEKAJBJ@Modifiy@			; `string'
PUBLIC	??_C@_07DGKCKENG@ModNoWr@			; `string'
PUBLIC	??_C@_03KHCCLPOB@Bad@				; `string'
PUBLIC	??_C@_06MAFFGDO@Active@				; `string'
PUBLIC	??_C@_07KADDEKFE@Transit@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_06CGLFEPBO@Unused@			; `string'
PUBLIC	??_C@_08LBAJPEDB@ProcPriv@			; `string'
PUBLIC	??_C@_09BGPMMIPE@PageTable@			; `string'
PUBLIC	??_C@_09MFCNICMF@LargePage@			; `string'
PUBLIC	??_C@_0L@DHBAIELD@DriverLock@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_04PBAHLACE@File@				; `string'
PUBLIC	_Avx2WmemEnabledWeakValue
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04PBAHLACE@File@
CONST	SEGMENT
??_C@_04PBAHLACE@File@ DB 'File', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBAIELD@DriverLock@
CONST	SEGMENT
??_C@_0L@DHBAIELD@DriverLock@ DB 'DriverLock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCNICMF@LargePage@
CONST	SEGMENT
??_C@_09MFCNICMF@LargePage@ DB 'LargePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGPMMIPE@PageTable@
CONST	SEGMENT
??_C@_09BGPMMIPE@PageTable@ DB 'PageTable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBAJPEDB@ProcPriv@
CONST	SEGMENT
??_C@_08LBAJPEDB@ProcPriv@ DB 'ProcPriv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLFEPBO@Unused@
CONST	SEGMENT
??_C@_06CGLFEPBO@Unused@ DB 'Unused', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KADDEKFE@Transit@
CONST	SEGMENT
??_C@_07KADDEKFE@Transit@ DB 'Transit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAFFGDO@Active@
CONST	SEGMENT
??_C@_06MAFFGDO@Active@ DB 'Active', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHCCLPOB@Bad@
CONST	SEGMENT
??_C@_03KHCCLPOB@Bad@ DB 'Bad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGKCKENG@ModNoWr@
CONST	SEGMENT
??_C@_07DGKCKENG@ModNoWr@ DB 'ModNoWr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFEKAJBJ@Modifiy@
CONST	SEGMENT
??_C@_07PFEKAJBJ@Modifiy@ DB 'Modifiy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBDIIPN@Standby@
CONST	SEGMENT
??_C@_07LNBDIIPN@Standby@ DB 'Standby', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJGBDOP@Zero@
CONST	SEGMENT
??_C@_04PCJGBDOP@Zero@ DB 'Zero', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKFIPBAL@ARM64@
CONST	SEGMENT
??_C@_05DKFIPBAL@ARM64@ DB 'ARM64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMOGNHL@X64@
CONST	SEGMENT
??_C@_03ELMOGNHL@X64@ DB 'X64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLKBMKC@X86PAE@
CONST	SEGMENT
??_C@_06IDLKBMKC@X86PAE@ DB 'X86PAE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDGGCCPD@X86@
CONST	SEGMENT
??_C@_03HDGGCCPD@X86@ DB 'X86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A@ DB 'N/A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCHLEDFD@LcCommand@
CONST	SEGMENT
??_C@_09DCHLEDFD@LcCommand@ DB 'LcCommand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPFAGJPB@LcSetOption@
CONST	SEGMENT
??_C@_0M@FPFAGJPB@LcSetOption@ DB 'LcSetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFEIGD@LcGetOption@
CONST	SEGMENT
??_C@_0M@HBBFEIGD@LcGetOption@ DB 'LcGetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJMPOFM@LcWriteScatter@
CONST	SEGMENT
??_C@_0P@DAJMPOFM@LcWriteScatter@ DB 'LcWriteScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBHEMNEL@LcWrite@
CONST	SEGMENT
??_C@_07MBHEMNEL@LcWrite@ DB 'LcWrite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBNAKKC@LcReadScatter@
CONST	SEGMENT
??_C@_0O@CBBNAKKC@LcReadScatter@ DB 'LcReadScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJPHNGFG@LcRead@
CONST	SEGMENT
??_C@_06GJPHNGFG@LcRead@ DB 'LcRead', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKGGCJO@LcOpen@
CONST	SEGMENT
??_C@_06GLKGGCJO@LcOpen@ DB 'LcOpen', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	fabsf
PUBLIC	?abs@@YAMM@Z					; abs
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::move
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::WSInit
PUBLIC	??1WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::~WSInit
PUBLIC	??0SSLInit@detail@httplib@@QEAA@XZ		; httplib::detail::SSLInit::SSLInit
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	??0ImVec2@@QEAA@XZ				; ImVec2::ImVec2
PUBLIC	??0ImVec2@@QEAA@MM@Z				; ImVec2::ImVec2
PUBLIC	??AImVec2@@QEBAM_K@Z				; ImVec2::operator[]
PUBLIC	??AImVec2@@QEAAAEAM_K@Z				; ImVec2::operator[]
PUBLIC	??0ImVec4@@QEAA@XZ				; ImVec4::ImVec4
PUBLIC	??0ImVec4@@QEAA@MMMM@Z				; ImVec4::ImVec4
PUBLIC	?Separator@ImGui@@YAXXZ				; ImGui::Separator
PUBLIC	?NewLine@ImGui@@YAXXZ				; ImGui::NewLine
PUBLIC	?Spacing@ImGui@@YAXXZ				; ImGui::Spacing
PUBLIC	?Dummy@ImGui@@YAXAEBUImVec2@@@Z			; ImGui::Dummy
PUBLIC	?AlignTextToFramePadding@ImGui@@YAXXZ		; ImGui::AlignTextToFramePadding
PUBLIC	?TextUnformatted@ImGui@@YAXPEBD0@Z		; ImGui::TextUnformatted
PUBLIC	?TextUnformatted2@ImGui@@YAXPEBD0@Z		; ImGui::TextUnformatted2
PUBLIC	?Text@ImGui@@YAXPEBDZZ				; ImGui::Text
PUBLIC	?TextV@ImGui@@YAXPEBDPEAD@Z			; ImGui::TextV
PUBLIC	?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ	; ImGui::TextColored
PUBLIC	?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z	; ImGui::TextColoredV
PUBLIC	?TextDisabled@ImGui@@YAXPEBDZZ			; ImGui::TextDisabled
PUBLIC	?TextDisabledV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextDisabledV
PUBLIC	?TextWrapped@ImGui@@YAXPEBDZZ			; ImGui::TextWrapped
PUBLIC	?TextWrappedV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextWrappedV
PUBLIC	?LabelText@ImGui@@YAXPEBD0ZZ			; ImGui::LabelText
PUBLIC	?LabelTextV@ImGui@@YAXPEBD0PEAD@Z		; ImGui::LabelTextV
PUBLIC	?BulletText@ImGui@@YAXPEBDZZ			; ImGui::BulletText
PUBLIC	?BulletTextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::BulletTextV
PUBLIC	?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z		; ImGui::Button
PUBLIC	?SmallButton@ImGui@@YA_NPEBD@Z			; ImGui::SmallButton
PUBLIC	?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@@Z	; ImGui::InvisibleButton
PUBLIC	?ArrowButton@ImGui@@YA_NPEBDH@Z			; ImGui::ArrowButton
PUBLIC	?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z ; ImGui::Image
PUBLIC	?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z ; ImGui::ImageButton
PUBLIC	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z		; ImGui::Checkbox
PUBLIC	?Checkbox1@ImGui@@YA_NPEBDPEAHPEAM@Z		; ImGui::Checkbox1
PUBLIC	?Checkbox2@ImGui@@YA_NPEBDPEAH@Z		; ImGui::Checkbox2
PUBLIC	?ToggleButton@ImGui@@YA_NPEBDPEA_NMMM@Z		; ImGui::ToggleButton
PUBLIC	?CheckboxFlags@ImGui@@YA_NPEBDPEAII@Z		; ImGui::CheckboxFlags
PUBLIC	?RadioButton@ImGui@@YA_NPEBD_N@Z		; ImGui::RadioButton
PUBLIC	?RadioButton@ImGui@@YA_NPEBDPEAHH@Z		; ImGui::RadioButton
PUBLIC	?ProgressBar@ImGui@@YAXMAEBUImVec2@@PEBD@Z	; ImGui::ProgressBar
PUBLIC	?Bullet@ImGui@@YAXXZ				; ImGui::Bullet
PUBLIC	?BeginCombo@ImGui@@YA_NPEBD0H@Z			; ImGui::BeginCombo
PUBLIC	?EndCombo@ImGui@@YAXXZ				; ImGui::EndCombo
PUBLIC	?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z		; ImGui::Combo
PUBLIC	?Combo@ImGui@@YA_NPEBDPEAH0H@Z			; ImGui::Combo
PUBLIC	?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z ; ImGui::Combo
PUBLIC	?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z	; ImGui::MultiCombo
PUBLIC	?DragFloat@ImGui@@YA_NPEBDPEAMMMM0M@Z		; ImGui::DragFloat
PUBLIC	?DragFloat2@ImGui@@YA_NPEBDQEAMMMM0M@Z		; ImGui::DragFloat2
PUBLIC	?DragFloat3@ImGui@@YA_NPEBDQEAMMMM0M@Z		; ImGui::DragFloat3
PUBLIC	?DragFloat4@ImGui@@YA_NPEBDQEAMMMM0M@Z		; ImGui::DragFloat4
PUBLIC	?DragFloatRange2@ImGui@@YA_NPEBDPEAM1MMM00M@Z	; ImGui::DragFloatRange2
PUBLIC	?DragInt@ImGui@@YA_NPEBDPEAHMHH0@Z		; ImGui::DragInt
PUBLIC	?DragInt2@ImGui@@YA_NPEBDQEAHMHH0@Z		; ImGui::DragInt2
PUBLIC	?DragInt3@ImGui@@YA_NPEBDQEAHMHH0@Z		; ImGui::DragInt3
PUBLIC	?DragInt4@ImGui@@YA_NPEBDQEAHMHH0@Z		; ImGui::DragInt4
PUBLIC	?DragIntRange2@ImGui@@YA_NPEBDPEAH1MHH00@Z	; ImGui::DragIntRange2
PUBLIC	?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20M@Z	; ImGui::DragScalar
PUBLIC	?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z	; ImGui::DragScalarN
PUBLIC	?SliderFloat@ImGui@@YA_NPEBDPEAMMM0M_N@Z	; ImGui::SliderFloat
PUBLIC	?SliderFloat2@ImGui@@YA_NPEBDQEAMMM0M@Z		; ImGui::SliderFloat2
PUBLIC	?SliderFloat3@ImGui@@YA_NPEBDQEAMMM0M@Z		; ImGui::SliderFloat3
PUBLIC	?SliderFloat4@ImGui@@YA_NPEBDQEAMMM0M@Z		; ImGui::SliderFloat4
PUBLIC	?SliderAngle@ImGui@@YA_NPEBDPEAMMM0@Z		; ImGui::SliderAngle
PUBLIC	?SliderInt@ImGui@@YA_NPEBDPEAHHH0_N@Z		; ImGui::SliderInt
PUBLIC	?SliderInt2@ImGui@@YA_NPEBDQEAHHH0@Z		; ImGui::SliderInt2
PUBLIC	?SliderInt3@ImGui@@YA_NPEBDQEAHHH0@Z		; ImGui::SliderInt3
PUBLIC	?SliderInt4@ImGui@@YA_NPEBDQEAHHH0@Z		; ImGui::SliderInt4
PUBLIC	?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20M_N@Z	; ImGui::SliderScalar
PUBLIC	?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z	; ImGui::SliderScalarN
PUBLIC	?VSliderFloat@ImGui@@YA_NPEBDAEBUImVec2@@PEAMMM0M@Z ; ImGui::VSliderFloat
PUBLIC	?VSliderInt@ImGui@@YA_NPEBDAEBUImVec2@@PEAHHH0@Z ; ImGui::VSliderInt
PUBLIC	?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30M@Z ; ImGui::VSliderScalar
PUBLIC	?RenderTextOverlay@ImGui@@YAXUImVec2@@PEBD1_N@Z	; ImGui::RenderTextOverlay
PUBLIC	?InputText@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputText
PUBLIC	?InputTextMultiline@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextMultiline
PUBLIC	?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputText
PUBLIC	?InputTextMultiline@ImGui@@YA_NPEBDPEAD_KAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextMultiline
PUBLIC	?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z		; ImGui::InputFloat
PUBLIC	?InputFloat2@ImGui@@YA_NPEBDQEAM0H@Z		; ImGui::InputFloat2
PUBLIC	?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z		; ImGui::InputFloat3
PUBLIC	?InputFloat4@ImGui@@YA_NPEBDQEAM0H@Z		; ImGui::InputFloat4
PUBLIC	?InputInt@ImGui@@YA_NPEBDPEAHHHH@Z		; ImGui::InputInt
PUBLIC	?InputInt2@ImGui@@YA_NPEBDQEAHH@Z		; ImGui::InputInt2
PUBLIC	?InputInt3@ImGui@@YA_NPEBDQEAHH@Z		; ImGui::InputInt3
PUBLIC	?InputInt4@ImGui@@YA_NPEBDQEAHH@Z		; ImGui::InputInt4
PUBLIC	?InputDouble@ImGui@@YA_NPEBDPEANNN0H@Z		; ImGui::InputDouble
PUBLIC	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z	; ImGui::InputScalar
PUBLIC	?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z	; ImGui::InputScalarN
PUBLIC	?ColorEdit3@ImGui@@YA_NPEBDQEAMH@Z		; ImGui::ColorEdit3
PUBLIC	?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z		; ImGui::ColorEdit4
PUBLIC	?ColorPicker3@ImGui@@YA_NPEBDQEAMH@Z		; ImGui::ColorPicker3
PUBLIC	?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z	; ImGui::ColorPicker4
PUBLIC	?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z ; ImGui::ColorButton
PUBLIC	?SetColorEditOptions@ImGui@@YAXH@Z		; ImGui::SetColorEditOptions
PUBLIC	?BufferingBar@ImGui@@YA_NPEBDMAEBUImVec2@@AEBI2@Z ; ImGui::BufferingBar
PUBLIC	?Spinner@ImGui@@YA_NPEBDMHAEBI@Z		; ImGui::Spinner
PUBLIC	?TreeNode@ImGui@@YA_NPEBD@Z			; ImGui::TreeNode
PUBLIC	?TreeNode@ImGui@@YA_NPEBD0ZZ			; ImGui::TreeNode
PUBLIC	?TreeNode@ImGui@@YA_NPEBXPEBDZZ			; ImGui::TreeNode
PUBLIC	?TreeNodeV@ImGui@@YA_NPEBD0PEAD@Z		; ImGui::TreeNodeV
PUBLIC	?TreeNodeV@ImGui@@YA_NPEBXPEBDPEAD@Z		; ImGui::TreeNodeV
PUBLIC	?TreeNodeEx@ImGui@@YA_NPEBDH@Z			; ImGui::TreeNodeEx
PUBLIC	?TreeNodeEx@ImGui@@YA_NPEBDH0ZZ			; ImGui::TreeNodeEx
PUBLIC	?TreeNodeEx@ImGui@@YA_NPEBXHPEBDZZ		; ImGui::TreeNodeEx
PUBLIC	?TreeNodeExV@ImGui@@YA_NPEBDH0PEAD@Z		; ImGui::TreeNodeExV
PUBLIC	?TreeNodeExV@ImGui@@YA_NPEBXHPEBDPEAD@Z		; ImGui::TreeNodeExV
PUBLIC	?TreePush@ImGui@@YAXPEBD@Z			; ImGui::TreePush
PUBLIC	?TreePush@ImGui@@YAXPEBX@Z			; ImGui::TreePush
PUBLIC	?TreePop@ImGui@@YAXXZ				; ImGui::TreePop
PUBLIC	?TreeAdvanceToLabelPos@ImGui@@YAXXZ		; ImGui::TreeAdvanceToLabelPos
PUBLIC	?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ		; ImGui::GetTreeNodeToLabelSpacing
PUBLIC	?SetNextTreeNodeOpen@ImGui@@YAX_NH@Z		; ImGui::SetNextTreeNodeOpen
PUBLIC	?CollapsingHeader@ImGui@@YA_NPEBDH@Z		; ImGui::CollapsingHeader
PUBLIC	?CollapsingHeader@ImGui@@YA_NPEBDPEA_NH@Z	; ImGui::CollapsingHeader
PUBLIC	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z	; ImGui::Selectable
PUBLIC	?Selectable@ImGui@@YA_NPEBDPEA_NHAEBUImVec2@@@Z	; ImGui::Selectable
PUBLIC	?ListBox@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z		; ImGui::ListBox
PUBLIC	?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z ; ImGui::ListBox
PUBLIC	?ListBoxHeader@ImGui@@YA_NPEBDAEBUImVec2@@@Z	; ImGui::ListBoxHeader
PUBLIC	?ListBoxHeader@ImGui@@YA_NPEBDHH@Z		; ImGui::ListBoxHeader
PUBLIC	?ListBoxFooter@ImGui@@YAXXZ			; ImGui::ListBoxFooter
PUBLIC	?PlotLines@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z	; ImGui::PlotLines
PUBLIC	?PlotLines@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z ; ImGui::PlotLines
PUBLIC	?PlotHistogram@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z ; ImGui::PlotHistogram
PUBLIC	?PlotHistogram@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z ; ImGui::PlotHistogram
PUBLIC	?Value@ImGui@@YAXPEBD_N@Z			; ImGui::Value
PUBLIC	?Value@ImGui@@YAXPEBDH@Z			; ImGui::Value
PUBLIC	?Value@ImGui@@YAXPEBDI@Z			; ImGui::Value
PUBLIC	?Value@ImGui@@YAXPEBDM0@Z			; ImGui::Value
PUBLIC	?BeginMainMenuBar@ImGui@@YA_NXZ			; ImGui::BeginMainMenuBar
PUBLIC	?EndMainMenuBar@ImGui@@YAXXZ			; ImGui::EndMainMenuBar
PUBLIC	?BeginMenuBar@ImGui@@YA_NXZ			; ImGui::BeginMenuBar
PUBLIC	?EndMenuBar@ImGui@@YAXXZ			; ImGui::EndMenuBar
PUBLIC	?BeginMenu@ImGui@@YA_NPEBD_N@Z			; ImGui::BeginMenu
PUBLIC	?EndMenu@ImGui@@YAXXZ				; ImGui::EndMenu
PUBLIC	?MenuItem@ImGui@@YA_NPEBD0_N1@Z			; ImGui::MenuItem
PUBLIC	?MenuItem@ImGui@@YA_NPEBD0PEA_N_N@Z		; ImGui::MenuItem
PUBLIC	?BeginTabBar@ImGui@@YA_NPEBDH@Z			; ImGui::BeginTabBar
PUBLIC	?EndTabBar@ImGui@@YAXXZ				; ImGui::EndTabBar
PUBLIC	?BeginTabItem@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::BeginTabItem
PUBLIC	?EndTabItem@ImGui@@YAXXZ			; ImGui::EndTabItem
PUBLIC	?SetTabItemClosed@ImGui@@YAXPEBD@Z		; ImGui::SetTabItemClosed
PUBLIC	??A?$ImVector@G@@QEAAAEAGH@Z			; ImVector<unsigned short>::operator[]
PUBLIC	??A?$ImVector@G@@QEBAAEBGH@Z			; ImVector<unsigned short>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@G@@QEBAHH@Z		; ImVector<unsigned short>::_grow_capacity
PUBLIC	?resize@?$ImVector@G@@QEAAXH@Z			; ImVector<unsigned short>::resize
PUBLIC	?reserve@?$ImVector@G@@QEAAXH@Z			; ImVector<unsigned short>::reserve
PUBLIC	?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z ; ImGuiInputTextCallbackData::InsertChars
PUBLIC	??0ImGuiInputTextCallbackData@@QEAA@XZ		; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData
PUBLIC	?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z ; ImGuiInputTextCallbackData::DeleteChars
PUBLIC	?InputFloat@ImGui@@YA_NPEBDPEAMMMHH@Z		; ImGui::InputFloat
PUBLIC	?InputFloat2@ImGui@@YA_NPEBDQEAMHH@Z		; ImGui::InputFloat2
PUBLIC	?InputFloat3@ImGui@@YA_NPEBDQEAMHH@Z		; ImGui::InputFloat3
PUBLIC	?InputFloat4@ImGui@@YA_NPEBDQEAMHH@Z		; ImGui::InputFloat4
PUBLIC	??2@YAPEAX_KUImNewDummy@@PEAX@Z			; operator new
PUBLIC	??3@YAXPEAXUImNewDummy@@0@Z			; operator delete
PUBLIC	??0?$ImVector@D@@QEAA@XZ			; ImVector<char>::ImVector<char>
PUBLIC	??1?$ImVector@D@@QEAA@XZ			; ImVector<char>::~ImVector<char>
PUBLIC	?_grow_capacity@?$ImVector@D@@QEBAHH@Z		; ImVector<char>::_grow_capacity
PUBLIC	?resize@?$ImVector@D@@QEAAXH@Z			; ImVector<char>::resize
PUBLIC	?reserve@?$ImVector@D@@QEAAXH@Z			; ImVector<char>::reserve
PUBLIC	??0ImGuiTextBuffer@@QEAA@XZ			; ImGuiTextBuffer::ImGuiTextBuffer
PUBLIC	?size@ImGuiTextBuffer@@QEBAHXZ			; ImGuiTextBuffer::size
PUBLIC	??1ImGuiTextBuffer@@QEAA@XZ			; ImGuiTextBuffer::~ImGuiTextBuffer
PUBLIC	??0ImGuiListClipper@@QEAA@HM@Z			; ImGuiListClipper::ImGuiListClipper
PUBLIC	??1ImGuiListClipper@@QEAA@XZ			; ImGuiListClipper::~ImGuiListClipper
PUBLIC	??0ImColor@@QEAA@HHHH@Z				; ImColor::ImColor
PUBLIC	??BImColor@@QEBAIXZ				; ImColor::operator unsigned int
PUBLIC	?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z	; ImVector<ImVec2>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z		; ImVector<ImVec2>::reserve
PUBLIC	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
PUBLIC	?PathClear@ImDrawList@@QEAAXXZ			; ImDrawList::PathClear
PUBLIC	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z	; ImDrawList::PathLineTo
PUBLIC	?PathFillConvex@ImDrawList@@QEAAXI@Z		; ImDrawList::PathFillConvex
PUBLIC	?PathStroke@ImDrawList@@QEAAXI_NM@Z		; ImDrawList::PathStroke
PUBLIC	?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z	; ImDrawList::PrimWriteVtx
PUBLIC	?PrimWriteIdx@ImDrawList@@QEAAXG@Z		; ImDrawList::PrimWriteIdx
PUBLIC	?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z	; ImDrawList::PrimVtx
PUBLIC	??A?$ImVector@M@@QEBAAEBMH@Z			; ImVector<float>::operator[]
PUBLIC	?GetCharAdvance@ImFont@@QEBAMG@Z		; ImFont::GetCharAdvance
PUBLIC	?ImParseFormatFindStart@@YAPEBDPEBD@Z		; ImParseFormatFindStart
PUBLIC	?ImParseFormatFindEnd@@YAPEBDPEBD@Z		; ImParseFormatFindEnd
PUBLIC	?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z ; ImParseFormatTrimDecorations
PUBLIC	?ImParseFormatPrecision@@YAHPEBDH@Z		; ImParseFormatPrecision
PUBLIC	??0ImRect@@QEAA@XZ				; ImRect::ImRect
PUBLIC	??0ImRect@@QEAA@AEBUImVec2@@0@Z			; ImRect::ImRect
PUBLIC	??0ImRect@@QEAA@AEBUImVec4@@@Z			; ImRect::ImRect
PUBLIC	??0ImRect@@QEAA@MMMM@Z				; ImRect::ImRect
PUBLIC	?GetCenter@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetCenter
PUBLIC	?GetSize@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetSize
PUBLIC	?GetWidth@ImRect@@QEBAMXZ			; ImRect::GetWidth
PUBLIC	?GetHeight@ImRect@@QEBAMXZ			; ImRect::GetHeight
PUBLIC	?GetTL@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetTL
PUBLIC	?GetTR@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetTR
PUBLIC	?GetBL@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetBL
PUBLIC	?GetBR@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetBR
PUBLIC	?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z		; ImRect::Contains
PUBLIC	?Contains@ImRect@@QEBA_NAEBU1@@Z		; ImRect::Contains
PUBLIC	?Overlaps@ImRect@@QEBA_NAEBU1@@Z		; ImRect::Overlaps
PUBLIC	?Expand@ImRect@@QEAAXM@Z			; ImRect::Expand
PUBLIC	?Expand@ImRect@@QEAAXAEBUImVec2@@@Z		; ImRect::Expand
PUBLIC	?Translate@ImRect@@QEAAXAEBUImVec2@@@Z		; ImRect::Translate
PUBLIC	?ClipWith@ImRect@@QEAAXAEBU1@@Z			; ImRect::ClipWith
PUBLIC	??0ImGuiMenuColumns@@QEAA@XZ			; ImGuiMenuColumns::ImGuiMenuColumns
PUBLIC	?Update@ImGuiMenuColumns@@QEAAXHM_N@Z		; ImGuiMenuColumns::Update
PUBLIC	?DeclColumns@ImGuiMenuColumns@@QEAAMMMM@Z	; ImGuiMenuColumns::DeclColumns
PUBLIC	?CalcExtraSpace@ImGuiMenuColumns@@QEAAMM@Z	; ImGuiMenuColumns::CalcExtraSpace
PUBLIC	?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ	; ImGuiInputTextState::CursorAnimReset
PUBLIC	?CursorClamp@ImGuiInputTextState@@QEAAXXZ	; ImGuiInputTextState::CursorClamp
PUBLIC	?HasSelection@ImGuiInputTextState@@QEBA_NXZ	; ImGuiInputTextState::HasSelection
PUBLIC	?ClearSelection@ImGuiInputTextState@@QEAAXXZ	; ImGuiInputTextState::ClearSelection
PUBLIC	?SelectAll@ImGuiInputTextState@@QEAAXXZ		; ImGuiInputTextState::SelectAll
PUBLIC	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z	; ImGuiInputTextState::OnKeyPressed
PUBLIC	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
PUBLIC	??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QEBAHH@Z ; ImVector<ImGuiTabBar>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z	; ImVector<ImGuiTabBar>::resize
PUBLIC	?reserve@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z	; ImVector<ImGuiTabBar>::reserve
PUBLIC	?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@I@Z ; ImPool<ImGuiTabBar>::GetOrAddByKey
PUBLIC	?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ ; ImPool<ImGuiTabBar>::Add
PUBLIC	??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z ; ImVector<ImGuiTabBarSortItem>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UImGuiTabBarSortItem@@@@QEBAHH@Z ; ImVector<ImGuiTabBarSortItem>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z ; ImVector<ImGuiTabBarSortItem>::resize
PUBLIC	?reserve@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z ; ImVector<ImGuiTabBarSortItem>::reserve
PUBLIC	?back@?$ImVector@PEAUImGuiTabBar@@@@QEAAAEAPEAUImGuiTabBar@@XZ ; ImVector<ImGuiTabBar *>::back
PUBLIC	?_grow_capacity@?$ImVector@PEAUImGuiTabBar@@@@QEBAHH@Z ; ImVector<ImGuiTabBar *>::_grow_capacity
PUBLIC	?reserve@?$ImVector@PEAUImGuiTabBar@@@@QEAAXH@Z	; ImVector<ImGuiTabBar *>::reserve
PUBLIC	?push_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXAEBQEAUImGuiTabBar@@@Z ; ImVector<ImGuiTabBar *>::push_back
PUBLIC	?pop_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXXZ	; ImVector<ImGuiTabBar *>::pop_back
PUBLIC	?empty@?$ImVector@UImGuiGroupData@@@@QEBA_NXZ	; ImVector<ImGuiGroupData>::empty
PUBLIC	?back@?$ImVector@UImGuiGroupData@@@@QEAAAEAUImGuiGroupData@@XZ ; ImVector<ImGuiGroupData>::back
PUBLIC	?back@?$ImVector@I@@QEAAAEAIXZ			; ImVector<unsigned int>::back
PUBLIC	?_grow_capacity@?$ImVector@I@@QEBAHH@Z		; ImVector<unsigned int>::_grow_capacity
PUBLIC	?reserve@?$ImVector@I@@QEAAXH@Z			; ImVector<unsigned int>::reserve
PUBLIC	?push_back@?$ImVector@I@@QEAAXAEBI@Z		; ImVector<unsigned int>::push_back
PUBLIC	?pop_back@?$ImVector@I@@QEAAXXZ			; ImVector<unsigned int>::pop_back
PUBLIC	?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ		; ImGuiWindow::Rect
PUBLIC	?CalcFontSize@ImGuiWindow@@QEBAMXZ		; ImGuiWindow::CalcFontSize
PUBLIC	?TitleBarHeight@ImGuiWindow@@QEBAMXZ		; ImGuiWindow::TitleBarHeight
PUBLIC	?MenuBarHeight@ImGuiWindow@@QEBAMXZ		; ImGuiWindow::MenuBarHeight
PUBLIC	?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ	; ImGuiWindow::MenuBarRect
PUBLIC	??0ImGuiItemHoveredDataBackup@@QEAA@XZ		; ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup
PUBLIC	?Backup@ImGuiItemHoveredDataBackup@@QEAAXXZ	; ImGuiItemHoveredDataBackup::Backup
PUBLIC	?Restore@ImGuiItemHoveredDataBackup@@QEBAXXZ	; ImGuiItemHoveredDataBackup::Restore
PUBLIC	??0ImGuiTabItem@@QEAA@XZ			; ImGuiTabItem::ImGuiTabItem
PUBLIC	??0?$ImVector@UImGuiTabItem@@@@QEAA@XZ		; ImVector<ImGuiTabItem>::ImVector<ImGuiTabItem>
PUBLIC	??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ		; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>
PUBLIC	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
PUBLIC	?back@?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@XZ ; ImVector<ImGuiTabItem>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z ; ImVector<ImGuiTabItem>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z	; ImVector<ImGuiTabItem>::resize
PUBLIC	?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z	; ImVector<ImGuiTabItem>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z ; ImVector<ImGuiTabItem>::push_back
PUBLIC	?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z ; ImVector<ImGuiTabItem>::erase
PUBLIC	?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QEBAHPEBUImGuiTabItem@@@Z ; ImVector<ImGuiTabItem>::index_from_ptr
PUBLIC	??0ImGuiTabBar@@QEAA@XZ				; ImGuiTabBar::ImGuiTabBar
PUBLIC	?GetTabOrder@ImGuiTabBar@@QEBAHPEBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabOrder
PUBLIC	?GetTabName@ImGuiTabBar@@QEBAPEBDPEBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabName
PUBLIC	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ	; ImGui::GetCurrentWindow
PUBLIC	?IsKeyPressedMap@ImGui@@YA_NH_N@Z		; ImGui::IsKeyPressedMap
PUBLIC	?IsNavInputDown@ImGui@@YA_NH@Z			; ImGui::IsNavInputDown
PUBLIC	?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressed
PUBLIC	?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@H@Z ; ImGui::BeginTabBarEx
PUBLIC	?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
PUBLIC	?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z	; ImGui::TabBarRemoveTab
PUBLIC	?TabBarCloseTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z ; ImGui::TabBarCloseTab
PUBLIC	?TabBarQueueChangeTabOrder@ImGui@@YAXPEAUImGuiTabBar@@PEBUImGuiTabItem@@H@Z ; ImGui::TabBarQueueChangeTabOrder
PUBLIC	?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NH@Z ; ImGui::TabItemEx
PUBLIC	?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z	; ImGui::TabItemCalcSize
PUBLIC	?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z ; ImGui::TabItemBackground
PUBLIC	?TabItemLabelAndCloseButton@ImGui@@YA_NPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII@Z ; ImGui::TabItemLabelAndCloseButton
PUBLIC	?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z ; ImGui::RenderColorRectWithAlphaCheckerboard
PUBLIC	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z	; ImGui::ButtonEx
PUBLIC	?CloseButton@ImGui@@YA_NIAEBUImVec2@@M@Z	; ImGui::CloseButton
PUBLIC	?CollapseButton@ImGui@@YA_NIAEBUImVec2@@@Z	; ImGui::CollapseButton
PUBLIC	?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z	; ImGui::ArrowButtonEx
PUBLIC	?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z		; ImGui::Scrollbar
PUBLIC	?GetScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z ; ImGui::GetScrollbarID
PUBLIC	?VerticalSeparator@ImGui@@YAXXZ			; ImGui::VerticalSeparator
PUBLIC	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
PUBLIC	?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDMH@Z	; ImGui::DragBehavior
PUBLIC	?SliderBehavior@ImGui@@YA_NAEBUImRect@@IHPEAXPEBX2PEBDMHPEAU2@@Z ; ImGui::SliderBehavior
PUBLIC	?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMM@Z ; ImGui::SplitterBehavior
PUBLIC	?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z		; ImGui::TreeNodeBehavior
PUBLIC	?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z		; ImGui::TreeNodeBehaviorIsOpen
PUBLIC	?TreePushRawID@ImGui@@YAXI@Z			; ImGui::TreePushRawID
PUBLIC	?InputTextEx@ImGui@@YA_NPEBDPEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextEx
PUBLIC	?InputScalarAsWidgetReplacement@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1@Z ; ImGui::InputScalarAsWidgetReplacement
PUBLIC	?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z		; ImGui::ColorTooltip
PUBLIC	?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z	; ImGui::ColorEditOptionsPopup
PUBLIC	?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z	; ImGui::ColorPickerOptionsPopup
PUBLIC	?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PEBDP6AMPEAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
PUBLIC	??1ImGuiDataTypeInfo@@QEAA@XZ			; ImGuiDataTypeInfo::~ImGuiDataTypeInfo
PUBLIC	??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDMH@Z ; ImGui::DragBehaviorT<int,int,float>
PUBLIC	??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDMH@Z ; ImGui::DragBehaviorT<unsigned int,int,float>
PUBLIC	??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDMH@Z ; ImGui::DragBehaviorT<__int64,__int64,double>
PUBLIC	??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDMH@Z ; ImGui::DragBehaviorT<unsigned __int64,__int64,double>
PUBLIC	??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDMH@Z ; ImGui::DragBehaviorT<float,float,float>
PUBLIC	??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDMH@Z ; ImGui::DragBehaviorT<double,double,double>
PUBLIC	??$SliderBehaviorT@HHM@ImGui@@YA_NAEBUImRect@@IHPEAHHHPEBDMHPEAU1@@Z ; ImGui::SliderBehaviorT<int,int,float>
PUBLIC	??$SliderBehaviorT@IHM@ImGui@@YA_NAEBUImRect@@IHPEAIIIPEBDMHPEAU1@@Z ; ImGui::SliderBehaviorT<unsigned int,int,float>
PUBLIC	??$SliderBehaviorT@_J_JN@ImGui@@YA_NAEBUImRect@@IHPEA_J_J2PEBDMHPEAU1@@Z ; ImGui::SliderBehaviorT<__int64,__int64,double>
PUBLIC	??$SliderBehaviorT@_K_JN@ImGui@@YA_NAEBUImRect@@IHPEA_K_K2PEBDMHPEAU1@@Z ; ImGui::SliderBehaviorT<unsigned __int64,__int64,double>
PUBLIC	??$SliderBehaviorT@MMM@ImGui@@YA_NAEBUImRect@@IHPEAMMMPEBDMHPEAU1@@Z ; ImGui::SliderBehaviorT<float,float,float>
PUBLIC	??$SliderBehaviorT@NNN@ImGui@@YA_NAEBUImRect@@IHPEANNNPEBDMHPEAU1@@Z ; ImGui::SliderBehaviorT<double,double,double>
PUBLIC	??0ImGuiPlotArrayGetterData@@QEAA@PEBMH@Z	; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Max_limit@_J@std@@YA_JXZ			; std::_Max_limit<__int64>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$RoundScalarWithFormatT@HH@ImGui@@YAHPEBDHH@Z	; ImGui::RoundScalarWithFormatT<int,int>
PUBLIC	??$RoundScalarWithFormatT@IH@ImGui@@YAIPEBDHI@Z	; ImGui::RoundScalarWithFormatT<unsigned int,int>
PUBLIC	??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPEBDH_J@Z ; ImGui::RoundScalarWithFormatT<__int64,__int64>
PUBLIC	??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPEBDH_K@Z ; ImGui::RoundScalarWithFormatT<unsigned __int64,__int64>
PUBLIC	??$RoundScalarWithFormatT@MM@ImGui@@YAMPEBDHM@Z	; ImGui::RoundScalarWithFormatT<float,float>
PUBLIC	??$RoundScalarWithFormatT@NN@ImGui@@YANPEBDHN@Z	; ImGui::RoundScalarWithFormatT<double,double>
PUBLIC	??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z ; ImGui::SliderCalcRatioFromValueT<int,float>
PUBLIC	??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z ; ImGui::SliderCalcRatioFromValueT<unsigned int,float>
PUBLIC	??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z ; ImGui::SliderCalcRatioFromValueT<__int64,double>
PUBLIC	??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z ; ImGui::SliderCalcRatioFromValueT<unsigned __int64,double>
PUBLIC	??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z ; ImGui::SliderCalcRatioFromValueT<float,float>
PUBLIC	??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z ; ImGui::SliderCalcRatioFromValueT<double,double>
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z	; std::forward<char * &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z ; <lambda_f3a66ab6a0570788f31503db83886f49>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const *,unsigned __int64>
PUBLIC	??$?0$0A@@id@locale@std@@QEAA@XZ		; std::locale::id::id<0>
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5@				; `string'
PUBLIC	??_C@_08ENAFOMOP@?$CDSCROLLX@			; `string'
PUBLIC	??_C@_08FEBONNKO@?$CDSCROLLY@			; `string'
PUBLIC	??_C@_06EBHDMMP@?$CDimage@			; `string'
PUBLIC	??_C@_06KLKJBGEJ@?$CF?40f?$CF?$CF@		; `string'
PUBLIC	??_C@_0BD@JMKMPHNG@?$CD?$CD?$CL?9C?4o?4m?4b?4o_?$CF02d@ ; `string'
PUBLIC	??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@	; `string'
PUBLIC	??_C@_04OHJIHAFH@None@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu@				; `string'
PUBLIC	??_C@_05LLAMLEHD@?$CFI64d@			; `string'
PUBLIC	??_C@_05OINFJHGD@?$CFI64u@			; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf@			; `string'
PUBLIC	??_C@_09JKJEEIJP@?$CF?4?$CKs?$CF?$CFd?$CFs@	; `string'
PUBLIC	??_C@_07DCHPOBDK@?$CD?$CD?$CL?9min@		; `string'
PUBLIC	??_C@_07CAPEAFFF@?$CD?$CD?$CL?9max@		; `string'
PUBLIC	??_C@_08FKIHKODH@?$CF?40f?5deg@			; `string'
PUBLIC	??_C@_01MIFGBAGJ@?$CL@				; `string'
PUBLIC	??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@		; `string'
PUBLIC	??_C@_04JIMNDDED@?$CF08X@			; `string'
PUBLIC	??_C@_07FFNLLALM@M?30?4000@			; `string'
PUBLIC	??_C@_05BNGMMMAL@M?3000@			; `string'
PUBLIC	??_C@_03CEFFAPNG@?$CD?$CDX@			; `string'
PUBLIC	??_C@_03DNEODOJH@?$CD?$CDY@			; `string'
PUBLIC	??_C@_03BGGDGNFE@?$CD?$CDZ@			; `string'
PUBLIC	??_C@_03KDMNBDBJ@?$CD?$CDW@			; `string'
PUBLIC	??_C@_03GOOLIKIF@?$CF3d@			; `string'
PUBLIC	??_C@_05FELKPNOB@R?3?$CF3d@			; `string'
PUBLIC	??_C@_05HKBGOMJ@G?3?$CF3d@			; `string'
PUBLIC	??_C@_05FHGMPPHK@B?3?$CF3d@			; `string'
PUBLIC	??_C@_05NBPIINNE@A?3?$CF3d@			; `string'
PUBLIC	??_C@_05PGPHNMBM@H?3?$CF3d@			; `string'
PUBLIC	??_C@_05JPOGCOEE@S?3?$CF3d@			; `string'
PUBLIC	??_C@_05MPCLLPPH@V?3?$CF3d@			; `string'
PUBLIC	??_C@_05ONBKDNLK@?$CF0?43f@			; `string'
PUBLIC	??_C@_07CCOKENNH@R?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07BGLBHCJI@G?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07FOFBHMPM@B?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07NANOHLBP@A?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07MPJBGADE@H?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07OOEAENEJ@S?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07KGKAEDCN@V?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07JKKCBBMM@context@			; `string'
PUBLIC	??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@ ; `string'
PUBLIC	??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@	; `string'
PUBLIC	??_C@_08HDCBKACM@?$CD?$CD?$CL?9Text@		; `string'
PUBLIC	??_C@_0BB@DDMGLOLI@?$CF02X?$CF02X?$CF02X?$CF02X@ ; `string'
PUBLIC	??_C@_0N@KODLFHPJ@?$CF02X?$CF02X?$CF02X@	; `string'
PUBLIC	??_C@_0BA@DICBDPDG@?$CD?$CD?$CL?9ColorButton@	; `string'
PUBLIC	??_C@_06MAKAMBBI@picker@			; `string'
PUBLIC	??_C@_0L@OPIIJFHG@?$CD?$CD?$CL?9picker@		; `string'
PUBLIC	??_C@_06LFKNFKEK@_COL3F@			; `string'
PUBLIC	??_C@_06LAOCEMMP@_COL4F@			; `string'
PUBLIC	??_C@_03PPLPHHG@hsv@				; `string'
PUBLIC	??_C@_02CPGMCOJE@sv@				; `string'
PUBLIC	??_C@_03GKJJMKFG@hue@				; `string'
PUBLIC	??_C@_05IAEKHIAN@alpha@				; `string'
PUBLIC	??_C@_0O@EALHHNOL@?$CD?$CD?$CDCurrent?$CD?$CD?$CD@ ; `string'
PUBLIC	??_C@_0M@BANGFOMF@?$CD?$CD?$CL?9current@	; `string'
PUBLIC	??_C@_0P@ECAOJHDA@?$CD?$CD?$CDOriginal?$CD?$CD?$CD@ ; `string'
PUBLIC	??_C@_0N@CHHIOJEB@?$CD?$CD?$CL?9original@	; `string'
PUBLIC	??_C@_07JMCOMEPF@?$CD?$CD?$CL?9rgb@		; `string'
PUBLIC	??_C@_07JGALKPPH@?$CD?$CD?$CL?9hsv@		; `string'
PUBLIC	??_C@_07BACDFNLL@?$CD?$CD?$CL?9hex@		; `string'
PUBLIC	??_C@_05PDOBBJNA@Color@				; `string'
PUBLIC	??_C@_0M@KBLIMBPK@?$CD?$CD?$CL?9preview@	; `string'
PUBLIC	??_C@_0DF@FAPNKOHO@?$CD?$CF02X?$CF02X?$CF02X?6R?3?5?$CFd?0?5G?3?5?$CFd?0?5B?3?5@ ; `string'
PUBLIC	??_C@_0EC@EBPMGCGK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X?6R?3?$CFd?0?5G?3?$CFd?0?5B@ ; `string'
PUBLIC	??_C@_03ICFFBAI@RGB@				; `string'
PUBLIC	??_C@_03CAADKAK@HSV@				; `string'
PUBLIC	??_C@_03IECIMIEG@HEX@				; `string'
PUBLIC	??_C@_06FDBEKFBH@0?4?4255@			; `string'
PUBLIC	??_C@_0L@MDNPBJBM@0?400?4?41?400@		; `string'
PUBLIC	??_C@_09NMCCFHEI@Copy?5as?4?4@			; `string'
PUBLIC	??_C@_04OPMHGHMB@Copy@				; `string'
PUBLIC	??_C@_0BN@GKCJMPCH@?$CI?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?$CJ@ ; `string'
PUBLIC	??_C@_0O@EJHNAHBL@?$CI?$CFd?0?$CFd?0?$CFd?0?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0P@GDANBODO@0x?$CF02X?$CF02X?$CF02X@	; `string'
PUBLIC	??_C@_0BD@MLNOPBDA@0x?$CF02X?$CF02X?$CF02X?$CF02X@ ; `string'
PUBLIC	??_C@_0P@OGDNCJGJ@?$CD?$CD?$CL?9selectable@	; `string'
PUBLIC	??_C@_0BA@PODNGMKL@?$CD?$CD?$CL?9dummypicker@	; `string'
PUBLIC	??_C@_09KEDLMDJL@Alpha?5Bar@			; `string'
PUBLIC	??_C@_09GHACPMKF@?$CDTreePush@			; `string'
PUBLIC	??_C@_0BE@OBCBLNMM@?$CFd?3?5?$CF8?44g?6?$CFd?3?5?$CF8?44g@ ; `string'
PUBLIC	??_C@_09OADNPGHP@?$CFd?3?5?$CF8?44g@		; `string'
PUBLIC	??_C@_06DJHOIPC@?$CFs?3?5?$CFs@			; `string'
PUBLIC	??_C@_06GBEGMGE@?$CFs?3?5?$CFd@			; `string'
PUBLIC	??_C@_07EKEPIENH@?$CF?$CFs?3?5?$CFs@		; `string'
PUBLIC	??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f@		; `string'
PUBLIC	??_C@_0BC@ELGDDMPM@?$CD?$CDMain?$CL?9Menu?$CL?9Bar@ ; `string'
PUBLIC	??_C@_0M@GEGHBGML@?$CD?$CD?$CL?9menubar@	; `string'
PUBLIC	??_C@_05HNDBPIGD@?$CD?$CD?$CL?9?$DM@		; `string'
PUBLIC	??_C@_05EPAHJKOB@?$CD?$CD?$CL?9?$DO@		; `string'
PUBLIC	??_C@_05HHKHFPOM@?$CD?$CD?$CL?9v@		; `string'
PUBLIC	??_C@_04EBNJJJJI@?$CF?4?$CKs@			; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?id@?$collate@D@std@@2V0locale@2@A		; std::collate<char>::id
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@00800000
PUBLIC	__real@358637bd
PUBLIC	__real@3727c5ac
PUBLIC	__real@38d1b717
PUBLIC	__real@3b808081
PUBLIC	__real@3c23d70a
PUBLIC	__real@3cdd2f1b
PUBLIC	__real@3da3d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e09374c
PUBLIC	__real@3e19999a
PUBLIC	__real@3e3851ec
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3e99999a
PUBLIC	__real@3ebcb924
PUBLIC	__real@3ec7ae14
PUBLIC	__real@3ecccccd
PUBLIC	__real@3ececbfb
PUBLIC	__real@3ef0f0f1
PUBLIC	__real@3effbe77
PUBLIC	__real@3f000000
PUBLIC	__real@3f0ccccd
PUBLIC	__real@3f128f5c
PUBLIC	__real@3f266666
PUBLIC	__real@3f333333
PUBLIC	__real@3f350481
PUBLIC	__real@3f47ae14
PUBLIC	__real@3f48c8c9
PUBLIC	__real@3f4a3d71
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f52d2d3
PUBLIC	__real@3f5adaba
PUBLIC	__real@3f5db22d
PUBLIC	__real@3f5db3d0
PUBLIC	__real@3f7fbe77
PUBLIC	__real@3f7ff972
PUBLIC	__real@3f800000
PUBLIC	__real@3f99999a
PUBLIC	__real@3fb33333
PUBLIC	__real@3fc00000
PUBLIC	__real@3fd9999a
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ffcccccc0000000
PUBLIC	__real@40000000
PUBLIC	__real@4004000000000000
PUBLIC	__real@400e666666666666
PUBLIC	__real@40200000
PUBLIC	__real@4020000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@4024800000000000
PUBLIC	__real@403f5c29
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@4059000000000000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40b33333
PUBLIC	__real@40c00000
PUBLIC	__real@40c90fdb
PUBLIC	__real@40e00000
PUBLIC	__real@40eccccd
PUBLIC	__real@41000000
PUBLIC	__real@41100000
PUBLIC	__real@41200000
PUBLIC	__real@41400000
PUBLIC	__real@41800000
PUBLIC	__real@41a00000
PUBLIC	__real@41f00000
PUBLIC	__real@428c0000
PUBLIC	__real@42c80000
PUBLIC	__real@437f0000
PUBLIC	__real@43b40000
PUBLIC	__real@43e0000000000000
PUBLIC	__real@47efffffe0000000
PUBLIC	__real@5f000000
PUBLIC	__real@7f7fffff
PUBLIC	__real@7fefffffffffffff
PUBLIC	__real@be99999a
PUBLIC	__real@bf000000
PUBLIC	__real@bf400000
PUBLIC	__real@bf5db3d0
PUBLIC	__real@bf800000
PUBLIC	__real@c059000000000000
PUBLIC	__real@c1100000
PUBLIC	__real@c1400000
PUBLIC	__real@c2c80000
PUBLIC	__real@ff7fffff
PUBLIC	__real@ffefffffffffffff
PUBLIC	__xmm@80000000000000008000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_M@YAXPEAX_K1P6AX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	_Init_thread_header:PROC
EXTRN	_Init_thread_abort:PROC
EXTRN	_Init_thread_footer:PROC
EXTRN	_invalid_parameter_noinfo_noreturn:PROC
EXTRN	__stdio_common_vsscanf:PROC
EXTRN	memchr:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	fabs:PROC
EXTRN	pow:PROC
EXTRN	atof:PROC
EXTRN	atan2f:PROC
EXTRN	cosf:PROC
EXTRN	fmodf:PROC
EXTRN	powf:PROC
EXTRN	sinf:PROC
EXTRN	qsort:PROC
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPEBD@Z:PROC		; std::_Xout_of_range
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	isprint:PROC
EXTRN	__imp_IsBadReadPtr:PROC
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	OPENSSL_init_ssl:PROC
EXTRN	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ:PROC	; ImGui::GetStyle
EXTRN	?Begin@ImGui@@YA_NPEBDPEA_NH@Z:PROC		; ImGui::Begin
EXTRN	?End@ImGui@@YAXXZ:PROC				; ImGui::End
EXTRN	?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ:PROC ; ImGui::GetWindowDrawList
EXTRN	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ:PROC ; ImGui::GetContentRegionMax
EXTRN	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ:PROC ; ImGui::GetContentRegionAvail
EXTRN	?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ:PROC ; ImGui::GetWindowContentRegionMax
EXTRN	?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z:PROC ; ImGui::SetNextWindowPos
EXTRN	?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z:PROC ; ImGui::SetNextWindowSize
EXTRN	?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z:PROC ; ImGui::SetNextWindowSizeConstraints
EXTRN	?GetScrollMaxY@ImGui@@YAMXZ:PROC		; ImGui::GetScrollMaxY
EXTRN	?PushFont@ImGui@@YAXPEAUImFont@@@Z:PROC		; ImGui::PushFont
EXTRN	?PopFont@ImGui@@YAXXZ:PROC			; ImGui::PopFont
EXTRN	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z:PROC	; ImGui::PushStyleColor
EXTRN	?PopStyleColor@ImGui@@YAXH@Z:PROC		; ImGui::PopStyleColor
EXTRN	?PushStyleVar@ImGui@@YAXHM@Z:PROC		; ImGui::PushStyleVar
EXTRN	?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z:PROC	; ImGui::PushStyleVar
EXTRN	?PopStyleVar@ImGui@@YAXH@Z:PROC			; ImGui::PopStyleVar
EXTRN	?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ:PROC ; ImGui::GetFontTexUvWhitePixel
EXTRN	?GetColorU32@ImGui@@YAIHM@Z:PROC		; ImGui::GetColorU32
EXTRN	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z:PROC	; ImGui::GetColorU32
EXTRN	?GetColorU32@ImGui@@YAIQEAM@Z:PROC		; ImGui::GetColorU32
EXTRN	?GetColorU32@ImGui@@YAII@Z:PROC			; ImGui::GetColorU32
EXTRN	?PushItemWidth@ImGui@@YAXM@Z:PROC		; ImGui::PushItemWidth
EXTRN	?PopItemWidth@ImGui@@YAXXZ:PROC			; ImGui::PopItemWidth
EXTRN	?CalcItemWidth@ImGui@@YAMXZ:PROC		; ImGui::CalcItemWidth
EXTRN	?PushTextWrapPos@ImGui@@YAXM@Z:PROC		; ImGui::PushTextWrapPos
EXTRN	?PopTextWrapPos@ImGui@@YAXXZ:PROC		; ImGui::PopTextWrapPos
EXTRN	?SameLine@ImGui@@YAXMMM@Z:PROC			; ImGui::SameLine
EXTRN	?Indent@ImGui@@YAXM@Z:PROC			; ImGui::Indent
EXTRN	?Unindent@ImGui@@YAXM@Z:PROC			; ImGui::Unindent
EXTRN	?BeginGroup@ImGui@@YAXXZ:PROC			; ImGui::BeginGroup
EXTRN	?EndGroup@ImGui@@YAXXZ:PROC			; ImGui::EndGroup
EXTRN	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetCursorScreenPos
EXTRN	?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z:PROC ; ImGui::SetCursorScreenPos
EXTRN	?GetTextLineHeight@ImGui@@YAMXZ:PROC		; ImGui::GetTextLineHeight
EXTRN	?GetTextLineHeightWithSpacing@ImGui@@YAMXZ:PROC	; ImGui::GetTextLineHeightWithSpacing
EXTRN	?GetFrameHeight@ImGui@@YAMXZ:PROC		; ImGui::GetFrameHeight
EXTRN	?PushID@ImGui@@YAXPEBD@Z:PROC			; ImGui::PushID
EXTRN	?PushID@ImGui@@YAXPEBX@Z:PROC			; ImGui::PushID
EXTRN	?PushID@ImGui@@YAXH@Z:PROC			; ImGui::PushID
EXTRN	?PopID@ImGui@@YAXXZ:PROC			; ImGui::PopID
EXTRN	?GetID@ImGui@@YAIPEBD@Z:PROC			; ImGui::GetID
EXTRN	?EndTooltip@ImGui@@YAXXZ:PROC			; ImGui::EndTooltip
EXTRN	?SetTooltip@ImGui@@YAXPEBDZZ:PROC		; ImGui::SetTooltip
EXTRN	?OpenPopup@ImGui@@YAXPEBD@Z:PROC		; ImGui::OpenPopup
EXTRN	?BeginPopup@ImGui@@YA_NPEBDH@Z:PROC		; ImGui::BeginPopup
EXTRN	?EndPopup@ImGui@@YAXXZ:PROC			; ImGui::EndPopup
EXTRN	?OpenPopupOnItemClick@ImGui@@YA_NPEBDH@Z:PROC	; ImGui::OpenPopupOnItemClick
EXTRN	?CloseCurrentPopup@ImGui@@YAXXZ:PROC		; ImGui::CloseCurrentPopup
EXTRN	?BeginDragDropSource@ImGui@@YA_NH@Z:PROC	; ImGui::BeginDragDropSource
EXTRN	?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z:PROC ; ImGui::SetDragDropPayload
EXTRN	?EndDragDropSource@ImGui@@YAXXZ:PROC		; ImGui::EndDragDropSource
EXTRN	?BeginDragDropTarget@ImGui@@YA_NXZ:PROC		; ImGui::BeginDragDropTarget
EXTRN	?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z:PROC ; ImGui::AcceptDragDropPayload
EXTRN	?EndDragDropTarget@ImGui@@YAXXZ:PROC		; ImGui::EndDragDropTarget
EXTRN	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z:PROC	; ImGui::PushClipRect
EXTRN	?PopClipRect@ImGui@@YAXXZ:PROC			; ImGui::PopClipRect
EXTRN	?SetItemDefaultFocus@ImGui@@YAXXZ:PROC		; ImGui::SetItemDefaultFocus
EXTRN	?IsItemHovered@ImGui@@YA_NH@Z:PROC		; ImGui::IsItemHovered
EXTRN	?IsItemActive@ImGui@@YA_NXZ:PROC		; ImGui::IsItemActive
EXTRN	?SetItemAllowOverlap@ImGui@@YAXXZ:PROC		; ImGui::SetItemAllowOverlap
EXTRN	?IsRectVisible@ImGui@@YA_NAEBUImVec2@@0@Z:PROC	; ImGui::IsRectVisible
EXTRN	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z:PROC ; ImGui::CalcTextSize
EXTRN	?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z:PROC ; ImGui::BeginChildFrame
EXTRN	?EndChildFrame@ImGui@@YAXXZ:PROC		; ImGui::EndChildFrame
EXTRN	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z:PROC ; ImGui::ColorConvertFloat4ToU32
EXTRN	?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z:PROC ; ImGui::ColorConvertRGBtoHSV
EXTRN	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z:PROC ; ImGui::ColorConvertHSVtoRGB
EXTRN	?IsKeyPressed@ImGui@@YA_NH_N@Z:PROC		; ImGui::IsKeyPressed
EXTRN	?IsMouseClicked@ImGui@@YA_NH_N@Z:PROC		; ImGui::IsMouseClicked
EXTRN	?IsMouseReleased@ImGui@@YA_NH@Z:PROC		; ImGui::IsMouseReleased
EXTRN	?IsMouseDragging@ImGui@@YA_NHM@Z:PROC		; ImGui::IsMouseDragging
EXTRN	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z:PROC ; ImGui::IsMouseHoveringRect
EXTRN	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z:PROC	; ImGui::IsMousePosValid
EXTRN	?SetMouseCursor@ImGui@@YAXH@Z:PROC		; ImGui::SetMouseCursor
EXTRN	?GetClipboardText@ImGui@@YAPEBDXZ:PROC		; ImGui::GetClipboardText
EXTRN	?SetClipboardText@ImGui@@YAXPEBD@Z:PROC		; ImGui::SetClipboardText
EXTRN	?MemAlloc@ImGui@@YAPEAX_K@Z:PROC		; ImGui::MemAlloc
EXTRN	?MemFree@ImGui@@YAXPEAX@Z:PROC			; ImGui::MemFree
EXTRN	??0ImGuiStyle@@QEAA@XZ:PROC			; ImGuiStyle::ImGuiStyle
EXTRN	?append@ImGuiTextBuffer@@QEAAXPEBD0@Z:PROC	; ImGuiTextBuffer::append
EXTRN	?GetInt@ImGuiStorage@@QEBAHIH@Z:PROC		; ImGuiStorage::GetInt
EXTRN	?SetInt@ImGuiStorage@@QEAAXIH@Z:PROC		; ImGuiStorage::SetInt
EXTRN	?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z:PROC	; ImGuiStorage::GetIntRef
EXTRN	?Step@ImGuiListClipper@@QEAA_NXZ:PROC		; ImGuiListClipper::Step
EXTRN	?Begin@ImGuiListClipper@@QEAAXHM@Z:PROC		; ImGuiListClipper::Begin
EXTRN	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z:PROC ; ImDrawList::AddLine
EXTRN	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z:PROC ; ImDrawList::AddRect
EXTRN	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z:PROC ; ImDrawList::AddRectFilled
EXTRN	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z:PROC ; ImDrawList::AddRectFilledMultiColor
EXTRN	?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z:PROC ; ImDrawList::AddTriangle
EXTRN	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z:PROC ; ImDrawList::AddCircle
EXTRN	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z:PROC ; ImDrawList::AddCircleFilled
EXTRN	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z:PROC ; ImDrawList::AddText
EXTRN	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z:PROC ; ImDrawList::AddImage
EXTRN	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z:PROC ; ImDrawList::AddPolyline
EXTRN	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z:PROC ; ImDrawList::AddConvexPolyFilled
EXTRN	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z:PROC ; ImDrawList::PathArcTo
EXTRN	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z:PROC ; ImDrawList::PathArcToFast
EXTRN	?PrimReserve@ImDrawList@@QEAAXHH@Z:PROC		; ImDrawList::PrimReserve
EXTRN	?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z:PROC ; ImFont::FindGlyph
EXTRN	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z:PROC ; ImFont::CalcTextSizeA
EXTRN	?ImTextStrToUtf8@@YAHPEADHPEBG1@Z:PROC		; ImTextStrToUtf8
EXTRN	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z:PROC	; ImTextCharFromUtf8
EXTRN	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z:PROC	; ImTextStrFromUtf8
EXTRN	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z:PROC	; ImTextCountCharsFromUtf8
EXTRN	?ImTextCountUtf8BytesFromChar@@YAHPEBD0@Z:PROC	; ImTextCountUtf8BytesFromChar
EXTRN	?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z:PROC	; ImTextCountUtf8BytesFromStr
EXTRN	?ImHashStr@@YAIPEBD_KI@Z:PROC			; ImHashStr
EXTRN	?ImTriangleContainsPoint@@YA_NAEBUImVec2@@000@Z:PROC ; ImTriangleContainsPoint
EXTRN	?ImTriangleClosestPoint@@YA?AUImVec2@@AEBU1@000@Z:PROC ; ImTriangleClosestPoint
EXTRN	?ImTriangleBarycentricCoords@@YAXAEBUImVec2@@000AEAM11@Z:PROC ; ImTriangleBarycentricCoords
EXTRN	?ImStrncpy@@YAXPEADPEBD_K@Z:PROC		; ImStrncpy
EXTRN	?ImStrbolW@@YAPEBGPEBG0@Z:PROC			; ImStrbolW
EXTRN	?ImStrTrimBlanks@@YAXPEAD@Z:PROC		; ImStrTrimBlanks
EXTRN	?ImFormatString@@YAHPEAD_KPEBDZZ:PROC		; ImFormatString
EXTRN	?ImFormatStringV@@YAHPEAD_KPEBD0@Z:PROC		; ImFormatStringV
EXTRN	?GetID@ImGuiWindow@@QEAAIPEBD0@Z:PROC		; ImGuiWindow::GetID
EXTRN	?GetID@ImGuiWindow@@QEAAIPEBX@Z:PROC		; ImGuiWindow::GetID
EXTRN	?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBD0@Z:PROC ; ImGuiWindow::GetIDNoKeepAlive
EXTRN	?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z:PROC ; ImGui::FindWindowByName
EXTRN	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z:PROC	; ImGui::FocusWindow
EXTRN	?FocusPreviousWindowIgnoringOne@ImGui@@YAXPEAUImGuiWindow@@@Z:PROC ; ImGui::FocusPreviousWindowIgnoringOne
EXTRN	?CalcWindowExpectedSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z:PROC ; ImGui::CalcWindowExpectedSize
EXTRN	?SetWindowScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z:PROC ; ImGui::SetWindowScrollY
EXTRN	?GetWindowAllowedExtentRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@@Z:PROC ; ImGui::GetWindowAllowedExtentRect
EXTRN	?StartMouseMovingWindow@ImGui@@YAXPEAUImGuiWindow@@@Z:PROC ; ImGui::StartMouseMovingWindow
EXTRN	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z:PROC ; ImGui::SetActiveID
EXTRN	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z:PROC	; ImGui::SetFocusID
EXTRN	?ClearActiveID@ImGui@@YAXXZ:PROC		; ImGui::ClearActiveID
EXTRN	?SetHoveredID@ImGui@@YAXI@Z:PROC		; ImGui::SetHoveredID
EXTRN	?KeepAliveID@ImGui@@YAXI@Z:PROC			; ImGui::KeepAliveID
EXTRN	?MarkItemEdited@ImGui@@YAXI@Z:PROC		; ImGui::MarkItemEdited
EXTRN	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z:PROC	; ImGui::ItemSize
EXTRN	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z:PROC	; ImGui::ItemSize
EXTRN	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z:PROC	; ImGui::ItemAdd
EXTRN	?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z:PROC	; ImGui::ItemHoverable
EXTRN	?IsClippedEx@ImGui@@YA_NAEBUImRect@@I_N@Z:PROC	; ImGui::IsClippedEx
EXTRN	?FocusableItemRegister@ImGui@@YA_NPEAUImGuiWindow@@I_N@Z:PROC ; ImGui::FocusableItemRegister
EXTRN	?FocusableItemUnregister@ImGui@@YAXPEAUImGuiWindow@@@Z:PROC ; ImGui::FocusableItemUnregister
EXTRN	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z:PROC	; ImGui::CalcItemSize
EXTRN	?CalcWrapWidthForPos@ImGui@@YAMAEBUImVec2@@M@Z:PROC ; ImGui::CalcWrapWidthForPos
EXTRN	?PushMultiItemsWidths@ImGui@@YAXHM@Z:PROC	; ImGui::PushMultiItemsWidths
EXTRN	?PushItemFlag@ImGui@@YAXH_N@Z:PROC		; ImGui::PushItemFlag
EXTRN	?PopItemFlag@ImGui@@YAXXZ:PROC			; ImGui::PopItemFlag
EXTRN	?OpenPopupEx@ImGui@@YAXI@Z:PROC			; ImGui::OpenPopupEx
EXTRN	?ClosePopupToLevel@ImGui@@YAXH_N@Z:PROC		; ImGui::ClosePopupToLevel
EXTRN	?IsPopupOpen@ImGui@@YA_NI@Z:PROC		; ImGui::IsPopupOpen
EXTRN	?BeginPopupEx@ImGui@@YA_NIH@Z:PROC		; ImGui::BeginPopupEx
EXTRN	?BeginTooltipEx@ImGui@@YAXH_N@Z:PROC		; ImGui::BeginTooltipEx
EXTRN	?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z:PROC ; ImGui::FindBestWindowPosForPopupEx
EXTRN	?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ:PROC ; ImGui::NavMoveRequestButNoResultYet
EXTRN	?NavMoveRequestCancel@ImGui@@YAXXZ:PROC		; ImGui::NavMoveRequestCancel
EXTRN	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z:PROC ; ImGui::GetNavInputAmount
EXTRN	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z:PROC ; ImGui::GetNavInputAmount2d
EXTRN	?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z:PROC ; ImGui::CalcTypematicPressedRepeatAmount
EXTRN	?SetNavID@ImGui@@YAXIH@Z:PROC			; ImGui::SetNavID
EXTRN	?SetNavIDWithRectRel@ImGui@@YAXIHAEBUImRect@@@Z:PROC ; ImGui::SetNavIDWithRectRel
EXTRN	?PushColumnClipRect@ImGui@@YAXH@Z:PROC		; ImGui::PushColumnClipRect
EXTRN	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z:PROC	; ImGui::RenderText
EXTRN	?RenderTextWrapped@ImGui@@YAXUImVec2@@PEBD1M@Z:PROC ; ImGui::RenderTextWrapped
EXTRN	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z:PROC ; ImGui::RenderTextClipped
EXTRN	?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z:PROC ; ImGui::RenderTextClippedEx
EXTRN	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z:PROC	; ImGui::RenderFrame
EXTRN	?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z:PROC	; ImGui::RenderFrameBorder
EXTRN	?RenderArrow@ImGui@@YAXUImVec2@@HM@Z:PROC	; ImGui::RenderArrow
EXTRN	?RenderBullet@ImGui@@YAXUImVec2@@@Z:PROC	; ImGui::RenderBullet
EXTRN	?RenderCheckMark@ImGui@@YAXUImVec2@@IM@Z:PROC	; ImGui::RenderCheckMark
EXTRN	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z:PROC ; ImGui::RenderNavHighlight
EXTRN	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z:PROC	; ImGui::FindRenderedTextEnd
EXTRN	?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z:PROC ; ImGui::RenderArrowPointingAt
EXTRN	?RenderRectFilledRangeH@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@IMMM@Z:PROC ; ImGui::RenderRectFilledRangeH
EXTRN	?RenderPixelEllipsis@ImGui@@YAXPEAUImDrawList@@UImVec2@@HI@Z:PROC ; ImGui::RenderPixelEllipsis
EXTRN	?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z:PROC ; ImGui::ShadeVertsLinearColorGradientKeepAlpha
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	_Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	?GImGui@@3PEAUImGuiContext@@EA:QWORD		; GImGui
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
EXTRN	_tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?wsinit_@detail@httplib@@3VWSInit@12@A DB 01H DUP (?)	; httplib::detail::wsinit_
	ALIGN	4

?sslinit_@detail@httplib@@3VSSLInit@12@A DB 01H DUP (?)	; httplib::detail::sslinit_
	ALIGN	8

?XYZMask@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?)	; IronMan::Core::Math::XYZMask
?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?) ; IronMan::Core::Math::QINV_SIGN_MASK
?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B DB 01b0H DUP (?) ; GDataTypeInfo
_BSS	ENDS
;	COMDAT ?ids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
_BSS	SEGMENT
?ids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 080H DUP (?) ; `ImGui::ColorEdit4'::`19'::ids
_BSS	ENDS
;	COMDAT ?$TSS0@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
_BSS	SEGMENT
?$TSS0@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 01H DUP (?) ; `ImGui::ColorEdit4'::`19'::$TSS0
_BSS	ENDS
;	COMDAT ?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
_BSS	SEGMENT
?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 0180H DUP (?) ; `ImGui::ColorEdit4'::`19'::fmt_table_int
_BSS	ENDS
;	COMDAT ?$TSS1@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
_BSS	SEGMENT
?$TSS1@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 01H DUP (?) ; `ImGui::ColorEdit4'::`19'::$TSS1
_BSS	ENDS
;	COMDAT ?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
_BSS	SEGMENT
?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 0180H DUP (?) ; `ImGui::ColorEdit4'::`19'::fmt_table_float
_BSS	ENDS
;	COMDAT ?$TSS2@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
_BSS	SEGMENT
?$TSS2@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 01H DUP (?) ; `ImGui::ColorEdit4'::`19'::$TSS2
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::collate<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fabsf DD	imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fabsf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?abs@@YAMM@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?abs@@YAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+154
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+130
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN5
	DD	imagerel $LN5+411
	DD	imagerel $unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+252
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN4
	DD	imagerel $LN4+252
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+180
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN11
	DD	imagerel $LN11+590
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD imagerel $LN5
	DD	imagerel $LN5+105
	DD	imagerel $unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+173
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DD imagerel $LN5
	DD	imagerel $LN5+88
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z@4HA DD imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??0WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??1WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ewsinit_@detail@httplib@@YAXXZ DD imagerel ??__Ewsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Ewsinit_@detail@httplib@@YAXXZ+34
	DD	imagerel $unwind$??__Ewsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fwsinit_@detail@httplib@@YAXXZ DD imagerel ??__Fwsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Fwsinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Fwsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SSLInit@detail@httplib@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0SSLInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Esslinit_@detail@httplib@@YAXXZ DD imagerel ??__Esslinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Esslinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Esslinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ+40
	DD	imagerel $unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ+53
	DD	imagerel $unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Separator@ImGui@@YAXXZ DD imagerel $LN12
	DD	imagerel $LN12+587
	DD	imagerel $unwind$?Separator@ImGui@@YAXXZ
$pdata$?NewLine@ImGui@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+184
	DD	imagerel $unwind$?NewLine@ImGui@@YAXXZ
$pdata$?Spacing@ImGui@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$?Spacing@ImGui@@YAXXZ
$pdata$?Dummy@ImGui@@YAXAEBUImVec2@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?Dummy@ImGui@@YAXAEBUImVec2@@@Z
$pdata$?AlignTextToFramePadding@ImGui@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+168
	DD	imagerel $unwind$?AlignTextToFramePadding@ImGui@@YAXXZ
$pdata$?TextUnformatted@ImGui@@YAXPEBD0@Z DD imagerel $LN25
	DD	imagerel $LN25+1497
	DD	imagerel $unwind$?TextUnformatted@ImGui@@YAXPEBD0@Z
$pdata$?TextUnformatted2@ImGui@@YAXPEBD0@Z DD imagerel $LN25
	DD	imagerel $LN25+1523
	DD	imagerel $unwind$?TextUnformatted2@ImGui@@YAXPEBD0@Z
$pdata$?Text@ImGui@@YAXPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$?Text@ImGui@@YAXPEBDZZ
$pdata$?TextV@ImGui@@YAXPEBDPEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+135
	DD	imagerel $unwind$?TextV@ImGui@@YAXPEBDPEAD@Z
$pdata$?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ
$pdata$?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z
$pdata$?TextDisabled@ImGui@@YAXPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$?TextDisabled@ImGui@@YAXPEBDZZ
$pdata$?TextDisabledV@ImGui@@YAXPEBDPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?TextDisabledV@ImGui@@YAXPEBDPEAD@Z
$pdata$?TextWrapped@ImGui@@YAXPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$?TextWrapped@ImGui@@YAXPEBDZZ
$pdata$?TextWrappedV@ImGui@@YAXPEBDPEAD@Z DD imagerel $LN7
	DD	imagerel $LN7+121
	DD	imagerel $unwind$?TextWrappedV@ImGui@@YAXPEBDPEAD@Z
$pdata$?LabelText@ImGui@@YAXPEBD0ZZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?LabelText@ImGui@@YAXPEBD0ZZ
$pdata$?LabelTextV@ImGui@@YAXPEBD0PEAD@Z DD imagerel $LN8
	DD	imagerel $LN8+743
	DD	imagerel $unwind$?LabelTextV@ImGui@@YAXPEBD0PEAD@Z
$pdata$?BulletText@ImGui@@YAXPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$?BulletText@ImGui@@YAXPEBDZZ
$pdata$?BulletTextV@ImGui@@YAXPEBDPEAD@Z DD imagerel $LN7
	DD	imagerel $LN7+782
	DD	imagerel $unwind$?BulletTextV@ImGui@@YAXPEBDPEAD@Z
$pdata$?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z
$pdata$?SmallButton@ImGui@@YA_NPEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+124
	DD	imagerel $unwind$?SmallButton@ImGui@@YA_NPEBD@Z
$pdata$?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@@Z DD imagerel $LN5
	DD	imagerel $LN5+237
	DD	imagerel $unwind$?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@@Z
$pdata$?ArrowButton@ImGui@@YA_NPEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$?ArrowButton@ImGui@@YA_NPEBDH@Z
$pdata$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD imagerel $LN8
	DD	imagerel $LN8+668
	DD	imagerel $unwind$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
$pdata$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z DD imagerel $LN13
	DD	imagerel $LN13+1059
	DD	imagerel $unwind$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z
$pdata$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z DD imagerel $LN19
	DD	imagerel $LN19+1076
	DD	imagerel $unwind$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z
$pdata$?Checkbox1@ImGui@@YA_NPEBDPEAHPEAM@Z DD imagerel $LN13
	DD	imagerel $LN13+1556
	DD	imagerel $unwind$?Checkbox1@ImGui@@YA_NPEBDPEAHPEAM@Z
$pdata$?Checkbox2@ImGui@@YA_NPEBDPEAH@Z DD imagerel $LN13
	DD	imagerel $LN13+6249
	DD	imagerel $unwind$?Checkbox2@ImGui@@YA_NPEBDPEAH@Z
$pdata$?ToggleButton@ImGui@@YA_NPEBDPEA_NMMM@Z DD imagerel $LN22
	DD	imagerel $LN22+1775
	DD	imagerel $unwind$?ToggleButton@ImGui@@YA_NPEBDPEA_NMMM@Z
$pdata$?CheckboxFlags@ImGui@@YA_NPEBDPEAII@Z DD imagerel $LN8
	DD	imagerel $LN8+158
	DD	imagerel $unwind$?CheckboxFlags@ImGui@@YA_NPEBDPEAII@Z
$pdata$?RadioButton@ImGui@@YA_NPEBD_N@Z DD imagerel $LN15
	DD	imagerel $LN15+1366
	DD	imagerel $unwind$?RadioButton@ImGui@@YA_NPEBD_N@Z
$pdata$?RadioButton@ImGui@@YA_NPEBDPEAHH@Z DD imagerel $LN6
	DD	imagerel $LN6+93
	DD	imagerel $unwind$?RadioButton@ImGui@@YA_NPEBDPEAHH@Z
$pdata$?ProgressBar@ImGui@@YAXMAEBUImVec2@@PEBD@Z DD imagerel $LN7
	DD	imagerel $LN7+1039
	DD	imagerel $unwind$?ProgressBar@ImGui@@YAXMAEBUImVec2@@PEBD@Z
$pdata$?Bullet@ImGui@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+463
	DD	imagerel $unwind$?Bullet@ImGui@@YAXXZ
$pdata$?BeginCombo@ImGui@@YA_NPEBD0H@Z DD imagerel $LN37
	DD	imagerel $LN37+2518
	DD	imagerel $unwind$?BeginCombo@ImGui@@YA_NPEBD0H@Z
$pdata$?EndCombo@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+15
	DD	imagerel $unwind$?EndCombo@ImGui@@YAXXZ
$pdata$?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z
$pdata$?Combo@ImGui@@YA_NPEBDPEAH0H@Z DD imagerel $LN5
	DD	imagerel $LN5+148
	DD	imagerel $unwind$?Combo@ImGui@@YA_NPEBDPEAH0H@Z
$pdata$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD imagerel $LN16
	DD	imagerel $LN16+572
	DD	imagerel $unwind$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
$pdata$?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z DD imagerel $LN16
	DD	imagerel $LN16+556
	DD	imagerel $unwind$?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA DD imagerel ?dtor$0@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA
	DD	imagerel ?dtor$0@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA
$pdata$?dtor$1@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA DD imagerel ?dtor$1@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA
	DD	imagerel ?dtor$1@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA
$pdata$?dtor$2@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA DD imagerel ?dtor$2@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA
	DD	imagerel ?dtor$2@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?DragFloat@ImGui@@YA_NPEBDPEAMMMM0M@Z DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$?DragFloat@ImGui@@YA_NPEBDPEAMMMM0M@Z
$pdata$?DragFloat2@ImGui@@YA_NPEBDQEAMMMM0M@Z DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$?DragFloat2@ImGui@@YA_NPEBDQEAMMMM0M@Z
$pdata$?DragFloat3@ImGui@@YA_NPEBDQEAMMMM0M@Z DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$?DragFloat3@ImGui@@YA_NPEBDQEAMMMM0M@Z
$pdata$?DragFloat4@ImGui@@YA_NPEBDQEAMMMM0M@Z DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$?DragFloat4@ImGui@@YA_NPEBDQEAMMMM0M@Z
$pdata$?DragFloatRange2@ImGui@@YA_NPEBDPEAM1MMM00M@Z DD imagerel $LN14
	DD	imagerel $LN14+691
	DD	imagerel $unwind$?DragFloatRange2@ImGui@@YA_NPEBDPEAM1MMM00M@Z
$pdata$?DragInt@ImGui@@YA_NPEBDPEAHMHH0@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?DragInt@ImGui@@YA_NPEBDPEAHMHH0@Z
$pdata$?DragInt2@ImGui@@YA_NPEBDQEAHMHH0@Z DD imagerel $LN3
	DD	imagerel $LN3+115
	DD	imagerel $unwind$?DragInt2@ImGui@@YA_NPEBDQEAHMHH0@Z
$pdata$?DragInt3@ImGui@@YA_NPEBDQEAHMHH0@Z DD imagerel $LN3
	DD	imagerel $LN3+115
	DD	imagerel $unwind$?DragInt3@ImGui@@YA_NPEBDQEAHMHH0@Z
$pdata$?DragInt4@ImGui@@YA_NPEBDQEAHMHH0@Z DD imagerel $LN3
	DD	imagerel $LN3+115
	DD	imagerel $unwind$?DragInt4@ImGui@@YA_NPEBDQEAHMHH0@Z
$pdata$?DragIntRange2@ImGui@@YA_NPEBDPEAH1MHH00@Z DD imagerel $LN14
	DD	imagerel $LN14+581
	DD	imagerel $unwind$?DragIntRange2@ImGui@@YA_NPEBDPEAH1MHH00@Z
$pdata$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20M@Z DD imagerel $LN28
	DD	imagerel $LN28+1625
	DD	imagerel $unwind$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20M@Z
$pdata$?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z DD imagerel $LN7
	DD	imagerel $LN7+408
	DD	imagerel $unwind$?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z
$pdata$?SliderFloat@ImGui@@YA_NPEBDPEAMMM0M_N@Z DD imagerel $LN3
	DD	imagerel $LN3+100
	DD	imagerel $unwind$?SliderFloat@ImGui@@YA_NPEBDPEAMMM0M_N@Z
$pdata$?SliderFloat2@ImGui@@YA_NPEBDQEAMMM0M@Z DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$?SliderFloat2@ImGui@@YA_NPEBDQEAMMM0M@Z
$pdata$?SliderFloat3@ImGui@@YA_NPEBDQEAMMM0M@Z DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$?SliderFloat3@ImGui@@YA_NPEBDQEAMMM0M@Z
$pdata$?SliderFloat4@ImGui@@YA_NPEBDQEAMMM0M@Z DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$?SliderFloat4@ImGui@@YA_NPEBDQEAMMM0M@Z
$pdata$?SliderAngle@ImGui@@YA_NPEBDPEAMMM0@Z DD imagerel $LN4
	DD	imagerel $LN4+187
	DD	imagerel $unwind$?SliderAngle@ImGui@@YA_NPEBDPEAMMM0@Z
$pdata$?SliderInt@ImGui@@YA_NPEBDPEAHHH0_N@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$?SliderInt@ImGui@@YA_NPEBDPEAHHH0_N@Z
$pdata$?SliderInt2@ImGui@@YA_NPEBDQEAHHH0@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$?SliderInt2@ImGui@@YA_NPEBDQEAHHH0@Z
$pdata$?SliderInt3@ImGui@@YA_NPEBDQEAHHH0@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$?SliderInt3@ImGui@@YA_NPEBDQEAHHH0@Z
$pdata$?SliderInt4@ImGui@@YA_NPEBDQEAHHH0@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$?SliderInt4@ImGui@@YA_NPEBDQEAHHH0@Z
$pdata$?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20M_N@Z DD imagerel $LN26
	DD	imagerel $LN26+3774
	DD	imagerel $unwind$?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20M_N@Z
$pdata$?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z DD imagerel $LN7
	DD	imagerel $LN7+399
	DD	imagerel $unwind$?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z
$pdata$?VSliderFloat@ImGui@@YA_NPEBDAEBUImVec2@@PEAMMM0M@Z DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$?VSliderFloat@ImGui@@YA_NPEBDAEBUImVec2@@PEAMMM0M@Z
$pdata$?VSliderInt@ImGui@@YA_NPEBDAEBUImVec2@@PEAHHH0@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$?VSliderInt@ImGui@@YA_NPEBDAEBUImVec2@@PEAHHH0@Z
$pdata$?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30M@Z DD imagerel $LN21
	DD	imagerel $LN21+1477
	DD	imagerel $unwind$?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30M@Z
$pdata$?RenderTextOverlay@ImGui@@YAXUImVec2@@PEBD1_N@Z DD imagerel $LN7
	DD	imagerel $LN7+1302
	DD	imagerel $unwind$?RenderTextOverlay@ImGui@@YAXUImVec2@@PEBD1_N@Z
$pdata$?InputText@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+193
	DD	imagerel $unwind$?InputText@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
$pdata$?InputTextMultiline@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+189
	DD	imagerel $unwind$?InputTextMultiline@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
$pdata$?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
$pdata$?InputTextMultiline@ImGui@@YA_NPEBDPEAD_KAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$?InputTextMultiline@ImGui@@YA_NPEBDPEAD_KAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
$pdata$?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z DD imagerel $LN7
	DD	imagerel $LN7+202
	DD	imagerel $unwind$?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z
$pdata$?InputFloat2@ImGui@@YA_NPEBDQEAM0H@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$?InputFloat2@ImGui@@YA_NPEBDQEAM0H@Z
$pdata$?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z
$pdata$?InputFloat4@ImGui@@YA_NPEBDQEAM0H@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$?InputFloat4@ImGui@@YA_NPEBDQEAM0H@Z
$pdata$?InputInt@ImGui@@YA_NPEBDPEAHHHH@Z DD imagerel $LN9
	DD	imagerel $LN9+216
	DD	imagerel $unwind$?InputInt@ImGui@@YA_NPEBDPEAHHHH@Z
$pdata$?InputInt2@ImGui@@YA_NPEBDQEAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$?InputInt2@ImGui@@YA_NPEBDQEAHH@Z
$pdata$?InputInt3@ImGui@@YA_NPEBDQEAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$?InputInt3@ImGui@@YA_NPEBDQEAHH@Z
$pdata$?InputInt4@ImGui@@YA_NPEBDQEAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$?InputInt4@ImGui@@YA_NPEBDQEAHH@Z
$pdata$?InputDouble@ImGui@@YA_NPEBDPEANNN0H@Z DD imagerel $LN7
	DD	imagerel $LN7+204
	DD	imagerel $unwind$?InputDouble@ImGui@@YA_NPEBDPEANNN0H@Z
$pdata$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD imagerel $LN17
	DD	imagerel $LN17+1120
	DD	imagerel $unwind$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
$pdata$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z DD imagerel $LN7
	DD	imagerel $LN7+390
	DD	imagerel $unwind$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z
$pdata$?ColorEdit3@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?ColorEdit3@ImGui@@YA_NPEBDQEAMH@Z
$pdata$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN117
	DD	imagerel $LN117+5840
	DD	imagerel $unwind$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$0@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$0@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$1@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$1@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$1@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$2@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$2@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$2@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$3@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$3@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$3@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$5@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$5@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$5@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$5@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$6@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$6@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$6@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$6@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$7@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$7@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$7@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$7@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$8@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$8@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$8@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$8@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$9@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$9@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$9@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$9@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$10@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$10@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$10@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$10@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$11@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$11@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$11@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$11@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$12@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$12@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$12@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$12@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$13@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$13@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$13@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$13@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$14@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$14@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$14@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$14@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$15@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$15@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$15@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$15@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$16@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$16@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$16@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$16@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$18@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$18@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$18@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$18@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$19@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$19@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$19@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$19@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$20@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$20@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$20@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$20@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$21@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$21@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$21@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$21@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$22@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$22@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$22@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$22@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$23@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$23@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$23@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$23@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$24@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$24@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$24@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$24@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$25@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$25@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$25@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$25@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$26@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$26@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$26@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$26@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$27@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$27@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$27@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$27@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$28@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$28@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$28@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$28@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$pdata$?dtor$29@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD imagerel ?dtor$29@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DD	imagerel ?dtor$29@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA+27
	DD	imagerel $unwind$?dtor$29@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ColorPicker3@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN4
	DD	imagerel $LN4+284
	DD	imagerel $unwind$?ColorPicker3@ImGui@@YA_NPEBDQEAMH@Z
$pdata$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD imagerel $LN87
	DD	imagerel $LN87+9303
	DD	imagerel $unwind$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
$pdata$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z DD imagerel $LN21
	DD	imagerel $LN21+2387
	DD	imagerel $unwind$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z
$pdata$?SetColorEditOptions@ImGui@@YAXH@Z DD imagerel $LN6
	DD	imagerel $LN6+113
	DD	imagerel $unwind$?SetColorEditOptions@ImGui@@YAXH@Z
$pdata$?BufferingBar@ImGui@@YA_NPEBDMAEBUImVec2@@AEBI2@Z DD imagerel $LN5
	DD	imagerel $LN5+1378
	DD	imagerel $unwind$?BufferingBar@ImGui@@YA_NPEBDMAEBUImVec2@@AEBI2@Z
$pdata$?Spinner@ImGui@@YA_NPEBDMHAEBI@Z DD imagerel $LN8
	DD	imagerel $LN8+888
	DD	imagerel $unwind$?Spinner@ImGui@@YA_NPEBDMHAEBI@Z
$pdata$?TreeNode@ImGui@@YA_NPEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?TreeNode@ImGui@@YA_NPEBD@Z
$pdata$?TreeNode@ImGui@@YA_NPEBD0ZZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?TreeNode@ImGui@@YA_NPEBD0ZZ
$pdata$?TreeNode@ImGui@@YA_NPEBXPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?TreeNode@ImGui@@YA_NPEBXPEBDZZ
$pdata$?TreeNodeV@ImGui@@YA_NPEBD0PEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?TreeNodeV@ImGui@@YA_NPEBD0PEAD@Z
$pdata$?TreeNodeV@ImGui@@YA_NPEBXPEBDPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?TreeNodeV@ImGui@@YA_NPEBXPEBDPEAD@Z
$pdata$?TreeNodeEx@ImGui@@YA_NPEBDH@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?TreeNodeEx@ImGui@@YA_NPEBDH@Z
$pdata$?TreeNodeEx@ImGui@@YA_NPEBDH0ZZ DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$?TreeNodeEx@ImGui@@YA_NPEBDH0ZZ
$pdata$?TreeNodeEx@ImGui@@YA_NPEBXHPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$?TreeNodeEx@ImGui@@YA_NPEBXHPEBDZZ
$pdata$?TreeNodeExV@ImGui@@YA_NPEBDH0PEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+179
	DD	imagerel $unwind$?TreeNodeExV@ImGui@@YA_NPEBDH0PEAD@Z
$pdata$?TreeNodeExV@ImGui@@YA_NPEBXHPEBDPEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+176
	DD	imagerel $unwind$?TreeNodeExV@ImGui@@YA_NPEBXHPEBDPEAD@Z
$pdata$?TreePush@ImGui@@YAXPEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+99
	DD	imagerel $unwind$?TreePush@ImGui@@YAXPEBD@Z
$pdata$?TreePush@ImGui@@YAXPEBX@Z DD imagerel $LN5
	DD	imagerel $LN5+99
	DD	imagerel $unwind$?TreePush@ImGui@@YAXPEBX@Z
$pdata$?TreePop@ImGui@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+309
	DD	imagerel $unwind$?TreePop@ImGui@@YAXXZ
$pdata$?TreeAdvanceToLabelPos@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?TreeAdvanceToLabelPos@ImGui@@YAXXZ
$pdata$?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ
$pdata$?SetNextTreeNodeOpen@ImGui@@YAX_NH@Z DD imagerel $LN6
	DD	imagerel $LN6+104
	DD	imagerel $unwind$?SetNextTreeNodeOpen@ImGui@@YAX_NH@Z
$pdata$?CollapsingHeader@ImGui@@YA_NPEBDH@Z DD imagerel $LN4
	DD	imagerel $LN4+95
	DD	imagerel $unwind$?CollapsingHeader@ImGui@@YA_NPEBDH@Z
$pdata$?CollapsingHeader@ImGui@@YA_NPEBDPEA_NH@Z DD imagerel $LN9
	DD	imagerel $LN9+466
	DD	imagerel $unwind$?CollapsingHeader@ImGui@@YA_NPEBDPEA_NH@Z
$pdata$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z DD imagerel $LN45
	DD	imagerel $LN45+2029
	DD	imagerel $unwind$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z
$pdata$?Selectable@ImGui@@YA_NPEBDPEA_NHAEBUImVec2@@@Z DD imagerel $LN6
	DD	imagerel $LN6+112
	DD	imagerel $unwind$?Selectable@ImGui@@YA_NPEBDPEA_NHAEBUImVec2@@@Z
$pdata$?ListBox@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$?ListBox@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z
$pdata$?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD imagerel $LN16
	DD	imagerel $LN16+443
	DD	imagerel $unwind$?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z@4HA DD imagerel ?dtor$0@?0??ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z@4HA
	DD	imagerel ?dtor$0@?0??ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ListBoxHeader@ImGui@@YA_NPEBDAEBUImVec2@@@Z DD imagerel $LN8
	DD	imagerel $LN8+711
	DD	imagerel $unwind$?ListBoxHeader@ImGui@@YA_NPEBDAEBUImVec2@@@Z
$pdata$?ListBoxHeader@ImGui@@YA_NPEBDHH@Z DD imagerel $LN6
	DD	imagerel $LN6+195
	DD	imagerel $unwind$?ListBoxHeader@ImGui@@YA_NPEBDHH@Z
$pdata$?ListBoxFooter@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+135
	DD	imagerel $unwind$?ListBoxFooter@ImGui@@YAXXZ
$pdata$?PlotLines@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+155
	DD	imagerel $unwind$?PlotLines@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z
$pdata$?PlotLines@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z DD imagerel $LN3
	DD	imagerel $LN3+127
	DD	imagerel $unwind$?PlotLines@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z
$pdata$?PlotHistogram@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+158
	DD	imagerel $unwind$?PlotHistogram@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z
$pdata$?PlotHistogram@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z DD imagerel $LN3
	DD	imagerel $LN3+130
	DD	imagerel $unwind$?PlotHistogram@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z
$pdata$?Value@ImGui@@YAXPEBD_N@Z DD imagerel $LN5
	DD	imagerel $LN5+76
	DD	imagerel $unwind$?Value@ImGui@@YAXPEBD_N@Z
$pdata$?Value@ImGui@@YAXPEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?Value@ImGui@@YAXPEBDH@Z
$pdata$?Value@ImGui@@YAXPEBDI@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?Value@ImGui@@YAXPEBDI@Z
$pdata$?Value@ImGui@@YAXPEBDM0@Z DD imagerel $LN5
	DD	imagerel $LN5+170
	DD	imagerel $unwind$?Value@ImGui@@YAXPEBDM0@Z
$pdata$?BeginMainMenuBar@ImGui@@YA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+435
	DD	imagerel $unwind$?BeginMainMenuBar@ImGui@@YA_NXZ
$pdata$?EndMainMenuBar@ImGui@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$?EndMainMenuBar@ImGui@@YAXXZ
$pdata$?BeginMenuBar@ImGui@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+442
	DD	imagerel $unwind$?BeginMenuBar@ImGui@@YA_NXZ
$pdata$?EndMenuBar@ImGui@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+510
	DD	imagerel $unwind$?EndMenuBar@ImGui@@YAXXZ
$pdata$?BeginMenu@ImGui@@YA_NPEBD_N@Z DD imagerel $LN53
	DD	imagerel $LN53+3033
	DD	imagerel $unwind$?BeginMenu@ImGui@@YA_NPEBD_N@Z
$pdata$?EndMenu@ImGui@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+149
	DD	imagerel $unwind$?EndMenu@ImGui@@YAXXZ
$pdata$?MenuItem@ImGui@@YA_NPEBD0_N1@Z DD imagerel $LN17
	DD	imagerel $LN17+1187
	DD	imagerel $unwind$?MenuItem@ImGui@@YA_NPEBD0_N1@Z
$pdata$?MenuItem@ImGui@@YA_NPEBD0PEA_N_N@Z DD imagerel $LN9
	DD	imagerel $LN9+155
	DD	imagerel $unwind$?MenuItem@ImGui@@YA_NPEBD0PEA_N_N@Z
$pdata$?BeginTabBar@ImGui@@YA_NPEBDH@Z DD imagerel $LN4
	DD	imagerel $LN4+274
	DD	imagerel $unwind$?BeginTabBar@ImGui@@YA_NPEBDH@Z
$pdata$?EndTabBar@ImGui@@YAXXZ DD imagerel $LN11
	DD	imagerel $LN11+303
	DD	imagerel $unwind$?EndTabBar@ImGui@@YAXXZ
$pdata$?BeginTabItem@ImGui@@YA_NPEBDPEA_NH@Z DD imagerel $LN5
	DD	imagerel $LN5+230
	DD	imagerel $unwind$?BeginTabItem@ImGui@@YA_NPEBDPEA_NH@Z
$pdata$?EndTabItem@ImGui@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+152
	DD	imagerel $unwind$?EndTabItem@ImGui@@YAXXZ
$pdata$?SetTabItemClosed@ImGui@@YAXPEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+171
	DD	imagerel $unwind$?SetTabItemClosed@ImGui@@YAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@G@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@G@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@G@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@G@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@G@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+141
	DD	imagerel $unwind$?reserve@?$ImVector@G@@QEAAXH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z DD imagerel $LN11
	DD	imagerel $LN11+579
	DD	imagerel $unwind$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z
$pdata$??0ImGuiInputTextCallbackData@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??0ImGuiInputTextCallbackData@@QEAA@XZ
$pdata$?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z DD imagerel $LN8
	DD	imagerel $LN8+281
	DD	imagerel $unwind$?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z
$pdata$?InputFloat@ImGui@@YA_NPEBDPEAMMMHH@Z DD imagerel $LN4
	DD	imagerel $LN4+200
	DD	imagerel $unwind$?InputFloat@ImGui@@YA_NPEBDPEAMMMHH@Z
$pdata$?InputFloat2@ImGui@@YA_NPEBDQEAMHH@Z DD imagerel $LN4
	DD	imagerel $LN4+215
	DD	imagerel $unwind$?InputFloat2@ImGui@@YA_NPEBDQEAMHH@Z
$pdata$?InputFloat3@ImGui@@YA_NPEBDQEAMHH@Z DD imagerel $LN4
	DD	imagerel $LN4+215
	DD	imagerel $unwind$?InputFloat3@ImGui@@YA_NPEBDQEAMHH@Z
$pdata$?InputFloat4@ImGui@@YA_NPEBDQEAMHH@Z DD imagerel $LN4
	DD	imagerel $LN4+215
	DD	imagerel $unwind$?InputFloat4@ImGui@@YA_NPEBDQEAMHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@D@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@D@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@D@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@D@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@D@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@D@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@D@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$?reserve@?$ImVector@D@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiTextBuffer@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??0ImGuiTextBuffer@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiTextBuffer@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImGuiTextBuffer@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiTextBuffer@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiTextBuffer@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@ImGuiTextBuffer@@QEBAHXZ DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$?size@ImGuiTextBuffer@@QEBAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiTextBuffer@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1ImGuiTextBuffer@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiListClipper@@QEAA@HM@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0ImGuiListClipper@@QEAA@HM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImColor@@QEAA@HHHH@Z DD imagerel $LN3
	DD	imagerel $LN3+147
	DD	imagerel $unwind$??0ImColor@@QEAA@HHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??BImColor@@QEBAIXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??BImColor@@QEBAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathFillConvex@ImDrawList@@QEAAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$?PathFillConvex@ImDrawList@@QEAAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathStroke@ImDrawList@@QEAAXI_NM@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$?PathStroke@ImDrawList@@QEAAXI_NM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCharAdvance@ImFont@@QEBAMG@Z DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$?GetCharAdvance@ImFont@@QEBAMG@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?ImCharIsBlankA@@YA_ND@Z DD imagerel ?ImCharIsBlankA@@YA_ND@Z
	DD	imagerel ?ImCharIsBlankA@@YA_ND@Z+53
	DD	imagerel $unwind$?ImCharIsBlankA@@YA_ND@Z
$pdata$?ImCharIsBlankW@@YA_NI@Z DD imagerel ?ImCharIsBlankW@@YA_NI@Z
	DD	imagerel ?ImCharIsBlankW@@YA_NI@Z+57
	DD	imagerel $unwind$?ImCharIsBlankW@@YA_NI@Z
$pdata$?ImParseFormatFindStart@@YAPEBDPEBD@Z DD imagerel $LN8
	DD	imagerel $LN8+126
	DD	imagerel $unwind$?ImParseFormatFindStart@@YAPEBDPEBD@Z
$pdata$?ImParseFormatFindEnd@@YAPEBDPEBD@Z DD imagerel $LN9
	DD	imagerel $LN9+235
	DD	imagerel $unwind$?ImParseFormatFindEnd@@YAPEBDPEBD@Z
$pdata$?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+168
	DD	imagerel $unwind$?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z
$pdata$?ImParseFormatPrecision@@YAHPEBDH@Z DD imagerel $LN15
	DD	imagerel $LN15+298
	DD	imagerel $unwind$?ImParseFormatPrecision@@YAHPEBDH@Z
$pdata$??D@YA?AUImVec2@@AEBU0@M@Z DD imagerel ??D@YA?AUImVec2@@AEBU0@M@Z
	DD	imagerel ??D@YA?AUImVec2@@AEBU0@M@Z+74
	DD	imagerel $unwind$??D@YA?AUImVec2@@AEBU0@M@Z
$pdata$??H@YA?AUImVec2@@AEBU0@0@Z DD imagerel ??H@YA?AUImVec2@@AEBU0@0@Z
	DD	imagerel ??H@YA?AUImVec2@@AEBU0@0@Z+80
	DD	imagerel $unwind$??H@YA?AUImVec2@@AEBU0@0@Z
$pdata$??G@YA?AUImVec2@@AEBU0@0@Z DD imagerel ??G@YA?AUImVec2@@AEBU0@0@Z
	DD	imagerel ??G@YA?AUImVec2@@AEBU0@0@Z+80
	DD	imagerel $unwind$??G@YA?AUImVec2@@AEBU0@0@Z
$pdata$?ImFabs@@YAMM@Z DD imagerel ?ImFabs@@YAMM@Z
	DD	imagerel ?ImFabs@@YAMM@Z+26
	DD	imagerel $unwind$?ImFabs@@YAMM@Z
$pdata$?ImPow@@YAMMM@Z DD imagerel ?ImPow@@YAMMM@Z
	DD	imagerel ?ImPow@@YAMMM@Z+38
	DD	imagerel $unwind$?ImPow@@YAMMM@Z
$pdata$?ImPow@@YANNN@Z DD imagerel ?ImPow@@YANNN@Z
	DD	imagerel ?ImPow@@YANNN@Z+38
	DD	imagerel $unwind$?ImPow@@YANNN@Z
$pdata$?ImFmod@@YAMMM@Z DD imagerel ?ImFmod@@YAMMM@Z
	DD	imagerel ?ImFmod@@YAMMM@Z+38
	DD	imagerel $unwind$?ImFmod@@YAMMM@Z
$pdata$?ImCos@@YAMM@Z DD imagerel ?ImCos@@YAMM@Z
	DD	imagerel ?ImCos@@YAMM@Z+26
	DD	imagerel $unwind$?ImCos@@YAMM@Z
$pdata$?ImSin@@YAMM@Z DD imagerel ?ImSin@@YAMM@Z
	DD	imagerel ?ImSin@@YAMM@Z+26
	DD	imagerel $unwind$?ImSin@@YAMM@Z
$pdata$?ImAtan2@@YAMMM@Z DD imagerel ?ImAtan2@@YAMMM@Z
	DD	imagerel ?ImAtan2@@YAMMM@Z+38
	DD	imagerel $unwind$?ImAtan2@@YAMMM@Z
$pdata$?ImAtof@@YANPEBD@Z DD imagerel ?ImAtof@@YANPEBD@Z
	DD	imagerel ?ImAtof@@YANPEBD@Z+24
	DD	imagerel $unwind$?ImAtof@@YANPEBD@Z
$pdata$?ImMin@@YA?AUImVec2@@AEBU1@0@Z DD imagerel ?ImMin@@YA?AUImVec2@@AEBU1@0@Z
	DD	imagerel ?ImMin@@YA?AUImVec2@@AEBU1@0@Z+157
	DD	imagerel $unwind$?ImMin@@YA?AUImVec2@@AEBU1@0@Z
$pdata$?ImMax@@YA?AUImVec2@@AEBU1@0@Z DD imagerel ?ImMax@@YA?AUImVec2@@AEBU1@0@Z
	DD	imagerel ?ImMax@@YA?AUImVec2@@AEBU1@0@Z+157
	DD	imagerel $unwind$?ImMax@@YA?AUImVec2@@AEBU1@0@Z
$pdata$?ImLerp@@YA?AUImVec2@@AEBU1@0M@Z DD imagerel ?ImLerp@@YA?AUImVec2@@AEBU1@0M@Z
	DD	imagerel ?ImLerp@@YA?AUImVec2@@AEBU1@0M@Z+131
	DD	imagerel $unwind$?ImLerp@@YA?AUImVec2@@AEBU1@0M@Z
$pdata$?ImLerp@@YA?AUImVec2@@AEBU1@00@Z DD imagerel ?ImLerp@@YA?AUImVec2@@AEBU1@00@Z
	DD	imagerel ?ImLerp@@YA?AUImVec2@@AEBU1@00@Z+137
	DD	imagerel $unwind$?ImLerp@@YA?AUImVec2@@AEBU1@00@Z
$pdata$?ImSaturate@@YAMM@Z DD imagerel ?ImSaturate@@YAMM@Z
	DD	imagerel ?ImSaturate@@YAMM@Z+94
	DD	imagerel $unwind$?ImSaturate@@YAMM@Z
$pdata$?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z DD imagerel ?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z
	DD	imagerel ?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z+119
	DD	imagerel $unwind$?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z
$pdata$?ImLinearSweep@@YAMMMM@Z DD imagerel ?ImLinearSweep@@YAMMMM@Z
	DD	imagerel ?ImLinearSweep@@YAMMMM@Z+109
	DD	imagerel $unwind$?ImLinearSweep@@YAMMMM@Z
$pdata$??$ImMin@M@@YAMMM@Z DD imagerel ??$ImMin@M@@YAMMM@Z
	DD	imagerel ??$ImMin@M@@YAMMM@Z+63
	DD	imagerel $unwind$??$ImMin@M@@YAMMM@Z
$pdata$??$ImMax@M@@YAMMM@Z DD imagerel ??$ImMax@M@@YAMMM@Z
	DD	imagerel ??$ImMax@M@@YAMMM@Z+63
	DD	imagerel $unwind$??$ImMax@M@@YAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImRect@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$??0ImRect@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImRect@@QEAA@AEBUImVec4@@@Z DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$??0ImRect@@QEAA@AEBUImVec4@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImRect@@QEAA@MMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$??0ImRect@@QEAA@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCenter@ImRect@@QEBA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$?GetCenter@ImRect@@QEBA?AUImVec2@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetSize@ImRect@@QEBA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?GetSize@ImRect@@QEBA?AUImVec2@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetTR@ImRect@@QEBA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?GetTR@ImRect@@QEBA?AUImVec2@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetBL@ImRect@@QEBA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?GetBL@ImRect@@QEBA?AUImVec2@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z DD imagerel $LN5
	DD	imagerel $LN5+120
	DD	imagerel $unwind$?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Contains@ImRect@@QEBA_NAEBU1@@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?Contains@ImRect@@QEBA_NAEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Overlaps@ImRect@@QEBA_NAEBU1@@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?Overlaps@ImRect@@QEBA_NAEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClipWith@ImRect@@QEAAXAEBU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$?ClipWith@ImRect@@QEAAXAEBU1@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0ImGuiMenuColumns@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$??0ImGuiMenuColumns@@QEAA@XZ
$pdata$?Update@ImGuiMenuColumns@@QEAAXHM_N@Z DD imagerel $LN8
	DD	imagerel $LN8+302
	DD	imagerel $unwind$?Update@ImGuiMenuColumns@@QEAAXHM_N@Z
$pdata$?DeclColumns@ImGuiMenuColumns@@QEAAMMMM@Z DD imagerel $LN8
	DD	imagerel $LN8+359
	DD	imagerel $unwind$?DeclColumns@ImGuiMenuColumns@@QEAAMMMM@Z
$pdata$?CalcExtraSpace@ImGuiMenuColumns@@QEAAMM@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?CalcExtraSpace@ImGuiMenuColumns@@QEAAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CursorClamp@ImGuiInputTextState@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$?CursorClamp@ImGuiInputTextState@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?HasSelection@ImGuiInputTextState@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$?HasSelection@ImGuiInputTextState@@QEBA_NXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z
$pdata$??$ImMin@H@@YAHHH@Z DD imagerel ??$ImMin@H@@YAHHH@Z
	DD	imagerel ??$ImMin@H@@YAHHH@Z+46
	DD	imagerel $unwind$??$ImMin@H@@YAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+149
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@I@Z DD imagerel $LN4
	DD	imagerel $LN4+121
	DD	imagerel $unwind$?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ DD imagerel $LN8
	DD	imagerel $LN8+289
	DD	imagerel $unwind$?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ@4HA DD imagerel ?dtor$0@?0??Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ@4HA
	DD	imagerel ?dtor$0@?0??Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ@4HA+35
	DD	imagerel $unwind$?dtor$0@?0??Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiTabBarSortItem@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiTabBarSortItem@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@PEAUImGuiTabBar@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@PEAUImGuiTabBar@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@PEAUImGuiTabBar@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@PEAUImGuiTabBar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXAEBQEAUImGuiTabBar@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXAEBQEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$ImVector@UImGuiGroupData@@@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$?empty@?$ImVector@UImGuiGroupData@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@I@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@I@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@I@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@I@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@I@@QEAAXAEBI@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@I@@QEAAXAEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TitleBarHeight@ImGuiWindow@@QEBAMXZ DD imagerel $LN5
	DD	imagerel $LN5+89
	DD	imagerel $unwind$?TitleBarHeight@ImGuiWindow@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MenuBarHeight@ImGuiWindow@@QEBAMXZ DD imagerel $LN5
	DD	imagerel $LN5+111
	DD	imagerel $unwind$?MenuBarHeight@ImGuiWindow@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ DD imagerel $LN3
	DD	imagerel $LN3+168
	DD	imagerel $unwind$?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiItemHoveredDataBackup@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$??0ImGuiItemHoveredDataBackup@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Backup@ImGuiItemHoveredDataBackup@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$?Backup@ImGuiItemHoveredDataBackup@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Restore@ImGuiItemHoveredDataBackup@@QEBAXXZ DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$?Restore@ImGuiItemHoveredDataBackup@@QEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z DD imagerel $LN3
	DD	imagerel $LN3+158
	DD	imagerel $unwind$?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QEBAHPEBUImGuiTabItem@@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QEBAHPEBUImGuiTabItem@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0ImGuiTabBar@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+293
	DD	imagerel $unwind$??0ImGuiTabBar@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiTabBar@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImGuiTabBar@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiTabBar@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiTabBar@@QEAA@XZ@4HA
$pdata$?dtor$1@?0???0ImGuiTabBar@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0ImGuiTabBar@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0ImGuiTabBar@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0ImGuiTabBar@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetTabOrder@ImGuiTabBar@@QEBAHPEBUImGuiTabItem@@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?GetTabOrder@ImGuiTabBar@@QEBAHPEBUImGuiTabItem@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsKeyPressedMap@ImGui@@YA_NH_N@Z DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$?IsKeyPressedMap@ImGui@@YA_NH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsNavInputDown@ImGui@@YA_NH@Z DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$?IsNavInputDown@ImGui@@YA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@H@Z DD imagerel $LN10
	DD	imagerel $LN10+844
	DD	imagerel $unwind$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@H@Z
$pdata$?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z DD imagerel $LN8
	DD	imagerel $LN8+130
	DD	imagerel $unwind$?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z
$pdata$?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z DD imagerel $LN7
	DD	imagerel $LN7+151
	DD	imagerel $unwind$?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z
$pdata$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NH@Z DD imagerel $LN63
	DD	imagerel $LN63+2990
	DD	imagerel $unwind$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NH@Z
$pdata$?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z DD imagerel $LN5
	DD	imagerel $LN5+297
	DD	imagerel $unwind$?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z
$pdata$?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z DD imagerel $LN4
	DD	imagerel $LN4+859
	DD	imagerel $unwind$?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z
$pdata$?TabItemLabelAndCloseButton@ImGui@@YA_NPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII@Z DD imagerel $LN17
	DD	imagerel $LN17+2005
	DD	imagerel $unwind$?TabItemLabelAndCloseButton@ImGui@@YA_NPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII@Z
$pdata$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z DD imagerel $LN21
	DD	imagerel $LN21+1002
	DD	imagerel $unwind$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z
$pdata$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z DD imagerel $LN15
	DD	imagerel $LN15+852
	DD	imagerel $unwind$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z
$pdata$?CloseButton@ImGui@@YA_NIAEBUImVec2@@M@Z DD imagerel $LN9
	DD	imagerel $LN9+976
	DD	imagerel $unwind$?CloseButton@ImGui@@YA_NIAEBUImVec2@@M@Z
$pdata$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@@Z DD imagerel $LN12
	DD	imagerel $LN12+696
	DD	imagerel $unwind$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@@Z
$pdata$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z DD imagerel $LN12
	DD	imagerel $LN12+657
	DD	imagerel $unwind$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z
$pdata$?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z DD imagerel $LN57
	DD	imagerel $LN57+3234
	DD	imagerel $unwind$?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z
$pdata$?GetScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z DD imagerel $LN5
	DD	imagerel $LN5+69
	DD	imagerel $unwind$?GetScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z
$pdata$?VerticalSeparator@ImGui@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+422
	DD	imagerel $unwind$?VerticalSeparator@ImGui@@YAXXZ
$pdata$?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z DD imagerel $LN59
	DD	imagerel $LN59+1922
	DD	imagerel $unwind$?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z
$pdata$?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDMH@Z DD imagerel $LN42
	DD	imagerel $LN42+1404
	DD	imagerel $unwind$?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDMH@Z
$pdata$?SliderBehavior@ImGui@@YA_NAEBUImRect@@IHPEAXPEBX2PEBDMHPEAU2@@Z DD imagerel $LN13
	DD	imagerel $LN13+808
	DD	imagerel $unwind$?SliderBehavior@ImGui@@YA_NAEBUImRect@@IHPEAXPEBX2PEBDMHPEAU2@@Z
$pdata$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMM@Z DD imagerel $LN26
	DD	imagerel $LN26+1161
	DD	imagerel $unwind$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMM@Z
$pdata$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z DD imagerel $LN65
	DD	imagerel $LN65+3177
	DD	imagerel $unwind$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z
$pdata$?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z DD imagerel $LN16
	DD	imagerel $LN16+367
	DD	imagerel $unwind$?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z
$pdata$?TreePushRawID@ImGui@@YAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$?TreePushRawID@ImGui@@YAXI@Z
$pdata$?InputTextEx@ImGui@@YA_NPEBDPEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD imagerel $LN310
	DD	imagerel $LN310+14752
	DD	imagerel $unwind$?InputTextEx@ImGui@@YA_NPEBDPEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
$pdata$?InputScalarAsWidgetReplacement@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1@Z DD imagerel $LN8
	DD	imagerel $LN8+409
	DD	imagerel $unwind$?InputScalarAsWidgetReplacement@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1@Z
$pdata$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD imagerel $LN10
	DD	imagerel $LN10+1082
	DD	imagerel $unwind$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
$pdata$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN41
	DD	imagerel $LN41+1489
	DD	imagerel $unwind$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
$pdata$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN22
	DD	imagerel $LN22+698
	DD	imagerel $unwind$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
$pdata$?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PEBDP6AMPEAXH@Z2HH1MMUImVec2@@@Z DD imagerel $LN51
	DD	imagerel $LN51+3098
	DD	imagerel $unwind$?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PEBDP6AMPEAXH@Z2HH1MMUImVec2@@@Z
$pdata$?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z DD imagerel ?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z
	DD	imagerel ?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z+222
	DD	imagerel $unwind$?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z
$pdata$?DataTypeApplyOp@@YAXHHPEAX0PEBX@Z DD imagerel ?DataTypeApplyOp@@YAXHHPEAX0PEBX@Z
	DD	imagerel ?DataTypeApplyOp@@YAXHHPEAX0PEBX@Z+508
	DD	imagerel $unwind$?DataTypeApplyOp@@YAXHHPEAX0PEBX@Z
$pdata$?DataTypeApplyOpFromText@@YA_NPEBD0HPEAX0@Z DD imagerel ?DataTypeApplyOpFromText@@YA_NPEBD0HPEAX0@Z
	DD	imagerel ?DataTypeApplyOpFromText@@YA_NPEBD0HPEAX0@Z+1383
	DD	imagerel $unwind$?DataTypeApplyOpFromText@@YA_NPEBD0HPEAX0@Z
$pdata$?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD imagerel ?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
	DD	imagerel ?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z+770
	DD	imagerel $unwind$?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
$pdata$?InputTextCalcTextLenAndLineCount@@YAHPEBDPEAPEBD@Z DD imagerel ?InputTextCalcTextLenAndLineCount@@YAHPEBDPEAPEBD@Z
	DD	imagerel ?InputTextCalcTextLenAndLineCount@@YAHPEBDPEAPEBD@Z+185
	DD	imagerel $unwind$?InputTextCalcTextLenAndLineCount@@YAHPEBDPEAPEBD@Z
$pdata$?InputTextCalcTextSizeW@@YA?AUImVec2@@PEBG0PEAPEBGPEAU1@_N@Z DD imagerel ?InputTextCalcTextSizeW@@YA?AUImVec2@@PEBG0PEAPEBGPEAU1@_N@Z
	DD	imagerel ?InputTextCalcTextSizeW@@YA?AUImVec2@@PEBG0PEAPEBGPEAU1@_N@Z+504
	DD	imagerel $unwind$?InputTextCalcTextSizeW@@YA?AUImVec2@@PEBG0PEAPEBGPEAU1@_N@Z
$pdata$??$ImClamp@M@@YAMMMM@Z DD imagerel ??$ImClamp@M@@YAMMMM@Z
	DD	imagerel ??$ImClamp@M@@YAMMMM@Z+108
	DD	imagerel $unwind$??$ImClamp@M@@YAMMMM@Z
$pdata$?CalcMaxPopupHeightFromItemCount@@YAMH@Z DD imagerel ?CalcMaxPopupHeightFromItemCount@@YAMH@Z
	DD	imagerel ?CalcMaxPopupHeightFromItemCount@@YAMH@Z+111
	DD	imagerel $unwind$?CalcMaxPopupHeightFromItemCount@@YAMH@Z
$pdata$?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z DD imagerel ?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z
	DD	imagerel ?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z+63
	DD	imagerel $unwind$?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z
$pdata$?Items_SingleStringGetter@@YA_NPEAXHPEAPEBD@Z DD imagerel ?Items_SingleStringGetter@@YA_NPEAXHPEAPEBD@Z
	DD	imagerel ?Items_SingleStringGetter@@YA_NPEAXHPEAPEBD@Z+151
	DD	imagerel $unwind$?Items_SingleStringGetter@@YA_NPEAXHPEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiDataTypeInfo@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??1ImGuiDataTypeInfo@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EGDataTypeInfo@@YAXXZ DD imagerel ??__EGDataTypeInfo@@YAXXZ
	DD	imagerel ??__EGDataTypeInfo@@YAXXZ+328
	DD	imagerel $unwind$??__EGDataTypeInfo@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__EGDataTypeInfo@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__EGDataTypeInfo@@YAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???__EGDataTypeInfo@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???__EGDataTypeInfo@@YAXXZ@4HA DD imagerel ?dtor$2@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DD	imagerel ?dtor$2@?0???__EGDataTypeInfo@@YAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$2@?0???__EGDataTypeInfo@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???__EGDataTypeInfo@@YAXXZ@4HA DD imagerel ?dtor$3@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DD	imagerel ?dtor$3@?0???__EGDataTypeInfo@@YAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$3@?0???__EGDataTypeInfo@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0???__EGDataTypeInfo@@YAXXZ@4HA DD imagerel ?dtor$5@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DD	imagerel ?dtor$5@?0???__EGDataTypeInfo@@YAXXZ@4HA+31
	DD	imagerel $unwind$?dtor$5@?0???__EGDataTypeInfo@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0???__EGDataTypeInfo@@YAXXZ@4HA DD imagerel ?dtor$6@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DD	imagerel ?dtor$6@?0???__EGDataTypeInfo@@YAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$6@?0???__EGDataTypeInfo@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$8@?0???__EGDataTypeInfo@@YAXXZ@4HA DD imagerel ?dtor$8@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DD	imagerel ?dtor$8@?0???__EGDataTypeInfo@@YAXXZ@4HA+34
	DD	imagerel $unwind$?dtor$8@?0???__EGDataTypeInfo@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$9@?0???__EGDataTypeInfo@@YAXXZ@4HA DD imagerel ?dtor$9@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DD	imagerel ?dtor$9@?0???__EGDataTypeInfo@@YAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$9@?0???__EGDataTypeInfo@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$11@?0???__EGDataTypeInfo@@YAXXZ@4HA DD imagerel ?dtor$11@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DD	imagerel ?dtor$11@?0???__EGDataTypeInfo@@YAXXZ@4HA+34
	DD	imagerel $unwind$?dtor$11@?0???__EGDataTypeInfo@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$12@?0???__EGDataTypeInfo@@YAXXZ@4HA DD imagerel ?dtor$12@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DD	imagerel ?dtor$12@?0???__EGDataTypeInfo@@YAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$12@?0???__EGDataTypeInfo@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$14@?0???__EGDataTypeInfo@@YAXXZ@4HA DD imagerel ?dtor$14@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DD	imagerel ?dtor$14@?0???__EGDataTypeInfo@@YAXXZ@4HA+34
	DD	imagerel $unwind$?dtor$14@?0???__EGDataTypeInfo@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$15@?0???__EGDataTypeInfo@@YAXXZ@4HA DD imagerel ?dtor$15@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DD	imagerel ?dtor$15@?0???__EGDataTypeInfo@@YAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$15@?0???__EGDataTypeInfo@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FGDataTypeInfo@@YAXXZ DD imagerel ??__FGDataTypeInfo@@YAXXZ
	DD	imagerel ??__FGDataTypeInfo@@YAXXZ+40
	DD	imagerel $unwind$??__FGDataTypeInfo@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?PatchFormatStringFloatToInt@@YAPEBDPEBD@Z DD imagerel ?PatchFormatStringFloatToInt@@YAPEBDPEBD@Z
	DD	imagerel ?PatchFormatStringFloatToInt@@YAPEBDPEBD@Z+354
	DD	imagerel $unwind$?PatchFormatStringFloatToInt@@YAPEBDPEBD@Z
$pdata$?GetMinimumStepAtDecimalPrecision@@YAMH@Z DD imagerel ?GetMinimumStepAtDecimalPrecision@@YAMH@Z
	DD	imagerel ?GetMinimumStepAtDecimalPrecision@@YAMH@Z+100
	DD	imagerel $unwind$?GetMinimumStepAtDecimalPrecision@@YAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDMH@Z DD imagerel $LN48
	DD	imagerel $LN48+1897
	DD	imagerel $unwind$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDMH@Z DD imagerel $LN48
	DD	imagerel $LN48+1923
	DD	imagerel $unwind$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDMH@Z DD imagerel $LN48
	DD	imagerel $LN48+2036
	DD	imagerel $unwind$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDMH@Z DD imagerel $LN66
	DD	imagerel $LN66+2402
	DD	imagerel $unwind$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDMH@Z DD imagerel $LN50
	DD	imagerel $LN50+1929
	DD	imagerel $unwind$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDMH@Z DD imagerel $LN50
	DD	imagerel $LN50+2007
	DD	imagerel $unwind$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDMH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??$ImMax@H@@YAHHH@Z DD imagerel ??$ImMax@H@@YAHHH@Z
	DD	imagerel ??$ImMax@H@@YAHHH@Z+46
	DD	imagerel $unwind$??$ImMax@H@@YAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SliderBehaviorT@HHM@ImGui@@YA_NAEBUImRect@@IHPEAHHHPEBDMHPEAU1@@Z DD imagerel $LN68
	DD	imagerel $LN68+3013
	DD	imagerel $unwind$??$SliderBehaviorT@HHM@ImGui@@YA_NAEBUImRect@@IHPEAHHHPEBDMHPEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SliderBehaviorT@IHM@ImGui@@YA_NAEBUImRect@@IHPEAIIIPEBDMHPEAU1@@Z DD imagerel $LN68
	DD	imagerel $LN68+3036
	DD	imagerel $unwind$??$SliderBehaviorT@IHM@ImGui@@YA_NAEBUImRect@@IHPEAIIIPEBDMHPEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SliderBehaviorT@_J_JN@ImGui@@YA_NAEBUImRect@@IHPEA_J_J2PEBDMHPEAU1@@Z DD imagerel $LN68
	DD	imagerel $LN68+3123
	DD	imagerel $unwind$??$SliderBehaviorT@_J_JN@ImGui@@YA_NAEBUImRect@@IHPEA_J_J2PEBDMHPEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SliderBehaviorT@_K_JN@ImGui@@YA_NAEBUImRect@@IHPEA_K_K2PEBDMHPEAU1@@Z DD imagerel $LN84
	DD	imagerel $LN84+3464
	DD	imagerel $unwind$??$SliderBehaviorT@_K_JN@ImGui@@YA_NAEBUImRect@@IHPEA_K_K2PEBDMHPEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SliderBehaviorT@MMM@ImGui@@YA_NAEBUImRect@@IHPEAMMMPEBDMHPEAU1@@Z DD imagerel $LN69
	DD	imagerel $LN69+3075
	DD	imagerel $unwind$??$SliderBehaviorT@MMM@ImGui@@YA_NAEBUImRect@@IHPEAMMMPEBDMHPEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SliderBehaviorT@NNN@ImGui@@YA_NAEBUImRect@@IHPEANNNPEBDMHPEAU1@@Z DD imagerel $LN69
	DD	imagerel $LN69+3133
	DD	imagerel $unwind$??$SliderBehaviorT@NNN@ImGui@@YA_NAEBUImRect@@IHPEANNNPEBDMHPEAU1@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??$ImMin@_K@@YA_K_K0@Z DD imagerel ??$ImMin@_K@@YA_K_K0@Z
	DD	imagerel ??$ImMin@_K@@YA_K_K0@Z+55
	DD	imagerel $unwind$??$ImMin@_K@@YA_K_K0@Z
$pdata$??$ImAtoi@H@@YAPEBDPEBDPEAH@Z DD imagerel ??$ImAtoi@H@@YAPEBDPEBDPEAH@Z
	DD	imagerel ??$ImAtoi@H@@YAPEBDPEBDPEAH@Z+203
	DD	imagerel $unwind$??$ImAtoi@H@@YAPEBDPEBDPEAH@Z
$pdata$?InputTextCallback@@YAHPEAUImGuiInputTextCallbackData@@@Z DD imagerel ?InputTextCallback@@YAHPEAUImGuiInputTextCallbackData@@@Z
	DD	imagerel ?InputTextCallback@@YAHPEAUImGuiInputTextCallbackData@@@Z+158
	DD	imagerel $unwind$?InputTextCallback@@YAHPEAUImGuiInputTextCallbackData@@@Z
$pdata$?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z+49
	DD	imagerel $unwind$?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z
$pdata$?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPEAUImGuiInputTextState@@HH@Z DD imagerel ?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPEAUImGuiInputTextState@@HH@Z
	DD	imagerel ?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPEAUImGuiInputTextState@@HH@Z+155
	DD	imagerel $unwind$?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPEAUImGuiInputTextState@@HH@Z
$pdata$?STB_TEXTEDIT_KEYTOTEXT@ImGuiStb@@YAHH@Z DD imagerel ?STB_TEXTEDIT_KEYTOTEXT@ImGuiStb@@YAHH@Z
	DD	imagerel ?STB_TEXTEDIT_KEYTOTEXT@ImGuiStb@@YAHH@Z+42
	DD	imagerel $unwind$?STB_TEXTEDIT_KEYTOTEXT@ImGuiStb@@YAHH@Z
$pdata$?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z+223
	DD	imagerel $unwind$?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z
$pdata$?is_separator@ImGuiStb@@YA_NI@Z DD imagerel ?is_separator@ImGuiStb@@YA_NI@Z
	DD	imagerel ?is_separator@ImGuiStb@@YA_NI@Z+115
	DD	imagerel $unwind$?is_separator@ImGuiStb@@YA_NI@Z
$pdata$?is_word_boundary_from_right@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?is_word_boundary_from_right@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?is_word_boundary_from_right@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z+159
	DD	imagerel $unwind$?is_word_boundary_from_right@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z
$pdata$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z+94
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z
$pdata$?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z+112
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z
$pdata$?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPEAUImGuiInputTextState@@HH@Z DD imagerel ?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPEAUImGuiInputTextState@@HH@Z
	DD	imagerel ?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPEAUImGuiInputTextState@@HH@Z+248
	DD	imagerel $unwind$?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPEAUImGuiInputTextState@@HH@Z
$pdata$?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z DD imagerel ?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z
	DD	imagerel ?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z+478
	DD	imagerel $unwind$?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z
$pdata$??$ImClamp@H@@YAHHHH@Z DD imagerel ??$ImClamp@H@@YAHHHH@Z
	DD	imagerel ??$ImClamp@H@@YAHHHH@Z+79
	DD	imagerel $unwind$??$ImClamp@H@@YAHHHH@Z
$pdata$?stb_text_locate_coord@ImGuiStb@@YAHPEAUImGuiInputTextState@@MM@Z DD imagerel ?stb_text_locate_coord@ImGuiStb@@YAHPEAUImGuiInputTextState@@MM@Z
	DD	imagerel ?stb_text_locate_coord@ImGuiStb@@YAHPEAUImGuiInputTextState@@MM@Z+586
	DD	imagerel $unwind$?stb_text_locate_coord@ImGuiStb@@YAHPEAUImGuiInputTextState@@MM@Z
$pdata$?stb_textedit_click@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z DD imagerel ?stb_textedit_click@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z
	DD	imagerel ?stb_textedit_click@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z+170
	DD	imagerel $unwind$?stb_textedit_click@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z
$pdata$?stb_textedit_drag@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z DD imagerel ?stb_textedit_drag@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z
	DD	imagerel ?stb_textedit_drag@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z+192
	DD	imagerel $unwind$?stb_textedit_drag@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z
$pdata$?stb_text_undo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_text_undo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_text_undo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+691
	DD	imagerel $unwind$?stb_text_undo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
$pdata$?stb_text_redo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_text_redo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_text_redo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+591
	DD	imagerel $unwind$?stb_text_redo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
$pdata$?stb_text_makeundo_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z DD imagerel ?stb_text_makeundo_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z
	DD	imagerel ?stb_text_makeundo_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z+141
	DD	imagerel $unwind$?stb_text_makeundo_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z
$pdata$?stb_text_makeundo_insert@ImGuiStb@@YAXPEAUSTB_TexteditState@1@HH@Z DD imagerel ?stb_text_makeundo_insert@ImGuiStb@@YAXPEAUSTB_TexteditState@1@HH@Z
	DD	imagerel ?stb_text_makeundo_insert@ImGuiStb@@YAXPEAUSTB_TexteditState@1@HH@Z+53
	DD	imagerel $unwind$?stb_text_makeundo_insert@ImGuiStb@@YAXPEAUSTB_TexteditState@1@HH@Z
$pdata$?stb_text_makeundo_replace@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z DD imagerel ?stb_text_makeundo_replace@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z
	DD	imagerel ?stb_text_makeundo_replace@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z+143
	DD	imagerel $unwind$?stb_text_makeundo_replace@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z
$pdata$?stb_textedit_find_charpos@ImGuiStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z DD imagerel ?stb_textedit_find_charpos@ImGuiStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z
	DD	imagerel ?stb_textedit_find_charpos@ImGuiStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z+645
	DD	imagerel $unwind$?stb_textedit_find_charpos@ImGuiStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z
$pdata$?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+160
	DD	imagerel $unwind$?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
$pdata$?stb_textedit_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z DD imagerel ?stb_textedit_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z
	DD	imagerel ?stb_textedit_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z+82
	DD	imagerel $unwind$?stb_textedit_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z
$pdata$?stb_textedit_delete_selection@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_textedit_delete_selection@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_textedit_delete_selection@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+236
	DD	imagerel $unwind$?stb_textedit_delete_selection@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
$pdata$?stb_textedit_sortselection@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z DD imagerel ?stb_textedit_sortselection@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_textedit_sortselection@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z+70
	DD	imagerel $unwind$?stb_textedit_sortselection@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z
$pdata$?stb_textedit_move_to_first@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z DD imagerel ?stb_textedit_move_to_first@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_textedit_move_to_first@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z+82
	DD	imagerel $unwind$?stb_textedit_move_to_first@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z
$pdata$?stb_textedit_move_to_last@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_textedit_move_to_last@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_textedit_move_to_last@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+102
	DD	imagerel $unwind$?stb_textedit_move_to_last@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
$pdata$?stb_textedit_cut@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_textedit_cut@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_textedit_cut@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+70
	DD	imagerel $unwind$?stb_textedit_cut@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
$pdata$?stb_textedit_paste_internal@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z DD imagerel ?stb_textedit_paste_internal@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z
	DD	imagerel ?stb_textedit_paste_internal@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z+195
	DD	imagerel $unwind$?stb_textedit_paste_internal@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z
$pdata$?stb_textedit_key@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z DD imagerel ?stb_textedit_key@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z
	DD	imagerel ?stb_textedit_key@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z+4152
	DD	imagerel $unwind$?stb_textedit_key@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z
$pdata$?stb_textedit_discard_undo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z DD imagerel ?stb_textedit_discard_undo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z
	DD	imagerel ?stb_textedit_discard_undo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z+365
	DD	imagerel $unwind$?stb_textedit_discard_undo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z
$pdata$?stb_textedit_discard_redo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z DD imagerel ?stb_textedit_discard_redo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z
	DD	imagerel ?stb_textedit_discard_redo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z+482
	DD	imagerel $unwind$?stb_textedit_discard_redo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z
$pdata$?stb_text_create_undo_record@ImGuiStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z DD imagerel ?stb_text_create_undo_record@ImGuiStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z
	DD	imagerel ?stb_text_create_undo_record@ImGuiStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z+200
	DD	imagerel $unwind$?stb_text_create_undo_record@ImGuiStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z
$pdata$?stb_text_createundo@ImGuiStb@@YAPEAGPEAUStbUndoState@1@HHH@Z DD imagerel ?stb_text_createundo@ImGuiStb@@YAPEAGPEAUStbUndoState@1@HHH@Z
	DD	imagerel ?stb_text_createundo@ImGuiStb@@YAPEAGPEAUStbUndoState@1@HHH@Z+186
	DD	imagerel $unwind$?stb_text_createundo@ImGuiStb@@YAPEAGPEAUStbUndoState@1@HHH@Z
$pdata$?stb_textedit_initialize_state@ImGuiStb@@YAXPEAUSTB_TexteditState@1@H@Z DD imagerel ?stb_textedit_initialize_state@ImGuiStb@@YAXPEAUSTB_TexteditState@1@H@Z
	DD	imagerel ?stb_textedit_initialize_state@ImGuiStb@@YAXPEAUSTB_TexteditState@1@H@Z+33
	DD	imagerel $unwind$?stb_textedit_initialize_state@ImGuiStb@@YAXPEAUSTB_TexteditState@1@H@Z
$pdata$?stb_textedit_paste@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z DD imagerel ?stb_textedit_paste@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z
	DD	imagerel ?stb_textedit_paste@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z+54
	DD	imagerel $unwind$?stb_textedit_paste@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ DD imagerel ??__Fids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ
	DD	imagerel ??__Fids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ+40
	DD	imagerel $unwind$??__Fids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ffmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ DD imagerel ??__Ffmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ
	DD	imagerel ??__Ffmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ+58
	DD	imagerel $unwind$??__Ffmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ffmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ DD imagerel ??__Ffmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ
	DD	imagerel ??__Ffmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ+58
	DD	imagerel $unwind$??__Ffmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?ImAlphaBlendColor@@YAIII@Z DD imagerel ?ImAlphaBlendColor@@YAIII@Z
	DD	imagerel ?ImAlphaBlendColor@@YAIII@Z+195
	DD	imagerel $unwind$?ImAlphaBlendColor@@YAIII@Z
$pdata$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1M@Z DD imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1M@Z
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1M@Z+504
	DD	imagerel $unwind$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1M@Z
$pdata$?Plot_ArrayGetter@@YAMPEAXH@Z DD imagerel ?Plot_ArrayGetter@@YAMPEAXH@Z
	DD	imagerel ?Plot_ArrayGetter@@YAMPEAXH@Z+69
	DD	imagerel $unwind$?Plot_ArrayGetter@@YAMPEAXH@Z
$pdata$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+3266
	DD	imagerel $unwind$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
$pdata$?TabBarCalcTabID@ImGui@@YAIPEAUImGuiTabBar@@PEBD@Z DD imagerel ?TabBarCalcTabID@ImGui@@YAIPEAUImGuiTabBar@@PEBD@Z
	DD	imagerel ?TabBarCalcTabID@ImGui@@YAIPEAUImGuiTabBar@@PEBD@Z+109
	DD	imagerel $unwind$?TabBarCalcTabID@ImGui@@YAIPEAUImGuiTabBar@@PEBD@Z
$pdata$?TabBarCalcMaxTabWidth@ImGui@@YAMXZ DD imagerel ?TabBarCalcMaxTabWidth@ImGui@@YAMXZ
	DD	imagerel ?TabBarCalcMaxTabWidth@ImGui@@YAMXZ+40
	DD	imagerel $unwind$?TabBarCalcMaxTabWidth@ImGui@@YAMXZ
$pdata$?TabBarScrollClamp@ImGui@@YAMPEAUImGuiTabBar@@M@Z DD imagerel ?TabBarScrollClamp@ImGui@@YAMPEAUImGuiTabBar@@M@Z
	DD	imagerel ?TabBarScrollClamp@ImGui@@YAMPEAUImGuiTabBar@@M@Z+88
	DD	imagerel $unwind$?TabBarScrollClamp@ImGui@@YAMPEAUImGuiTabBar@@M@Z
$pdata$?TabBarScrollToTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z DD imagerel ?TabBarScrollToTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z
	DD	imagerel ?TabBarScrollToTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z+330
	DD	imagerel $unwind$?TabBarScrollToTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z
$pdata$?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD imagerel ?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
	DD	imagerel ?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+1177
	DD	imagerel $unwind$?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
$pdata$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+616
	DD	imagerel $unwind$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
$pdata$?TabItemComparerByVisibleOffset@@YAHPEBX0@Z DD imagerel ?TabItemComparerByVisibleOffset@@YAHPEBX0@Z
	DD	imagerel ?TabItemComparerByVisibleOffset@@YAHPEBX0@Z+61
	DD	imagerel $unwind$?TabItemComparerByVisibleOffset@@YAHPEBX0@Z
$pdata$?TabBarSortItemComparer@@YAHPEBX0@Z DD imagerel ?TabBarSortItemComparer@@YAHPEBX0@Z
	DD	imagerel ?TabBarSortItemComparer@@YAHPEBX0@Z+93
	DD	imagerel $unwind$?TabBarSortItemComparer@@YAHPEBX0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Max_limit@_J@std@@YA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??$_Max_limit@_J@std@@YA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+266
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD imagerel $LN3
	DD	imagerel $LN3+130
	DD	imagerel $unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel $LN6
	DD	imagerel $LN6+450
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+388
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z DD imagerel $LN3
	DD	imagerel $LN3+131
	DD	imagerel $unwind$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel $LN6
	DD	imagerel $LN6+448
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$RoundScalarWithFormatT@HH@ImGui@@YAHPEBDHH@Z DD imagerel $LN10
	DD	imagerel $LN10+268
	DD	imagerel $unwind$??$RoundScalarWithFormatT@HH@ImGui@@YAHPEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$RoundScalarWithFormatT@IH@ImGui@@YAIPEBDHI@Z DD imagerel $LN10
	DD	imagerel $LN10+269
	DD	imagerel $unwind$??$RoundScalarWithFormatT@IH@ImGui@@YAIPEBDHI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPEBDH_J@Z DD imagerel $LN10
	DD	imagerel $LN10+272
	DD	imagerel $unwind$??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPEBDH_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPEBDH_K@Z DD imagerel $LN11
	DD	imagerel $LN11+321
	DD	imagerel $unwind$??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPEBDH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$RoundScalarWithFormatT@MM@ImGui@@YAMPEBDHM@Z DD imagerel $LN10
	DD	imagerel $LN10+284
	DD	imagerel $unwind$??$RoundScalarWithFormatT@MM@ImGui@@YAMPEBDHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$RoundScalarWithFormatT@NN@ImGui@@YANPEBDHN@Z DD imagerel $LN10
	DD	imagerel $LN10+277
	DD	imagerel $unwind$??$RoundScalarWithFormatT@NN@ImGui@@YANPEBDHN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z DD imagerel $LN13
	DD	imagerel $LN13+508
	DD	imagerel $unwind$??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z DD imagerel $LN13
	DD	imagerel $LN13+525
	DD	imagerel $unwind$??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??$ImMin@I@@YAIII@Z DD imagerel ??$ImMin@I@@YAIII@Z
	DD	imagerel ??$ImMin@I@@YAIII@Z+46
	DD	imagerel $unwind$??$ImMin@I@@YAIII@Z
$pdata$??$ImMax@I@@YAIII@Z DD imagerel ??$ImMax@I@@YAIII@Z
	DD	imagerel ??$ImMax@I@@YAIII@Z+46
	DD	imagerel $unwind$??$ImMax@I@@YAIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z DD imagerel $LN13
	DD	imagerel $LN13+617
	DD	imagerel $unwind$??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??$ImMin@_J@@YA_J_J0@Z DD imagerel ??$ImMin@_J@@YA_J_J0@Z
	DD	imagerel ??$ImMin@_J@@YA_J_J0@Z+55
	DD	imagerel $unwind$??$ImMin@_J@@YA_J_J0@Z
$pdata$??$ImMax@_J@@YA_J_J0@Z DD imagerel ??$ImMax@_J@@YA_J_J0@Z
	DD	imagerel ??$ImMax@_J@@YA_J_J0@Z+55
	DD	imagerel $unwind$??$ImMax@_J@@YA_J_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z DD imagerel $LN23
	DD	imagerel $LN23+780
	DD	imagerel $unwind$??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??$ImMax@_K@@YA_K_K0@Z DD imagerel ??$ImMax@_K@@YA_K_K0@Z
	DD	imagerel ??$ImMax@_K@@YA_K_K0@Z+55
	DD	imagerel $unwind$??$ImMax@_K@@YA_K_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z DD imagerel $LN13
	DD	imagerel $LN13+517
	DD	imagerel $unwind$??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z DD imagerel $LN13
	DD	imagerel $LN13+550
	DD	imagerel $unwind$??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??$ImMin@N@@YANNN@Z DD imagerel ??$ImMin@N@@YANNN@Z
	DD	imagerel ??$ImMin@N@@YANNN@Z+64
	DD	imagerel $unwind$??$ImMin@N@@YANNN@Z
$pdata$??$ImMax@N@@YANNN@Z DD imagerel ??$ImMax@N@@YANNN@Z
	DD	imagerel ??$ImMax@N@@YANNN@Z+64
	DD	imagerel $unwind$??$ImMax@N@@YANNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+135
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z DD imagerel $LN3
	DD	imagerel $LN3+164
	DD	imagerel $unwind$??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD imagerel $LN6
	DD	imagerel $LN6+485
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$??$ImAtoi@_J@@YAPEBDPEBDPEA_J@Z DD imagerel ??$ImAtoi@_J@@YAPEBDPEBDPEA_J@Z
	DD	imagerel ??$ImAtoi@_J@@YAPEBDPEBDPEA_J@Z+222
	DD	imagerel $unwind$??$ImAtoi@_J@@YAPEBDPEBDPEA_J@Z
$pdata$??$ImAtoi@M@@YAPEBDPEBDPEAM@Z DD imagerel ??$ImAtoi@M@@YAPEBDPEBDPEAM@Z
	DD	imagerel ??$ImAtoi@M@@YAPEBDPEBDPEAM@Z+243
	DD	imagerel $unwind$??$ImAtoi@M@@YAPEBDPEBDPEAM@Z
$pdata$??$ImAtoi@N@@YAPEBDPEBDPEAN@Z DD imagerel ??$ImAtoi@N@@YAPEBDPEBDPEAN@Z
	DD	imagerel ??$ImAtoi@N@@YAPEBDPEBDPEAN@Z+245
	DD	imagerel $unwind$??$ImAtoi@N@@YAPEBDPEBDPEAN@Z
$pdata$??$ImClamp@I@@YAIIII@Z DD imagerel ??$ImClamp@I@@YAIIII@Z
	DD	imagerel ??$ImClamp@I@@YAIIII@Z+79
	DD	imagerel $unwind$??$ImClamp@I@@YAIIII@Z
$pdata$??$ImClamp@_J@@YA_J_J00@Z DD imagerel ??$ImClamp@_J@@YA_J_J00@Z
	DD	imagerel ??$ImClamp@_J@@YA_J_J00@Z+94
	DD	imagerel $unwind$??$ImClamp@_J@@YA_J_J00@Z
$pdata$??$ImClamp@_K@@YA_K_K00@Z DD imagerel ??$ImClamp@_K@@YA_K_K00@Z
	DD	imagerel ??$ImClamp@_K@@YA_K_K00@Z+94
	DD	imagerel $unwind$??$ImClamp@_K@@YA_K_K00@Z
$pdata$??$ImClamp@N@@YANNNN@Z DD imagerel ??$ImClamp@N@@YANNNN@Z
	DD	imagerel ??$ImClamp@N@@YANNNN@Z+110
	DD	imagerel $unwind$??$ImClamp@N@@YANNNN@Z
pdata	ENDS
CRT$XCU	SEGMENT
?wsinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Ewsinit_@detail@httplib@@YAXXZ ; httplib::detail::wsinit_$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@ffefffffffffffff
CONST	SEGMENT
__real@ffefffffffffffff DQ 0ffefffffffffffffr	; -1.79769e+308
CONST	ENDS
;	COMDAT __real@ff7fffff
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+38
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@c1400000
CONST	SEGMENT
__real@c1400000 DD 0c1400000r			; -12
CONST	ENDS
;	COMDAT __real@c1100000
CONST	SEGMENT
__real@c1100000 DD 0c1100000r			; -9
CONST	ENDS
;	COMDAT __real@c059000000000000
CONST	SEGMENT
__real@c059000000000000 DQ 0c059000000000000r	; -100
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf5db3d0
CONST	SEGMENT
__real@bf5db3d0 DD 0bf5db3d0r			; -0.866025
CONST	ENDS
;	COMDAT __real@bf400000
CONST	SEGMENT
__real@bf400000 DD 0bf400000r			; -0.75
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@be99999a
CONST	SEGMENT
__real@be99999a DD 0be99999ar			; -0.3
CONST	ENDS
;	COMDAT __real@7fefffffffffffff
CONST	SEGMENT
__real@7fefffffffffffff DQ 07fefffffffffffffr	; 1.79769e+308
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+38
CONST	ENDS
;	COMDAT __real@5f000000
CONST	SEGMENT
__real@5f000000 DD 05f000000r			; 9.22337e+18
CONST	ENDS
;	COMDAT __real@47efffffe0000000
CONST	SEGMENT
__real@47efffffe0000000 DQ 047efffffe0000000r	; 3.40282e+38
CONST	ENDS
;	COMDAT __real@43e0000000000000
CONST	SEGMENT
__real@43e0000000000000 DQ 043e0000000000000r	; 9.22337e+18
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@428c0000
CONST	SEGMENT
__real@428c0000 DD 0428c0000r			; 70
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40eccccd
CONST	SEGMENT
__real@40eccccd DD 040eccccdr			; 7.4
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40b33333
CONST	SEGMENT
__real@40b33333 DD 040b33333r			; 5.6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@403f5c29
CONST	SEGMENT
__real@403f5c29 DD 0403f5c29r			; 2.99
CONST	ENDS
;	COMDAT __real@4024800000000000
CONST	SEGMENT
__real@4024800000000000 DQ 04024800000000000r	; 10.25
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@400e666666666666
CONST	SEGMENT
__real@400e666666666666 DQ 0400e666666666666r	; 3.8
CONST	ENDS
;	COMDAT __real@4004000000000000
CONST	SEGMENT
__real@4004000000000000 DQ 04004000000000000r	; 2.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ffcccccc0000000
CONST	SEGMENT
__real@3ffcccccc0000000 DQ 03ffcccccc0000000r	; 1.8
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fd9999a
CONST	SEGMENT
__real@3fd9999a DD 03fd9999ar			; 1.7
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fb33333
CONST	SEGMENT
__real@3fb33333 DD 03fb33333r			; 1.4
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7ff972
CONST	SEGMENT
__real@3f7ff972 DD 03f7ff972r			; 0.9999
CONST	ENDS
;	COMDAT __real@3f7fbe77
CONST	SEGMENT
__real@3f7fbe77 DD 03f7fbe77r			; 0.999
CONST	ENDS
;	COMDAT __real@3f5db3d0
CONST	SEGMENT
__real@3f5db3d0 DD 03f5db3d0r			; 0.866025
CONST	ENDS
;	COMDAT __real@3f5db22d
CONST	SEGMENT
__real@3f5db22d DD 03f5db22dr			; 0.866
CONST	ENDS
;	COMDAT __real@3f5adaba
CONST	SEGMENT
__real@3f5adaba DD 03f5adabar			; 0.8549
CONST	ENDS
;	COMDAT __real@3f52d2d3
CONST	SEGMENT
__real@3f52d2d3 DD 03f52d2d3r			; 0.823529
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f4a3d71
CONST	SEGMENT
__real@3f4a3d71 DD 03f4a3d71r			; 0.79
CONST	ENDS
;	COMDAT __real@3f48c8c9
CONST	SEGMENT
__real@3f48c8c9 DD 03f48c8c9r			; 0.784314
CONST	ENDS
;	COMDAT __real@3f47ae14
CONST	SEGMENT
__real@3f47ae14 DD 03f47ae14r			; 0.78
CONST	ENDS
;	COMDAT __real@3f350481
CONST	SEGMENT
__real@3f350481 DD 03f350481r			; 0.7071
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f128f5c
CONST	SEGMENT
__real@3f128f5c DD 03f128f5cr			; 0.5725
CONST	ENDS
;	COMDAT __real@3f0ccccd
CONST	SEGMENT
__real@3f0ccccd DD 03f0ccccdr			; 0.55
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3effbe77
CONST	SEGMENT
__real@3effbe77 DD 03effbe77r			; 0.4995
CONST	ENDS
;	COMDAT __real@3ef0f0f1
CONST	SEGMENT
__real@3ef0f0f1 DD 03ef0f0f1r			; 0.470588
CONST	ENDS
;	COMDAT __real@3ececbfb
CONST	SEGMENT
__real@3ececbfb DD 03ececbfbr			; 0.4039
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3ec7ae14
CONST	SEGMENT
__real@3ec7ae14 DD 03ec7ae14r			; 0.39
CONST	ENDS
;	COMDAT __real@3ebcb924
CONST	SEGMENT
__real@3ebcb924 DD 03ebcb924r			; 0.3686
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e3851ec
CONST	SEGMENT
__real@3e3851ec DD 03e3851ecr			; 0.18
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3e09374c
CONST	SEGMENT
__real@3e09374c DD 03e09374cr			; 0.134
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3da3d70a
CONST	SEGMENT
__real@3da3d70a DD 03da3d70ar			; 0.08
CONST	ENDS
;	COMDAT __real@3cdd2f1b
CONST	SEGMENT
__real@3cdd2f1b DD 03cdd2f1br			; 0.027
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-05
CONST	ENDS
;	COMDAT __real@358637bd
CONST	SEGMENT
__real@358637bd DD 0358637bdr			; 1e-06
CONST	ENDS
;	COMDAT __real@00800000
CONST	SEGMENT
__real@00800000 DD 000800000r			; 1.17549e-38
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBNJJJJI@?$CF?4?$CKs@
CONST	SEGMENT
??_C@_04EBNJJJJI@?$CF?4?$CKs@ DB '%.*s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HHKHFPOM@?$CD?$CD?$CL?9v@
CONST	SEGMENT
??_C@_05HHKHFPOM@?$CD?$CD?$CL?9v@ DB '##+-v', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05EPAHJKOB@?$CD?$CD?$CL?9?$DO@
CONST	SEGMENT
??_C@_05EPAHJKOB@?$CD?$CD?$CL?9?$DO@ DB '##+->', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNDBPIGD@?$CD?$CD?$CL?9?$DM@
CONST	SEGMENT
??_C@_05HNDBPIGD@?$CD?$CD?$CL?9?$DM@ DB '##+-<', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GEGHBGML@?$CD?$CD?$CL?9menubar@
CONST	SEGMENT
??_C@_0M@GEGHBGML@?$CD?$CD?$CL?9menubar@ DB '##+-menubar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ELGDDMPM@?$CD?$CDMain?$CL?9Menu?$CL?9Bar@
CONST	SEGMENT
??_C@_0BC@ELGDDMPM@?$CD?$CDMain?$CL?9Menu?$CL?9Bar@ DB '##Main+-Menu+-Bar'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f@
CONST	SEGMENT
??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f@ DB '%s: %.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EKEPIENH@?$CF?$CFs?3?5?$CFs@
CONST	SEGMENT
??_C@_07EKEPIENH@?$CF?$CFs?3?5?$CFs@ DB '%%s: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GBEGMGE@?$CFs?3?5?$CFd@
CONST	SEGMENT
??_C@_06GBEGMGE@?$CFs?3?5?$CFd@ DB '%s: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DJHOIPC@?$CFs?3?5?$CFs@
CONST	SEGMENT
??_C@_06DJHOIPC@?$CFs?3?5?$CFs@ DB '%s: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OADNPGHP@?$CFd?3?5?$CF8?44g@
CONST	SEGMENT
??_C@_09OADNPGHP@?$CFd?3?5?$CF8?44g@ DB '%d: %8.4g', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OBCBLNMM@?$CFd?3?5?$CF8?44g?6?$CFd?3?5?$CF8?44g@
CONST	SEGMENT
??_C@_0BE@OBCBLNMM@?$CFd?3?5?$CF8?44g?6?$CFd?3?5?$CF8?44g@ DB '%d: %8.4g', 0aH
	DB	'%d: %8.4g', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09GHACPMKF@?$CDTreePush@
CONST	SEGMENT
??_C@_09GHACPMKF@?$CDTreePush@ DB '#TreePush', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KEDLMDJL@Alpha?5Bar@
CONST	SEGMENT
??_C@_09KEDLMDJL@Alpha?5Bar@ DB 'Alpha Bar', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PODNGMKL@?$CD?$CD?$CL?9dummypicker@
CONST	SEGMENT
??_C@_0BA@PODNGMKL@?$CD?$CD?$CL?9dummypicker@ DB '##+-dummypicker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OGDNCJGJ@?$CD?$CD?$CL?9selectable@
CONST	SEGMENT
??_C@_0P@OGDNCJGJ@?$CD?$CD?$CL?9selectable@ DB '##+-selectable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MLNOPBDA@0x?$CF02X?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0BD@MLNOPBDA@0x?$CF02X?$CF02X?$CF02X?$CF02X@ DB '0x%02X%02X%02X%02X'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GDANBODO@0x?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0P@GDANBODO@0x?$CF02X?$CF02X?$CF02X@ DB '0x%02X%02X%02X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EJHNAHBL@?$CI?$CFd?0?$CFd?0?$CFd?0?$CFd?$CJ@
CONST	SEGMENT
??_C@_0O@EJHNAHBL@?$CI?$CFd?0?$CFd?0?$CFd?0?$CFd?$CJ@ DB '(%d,%d,%d,%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GKCJMPCH@?$CI?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?$CJ@
CONST	SEGMENT
??_C@_0BN@GKCJMPCH@?$CI?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?$CJ@ DB '('
	DB	'%.3ff, %.3ff, %.3ff, %.3ff)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OPMHGHMB@Copy@
CONST	SEGMENT
??_C@_04OPMHGHMB@Copy@ DB 'Copy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09NMCCFHEI@Copy?5as?4?4@
CONST	SEGMENT
??_C@_09NMCCFHEI@Copy?5as?4?4@ DB 'Copy as..', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MDNPBJBM@0?400?4?41?400@
CONST	SEGMENT
??_C@_0L@MDNPBJBM@0?400?4?41?400@ DB '0.00..1.00', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDBEKFBH@0?4?4255@
CONST	SEGMENT
??_C@_06FDBEKFBH@0?4?4255@ DB '0..255', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IECIMIEG@HEX@
CONST	SEGMENT
??_C@_03IECIMIEG@HEX@ DB 'HEX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CAADKAK@HSV@
CONST	SEGMENT
??_C@_03CAADKAK@HSV@ DB 'HSV', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICFFBAI@RGB@
CONST	SEGMENT
??_C@_03ICFFBAI@RGB@ DB 'RGB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@EBPMGCGK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X?6R?3?$CFd?0?5G?3?$CFd?0?5B@
CONST	SEGMENT
??_C@_0EC@EBPMGCGK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X?6R?3?$CFd?0?5G?3?$CFd?0?5B@ DB '#'
	DB	'%02X%02X%02X%02X', 0aH, 'R:%d, G:%d, B:%d, A:%d', 0aH, '(%.3f'
	DB	', %.3f, %.3f, %.3f)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FAPNKOHO@?$CD?$CF02X?$CF02X?$CF02X?6R?3?5?$CFd?0?5G?3?5?$CFd?0?5B?3?5@
CONST	SEGMENT
??_C@_0DF@FAPNKOHO@?$CD?$CF02X?$CF02X?$CF02X?6R?3?5?$CFd?0?5G?3?5?$CFd?0?5B?3?5@ DB '#'
	DB	'%02X%02X%02X', 0aH, 'R: %d, G: %d, B: %d', 0aH, '(%.3f, %.3f,'
	DB	' %.3f)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KBLIMBPK@?$CD?$CD?$CL?9preview@
CONST	SEGMENT
??_C@_0M@KBLIMBPK@?$CD?$CD?$CL?9preview@ DB '##+-preview', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDOBBJNA@Color@
CONST	SEGMENT
??_C@_05PDOBBJNA@Color@ DB 'Color', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07BACDFNLL@?$CD?$CD?$CL?9hex@
CONST	SEGMENT
??_C@_07BACDFNLL@?$CD?$CD?$CL?9hex@ DB '##+-hex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JGALKPPH@?$CD?$CD?$CL?9hsv@
CONST	SEGMENT
??_C@_07JGALKPPH@?$CD?$CD?$CL?9hsv@ DB '##+-hsv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JMCOMEPF@?$CD?$CD?$CL?9rgb@
CONST	SEGMENT
??_C@_07JMCOMEPF@?$CD?$CD?$CL?9rgb@ DB '##+-rgb', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CHHIOJEB@?$CD?$CD?$CL?9original@
CONST	SEGMENT
??_C@_0N@CHHIOJEB@?$CD?$CD?$CL?9original@ DB '##+-original', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ECAOJHDA@?$CD?$CD?$CDOriginal?$CD?$CD?$CD@
CONST	SEGMENT
??_C@_0P@ECAOJHDA@?$CD?$CD?$CDOriginal?$CD?$CD?$CD@ DB '###Original###', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BANGFOMF@?$CD?$CD?$CL?9current@
CONST	SEGMENT
??_C@_0M@BANGFOMF@?$CD?$CD?$CL?9current@ DB '##+-current', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EALHHNOL@?$CD?$CD?$CDCurrent?$CD?$CD?$CD@
CONST	SEGMENT
??_C@_0O@EALHHNOL@?$CD?$CD?$CDCurrent?$CD?$CD?$CD@ DB '###Current###', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IAEKHIAN@alpha@
CONST	SEGMENT
??_C@_05IAEKHIAN@alpha@ DB 'alpha', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GKJJMKFG@hue@
CONST	SEGMENT
??_C@_03GKJJMKFG@hue@ DB 'hue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CPGMCOJE@sv@
CONST	SEGMENT
??_C@_02CPGMCOJE@sv@ DB 'sv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PPLPHHG@hsv@
CONST	SEGMENT
??_C@_03PPLPHHG@hsv@ DB 'hsv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LAOCEMMP@_COL4F@
CONST	SEGMENT
??_C@_06LAOCEMMP@_COL4F@ DB '_COL4F', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LFKNFKEK@_COL3F@
CONST	SEGMENT
??_C@_06LFKNFKEK@_COL3F@ DB '_COL3F', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPIIJFHG@?$CD?$CD?$CL?9picker@
CONST	SEGMENT
??_C@_0L@OPIIJFHG@?$CD?$CD?$CL?9picker@ DB '##+-picker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAKAMBBI@picker@
CONST	SEGMENT
??_C@_06MAKAMBBI@picker@ DB 'picker', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DICBDPDG@?$CD?$CD?$CL?9ColorButton@
CONST	SEGMENT
??_C@_0BA@DICBDPDG@?$CD?$CD?$CL?9ColorButton@ DB '##+-ColorButton', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KODLFHPJ@?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0N@KODLFHPJ@?$CF02X?$CF02X?$CF02X@ DB '%02X%02X%02X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DDMGLOLI@?$CF02X?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0BB@DDMGLOLI@?$CF02X?$CF02X?$CF02X?$CF02X@ DB '%02X%02X%02X%02X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HDCBKACM@?$CD?$CD?$CL?9Text@
CONST	SEGMENT
??_C@_08HDCBKACM@?$CD?$CD?$CL?9Text@ DB '##+-Text', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@ DB '#%02X%02X%02X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@ DB '#%02X%02X%02X%02'
	DB	'X', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07JKKCBBMM@context@
CONST	SEGMENT
??_C@_07JKKCBBMM@context@ DB 'context', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KGKAEDCN@V?3?$CF0?43f@
CONST	SEGMENT
??_C@_07KGKAEDCN@V?3?$CF0?43f@ DB 'V:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OOEAENEJ@S?3?$CF0?43f@
CONST	SEGMENT
??_C@_07OOEAENEJ@S?3?$CF0?43f@ DB 'S:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MPJBGADE@H?3?$CF0?43f@
CONST	SEGMENT
??_C@_07MPJBGADE@H?3?$CF0?43f@ DB 'H:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NANOHLBP@A?3?$CF0?43f@
CONST	SEGMENT
??_C@_07NANOHLBP@A?3?$CF0?43f@ DB 'A:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FOFBHMPM@B?3?$CF0?43f@
CONST	SEGMENT
??_C@_07FOFBHMPM@B?3?$CF0?43f@ DB 'B:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BGLBHCJI@G?3?$CF0?43f@
CONST	SEGMENT
??_C@_07BGLBHCJI@G?3?$CF0?43f@ DB 'G:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CCOKENNH@R?3?$CF0?43f@
CONST	SEGMENT
??_C@_07CCOKENNH@R?3?$CF0?43f@ DB 'R:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05ONBKDNLK@?$CF0?43f@
CONST	SEGMENT
??_C@_05ONBKDNLK@?$CF0?43f@ DB '%0.3f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPCLLPPH@V?3?$CF3d@
CONST	SEGMENT
??_C@_05MPCLLPPH@V?3?$CF3d@ DB 'V:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JPOGCOEE@S?3?$CF3d@
CONST	SEGMENT
??_C@_05JPOGCOEE@S?3?$CF3d@ DB 'S:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PGPHNMBM@H?3?$CF3d@
CONST	SEGMENT
??_C@_05PGPHNMBM@H?3?$CF3d@ DB 'H:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NBPIINNE@A?3?$CF3d@
CONST	SEGMENT
??_C@_05NBPIINNE@A?3?$CF3d@ DB 'A:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FHGMPPHK@B?3?$CF3d@
CONST	SEGMENT
??_C@_05FHGMPPHK@B?3?$CF3d@ DB 'B:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKBGOMJ@G?3?$CF3d@
CONST	SEGMENT
??_C@_05HKBGOMJ@G?3?$CF3d@ DB 'G:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FELKPNOB@R?3?$CF3d@
CONST	SEGMENT
??_C@_05FELKPNOB@R?3?$CF3d@ DB 'R:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GOOLIKIF@?$CF3d@
CONST	SEGMENT
??_C@_03GOOLIKIF@?$CF3d@ DB '%3d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KDMNBDBJ@?$CD?$CDW@
CONST	SEGMENT
??_C@_03KDMNBDBJ@?$CD?$CDW@ DB '##W', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BGGDGNFE@?$CD?$CDZ@
CONST	SEGMENT
??_C@_03BGGDGNFE@?$CD?$CDZ@ DB '##Z', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNEODOJH@?$CD?$CDY@
CONST	SEGMENT
??_C@_03DNEODOJH@?$CD?$CDY@ DB '##Y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CEFFAPNG@?$CD?$CDX@
CONST	SEGMENT
??_C@_03CEFFAPNG@?$CD?$CDX@ DB '##X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BNGMMMAL@M?3000@
CONST	SEGMENT
??_C@_05BNGMMMAL@M?3000@ DB 'M:000', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FFNLLALM@M?30?4000@
CONST	SEGMENT
??_C@_07FFNLLALM@M?30?4000@ DB 'M:0.000', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?STB_TEXTEDIT_NEWLINE@ImGuiStb@@3GA DW 0aH		; ImGuiStb::STB_TEXTEDIT_NEWLINE
_DATA	ENDS
;	COMDAT ??_C@_04JIMNDDED@?$CF08X@
CONST	SEGMENT
??_C@_04JIMNDDED@?$CF08X@ DB '%08X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@
CONST	SEGMENT
??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@ DB '%%.%df', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01MIFGBAGJ@?$CL@
CONST	SEGMENT
??_C@_01MIFGBAGJ@?$CL@ DB '+', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FKIHKODH@?$CF?40f?5deg@
CONST	SEGMENT
??_C@_08FKIHKODH@?$CF?40f?5deg@ DB '%.0f deg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CAPEAFFF@?$CD?$CD?$CL?9max@
CONST	SEGMENT
??_C@_07CAPEAFFF@?$CD?$CD?$CL?9max@ DB '##+-max', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCHPOBDK@?$CD?$CD?$CL?9min@
CONST	SEGMENT
??_C@_07DCHPOBDK@?$CD?$CD?$CL?9min@ DB '##+-min', 00H	; `string'
CONST	ENDS
;	COMDAT ?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB
CONST	SEGMENT
?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB DD 03f800000r ; 1 ; `GetMinimumStepAtDecimalPrecision'::`2'::min_steps
	DD	03dcccccdr			; 0.1
	DD	03c23d70ar			; 0.01
	DD	03a83126fr			; 0.001
	DD	038d1b717r			; 0.0001
	DD	03727c5acr			; 1e-05
	DD	0358637bdr			; 1e-06
	DD	033d6bf95r			; 1e-07
	DD	0322bcc77r			; 1e-08
	DD	03089705fr			; 1e-09
CONST	ENDS
;	COMDAT ??_C@_09JKJEEIJP@?$CF?4?$CKs?$CF?$CFd?$CFs@
CONST	SEGMENT
??_C@_09JKJEEIJP@?$CF?4?$CKs?$CF?$CFd?$CFs@ DB '%.*s%%d%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf@ DB '%lf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OINFJHGD@?$CFI64u@
CONST	SEGMENT
??_C@_05OINFJHGD@?$CFI64u@ DB '%I64u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LLAMLEHD@?$CFI64d@
CONST	SEGMENT
??_C@_05LLAMLEHD@?$CFI64d@ DB '%I64d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu@ DB '%u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None@
CONST	SEGMENT
??_C@_04OHJIHAFH@None@ DB 'None', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@
CONST	SEGMENT
??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@ DB '*Unknown item*', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JMKMPHNG@?$CD?$CD?$CL?9C?4o?4m?4b?4o_?$CF02d@
CONST	SEGMENT
??_C@_0BD@JMKMPHNG@?$CD?$CD?$CL?9C?4o?4m?4b?4o_?$CF02d@ DB '##+-C.o.m.b.o'
	DB	'_%02d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLKJBGEJ@?$CF?40f?$CF?$CF@
CONST	SEGMENT
??_C@_06KLKJBGEJ@?$CF?40f?$CF?$CF@ DB '%.0f%%', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBHDMMP@?$CDimage@
CONST	SEGMENT
??_C@_06EBHDMMP@?$CDimage@ DB '#image', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FEBONNKO@?$CDSCROLLY@
CONST	SEGMENT
??_C@_08FEBONNKO@?$CDSCROLLY@ DB '#SCROLLY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08ENAFOMOP@?$CDSCROLLX@
CONST	SEGMENT
??_C@_08ENAFOMOP@?$CDSCROLLX@ DB '#SCROLLX', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD 021b01H
	DD	013011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z DD 011a01H
	DD	0a21aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z DD 011a01H
	DD	0821aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z DD 011701H
	DD	0c217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z DD 011701H
	DD	0c217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z DD 011601H
	DD	0a216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z DD 011601H
	DD	0a216H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	020H
	DW	0100H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$RoundScalarWithFormatT@NN@ImGui@@YANPEBDHN@Z DD 022519H
	DD	0110116H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	020H
	DW	0107H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$RoundScalarWithFormatT@MM@ImGui@@YAMPEBDHM@Z DD 022519H
	DD	0110116H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01fH
	DW	012cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPEBDH_K@Z DD 022419H
	DD	0110115H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01fH
	DB	0fbH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPEBDH_J@Z DD 022419H
	DD	0110115H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01fH
	DB	0f8H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$RoundScalarWithFormatT@IH@ImGui@@YAIPEBDHI@Z DD 022419H
	DD	0110115H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01fH
	DB	0f7H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$RoundScalarWithFormatT@HH@ImGui@@YAHPEBDHH@Z DD 022419H
	DD	0110115H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 040H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 021b01H
	DD	011011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
	DD	imagerel $ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d11H
	DD	0420dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD 011211H
	DD	04212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 021b01H
	DD	011011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Max_limit@_J@std@@YA_JXZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ffmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ffmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SliderBehaviorT@NNN@ImGui@@YA_NAEBUImRect@@IHPEANNNPEBDMHPEAU1@@Z DD 041c01H
	DD	02f011cH
	DD	060147015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SliderBehaviorT@MMM@ImGui@@YA_NAEBUImRect@@IHPEAMMMPEBDMHPEAU1@@Z DD 041c01H
	DD	029011cH
	DD	060147015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SliderBehaviorT@_K_JN@ImGui@@YA_NAEBUImRect@@IHPEA_K_K2PEBDMHPEAU1@@Z DD 041c01H
	DD	02f011cH
	DD	060147015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SliderBehaviorT@_J_JN@ImGui@@YA_NAEBUImRect@@IHPEA_J_J2PEBDMHPEAU1@@Z DD 041c01H
	DD	02f011cH
	DD	060147015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SliderBehaviorT@IHM@ImGui@@YA_NAEBUImRect@@IHPEAIIIPEBDMHPEAU1@@Z DD 041c01H
	DD	029011cH
	DD	060147015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SliderBehaviorT@HHM@ImGui@@YA_NAEBUImRect@@IHPEAHHHPEBDMHPEAU1@@Z DD 041c01H
	DD	029011cH
	DD	060147015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDMH@Z DD 021c01H
	DD	019011cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDMH@Z DD 021c01H
	DD	015011cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDMH@Z DD 021b01H
	DD	019011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDMH@Z DD 021b01H
	DD	019011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDMH@Z DD 021b01H
	DD	015011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDMH@Z DD 021b01H
	DD	015011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FGDataTypeInfo@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$15@?0???__EGDataTypeInfo@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$14@?0???__EGDataTypeInfo@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$12@?0???__EGDataTypeInfo@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$11@?0???__EGDataTypeInfo@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$9@?0???__EGDataTypeInfo@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$8@?0???__EGDataTypeInfo@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0???__EGDataTypeInfo@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0???__EGDataTypeInfo@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???__EGDataTypeInfo@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???__EGDataTypeInfo@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__EGDataTypeInfo@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__EGDataTypeInfo@@YAXXZ DB 01aH
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	'('
	DB	04H
	DB	'>'
	DB	06H
	DB	'('
	DB	08H
	DB	'>'
	DB	0aH
	DB	'('
	DB	0cH
	DB	'>'
	DB	0eH
	DB	'('
	DB	010H
	DB	'>'
	DB	012H
	DB	'('
	DB	014H
	DB	'>'
	DB	016H
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__EGDataTypeInfo@@YAXXZ DB 016H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DB	036H
	DD	imagerel ?dtor$2@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DB	056H
	DD	imagerel ?dtor$5@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DB	056H
	DD	imagerel ?dtor$8@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$9@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DB	056H
	DD	imagerel ?dtor$11@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$12@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DB	056H
	DD	imagerel ?dtor$14@?0???__EGDataTypeInfo@@YAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$15@?0???__EGDataTypeInfo@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__EGDataTypeInfo@@YAXXZ DB 08H
	DD	imagerel $stateUnwindMap$??__EGDataTypeInfo@@YAXXZ
	DD	imagerel $ip2state$??__EGDataTypeInfo@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EGDataTypeInfo@@YAXXZ DD 010411H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__EGDataTypeInfo@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImGuiDataTypeInfo@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImGuiDataTypeInfo@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImGuiDataTypeInfo@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImGuiDataTypeInfo@@QEAA@XZ
	DD	imagerel $ip2state$??1ImGuiDataTypeInfo@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiDataTypeInfo@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImGuiDataTypeInfo@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z DD 010c01H
	DD	0620cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsNavInputDown@ImGui@@YA_NH@Z DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsKeyPressedMap@ImGui@@YA_NH_N@Z DD 010c01H
	DD	0620cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetTabOrder@ImGuiTabBar@@QEBAHPEBUImGuiTabItem@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QEBAHPEBUImGuiTabItem@@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Restore@ImGuiItemHoveredDataBackup@@QEBAXXZ DD 030b01H
	DD	07007220bH
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Backup@ImGuiItemHoveredDataBackup@@QEAAXXZ DD 030b01H
	DD	07007220bH
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiItemHoveredDataBackup@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MenuBarHeight@ImGuiWindow@@QEBAMXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TitleBarHeight@ImGuiWindow@@QEBAMXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@I@@QEAAXAEBI@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@I@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@I@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$ImVector@UImGuiGroupData@@@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXAEBQEAUImGuiTabBar@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@PEAUImGuiTabBar@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@PEAUImGuiTabBar@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiTabBarSortItem@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ DB 06H
	DB	00H
	DB	00H
	DB	'U', 03H
	DB	02H
	DB	'X'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ DB 08H
	DD	imagerel $stateUnwindMap$?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ
	DD	imagerel $ip2state$?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ DD 010911H
	DD	0e209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@I@Z DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?HasSelection@ImGuiInputTextState@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CursorClamp@ImGuiInputTextState@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClipWith@ImRect@@QEAAXAEBU1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Overlaps@ImRect@@QEBA_NAEBU1@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Contains@ImRect@@QEBA_NAEBU1@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetBL@ImRect@@QEBA?AUImVec2@@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetTR@ImRect@@QEBA?AUImVec2@@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetSize@ImRect@@QEBA?AUImVec2@@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCenter@ImRect@@QEBA?AUImVec2@@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImRect@@QEAA@MMMM@Z DD 011b01H
	DD	0621bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImRect@@QEAA@AEBUImVec4@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImRect@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCharAdvance@ImFont@@QEBAMG@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathStroke@ImDrawList@@QEAAXI_NM@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathFillConvex@ImDrawList@@QEAAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??BImColor@@QEBAIXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImColor@@QEAA@HHHH@Z DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiListClipper@@QEAA@HM@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImGuiTextBuffer@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImGuiTextBuffer@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImGuiTextBuffer@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ImGuiTextBuffer@@QEAA@XZ
	DD	imagerel $ip2state$??1ImGuiTextBuffer@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiTextBuffer@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImGuiTextBuffer@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@ImGuiTextBuffer@@QEBAHXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImGuiTextBuffer@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImGuiTextBuffer@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImGuiTextBuffer@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImGuiTextBuffer@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImGuiTextBuffer@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0ImGuiTextBuffer@@QEAA@XZ
	DD	imagerel $ip2state$??0ImGuiTextBuffer@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiTextBuffer@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImGuiTextBuffer@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@D@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@D@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@D@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@D@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@D@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1?$ImVector@D@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@D@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@D@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@G@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@G@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@G@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stb_textedit_key@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z
	DD	020H
	DD	0fb1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stb_textedit_find_charpos@ImGuiStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z
	DD	022H
	DD	0273H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stb_text_redo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	01aH
	DD	023bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stb_text_undo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	01aH
	DD	029fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stb_textedit_drag@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z
	DD	024H
	DD	0aeH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stb_textedit_click@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z
	DD	024H
	DD	098H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stb_text_locate_coord@ImGuiStb@@YAHPEAUImGuiInputTextState@@MM@Z
	DD	01fH
	DD	0238H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
	DD	01aH
	DD	05b9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?InputScalarAsWidgetReplacement@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1@Z
	DD	024H
	DD	0181H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?InputFloat4@ImGui@@YA_NPEBDQEAMHH@Z
	DD	024H
	DD	0c3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?InputFloat3@ImGui@@YA_NPEBDQEAMHH@Z
	DD	024H
	DD	0c3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?InputFloat2@ImGui@@YA_NPEBDQEAMHH@Z
	DD	024H
	DD	0c3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?InputFloat@ImGui@@YA_NPEBDPEAMMMHH@Z
	DD	026H
	DD	0b4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Value@ImGui@@YAXPEBDM0@Z
	DD	01eH
	DD	098H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
	DD	025H
	DD	0243fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ColorPicker3@ImGui@@YA_NPEBDQEAMH@Z
	DD	01dH
	DD	010aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
	DD	022H
	DD	016b6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
	DD	024H
	DD	0448H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30M@Z
	DD	025H
	DD	05adH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20M_N@Z
	DD	024H
	DD	0ea6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20M@Z
	DD	025H
	DD	0641H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z
	DD	025H
	DD	0214H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?BeginCombo@ImGui@@YA_NPEBD0H@Z
	DD	020H
	DD	09beH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ProgressBar@ImGui@@YAXMAEBUImVec2@@PEBD@Z
	DD	021H
	DD	03f7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Checkbox2@ImGui@@YA_NPEBDPEAH@Z
	DD	01dH
	DD	0184fH
voltbl	ENDS
xdata	SEGMENT
$unwind$?Separator@ImGui@@YAXXZ DD 020701H
	DD	0170107H
$unwind$?NewLine@ImGui@@YAXXZ DD 010401H
	DD	0a204H
$unwind$?Spacing@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?Dummy@ImGui@@YAXAEBUImVec2@@@Z DD 010901H
	DD	08209H
$unwind$?AlignTextToFramePadding@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?TextUnformatted@ImGui@@YAXPEBD0@Z DD 041301H
	DD	0250113H
	DD	0600b700cH
$unwind$?TextUnformatted2@ImGui@@YAXPEBD0@Z DD 041301H
	DD	0270113H
	DD	0600b700cH
$unwind$?Text@ImGui@@YAXPEBDZZ DD 011801H
	DD	06218H
$unwind$?TextV@ImGui@@YAXPEBDPEAD@Z DD 010e01H
	DD	0820eH
$unwind$?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ DD 011801H
	DD	06218H
$unwind$?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z DD 011301H
	DD	04213H
$unwind$?TextDisabled@ImGui@@YAXPEBDZZ DD 011801H
	DD	06218H
$unwind$?TextDisabledV@ImGui@@YAXPEBDPEAD@Z DD 010e01H
	DD	0420eH
$unwind$?TextWrapped@ImGui@@YAXPEBDZZ DD 011801H
	DD	06218H
$unwind$?TextWrappedV@ImGui@@YAXPEBDPEAD@Z DD 010e01H
	DD	0620eH
$unwind$?LabelText@ImGui@@YAXPEBD0ZZ DD 011801H
	DD	06218H
$unwind$?LabelTextV@ImGui@@YAXPEBD0PEAD@Z DD 021601H
	DD	01d0116H
$unwind$?BulletText@ImGui@@YAXPEBDZZ DD 011801H
	DD	06218H
$unwind$?BulletTextV@ImGui@@YAXPEBDPEAD@Z DD 021101H
	DD	0190111H
$unwind$?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z DD 010e01H
	DD	0420eH
$unwind$?SmallButton@ImGui@@YA_NPEBD@Z DD 010901H
	DD	08209H
$unwind$?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@@Z DD 010e01H
	DD	0c20eH
$unwind$?ArrowButton@ImGui@@YA_NPEBDH@Z DD 010d01H
	DD	0620dH
$unwind$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD 021b01H
	DD	019011bH
$unwind$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z DD 021b01H
	DD	027011bH
$unwind$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z DD 021101H
	DD	0210111H
$unwind$?Checkbox1@ImGui@@YA_NPEBDPEAHPEAM@Z DD 041801H
	DD	0330118H
	DD	060107011H
$unwind$?Checkbox2@ImGui@@YA_NPEBDPEAH@Z DD 042519H
	DD	01170113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	08a0H
$unwind$?ToggleButton@ImGui@@YA_NPEBDPEA_NMMM@Z DD 021d01H
	DD	02d011dH
$unwind$?CheckboxFlags@ImGui@@YA_NPEBDPEAII@Z DD 011301H
	DD	06213H
$unwind$?RadioButton@ImGui@@YA_NPEBD_N@Z DD 021001H
	DD	0250110H
$unwind$?RadioButton@ImGui@@YA_NPEBDPEAHH@Z DD 011301H
	DD	06213H
$unwind$?ProgressBar@ImGui@@YAXMAEBUImVec2@@PEBD@Z DD 022919H
	DD	0250117H
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$?Bullet@ImGui@@YAXXZ DD 020701H
	DD	0110107H
$unwind$?BeginCombo@ImGui@@YA_NPEBD0H@Z DD 022819H
	DD	0450116H
	DD	imagerel __GSHandlerCheck
	DD	0218H
$unwind$?EndCombo@ImGui@@YAXXZ DD 010401H
	DD	04204H
$unwind$?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z DD 011801H
	DD	08218H
$unwind$?Combo@ImGui@@YA_NPEBDPEAH0H@Z DD 011801H
	DD	08218H
$unwind$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD 021b01H
	DD	013011bH
$unwind$?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z DD 022d19H
	DD	01d011bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z
	DD	0d2H
$cppxdata$?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z DB 08H
	DD	imagerel $stateUnwindMap$?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z
	DD	imagerel $ip2state$?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z
$stateUnwindMap$?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA
$ip2state$?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z DB 0eH
	DB	00H
	DB	00H
	DB	096H
	DB	02H
	DB	0fcH
	DB	04H
	DB	'P'
	DB	06H
	DB	' '
	DB	04H
	DB	01cH
	DB	02H
	DB	0e9H, 03H
	DB	00H
	ORG $+3
$unwind$?dtor$0@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?DragFloat@ImGui@@YA_NPEBDPEAMMMM0M@Z DD 011a01H
	DD	0821aH
$unwind$?DragFloat2@ImGui@@YA_NPEBDQEAMMMM0M@Z DD 011a01H
	DD	0a21aH
$unwind$?DragFloat3@ImGui@@YA_NPEBDQEAMMMM0M@Z DD 011a01H
	DD	0a21aH
$unwind$?DragFloat4@ImGui@@YA_NPEBDQEAMMMM0M@Z DD 011a01H
	DD	0a21aH
$unwind$?DragFloatRange2@ImGui@@YA_NPEBDPEAM1MMM00M@Z DD 021c01H
	DD	011011cH
$unwind$?DragInt@ImGui@@YA_NPEBDPEAHMHH0@Z DD 011901H
	DD	08219H
$unwind$?DragInt2@ImGui@@YA_NPEBDQEAHMHH0@Z DD 011901H
	DD	0a219H
$unwind$?DragInt3@ImGui@@YA_NPEBDQEAHMHH0@Z DD 011901H
	DD	0a219H
$unwind$?DragInt4@ImGui@@YA_NPEBDQEAHMHH0@Z DD 011901H
	DD	0a219H
$unwind$?DragIntRange2@ImGui@@YA_NPEBDPEAH1MHH00@Z DD 011901H
	DD	0e219H
$unwind$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20M@Z DD 022d19H
	DD	029011bH
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z DD 011701H
	DD	0e217H
$unwind$?SliderFloat@ImGui@@YA_NPEBDPEAMMM0M_N@Z DD 011a01H
	DD	0821aH
$unwind$?SliderFloat2@ImGui@@YA_NPEBDQEAMMM0M@Z DD 011a01H
	DD	0821aH
$unwind$?SliderFloat3@ImGui@@YA_NPEBDQEAMMM0M@Z DD 011a01H
	DD	0821aH
$unwind$?SliderFloat4@ImGui@@YA_NPEBDQEAMMM0M@Z DD 011a01H
	DD	0821aH
$unwind$?SliderAngle@ImGui@@YA_NPEBDPEAMMM0@Z DD 011a01H
	DD	0a21aH
$unwind$?SliderInt@ImGui@@YA_NPEBDPEAHHH0_N@Z DD 011801H
	DD	08218H
$unwind$?SliderInt2@ImGui@@YA_NPEBDQEAHHH0@Z DD 011801H
	DD	08218H
$unwind$?SliderInt3@ImGui@@YA_NPEBDQEAHHH0@Z DD 011801H
	DD	08218H
$unwind$?SliderInt4@ImGui@@YA_NPEBDQEAHHH0@Z DD 011801H
	DD	08218H
$unwind$?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20M_N@Z DD 022c19H
	DD	085011aH
	DD	imagerel __GSHandlerCheck
	DD	0410H
$unwind$?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z DD 011701H
	DD	0e217H
$unwind$?VSliderFloat@ImGui@@YA_NPEBDAEBUImVec2@@PEAMMM0M@Z DD 011901H
	DD	08219H
$unwind$?VSliderInt@ImGui@@YA_NPEBDAEBUImVec2@@PEAHHH0@Z DD 011801H
	DD	08218H
$unwind$?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30M@Z DD 022d19H
	DD	02f011bH
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$?RenderTextOverlay@ImGui@@YAXUImVec2@@PEBD1_N@Z DD 021b01H
	DD	031011bH
$unwind$?InputText@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD 011801H
	DD	0c218H
$unwind$?InputTextMultiline@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD 011801H
	DD	0e218H
$unwind$?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD 011801H
	DD	0a218H
$unwind$?InputTextMultiline@ImGui@@YA_NPEBDPEAD_KAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD 011801H
	DD	08218H
$unwind$?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z DD 011a01H
	DD	0c21aH
$unwind$?InputFloat2@ImGui@@YA_NPEBDQEAM0H@Z DD 011801H
	DD	08218H
$unwind$?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z DD 011801H
	DD	08218H
$unwind$?InputFloat4@ImGui@@YA_NPEBDQEAM0H@Z DD 011801H
	DD	08218H
$unwind$?InputInt@ImGui@@YA_NPEBDPEAHHHH@Z DD 011801H
	DD	0e218H
$unwind$?InputInt2@ImGui@@YA_NPEBDQEAHH@Z DD 011301H
	DD	08213H
$unwind$?InputInt3@ImGui@@YA_NPEBDQEAHH@Z DD 011301H
	DD	08213H
$unwind$?InputInt4@ImGui@@YA_NPEBDQEAHH@Z DD 011301H
	DD	08213H
$unwind$?InputDouble@ImGui@@YA_NPEBDPEANNN0H@Z DD 011a01H
	DD	0c21aH
$unwind$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD 022c19H
	DD	01b011aH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z DD 011701H
	DD	0e217H
$unwind$?ColorEdit3@ImGui@@YA_NPEBDQEAMH@Z DD 011301H
	DD	04213H
$unwind$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 042a19H
	DD	0450118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
	DD	0212H
$cppxdata$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DB 08H
	DD	imagerel $stateUnwindMap$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
	DD	imagerel $ip2state$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
$stateUnwindMap$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DB 038H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	0aeH
	DD	imagerel ?dtor$5@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$8@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$9@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$10@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$11@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$12@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$13@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$14@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$15@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$16@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	01dH
	DB	05H
	DD	imagerel ?dtor$18@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	036H
	DD	imagerel ?dtor$19@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$20@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$21@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$22@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$23@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$24@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$25@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$26@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$27@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$28@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$29@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
$ip2state$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DB 'F'
	DB	00H
	DB	00H
	DB	019H, 01cH
	DB	02H
	DB	'('
	DB	04H
	DB	'('
	DB	06H
	DB	'('
	DB	08H
	DB	'('
	DB	02H
	DB	01aH
	DB	00H
	DB	09eH
	DB	0aH
	DB	'('
	DB	0cH
	DB	'('
	DB	0eH
	DB	'('
	DB	010H
	DB	'('
	DB	012H
	DB	'('
	DB	014H
	DB	'('
	DB	016H
	DB	'('
	DB	018H
	DB	'('
	DB	01aH
	DB	'('
	DB	01cH
	DB	'('
	DB	01eH
	DB	'('
	DB	' '
	DB	'('
	DB	0aH
	DB	01aH
	DB	00H
	DB	09eH
	DB	'"'
	DB	'('
	DB	'$'
	DB	'('
	DB	'&'
	DB	'('
	DB	'('
	DB	'('
	DB	'*'
	DB	'('
	DB	','
	DB	'('
	DB	'.'
	DB	'('
	DB	'0'
	DB	'('
	DB	'2'
	DB	'('
	DB	'4'
	DB	'('
	DB	'6'
	DB	'('
	DB	'8'
	DB	'('
	DB	'"'
	DB	01aH
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$5@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$6@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$7@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$8@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$9@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$10@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$11@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$12@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$13@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$14@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$15@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$16@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$18@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$19@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$20@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$21@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$22@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$23@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$24@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$25@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$26@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$27@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$28@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$29@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ColorPicker3@ImGui@@YA_NPEBDQEAMH@Z DD 012219H
	DD	08213H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD 022d19H
	DD	08d011bH
	DD	imagerel __GSHandlerCheck
	DD	0458H
$unwind$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z DD 041d01H
	DD	045011dH
	DD	060157016H
$unwind$?SetColorEditOptions@ImGui@@YAXH@Z DD 010801H
	DD	02208H
$unwind$?BufferingBar@ImGui@@YA_NPEBDMAEBUImVec2@@AEBI2@Z DD 021c01H
	DD	025011cH
$unwind$?Spinner@ImGui@@YA_NPEBDMHAEBI@Z DD 021c01H
	DD	017011cH
$unwind$?TreeNode@ImGui@@YA_NPEBD@Z DD 010901H
	DD	06209H
$unwind$?TreeNode@ImGui@@YA_NPEBD0ZZ DD 011801H
	DD	06218H
$unwind$?TreeNode@ImGui@@YA_NPEBXPEBDZZ DD 011801H
	DD	06218H
$unwind$?TreeNodeV@ImGui@@YA_NPEBD0PEAD@Z DD 011301H
	DD	04213H
$unwind$?TreeNodeV@ImGui@@YA_NPEBXPEBDPEAD@Z DD 011301H
	DD	04213H
$unwind$?TreeNodeEx@ImGui@@YA_NPEBDH@Z DD 010d01H
	DD	0620dH
$unwind$?TreeNodeEx@ImGui@@YA_NPEBDH0ZZ DD 011701H
	DD	06217H
$unwind$?TreeNodeEx@ImGui@@YA_NPEBXHPEBDZZ DD 011701H
	DD	06217H
$unwind$?TreeNodeExV@ImGui@@YA_NPEBDH0PEAD@Z DD 011701H
	DD	08217H
$unwind$?TreeNodeExV@ImGui@@YA_NPEBXHPEBDPEAD@Z DD 011701H
	DD	08217H
$unwind$?TreePush@ImGui@@YAXPEBD@Z DD 010901H
	DD	06209H
$unwind$?TreePush@ImGui@@YAXPEBX@Z DD 010901H
	DD	06209H
$unwind$?TreePop@ImGui@@YAXXZ DD 010401H
	DD	08204H
$unwind$?TreeAdvanceToLabelPos@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ DD 010401H
	DD	02204H
$unwind$?SetNextTreeNodeOpen@ImGui@@YAX_NH@Z DD 010c01H
	DD	0220cH
$unwind$?CollapsingHeader@ImGui@@YA_NPEBDH@Z DD 010d01H
	DD	0620dH
$unwind$?CollapsingHeader@ImGui@@YA_NPEBDPEA_NH@Z DD 021601H
	DD	0150116H
$unwind$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z DD 021a01H
	DD	025011aH
$unwind$?Selectable@ImGui@@YA_NPEBDPEA_NHAEBUImVec2@@@Z DD 011801H
	DD	06218H
$unwind$?ListBox@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z DD 011801H
	DD	08218H
$unwind$?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD 011811H
	DD	0e218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
$cppxdata$?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DB 08H
	DD	imagerel $stateUnwindMap$?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
	DD	imagerel $ip2state$?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
$stateUnwindMap$?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z@4HA
$ip2state$?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DB 06H
	DB	00H
	DB	00H
	DB	0daH
	DB	02H
	DB	0e9H, 04H
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ListBoxHeader@ImGui@@YA_NPEBDAEBUImVec2@@@Z DD 041301H
	DD	01d0113H
	DD	0600b700cH
$unwind$?ListBoxHeader@ImGui@@YA_NPEBDHH@Z DD 011201H
	DD	08212H
$unwind$?ListBoxFooter@ImGui@@YAXXZ DD 030701H
	DD	070038207H
	DD	06002H
$unwind$?PlotLines@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z DD 011801H
	DD	0c218H
$unwind$?PlotLines@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z DD 011801H
	DD	0a218H
$unwind$?PlotHistogram@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z DD 011801H
	DD	0c218H
$unwind$?PlotHistogram@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z DD 011801H
	DD	0a218H
$unwind$?Value@ImGui@@YAXPEBD_N@Z DD 010d01H
	DD	0620dH
$unwind$?Value@ImGui@@YAXPEBDH@Z DD 010d01H
	DD	0420dH
$unwind$?Value@ImGui@@YAXPEBDI@Z DD 010d01H
	DD	0420dH
$unwind$?Value@ImGui@@YAXPEBDM0@Z DD 012319H
	DD	0e214H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$?BeginMainMenuBar@ImGui@@YA_NXZ DD 020701H
	DD	0110107H
$unwind$?EndMainMenuBar@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?BeginMenuBar@ImGui@@YA_NXZ DD 010401H
	DD	0e204H
$unwind$?EndMenuBar@ImGui@@YAXXZ DD 010401H
	DD	0a204H
$unwind$?BeginMenu@ImGui@@YA_NPEBD_N@Z DD 021001H
	DD	0390110H
$unwind$?EndMenu@ImGui@@YAXXZ DD 010401H
	DD	06204H
$unwind$?MenuItem@ImGui@@YA_NPEBD0_N1@Z DD 021b01H
	DD	021011bH
$unwind$?MenuItem@ImGui@@YA_NPEBD0PEA_N_N@Z DD 011801H
	DD	06218H
$unwind$?BeginTabBar@ImGui@@YA_NPEBDH@Z DD 010d01H
	DD	0e20dH
$unwind$?EndTabBar@ImGui@@YAXXZ DD 010401H
	DD	08204H
$unwind$?BeginTabItem@ImGui@@YA_NPEBDPEA_NH@Z DD 011301H
	DD	0a213H
$unwind$?EndTabItem@ImGui@@YAXXZ DD 010401H
	DD	08204H
$unwind$?SetTabItemClosed@ImGui@@YAXPEBD@Z DD 010901H
	DD	08209H
$unwind$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z DD 011701H
	DD	0c217H
$unwind$??0ImGuiInputTextCallbackData@@QEAA@XZ DD 010901H
	DD	04209H
$unwind$?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z DD 011201H
	DD	04212H
$unwind$?InputFloat@ImGui@@YA_NPEBDPEAMMMHH@Z DD 032b19H
	DD	07018a21cH
	DD	06017H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$?InputFloat2@ImGui@@YA_NPEBDQEAMHH@Z DD 032919H
	DD	07016c21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?InputFloat3@ImGui@@YA_NPEBDQEAMHH@Z DD 032919H
	DD	07016c21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?InputFloat4@ImGui@@YA_NPEBDQEAMHH@Z DD 032919H
	DD	07016c21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?ImCharIsBlankA@@YA_ND@Z DD 010801H
	DD	02208H
$unwind$?ImCharIsBlankW@@YA_NI@Z DD 010801H
	DD	02208H
$unwind$?ImParseFormatFindStart@@YAPEBDPEBD@Z DD 010901H
	DD	02209H
$unwind$?ImParseFormatFindEnd@@YAPEBDPEBD@Z DD 010901H
	DD	04209H
$unwind$?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z DD 011301H
	DD	06213H
$unwind$?ImParseFormatPrecision@@YAHPEBDH@Z DD 010d01H
	DD	0620dH
$unwind$??D@YA?AUImVec2@@AEBU0@M@Z DD 011401H
	DD	04214H
$unwind$??H@YA?AUImVec2@@AEBU0@0@Z DD 011301H
	DD	04213H
$unwind$??G@YA?AUImVec2@@AEBU0@0@Z DD 011301H
	DD	04213H
$unwind$?ImFabs@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?ImPow@@YAMMM@Z DD 011001H
	DD	04210H
$unwind$?ImPow@@YANNN@Z DD 011001H
	DD	04210H
$unwind$?ImFmod@@YAMMM@Z DD 011001H
	DD	04210H
$unwind$?ImCos@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?ImSin@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?ImAtan2@@YAMMM@Z DD 011001H
	DD	04210H
$unwind$?ImAtof@@YANPEBD@Z DD 010901H
	DD	04209H
$unwind$?ImMin@@YA?AUImVec2@@AEBU1@0@Z DD 011301H
	DD	06213H
$unwind$?ImMax@@YA?AUImVec2@@AEBU1@0@Z DD 011301H
	DD	06213H
$unwind$?ImLerp@@YA?AUImVec2@@AEBU1@0M@Z DD 011901H
	DD	04219H
$unwind$?ImLerp@@YA?AUImVec2@@AEBU1@00@Z DD 011801H
	DD	04218H
$unwind$?ImSaturate@@YAMM@Z DD 010a01H
	DD	0220aH
$unwind$?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z DD 011a01H
	DD	0421aH
$unwind$?ImLinearSweep@@YAMMMM@Z DD 011601H
	DD	04216H
$unwind$??$ImMin@M@@YAMMM@Z DD 011001H
	DD	02210H
$unwind$??$ImMax@M@@YAMMM@Z DD 011001H
	DD	02210H
$unwind$??0ImGuiMenuColumns@@QEAA@XZ DD 010901H
	DD	04209H
$unwind$?Update@ImGuiMenuColumns@@QEAAXHM_N@Z DD 011801H
	DD	06218H
$unwind$?DeclColumns@ImGuiMenuColumns@@QEAAMMMM@Z DD 011b01H
	DD	0621bH
$unwind$?CalcExtraSpace@ImGuiMenuColumns@@QEAAMM@Z DD 010f01H
	DD	0420fH
$unwind$?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z DD 010d01H
	DD	0420dH
$unwind$??$ImMin@H@@YAHHH@Z DD 010c01H
	DD	0220cH
$unwind$??0ImGuiTabBar@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImGuiTabBar@@QEAA@XZ
$cppxdata$??0ImGuiTabBar@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0ImGuiTabBar@@QEAA@XZ
	DD	imagerel $ip2state$??0ImGuiTabBar@@QEAA@XZ
$stateUnwindMap$??0ImGuiTabBar@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImGuiTabBar@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ImGuiTabBar@@QEAA@XZ@4HA
$ip2state$??0ImGuiTabBar@@QEAA@XZ DB 08H
	DB	00H
	DB	00H
	DB	'6'
	DB	02H
	DB	'h'
	DB	04H
	DB	'1', 03H
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0???0ImGuiTabBar@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???0ImGuiTabBar@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@H@Z DD 041801H
	DD	0150118H
	DD	060107011H
$unwind$?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z DD 010d01H
	DD	0820dH
$unwind$?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z DD 010d01H
	DD	0620dH
$unwind$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NH@Z DD 021b01H
	DD	031011bH
$unwind$?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z DD 011301H
	DD	0a213H
$unwind$?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z DD 021b01H
	DD	013011bH
$unwind$?TabItemLabelAndCloseButton@ImGui@@YA_NPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII@Z DD 041d01H
	DD	033011dH
	DD	060157016H
$unwind$?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z DD 021c01H
	DD	015011cH
$unwind$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z DD 021601H
	DD	0190116H
$unwind$?CloseButton@ImGui@@YA_NIAEBUImVec2@@M@Z DD 021601H
	DD	0270116H
$unwind$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@@Z DD 021001H
	DD	01d0110H
$unwind$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z DD 021a01H
	DD	013011aH
$unwind$?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z DD 040d01H
	DD	037010dH
	DD	060057006H
$unwind$?GetScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z DD 010d01H
	DD	0620dH
$unwind$?VerticalSeparator@ImGui@@YAXXZ DD 020701H
	DD	0170107H
$unwind$?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z DD 011701H
	DD	0c217H
$unwind$?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDMH@Z DD 021a01H
	DD	01b011aH
$unwind$?SliderBehavior@ImGui@@YA_NAEBUImRect@@IHPEAXPEBX2PEBDMHPEAU2@@Z DD 011701H
	DD	0c217H
$unwind$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMM@Z DD 041c01H
	DD	01f011cH
	DD	060147015H
$unwind$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z DD 041b01H
	DD	03b011bH
	DD	060137014H
$unwind$?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z DD 010c01H
	DD	0a20cH
$unwind$?TreePushRawID@ImGui@@YAXI@Z DD 010801H
	DD	06208H
$unwind$?InputTextEx@ImGui@@YA_NPEBDPEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD 021b01H
	DD	0b5011bH
$unwind$?InputScalarAsWidgetReplacement@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1@Z DD 022c19H
	DD	017011aH
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD 021601H
	DD	01b0116H
$unwind$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD 022219H
	DD	01f0110H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD 010d01H
	DD	0e20dH
$unwind$?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PEBDP6AMPEAXH@Z2HH1MMUImVec2@@@Z DD 021a01H
	DD	041011aH
$unwind$?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z DD 011701H
	DD	04217H
$unwind$?DataTypeApplyOp@@YAXHHPEAX0PEBX@Z DD 011601H
	DD	02216H
$unwind$?DataTypeApplyOpFromText@@YA_NPEBD0HPEAX0@Z DD 011801H
	DD	0e218H
$unwind$?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD 021a01H
	DD	011011aH
$unwind$?InputTextCalcTextLenAndLineCount@@YAHPEBDPEAPEBD@Z DD 010e01H
	DD	0220eH
$unwind$?InputTextCalcTextSizeW@@YA?AUImVec2@@PEBG0PEAPEBGPEAU1@_N@Z DD 011801H
	DD	0e218H
$unwind$??$ImClamp@M@@YAMMMM@Z DD 011601H
	DD	02216H
$unwind$?CalcMaxPopupHeightFromItemCount@@YAMH@Z DD 010801H
	DD	02208H
$unwind$?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z DD 011201H
	DD	02212H
$unwind$?Items_SingleStringGetter@@YA_NPEAXHPEAPEBD@Z DD 011201H
	DD	08212H
$unwind$?PatchFormatStringFloatToInt@@YAPEBDPEBD@Z DD 010901H
	DD	0a209H
$unwind$?GetMinimumStepAtDecimalPrecision@@YAMH@Z DD 010801H
	DD	06208H
$unwind$??$ImMax@H@@YAHHH@Z DD 010c01H
	DD	0220cH
$unwind$??$ImMin@_K@@YA_K_K0@Z DD 010e01H
	DD	0220eH
$unwind$??$ImAtoi@H@@YAPEBDPEBDPEAH@Z DD 010e01H
	DD	0220eH
$unwind$?InputTextCallback@@YAHPEAUImGuiInputTextCallbackData@@@Z DD 010901H
	DD	08209H
$unwind$?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z DD 010d01H
	DD	0620dH
$unwind$?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPEAUImGuiInputTextState@@HH@Z DD 011201H
	DD	08212H
$unwind$?STB_TEXTEDIT_KEYTOTEXT@ImGuiStb@@YAHH@Z DD 010801H
	DD	02208H
$unwind$?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z DD 011301H
	DD	0a213H
$unwind$?is_separator@ImGuiStb@@YA_NI@Z DD 010801H
	DD	06208H
$unwind$?is_word_boundary_from_right@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z DD 010d01H
	DD	0820dH
$unwind$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z DD 010d01H
	DD	0620dH
$unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z DD 010d01H
	DD	0620dH
$unwind$?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPEAUImGuiInputTextState@@HH@Z DD 011201H
	DD	08212H
$unwind$?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z DD 011701H
	DD	0a217H
$unwind$??$ImClamp@H@@YAHHHH@Z DD 011101H
	DD	02211H
$unwind$?stb_text_locate_coord@ImGuiStb@@YAHPEAUImGuiInputTextState@@MM@Z DD 012419H
	DD	0c215H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?stb_textedit_click@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z DD 012919H
	DD	0821aH
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$?stb_textedit_drag@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z DD 012919H
	DD	0a21aH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$?stb_text_undo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?stb_text_redo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 031f19H
	DD	0700ca210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$?stb_text_makeundo_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z DD 011801H
	DD	06218H
$unwind$?stb_text_makeundo_insert@ImGuiStb@@YAXPEAUSTB_TexteditState@1@HH@Z DD 011201H
	DD	04212H
$unwind$?stb_text_makeundo_replace@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z DD 011801H
	DD	06218H
$unwind$?stb_textedit_find_charpos@ImGuiStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z DD 012719H
	DD	0c218H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 010e01H
	DD	0620eH
$unwind$?stb_textedit_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z DD 011801H
	DD	04218H
$unwind$?stb_textedit_delete_selection@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 010e01H
	DD	0420eH
$unwind$?stb_textedit_sortselection@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z DD 010901H
	DD	02209H
$unwind$?stb_textedit_move_to_first@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z DD 010901H
	DD	04209H
$unwind$?stb_textedit_move_to_last@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 010e01H
	DD	0420eH
$unwind$?stb_textedit_cut@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 010e01H
	DD	0420eH
$unwind$?stb_textedit_paste_internal@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z DD 011801H
	DD	04218H
$unwind$?stb_textedit_key@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z DD 022819H
	DD	01f0116H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$?stb_textedit_discard_undo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z DD 010901H
	DD	08209H
$unwind$?stb_textedit_discard_redo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z DD 010901H
	DD	0a209H
$unwind$?stb_text_create_undo_record@ImGuiStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z DD 010d01H
	DD	0620dH
$unwind$?stb_text_createundo@ImGuiStb@@YAPEAGPEAUStbUndoState@1@HHH@Z DD 011701H
	DD	06217H
$unwind$?stb_textedit_initialize_state@ImGuiStb@@YAXPEAUSTB_TexteditState@1@H@Z DD 010d01H
	DD	0420dH
$unwind$?stb_textedit_paste@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z DD 011801H
	DD	04218H
$unwind$?ImAlphaBlendColor@@YAIII@Z DD 010c01H
	DD	0620cH
$unwind$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1M@Z DD 021c01H
	DD	011011cH
$unwind$?Plot_ArrayGetter@@YAMPEAXH@Z DD 010d01H
	DD	0220dH
$unwind$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD 040e01H
	DD	037010eH
	DD	060067007H
$unwind$?TabBarCalcTabID@ImGui@@YAIPEAUImGuiTabBar@@PEBD@Z DD 010e01H
	DD	0620eH
$unwind$?TabBarCalcMaxTabWidth@ImGui@@YAMXZ DD 010401H
	DD	02204H
$unwind$?TabBarScrollClamp@ImGui@@YAMPEAUImGuiTabBar@@M@Z DD 010f01H
	DD	0420fH
$unwind$?TabBarScrollToTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z DD 010e01H
	DD	0820eH
$unwind$?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD 040e01H
	DD	023010eH
	DD	060067007H
$unwind$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD 040e01H
	DD	017010eH
	DD	060067007H
$unwind$?TabItemComparerByVisibleOffset@@YAHPEBX0@Z DD 010e01H
	DD	0220eH
$unwind$?TabBarSortItemComparer@@YAHPEBX0@Z DD 010e01H
	DD	0420eH
$unwind$??$ImMin@I@@YAIII@Z DD 010c01H
	DD	0220cH
$unwind$??$ImMax@I@@YAIII@Z DD 010c01H
	DD	0220cH
$unwind$??$ImMin@_J@@YA_J_J0@Z DD 010e01H
	DD	0220eH
$unwind$??$ImMax@_J@@YA_J_J0@Z DD 010e01H
	DD	0220eH
$unwind$??$ImMax@_K@@YA_K_K0@Z DD 010e01H
	DD	0220eH
$unwind$??$ImMin@N@@YANNN@Z DD 011001H
	DD	02210H
$unwind$??$ImMax@N@@YANNN@Z DD 011001H
	DD	02210H
$unwind$??$ImAtoi@_J@@YAPEBDPEBDPEA_J@Z DD 010e01H
	DD	0420eH
$unwind$??$ImAtoi@M@@YAPEBDPEBDPEAM@Z DD 010e01H
	DD	0220eH
$unwind$??$ImAtoi@N@@YAPEBDPEBDPEAN@Z DD 010e01H
	DD	0420eH
$unwind$??$ImClamp@I@@YAIIII@Z DD 011101H
	DD	02211H
$unwind$??$ImClamp@_J@@YA_J_J00@Z DD 011301H
	DD	02213H
$unwind$??$ImClamp@_K@@YA_K_K00@Z DD 011301H
	DD	02213H
$unwind$??$ImClamp@N@@YANNNN@Z DD 011601H
	DD	02216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD 011c01H
	DD	0221cH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	062H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD 012519H
	DD	06216H
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Esslinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SSLInit@detail@httplib@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fwsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ewsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1WSInit@detail@httplib@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1WSInit@detail@httplib@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1WSInit@detail@httplib@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	04fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0WSInit@detail@httplib@@QEAA@XZ DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DB 04H
	DB	00H
	DB	00H
	DB	084H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
	DD	imagerel $ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 021901H
	DD	07015d219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 021401H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021401H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 040H
	DD	imagerel $ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e19H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	09aH
	DB	02H
	DB	'V'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD 010e11H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'4'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_array_new_length@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'6'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_alloc@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_alloc@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@AEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'H'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1exception@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1exception@std@@UEAA@XZ DB 040H
	DD	imagerel $ip2state$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0exception@std@@QEAA@AEBV01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0exception@std@@QEAA@AEBV01@@Z DB 040H
	DD	imagerel $ip2state$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020f19H
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DB 040H
	DD	imagerel $ip2state$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 040H
	DD	imagerel $ip2state$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 040H
	DD	imagerel $ip2state$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?abs@@YAMM@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?abs@@YAMM@Z DB 040H
	DD	imagerel $ip2state$?abs@@YAMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?abs@@YAMM@Z DD 010a19H
	DD	0420aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?abs@@YAMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fabsf DD 010a01H
	DD	0420aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?sslinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Esslinit_@detail@httplib@@YAXXZ ; httplib::detail::sslinit_$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?XYZMask$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EXYZMask@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::XYZMask$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?QINV_SIGN_MASK$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::QINV_SIGN_MASK$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?GDataTypeInfo$initializer$@@3P6AXXZEA DQ FLAT:??__EGDataTypeInfo@@YAXXZ ; GDataTypeInfo$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv66 = 0
tv67 = 8
v$ = 32
mn$ = 40
mx$ = 48
??$ImClamp@N@@YANNNN@Z PROC				; ImClamp<double>

; 229  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movsd	QWORD PTR [rsp+24], xmm2
	movsd	QWORD PTR [rsp+16], xmm1
	movsd	QWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	movsd	xmm0, QWORD PTR mn$[rsp]
	comisd	xmm0, QWORD PTR v$[rsp]
	jbe	SHORT $LN5@ImClamp
	movsd	xmm0, QWORD PTR mn$[rsp]
	movsd	QWORD PTR tv67[rsp], xmm0
	jmp	SHORT $LN6@ImClamp
$LN5@ImClamp:
	movsd	xmm0, QWORD PTR v$[rsp]
	comisd	xmm0, QWORD PTR mx$[rsp]
	jbe	SHORT $LN3@ImClamp
	movsd	xmm0, QWORD PTR mx$[rsp]
	movsd	QWORD PTR tv66[rsp], xmm0
	jmp	SHORT $LN4@ImClamp
$LN3@ImClamp:
	movsd	xmm0, QWORD PTR v$[rsp]
	movsd	QWORD PTR tv66[rsp], xmm0
$LN4@ImClamp:
	movsd	xmm0, QWORD PTR tv66[rsp]
	movsd	QWORD PTR tv67[rsp], xmm0
$LN6@ImClamp:
	movsd	xmm0, QWORD PTR tv67[rsp]
	add	rsp, 24
	ret	0
??$ImClamp@N@@YANNNN@Z ENDP				; ImClamp<double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv66 = 0
tv67 = 8
v$ = 32
mn$ = 40
mx$ = 48
??$ImClamp@_K@@YA_K_K00@Z PROC				; ImClamp<unsigned __int64>

; 229  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR mn$[rsp]
	cmp	QWORD PTR v$[rsp], rax
	jae	SHORT $LN5@ImClamp
	mov	rax, QWORD PTR mn$[rsp]
	mov	QWORD PTR tv67[rsp], rax
	jmp	SHORT $LN6@ImClamp
$LN5@ImClamp:
	mov	rax, QWORD PTR mx$[rsp]
	cmp	QWORD PTR v$[rsp], rax
	jbe	SHORT $LN3@ImClamp
	mov	rax, QWORD PTR mx$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@ImClamp
$LN3@ImClamp:
	mov	rax, QWORD PTR v$[rsp]
	mov	QWORD PTR tv66[rsp], rax
$LN4@ImClamp:
	mov	rax, QWORD PTR tv66[rsp]
	mov	QWORD PTR tv67[rsp], rax
$LN6@ImClamp:
	mov	rax, QWORD PTR tv67[rsp]
	add	rsp, 24
	ret	0
??$ImClamp@_K@@YA_K_K00@Z ENDP				; ImClamp<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv66 = 0
tv67 = 8
v$ = 32
mn$ = 40
mx$ = 48
??$ImClamp@_J@@YA_J_J00@Z PROC				; ImClamp<__int64>

; 229  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR mn$[rsp]
	cmp	QWORD PTR v$[rsp], rax
	jge	SHORT $LN5@ImClamp
	mov	rax, QWORD PTR mn$[rsp]
	mov	QWORD PTR tv67[rsp], rax
	jmp	SHORT $LN6@ImClamp
$LN5@ImClamp:
	mov	rax, QWORD PTR mx$[rsp]
	cmp	QWORD PTR v$[rsp], rax
	jle	SHORT $LN3@ImClamp
	mov	rax, QWORD PTR mx$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@ImClamp
$LN3@ImClamp:
	mov	rax, QWORD PTR v$[rsp]
	mov	QWORD PTR tv66[rsp], rax
$LN4@ImClamp:
	mov	rax, QWORD PTR tv66[rsp]
	mov	QWORD PTR tv67[rsp], rax
$LN6@ImClamp:
	mov	rax, QWORD PTR tv67[rsp]
	add	rsp, 24
	ret	0
??$ImClamp@_J@@YA_J_J00@Z ENDP				; ImClamp<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv66 = 0
tv67 = 4
v$ = 32
mn$ = 40
mx$ = 48
??$ImClamp@I@@YAIIII@Z PROC				; ImClamp<unsigned int>

; 229  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	mov	eax, DWORD PTR mn$[rsp]
	cmp	DWORD PTR v$[rsp], eax
	jae	SHORT $LN5@ImClamp
	mov	eax, DWORD PTR mn$[rsp]
	mov	DWORD PTR tv67[rsp], eax
	jmp	SHORT $LN6@ImClamp
$LN5@ImClamp:
	mov	eax, DWORD PTR mx$[rsp]
	cmp	DWORD PTR v$[rsp], eax
	jbe	SHORT $LN3@ImClamp
	mov	eax, DWORD PTR mx$[rsp]
	mov	DWORD PTR tv66[rsp], eax
	jmp	SHORT $LN4@ImClamp
$LN3@ImClamp:
	mov	eax, DWORD PTR v$[rsp]
	mov	DWORD PTR tv66[rsp], eax
$LN4@ImClamp:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR tv67[rsp], eax
$LN6@ImClamp:
	mov	eax, DWORD PTR tv67[rsp]
	add	rsp, 24
	ret	0
??$ImClamp@I@@YAIIII@Z ENDP				; ImClamp<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
negative$ = 0
v$ = 8
tv84 = 16
tv81 = 24
src$ = 48
output$ = 56
??$ImAtoi@N@@YAPEBDPEBDPEAN@Z PROC			; ImAtoi<double>

; 2030 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2031 : 	int negative = 0;

	mov	DWORD PTR negative$[rsp], 0

; 2032 : 	if (*src == '-') { negative = 1; src++; }

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN4@ImAtoi
	mov	DWORD PTR negative$[rsp], 1
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN4@ImAtoi:

; 2033 : 	if (*src == '+') { src++; }

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN5@ImAtoi
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN5@ImAtoi:

; 2034 : 	TYPE v = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR v$[rsp], xmm0
$LN2@ImAtoi:

; 2035 : 	while (*src >= '0' && *src <= '9')

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@ImAtoi
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN3@ImAtoi

; 2036 : 		v = (v * 10) + (*src++ - '0');

	movsd	xmm0, QWORD PTR v$[rsp]
	mulsd	xmm0, QWORD PTR __real@4024000000000000
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	cvtsi2sd xmm1, eax
	addsd	xmm0, xmm1
	movsd	QWORD PTR tv81[rsp], xmm0
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
	movsd	xmm0, QWORD PTR tv81[rsp]
	movsd	QWORD PTR v$[rsp], xmm0
	jmp	SHORT $LN2@ImAtoi
$LN3@ImAtoi:

; 2037 : 	*output = negative ? -v : v;

	cmp	DWORD PTR negative$[rsp], 0
	je	SHORT $LN7@ImAtoi
	movsd	xmm0, QWORD PTR v$[rsp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR tv84[rsp], xmm0
	jmp	SHORT $LN8@ImAtoi
$LN7@ImAtoi:
	movsd	xmm0, QWORD PTR v$[rsp]
	movsd	QWORD PTR tv84[rsp], xmm0
$LN8@ImAtoi:
	mov	rax, QWORD PTR output$[rsp]
	movsd	xmm0, QWORD PTR tv84[rsp]
	movsd	QWORD PTR [rax], xmm0

; 2038 : 	return src;

	mov	rax, QWORD PTR src$[rsp]

; 2039 : }

	add	rsp, 40					; 00000028H
	ret	0
??$ImAtoi@N@@YAPEBDPEBDPEAN@Z ENDP			; ImAtoi<double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
v$ = 0
negative$ = 4
tv84 = 8
tv81 = 12
src$ = 32
output$ = 40
??$ImAtoi@M@@YAPEBDPEBDPEAM@Z PROC			; ImAtoi<float>

; 2030 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2031 : 	int negative = 0;

	mov	DWORD PTR negative$[rsp], 0

; 2032 : 	if (*src == '-') { negative = 1; src++; }

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN4@ImAtoi
	mov	DWORD PTR negative$[rsp], 1
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN4@ImAtoi:

; 2033 : 	if (*src == '+') { src++; }

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN5@ImAtoi
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN5@ImAtoi:

; 2034 : 	TYPE v = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR v$[rsp], xmm0
$LN2@ImAtoi:

; 2035 : 	while (*src >= '0' && *src <= '9')

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@ImAtoi
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN3@ImAtoi

; 2036 : 		v = (v * 10) + (*src++ - '0');

	movss	xmm0, DWORD PTR v$[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	cvtsi2ss xmm1, eax
	addss	xmm0, xmm1
	movss	DWORD PTR tv81[rsp], xmm0
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
	movss	xmm0, DWORD PTR tv81[rsp]
	movss	DWORD PTR v$[rsp], xmm0
	jmp	SHORT $LN2@ImAtoi
$LN3@ImAtoi:

; 2037 : 	*output = negative ? -v : v;

	cmp	DWORD PTR negative$[rsp], 0
	je	SHORT $LN7@ImAtoi
	movss	xmm0, DWORD PTR v$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv84[rsp], xmm0
	jmp	SHORT $LN8@ImAtoi
$LN7@ImAtoi:
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR tv84[rsp], xmm0
$LN8@ImAtoi:
	mov	rax, QWORD PTR output$[rsp]
	movss	xmm0, DWORD PTR tv84[rsp]
	movss	DWORD PTR [rax], xmm0

; 2038 : 	return src;

	mov	rax, QWORD PTR src$[rsp]

; 2039 : }

	add	rsp, 24
	ret	0
??$ImAtoi@M@@YAPEBDPEBDPEAM@Z ENDP			; ImAtoi<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
negative$ = 0
v$ = 8
tv84 = 16
tv81 = 24
src$ = 48
output$ = 56
??$ImAtoi@_J@@YAPEBDPEBDPEA_J@Z PROC			; ImAtoi<__int64>

; 2030 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2031 : 	int negative = 0;

	mov	DWORD PTR negative$[rsp], 0

; 2032 : 	if (*src == '-') { negative = 1; src++; }

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN4@ImAtoi
	mov	DWORD PTR negative$[rsp], 1
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN4@ImAtoi:

; 2033 : 	if (*src == '+') { src++; }

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN5@ImAtoi
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN5@ImAtoi:

; 2034 : 	TYPE v = 0;

	mov	QWORD PTR v$[rsp], 0
$LN2@ImAtoi:

; 2035 : 	while (*src >= '0' && *src <= '9')

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@ImAtoi
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN3@ImAtoi

; 2036 : 		v = (v * 10) + (*src++ - '0');

	imul	rax, QWORD PTR v$[rsp], 10
	mov	rcx, QWORD PTR src$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR tv81[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
	mov	rax, QWORD PTR tv81[rsp]
	mov	QWORD PTR v$[rsp], rax
	jmp	SHORT $LN2@ImAtoi
$LN3@ImAtoi:

; 2037 : 	*output = negative ? -v : v;

	cmp	DWORD PTR negative$[rsp], 0
	je	SHORT $LN7@ImAtoi
	mov	rax, QWORD PTR v$[rsp]
	neg	rax
	mov	QWORD PTR tv84[rsp], rax
	jmp	SHORT $LN8@ImAtoi
$LN7@ImAtoi:
	mov	rax, QWORD PTR v$[rsp]
	mov	QWORD PTR tv84[rsp], rax
$LN8@ImAtoi:
	mov	rax, QWORD PTR output$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	mov	QWORD PTR [rax], rcx

; 2038 : 	return src;

	mov	rax, QWORD PTR src$[rsp]

; 2039 : }

	add	rsp, 40					; 00000028H
	ret	0
??$ImAtoi@_J@@YAPEBDPEBDPEA_J@Z ENDP			; ImAtoi<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\locale
;	COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 124  : __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::collate<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 809  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0$0A@@id@locale@std@@QEAA@XZ PROC			; std::locale::id::id<0>, COMDAT

; 81   :         id() noexcept /* strengthened */ {}

	mov	QWORD PTR [rsp+8], rcx

; 82   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 83   : 
; 84   :         id(const id&)            = delete;
; 85   :         id& operator=(const id&) = delete;
; 86   : 
; 87   :         template <int = 0> // TRANSITION, ABI
; 88   :         size_t _Get_index() { // get stamp, with lazy allocation
; 89   :             if (_Id == 0) { // still zero, allocate stamp
; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 91   :                 if (_Id == 0) {
; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 93   :                 }
; 94   :                 _END_LOCK()
; 95   :             }
; 96   :             return _Id;
; 97   :         }
; 98   : 
; 99   : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 100  :         __CLR_OR_THIS_CALL operator size_t() {
; 101  :             return _Get_index();
; 102  :         }
; 103  : #endif // defined(_CRTBLD)
; 104  : 
; 105  :     private:
; 106  :         size_t _Id = 0; // the identifier stamp

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :         id() noexcept /* strengthened */ {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$0A@@id@locale@std@@QEAA@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
_TEXT	SEGMENT
_My_data$ = 64
_Old_size$ = 72
_New_ptr$ = 80
_New_size$ = 88
_New_capacity$ = 96
_Old_capacity$ = 104
_Old_ptr$1 = 112
_Al$ = 120
_Raw_new$ = 128
this$ = 160
_Size_increase$ = 168
_Fn$ = 176
<_Args_0>$ = 184
<_Args_1>$ = 192
<_Args_2>$ = 200
??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const *,unsigned __int64>, COMDAT

; 2988 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 2989 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 2990 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 2991 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2992 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 2993 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 2994 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 2999 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 3000 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 3001 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 3002 : 
; 3003 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 3004 :         _ASAN_STRING_REMOVE(*this);
; 3005 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 3006 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 3008 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 15
	jbe	SHORT $LN3@Reallocate

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 3010 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR <_Args_2>$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z ; <lambda_f3a66ab6a0570788f31503db83886f49>::operator()

; 3011 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	r8, QWORD PTR _Old_capacity$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3012 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 3013 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3014 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR <_Args_2>$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z ; <lambda_f3a66ab6a0570788f31503db83886f49>::operator()

; 3015 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1
$LN4@Reallocate:

; 3016 :         }
; 3017 : 
; 3018 :         _ASAN_STRING_CREATE(*this);
; 3019 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 3020 :     }

	add	rsp, 152				; 00000098H
	ret	0
??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z
_TEXT	SEGMENT
tv78 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Off$ = 96
_Ptr$ = 104
_Count$ = 112
??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z PROC ; <lambda_f3a66ab6a0570788f31503db83886f49>::operator(), COMDAT

; 1750 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1747 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);

	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1748 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1749 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	inc	rax
	mov	rcx, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	rdx, QWORD PTR _Off$[rsp]
	mov	r8, QWORD PTR _New_ptr$[rsp]
	add	r8, rdx
	mov	rdx, r8
	add	rdx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR tv78[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv78[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 1750 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z ENDP ; <lambda_f3a66ab6a0570788f31503db83886f49>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Count$ = 32
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 0

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {
; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]

; 123  : }

	add	rsp, 24
	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Ptr_container$ = 32
_Block_size$ = 40
_Ptr$ = 48
_Bytes$ = 80
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	rax, QWORD PTR _Bytes$[rsp]
	add	rax, 39					; 00000027H
	mov	QWORD PTR _Block_size$[rsp], rax

; 185  :     if (_Block_size <= _Bytes) {

	mov	rax, QWORD PTR _Bytes$[rsp]
	cmp	QWORD PTR _Block_size$[rsp], rax
	ja	SHORT $LN8@Allocate_m

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN8@Allocate_m:

; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	rcx, QWORD PTR _Block_size$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	mov	QWORD PTR _Ptr_container$[rsp], rax
$LN4@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	QWORD PTR _Ptr_container$[rsp], 0
	je	SHORT $LN9@Allocate_m
	jmp	SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN10@Allocate_m:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	rax, QWORD PTR _Ptr_container$[rsp]
	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Ptr$[rsp], rax

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rdx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
$LN11@Allocate_m:

; 198  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z PROC		; std::forward<char * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
_TEXT	SEGMENT
_Fancy_ptr$ = 32
_Al$ = 64
_Capacity$ = 72
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 799  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 800  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 801  :         ++_Capacity; // Take null terminator into consideration

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 802  : 
; 803  :         pointer _Fancy_ptr = nullptr;

	mov	QWORD PTR _Fancy_ptr$[rsp], 0

; 804  :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 805  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

	mov	rdx, QWORD PTR _Capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
	mov	QWORD PTR _Fancy_ptr$[rsp], rax

; 806  :         } else {
; 807  :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 808  :             _Fancy_ptr = _Al.allocate(_Capacity);
; 809  :         }
; 810  : 
; 811  : #if _HAS_CXX20
; 812  :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 813  :         // but likely more impactful to throughput.
; 814  :         if (_STD is_constant_evaluated()) {
; 815  :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 816  :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 817  :                 _STD construct_at(_Ptr + _Idx);
; 818  :             }
; 819  :         }
; 820  : #endif // _HAS_CXX20
; 821  :         --_Capacity;

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 822  :         return _Fancy_ptr;

	mov	rax, QWORD PTR _Fancy_ptr$[rsp]

; 823  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMax@N@@YANNN@Z PROC				; ImMax<double>

; 228  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

	movsd	QWORD PTR [rsp+16], xmm1
	movsd	QWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	movsd	xmm0, QWORD PTR lhs$[rsp]
	comisd	xmm0, QWORD PTR rhs$[rsp]
	jb	SHORT $LN3@ImMax
	movsd	xmm0, QWORD PTR lhs$[rsp]
	movsd	QWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN4@ImMax
$LN3@ImMax:
	movsd	xmm0, QWORD PTR rhs$[rsp]
	movsd	QWORD PTR tv65[rsp], xmm0
$LN4@ImMax:
	movsd	xmm0, QWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMax@N@@YANNN@Z ENDP				; ImMax<double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@N@@YANNNM@Z PROC				; ImLerp<double>

; 230  : template<typename T> static inline T ImLerp(T a, T b, float t) { return (T)(a + (b - a) * t); }

	movss	DWORD PTR [rsp+24], xmm2
	movsd	QWORD PTR [rsp+16], xmm1
	movsd	QWORD PTR [rsp+8], xmm0
	movsd	xmm0, QWORD PTR b$[rsp]
	subsd	xmm0, QWORD PTR a$[rsp]
	cvtss2sd xmm1, DWORD PTR t$[rsp]
	mulsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR a$[rsp]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	ret	0
??$ImLerp@N@@YANNNM@Z ENDP				; ImLerp<double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMin@N@@YANNN@Z PROC				; ImMin<double>

; 227  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

	movsd	QWORD PTR [rsp+16], xmm1
	movsd	QWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	movsd	xmm0, QWORD PTR rhs$[rsp]
	comisd	xmm0, QWORD PTR lhs$[rsp]
	jbe	SHORT $LN3@ImMin
	movsd	xmm0, QWORD PTR lhs$[rsp]
	movsd	QWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN4@ImMin
$LN3@ImMin:
	movsd	xmm0, QWORD PTR rhs$[rsp]
	movsd	QWORD PTR tv65[rsp], xmm0
$LN4@ImMin:
	movsd	xmm0, QWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMin@N@@YANNN@Z ENDP				; ImMin<double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z
_TEXT	SEGMENT
tv68 = 32
is_power$ = 33
f$1 = 36
f$2 = 40
v_clamped$ = 48
tv78 = 56
tv82 = 64
tv132 = 72
data_type$ = 96
v$ = 104
v_min$ = 112
v_max$ = 120
power$ = 128
linear_zero_pos$ = 136
??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z PROC	; ImGui::SliderCalcRatioFromValueT<double,double>, COMDAT

; 2428 : {

$LN13:
	movsd	QWORD PTR [rsp+32], xmm3
	movsd	QWORD PTR [rsp+24], xmm2
	movsd	QWORD PTR [rsp+16], xmm1
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 2429 : 	if (v_min == v_max)

	movsd	xmm0, QWORD PTR v_min$[rsp]
	ucomisd	xmm0, QWORD PTR v_max$[rsp]
	jp	SHORT $LN2@SliderCalc
	jne	SHORT $LN2@SliderCalc

; 2430 : 		return 0.0f;

	xorps	xmm0, xmm0
	jmp	$LN1@SliderCalc
$LN2@SliderCalc:

; 2431 : 
; 2432 : 	const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN12@SliderCalc
	je	SHORT $LN8@SliderCalc
$LN12@SliderCalc:
	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN7@SliderCalc
	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN8@SliderCalc
$LN7@SliderCalc:
	mov	BYTE PTR tv68[rsp], 1
	jmp	SHORT $LN9@SliderCalc
$LN8@SliderCalc:
	mov	BYTE PTR tv68[rsp], 0
$LN9@SliderCalc:
	movzx	eax, BYTE PTR tv68[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2433 : 	const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	movsd	xmm0, QWORD PTR v_max$[rsp]
	comisd	xmm0, QWORD PTR v_min$[rsp]
	jbe	SHORT $LN10@SliderCalc
	movsd	xmm2, QWORD PTR v_max$[rsp]
	movsd	xmm1, QWORD PTR v_min$[rsp]
	movsd	xmm0, QWORD PTR v$[rsp]
	call	??$ImClamp@N@@YANNNN@Z			; ImClamp<double>
	movsd	QWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN11@SliderCalc
$LN10@SliderCalc:
	movsd	xmm2, QWORD PTR v_min$[rsp]
	movsd	xmm1, QWORD PTR v_max$[rsp]
	movsd	xmm0, QWORD PTR v$[rsp]
	call	??$ImClamp@N@@YANNNN@Z			; ImClamp<double>
	movsd	QWORD PTR tv78[rsp], xmm0
$LN11@SliderCalc:
	movsd	xmm0, QWORD PTR tv78[rsp]
	movsd	QWORD PTR v_clamped$[rsp], xmm0

; 2434 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN3@SliderCalc

; 2435 : 	{
; 2436 : 		if (v_clamped < 0.0f)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR v_clamped$[rsp]
	jbe	$LN4@SliderCalc

; 2437 : 		{
; 2438 : 			const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));

	movsd	xmm0, QWORD PTR v_clamped$[rsp]
	subsd	xmm0, QWORD PTR v_min$[rsp]
	movsd	QWORD PTR tv82[rsp], xmm0
	movsd	xmm1, QWORD PTR v_max$[rsp]
	xorps	xmm0, xmm0
	call	??$ImMin@N@@YANNN@Z			; ImMin<double>
	subsd	xmm0, QWORD PTR v_min$[rsp]
	movsd	xmm1, QWORD PTR tv82[rsp]
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR f$1[rsp], xmm0

; 2439 : 			return (1.0f - ImPow(f, 1.0f / power)) * linear_zero_pos;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR f$1[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	jmp	$LN1@SliderCalc

; 2440 : 		}

	jmp	$LN5@SliderCalc
$LN4@SliderCalc:

; 2441 : 		else
; 2442 : 		{
; 2443 : 			const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));

	movsd	xmm1, QWORD PTR v_min$[rsp]
	xorps	xmm0, xmm0
	call	??$ImMax@N@@YANNN@Z			; ImMax<double>
	movsd	xmm1, QWORD PTR v_clamped$[rsp]
	subsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR tv132[rsp], xmm0
	movsd	xmm1, QWORD PTR v_min$[rsp]
	xorps	xmm0, xmm0
	call	??$ImMax@N@@YANNN@Z			; ImMax<double>
	movsd	xmm1, QWORD PTR v_max$[rsp]
	subsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	xmm1, QWORD PTR tv132[rsp]
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR f$2[rsp], xmm0

; 2444 : 			return linear_zero_pos + ImPow(f, 1.0f / power) * (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR f$2[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	jmp	SHORT $LN1@SliderCalc
$LN5@SliderCalc:
$LN3@SliderCalc:

; 2445 : 		}
; 2446 : 	}
; 2447 : 
; 2448 : 	// Linear slider
; 2449 : 	return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));

	movsd	xmm0, QWORD PTR v_clamped$[rsp]
	subsd	xmm0, QWORD PTR v_min$[rsp]
	movsd	xmm1, QWORD PTR v_max$[rsp]
	subsd	xmm1, QWORD PTR v_min$[rsp]
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
$LN1@SliderCalc:

; 2450 : }

	add	rsp, 88					; 00000058H
	ret	0
??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z ENDP	; ImGui::SliderCalcRatioFromValueT<double,double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z
_TEXT	SEGMENT
tv68 = 32
is_power$ = 33
v_clamped$ = 36
tv78 = 40
tv82 = 44
f$1 = 48
tv131 = 52
f$2 = 56
data_type$ = 80
v$ = 88
v_min$ = 96
v_max$ = 104
power$ = 112
linear_zero_pos$ = 120
??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z PROC	; ImGui::SliderCalcRatioFromValueT<float,float>, COMDAT

; 2428 : {

$LN13:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 2429 : 	if (v_min == v_max)

	movss	xmm0, DWORD PTR v_min$[rsp]
	ucomiss	xmm0, DWORD PTR v_max$[rsp]
	jp	SHORT $LN2@SliderCalc
	jne	SHORT $LN2@SliderCalc

; 2430 : 		return 0.0f;

	xorps	xmm0, xmm0
	jmp	$LN1@SliderCalc
$LN2@SliderCalc:

; 2431 : 
; 2432 : 	const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN12@SliderCalc
	je	SHORT $LN8@SliderCalc
$LN12@SliderCalc:
	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN7@SliderCalc
	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN8@SliderCalc
$LN7@SliderCalc:
	mov	BYTE PTR tv68[rsp], 1
	jmp	SHORT $LN9@SliderCalc
$LN8@SliderCalc:
	mov	BYTE PTR tv68[rsp], 0
$LN9@SliderCalc:
	movzx	eax, BYTE PTR tv68[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2433 : 	const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	movss	xmm0, DWORD PTR v_max$[rsp]
	comiss	xmm0, DWORD PTR v_min$[rsp]
	jbe	SHORT $LN10@SliderCalc
	movss	xmm2, DWORD PTR v_max$[rsp]
	movss	xmm1, DWORD PTR v_min$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN11@SliderCalc
$LN10@SliderCalc:
	movss	xmm2, DWORD PTR v_min$[rsp]
	movss	xmm1, DWORD PTR v_max$[rsp]
	movss	xmm0, DWORD PTR v$[rsp]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR tv78[rsp], xmm0
$LN11@SliderCalc:
	movss	xmm0, DWORD PTR tv78[rsp]
	movss	DWORD PTR v_clamped$[rsp], xmm0

; 2434 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN3@SliderCalc

; 2435 : 	{
; 2436 : 		if (v_clamped < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR v_clamped$[rsp]
	jbe	$LN4@SliderCalc

; 2437 : 		{
; 2438 : 			const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));

	movss	xmm0, DWORD PTR v_clamped$[rsp]
	subss	xmm0, DWORD PTR v_min$[rsp]
	movss	DWORD PTR tv82[rsp], xmm0
	movss	xmm1, DWORD PTR v_max$[rsp]
	xorps	xmm0, xmm0
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	subss	xmm0, DWORD PTR v_min$[rsp]
	movss	xmm1, DWORD PTR tv82[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR f$1[rsp], xmm0

; 2439 : 			return (1.0f - ImPow(f, 1.0f / power)) * linear_zero_pos;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR f$1[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	jmp	$LN1@SliderCalc

; 2440 : 		}

	jmp	$LN5@SliderCalc
$LN4@SliderCalc:

; 2441 : 		else
; 2442 : 		{
; 2443 : 			const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));

	movss	xmm1, DWORD PTR v_min$[rsp]
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	xmm1, DWORD PTR v_clamped$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv131[rsp], xmm0
	movss	xmm1, DWORD PTR v_min$[rsp]
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	xmm1, DWORD PTR v_max$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR tv131[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR f$2[rsp], xmm0

; 2444 : 			return linear_zero_pos + ImPow(f, 1.0f / power) * (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR f$2[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	jmp	SHORT $LN1@SliderCalc
$LN5@SliderCalc:
$LN3@SliderCalc:

; 2445 : 		}
; 2446 : 	}
; 2447 : 
; 2448 : 	// Linear slider
; 2449 : 	return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));

	movss	xmm0, DWORD PTR v_clamped$[rsp]
	subss	xmm0, DWORD PTR v_min$[rsp]
	movss	xmm1, DWORD PTR v_max$[rsp]
	subss	xmm1, DWORD PTR v_min$[rsp]
	divss	xmm0, xmm1
$LN1@SliderCalc:

; 2450 : }

	add	rsp, 72					; 00000048H
	ret	0
??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z ENDP	; ImGui::SliderCalcRatioFromValueT<float,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMax@_K@@YA_K_K0@Z PROC				; ImMax<unsigned __int64>

; 228  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR rhs$[rsp]
	cmp	QWORD PTR lhs$[rsp], rax
	jb	SHORT $LN3@ImMax
	mov	rax, QWORD PTR lhs$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@ImMax
$LN3@ImMax:
	mov	rax, QWORD PTR rhs$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@ImMax:
	mov	rax, QWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMax@_K@@YA_K_K0@Z ENDP				; ImMax<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@_K@@YA_K_K0M@Z PROC				; ImLerp<unsigned __int64>

; 230  : template<typename T> static inline T ImLerp(T a, T b, float t) { return (T)(a + (b - a) * t); }

	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR a$[rsp]
	test	rax, rax
	jl	SHORT $LN6@ImLerp
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN7@ImLerp
$LN6@ImLerp:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN7@ImLerp:
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jl	SHORT $LN4@ImLerp
	cvtsi2ss xmm1, rax
	jmp	SHORT $LN5@ImLerp
$LN4@ImLerp:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm2, rcx
	addss	xmm2, xmm2
	movaps	xmm1, xmm2
$LN5@ImLerp:
	mulss	xmm1, DWORD PTR t$[rsp]
	addss	xmm0, xmm1
	xor	eax, eax
	comiss	xmm0, DWORD PTR __real@5f000000
	jb	SHORT $LN3@ImLerp
	subss	xmm0, DWORD PTR __real@5f000000
	comiss	xmm0, DWORD PTR __real@5f000000
	jae	SHORT $LN3@ImLerp
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN3@ImLerp:
	cvttss2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	ret	0
??$ImLerp@_K@@YA_K_K0M@Z ENDP				; ImLerp<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z
_TEXT	SEGMENT
tv68 = 32
is_power$ = 33
v_clamped$ = 40
f$1 = 48
f$2 = 52
tv78 = 56
tv83 = 64
tv87 = 72
tv132 = 80
tv136 = 88
data_type$ = 112
v$ = 120
v_min$ = 128
v_max$ = 136
power$ = 144
linear_zero_pos$ = 152
??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z PROC ; ImGui::SliderCalcRatioFromValueT<unsigned __int64,double>, COMDAT

; 2428 : {

$LN23:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 2429 : 	if (v_min == v_max)

	mov	rax, QWORD PTR v_max$[rsp]
	cmp	QWORD PTR v_min$[rsp], rax
	jne	SHORT $LN2@SliderCalc

; 2430 : 		return 0.0f;

	xorps	xmm0, xmm0
	jmp	$LN1@SliderCalc
$LN2@SliderCalc:

; 2431 : 
; 2432 : 	const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN22@SliderCalc
	je	SHORT $LN8@SliderCalc
$LN22@SliderCalc:
	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN7@SliderCalc
	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN8@SliderCalc
$LN7@SliderCalc:
	mov	BYTE PTR tv68[rsp], 1
	jmp	SHORT $LN9@SliderCalc
$LN8@SliderCalc:
	mov	BYTE PTR tv68[rsp], 0
$LN9@SliderCalc:
	movzx	eax, BYTE PTR tv68[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2433 : 	const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	mov	rax, QWORD PTR v_max$[rsp]
	cmp	QWORD PTR v_min$[rsp], rax
	jae	SHORT $LN10@SliderCalc
	mov	r8, QWORD PTR v_max$[rsp]
	mov	rdx, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	call	??$ImClamp@_K@@YA_K_K00@Z		; ImClamp<unsigned __int64>
	mov	QWORD PTR tv78[rsp], rax
	jmp	SHORT $LN11@SliderCalc
$LN10@SliderCalc:
	mov	r8, QWORD PTR v_min$[rsp]
	mov	rdx, QWORD PTR v_max$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	call	??$ImClamp@_K@@YA_K_K00@Z		; ImClamp<unsigned __int64>
	mov	QWORD PTR tv78[rsp], rax
$LN11@SliderCalc:
	mov	rax, QWORD PTR tv78[rsp]
	mov	QWORD PTR v_clamped$[rsp], rax

; 2434 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN3@SliderCalc

; 2435 : 	{
; 2436 : 		if (v_clamped < 0.0f)

	mov	rax, QWORD PTR v_clamped$[rsp]
	test	rax, rax
	jl	SHORT $LN20@SliderCalc
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN21@SliderCalc
$LN20@SliderCalc:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN21@SliderCalc:
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	$LN4@SliderCalc

; 2437 : 		{
; 2438 : 			const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));

	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_clamped$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv83[rsp], rax
	mov	rdx, QWORD PTR v_max$[rsp]
	xor	ecx, ecx
	call	??$ImMin@_K@@YA_K_K0@Z			; ImMin<unsigned __int64>
	sub	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR tv87[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv83[rsp]
	mov	rax, rcx
	mov	rcx, QWORD PTR tv87[rsp]
	div	rcx
	test	rax, rax
	jl	SHORT $LN18@SliderCalc
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN19@SliderCalc
$LN18@SliderCalc:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN19@SliderCalc:
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR f$1[rsp], xmm0

; 2439 : 			return (1.0f - ImPow(f, 1.0f / power)) * linear_zero_pos;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR f$1[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	jmp	$LN1@SliderCalc

; 2440 : 		}

	jmp	$LN5@SliderCalc
$LN4@SliderCalc:

; 2441 : 		else
; 2442 : 		{
; 2443 : 			const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));

	mov	rdx, QWORD PTR v_min$[rsp]
	xor	ecx, ecx
	call	??$ImMax@_K@@YA_K_K0@Z			; ImMax<unsigned __int64>
	mov	rcx, QWORD PTR v_clamped$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv132[rsp], rax
	mov	rdx, QWORD PTR v_min$[rsp]
	xor	ecx, ecx
	call	??$ImMax@_K@@YA_K_K0@Z			; ImMax<unsigned __int64>
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv136[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv132[rsp]
	mov	rax, rcx
	mov	rcx, QWORD PTR tv136[rsp]
	div	rcx
	test	rax, rax
	jl	SHORT $LN16@SliderCalc
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN17@SliderCalc
$LN16@SliderCalc:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN17@SliderCalc:
	movss	DWORD PTR f$2[rsp], xmm0

; 2444 : 			return linear_zero_pos + ImPow(f, 1.0f / power) * (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR f$2[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	jmp	SHORT $LN1@SliderCalc
$LN5@SliderCalc:
$LN3@SliderCalc:

; 2445 : 		}
; 2446 : 	}
; 2447 : 
; 2448 : 	// Linear slider
; 2449 : 	return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));

	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_clamped$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jl	SHORT $LN14@SliderCalc
	cvtsi2sd xmm0, rax
	jmp	SHORT $LN15@SliderCalc
$LN14@SliderCalc:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm1, rcx
	addsd	xmm1, xmm1
	movaps	xmm0, xmm1
$LN15@SliderCalc:
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jl	SHORT $LN12@SliderCalc
	cvtsi2sd xmm1, rax
	jmp	SHORT $LN13@SliderCalc
$LN12@SliderCalc:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm2, rcx
	addsd	xmm2, xmm2
	movaps	xmm1, xmm2
$LN13@SliderCalc:
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
$LN1@SliderCalc:

; 2450 : }

	add	rsp, 104				; 00000068H
	ret	0
??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z ENDP ; ImGui::SliderCalcRatioFromValueT<unsigned __int64,double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMax@_J@@YA_J_J0@Z PROC				; ImMax<__int64>

; 228  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR rhs$[rsp]
	cmp	QWORD PTR lhs$[rsp], rax
	jl	SHORT $LN3@ImMax
	mov	rax, QWORD PTR lhs$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@ImMax
$LN3@ImMax:
	mov	rax, QWORD PTR rhs$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@ImMax:
	mov	rax, QWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMax@_J@@YA_J_J0@Z ENDP				; ImMax<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@_J@@YA_J_J0M@Z PROC				; ImLerp<__int64>

; 230  : template<typename T> static inline T ImLerp(T a, T b, float t) { return (T)(a + (b - a) * t); }

	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	cvtsi2ss xmm0, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2ss xmm1, rax
	mulss	xmm1, DWORD PTR t$[rsp]
	addss	xmm0, xmm1
	cvttss2si rax, xmm0
	ret	0
??$ImLerp@_J@@YA_J_J0M@Z ENDP				; ImLerp<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMin@_J@@YA_J_J0@Z PROC				; ImMin<__int64>

; 227  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR rhs$[rsp]
	cmp	QWORD PTR lhs$[rsp], rax
	jge	SHORT $LN3@ImMin
	mov	rax, QWORD PTR lhs$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@ImMin
$LN3@ImMin:
	mov	rax, QWORD PTR rhs$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@ImMin:
	mov	rax, QWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMin@_J@@YA_J_J0@Z ENDP				; ImMin<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z
_TEXT	SEGMENT
tv68 = 32
is_power$ = 33
v_clamped$ = 40
f$1 = 48
f$2 = 52
tv78 = 56
tv83 = 64
tv87 = 72
tv132 = 80
tv136 = 88
data_type$ = 112
v$ = 120
v_min$ = 128
v_max$ = 136
power$ = 144
linear_zero_pos$ = 152
??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z PROC ; ImGui::SliderCalcRatioFromValueT<__int64,double>, COMDAT

; 2428 : {

$LN13:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 2429 : 	if (v_min == v_max)

	mov	rax, QWORD PTR v_max$[rsp]
	cmp	QWORD PTR v_min$[rsp], rax
	jne	SHORT $LN2@SliderCalc

; 2430 : 		return 0.0f;

	xorps	xmm0, xmm0
	jmp	$LN1@SliderCalc
$LN2@SliderCalc:

; 2431 : 
; 2432 : 	const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN12@SliderCalc
	je	SHORT $LN8@SliderCalc
$LN12@SliderCalc:
	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN7@SliderCalc
	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN8@SliderCalc
$LN7@SliderCalc:
	mov	BYTE PTR tv68[rsp], 1
	jmp	SHORT $LN9@SliderCalc
$LN8@SliderCalc:
	mov	BYTE PTR tv68[rsp], 0
$LN9@SliderCalc:
	movzx	eax, BYTE PTR tv68[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2433 : 	const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	mov	rax, QWORD PTR v_max$[rsp]
	cmp	QWORD PTR v_min$[rsp], rax
	jge	SHORT $LN10@SliderCalc
	mov	r8, QWORD PTR v_max$[rsp]
	mov	rdx, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	call	??$ImClamp@_J@@YA_J_J00@Z		; ImClamp<__int64>
	mov	QWORD PTR tv78[rsp], rax
	jmp	SHORT $LN11@SliderCalc
$LN10@SliderCalc:
	mov	r8, QWORD PTR v_min$[rsp]
	mov	rdx, QWORD PTR v_max$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	call	??$ImClamp@_J@@YA_J_J00@Z		; ImClamp<__int64>
	mov	QWORD PTR tv78[rsp], rax
$LN11@SliderCalc:
	mov	rax, QWORD PTR tv78[rsp]
	mov	QWORD PTR v_clamped$[rsp], rax

; 2434 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN3@SliderCalc

; 2435 : 	{
; 2436 : 		if (v_clamped < 0.0f)

	cvtsi2ss xmm0, QWORD PTR v_clamped$[rsp]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	$LN4@SliderCalc

; 2437 : 		{
; 2438 : 			const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));

	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_clamped$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv83[rsp], rax
	mov	rdx, QWORD PTR v_max$[rsp]
	xor	ecx, ecx
	call	??$ImMin@_J@@YA_J_J0@Z			; ImMin<__int64>
	sub	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR tv87[rsp], rax
	mov	rcx, QWORD PTR tv83[rsp]
	mov	rax, rcx
	cdq
	mov	rcx, QWORD PTR tv87[rsp]
	idiv	rcx
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR f$1[rsp], xmm0

; 2439 : 			return (1.0f - ImPow(f, 1.0f / power)) * linear_zero_pos;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR f$1[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	jmp	$LN1@SliderCalc

; 2440 : 		}

	jmp	$LN5@SliderCalc
$LN4@SliderCalc:

; 2441 : 		else
; 2442 : 		{
; 2443 : 			const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));

	mov	rdx, QWORD PTR v_min$[rsp]
	xor	ecx, ecx
	call	??$ImMax@_J@@YA_J_J0@Z			; ImMax<__int64>
	mov	rcx, QWORD PTR v_clamped$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv132[rsp], rax
	mov	rdx, QWORD PTR v_min$[rsp]
	xor	ecx, ecx
	call	??$ImMax@_J@@YA_J_J0@Z			; ImMax<__int64>
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv136[rsp], rax
	mov	rcx, QWORD PTR tv132[rsp]
	mov	rax, rcx
	cdq
	mov	rcx, QWORD PTR tv136[rsp]
	idiv	rcx
	cvtsi2ss xmm0, rax
	movss	DWORD PTR f$2[rsp], xmm0

; 2444 : 			return linear_zero_pos + ImPow(f, 1.0f / power) * (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR f$2[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	jmp	SHORT $LN1@SliderCalc
$LN5@SliderCalc:
$LN3@SliderCalc:

; 2445 : 		}
; 2446 : 	}
; 2447 : 
; 2448 : 	// Linear slider
; 2449 : 	return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));

	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_clamped$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2sd xmm0, rax
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2sd xmm1, rax
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
$LN1@SliderCalc:

; 2450 : }

	add	rsp, 104				; 00000068H
	ret	0
??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z ENDP ; ImGui::SliderCalcRatioFromValueT<__int64,double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMax@I@@YAIII@Z PROC				; ImMax<unsigned int>

; 228  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	mov	eax, DWORD PTR rhs$[rsp]
	cmp	DWORD PTR lhs$[rsp], eax
	jb	SHORT $LN3@ImMax
	mov	eax, DWORD PTR lhs$[rsp]
	mov	DWORD PTR tv65[rsp], eax
	jmp	SHORT $LN4@ImMax
$LN3@ImMax:
	mov	eax, DWORD PTR rhs$[rsp]
	mov	DWORD PTR tv65[rsp], eax
$LN4@ImMax:
	mov	eax, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMax@I@@YAIII@Z ENDP				; ImMax<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@I@@YAIIIM@Z PROC				; ImLerp<unsigned int>

; 230  : template<typename T> static inline T ImLerp(T a, T b, float t) { return (T)(a + (b - a) * t); }

	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	mov	eax, DWORD PTR a$[rsp]
	cvtsi2ss xmm0, rax
	mov	eax, DWORD PTR a$[rsp]
	mov	ecx, DWORD PTR b$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	cvtsi2ss xmm1, rax
	mulss	xmm1, DWORD PTR t$[rsp]
	addss	xmm0, xmm1
	cvttss2si rax, xmm0
	ret	0
??$ImLerp@I@@YAIIIM@Z ENDP				; ImLerp<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMin@I@@YAIII@Z PROC				; ImMin<unsigned int>

; 227  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	mov	eax, DWORD PTR rhs$[rsp]
	cmp	DWORD PTR lhs$[rsp], eax
	jae	SHORT $LN3@ImMin
	mov	eax, DWORD PTR lhs$[rsp]
	mov	DWORD PTR tv65[rsp], eax
	jmp	SHORT $LN4@ImMin
$LN3@ImMin:
	mov	eax, DWORD PTR rhs$[rsp]
	mov	DWORD PTR tv65[rsp], eax
$LN4@ImMin:
	mov	eax, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMin@I@@YAIII@Z ENDP				; ImMin<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z
_TEXT	SEGMENT
tv68 = 32
is_power$ = 33
v_clamped$ = 36
tv78 = 40
tv83 = 44
tv87 = 48
f$1 = 52
tv132 = 56
tv136 = 60
f$2 = 64
data_type$ = 96
v$ = 104
v_min$ = 112
v_max$ = 120
power$ = 128
linear_zero_pos$ = 136
??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z PROC	; ImGui::SliderCalcRatioFromValueT<unsigned int,float>, COMDAT

; 2428 : {

$LN13:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 2429 : 	if (v_min == v_max)

	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_min$[rsp], eax
	jne	SHORT $LN2@SliderCalc

; 2430 : 		return 0.0f;

	xorps	xmm0, xmm0
	jmp	$LN1@SliderCalc
$LN2@SliderCalc:

; 2431 : 
; 2432 : 	const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN12@SliderCalc
	je	SHORT $LN8@SliderCalc
$LN12@SliderCalc:
	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN7@SliderCalc
	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN8@SliderCalc
$LN7@SliderCalc:
	mov	BYTE PTR tv68[rsp], 1
	jmp	SHORT $LN9@SliderCalc
$LN8@SliderCalc:
	mov	BYTE PTR tv68[rsp], 0
$LN9@SliderCalc:
	movzx	eax, BYTE PTR tv68[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2433 : 	const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_min$[rsp], eax
	jae	SHORT $LN10@SliderCalc
	mov	r8d, DWORD PTR v_max$[rsp]
	mov	edx, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v$[rsp]
	call	??$ImClamp@I@@YAIIII@Z			; ImClamp<unsigned int>
	mov	DWORD PTR tv78[rsp], eax
	jmp	SHORT $LN11@SliderCalc
$LN10@SliderCalc:
	mov	r8d, DWORD PTR v_min$[rsp]
	mov	edx, DWORD PTR v_max$[rsp]
	mov	ecx, DWORD PTR v$[rsp]
	call	??$ImClamp@I@@YAIIII@Z			; ImClamp<unsigned int>
	mov	DWORD PTR tv78[rsp], eax
$LN11@SliderCalc:
	mov	eax, DWORD PTR tv78[rsp]
	mov	DWORD PTR v_clamped$[rsp], eax

; 2434 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN3@SliderCalc

; 2435 : 	{
; 2436 : 		if (v_clamped < 0.0f)

	mov	eax, DWORD PTR v_clamped$[rsp]
	cvtsi2ss xmm0, rax
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	$LN4@SliderCalc

; 2437 : 		{
; 2438 : 			const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));

	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_clamped$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv83[rsp], eax
	mov	edx, DWORD PTR v_max$[rsp]
	xor	ecx, ecx
	call	??$ImMin@I@@YAIII@Z			; ImMin<unsigned int>
	sub	eax, DWORD PTR v_min$[rsp]
	mov	DWORD PTR tv87[rsp], eax
	xor	edx, edx
	mov	ecx, DWORD PTR tv83[rsp]
	mov	eax, ecx
	mov	ecx, DWORD PTR tv87[rsp]
	div	ecx
	mov	eax, eax
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR f$1[rsp], xmm0

; 2439 : 			return (1.0f - ImPow(f, 1.0f / power)) * linear_zero_pos;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR f$1[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	jmp	$LN1@SliderCalc

; 2440 : 		}

	jmp	$LN5@SliderCalc
$LN4@SliderCalc:

; 2441 : 		else
; 2442 : 		{
; 2443 : 			const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));

	mov	edx, DWORD PTR v_min$[rsp]
	xor	ecx, ecx
	call	??$ImMax@I@@YAIII@Z			; ImMax<unsigned int>
	mov	ecx, DWORD PTR v_clamped$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv132[rsp], eax
	mov	edx, DWORD PTR v_min$[rsp]
	xor	ecx, ecx
	call	??$ImMax@I@@YAIII@Z			; ImMax<unsigned int>
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv136[rsp], eax
	xor	edx, edx
	mov	ecx, DWORD PTR tv132[rsp]
	mov	eax, ecx
	mov	ecx, DWORD PTR tv136[rsp]
	div	ecx
	mov	eax, eax
	cvtsi2ss xmm0, rax
	movss	DWORD PTR f$2[rsp], xmm0

; 2444 : 			return linear_zero_pos + ImPow(f, 1.0f / power) * (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR f$2[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	jmp	SHORT $LN1@SliderCalc
$LN5@SliderCalc:
$LN3@SliderCalc:

; 2445 : 		}
; 2446 : 	}
; 2447 : 
; 2448 : 	// Linear slider
; 2449 : 	return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));

	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_clamped$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	cvtsi2ss xmm0, rax
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	cvtsi2ss xmm1, rax
	divss	xmm0, xmm1
$LN1@SliderCalc:

; 2450 : }

	add	rsp, 88					; 00000058H
	ret	0
??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z ENDP	; ImGui::SliderCalcRatioFromValueT<unsigned int,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z
_TEXT	SEGMENT
tv68 = 32
is_power$ = 33
v_clamped$ = 36
tv78 = 40
tv83 = 44
tv87 = 48
f$1 = 52
tv132 = 56
tv136 = 60
f$2 = 64
data_type$ = 96
v$ = 104
v_min$ = 112
v_max$ = 120
power$ = 128
linear_zero_pos$ = 136
??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z PROC	; ImGui::SliderCalcRatioFromValueT<int,float>, COMDAT

; 2428 : {

$LN13:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 2429 : 	if (v_min == v_max)

	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_min$[rsp], eax
	jne	SHORT $LN2@SliderCalc

; 2430 : 		return 0.0f;

	xorps	xmm0, xmm0
	jmp	$LN1@SliderCalc
$LN2@SliderCalc:

; 2431 : 
; 2432 : 	const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN12@SliderCalc
	je	SHORT $LN8@SliderCalc
$LN12@SliderCalc:
	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN7@SliderCalc
	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN8@SliderCalc
$LN7@SliderCalc:
	mov	BYTE PTR tv68[rsp], 1
	jmp	SHORT $LN9@SliderCalc
$LN8@SliderCalc:
	mov	BYTE PTR tv68[rsp], 0
$LN9@SliderCalc:
	movzx	eax, BYTE PTR tv68[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2433 : 	const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_min$[rsp], eax
	jge	SHORT $LN10@SliderCalc
	mov	r8d, DWORD PTR v_max$[rsp]
	mov	edx, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v$[rsp]
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	DWORD PTR tv78[rsp], eax
	jmp	SHORT $LN11@SliderCalc
$LN10@SliderCalc:
	mov	r8d, DWORD PTR v_min$[rsp]
	mov	edx, DWORD PTR v_max$[rsp]
	mov	ecx, DWORD PTR v$[rsp]
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	DWORD PTR tv78[rsp], eax
$LN11@SliderCalc:
	mov	eax, DWORD PTR tv78[rsp]
	mov	DWORD PTR v_clamped$[rsp], eax

; 2434 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN3@SliderCalc

; 2435 : 	{
; 2436 : 		if (v_clamped < 0.0f)

	cvtsi2ss xmm0, DWORD PTR v_clamped$[rsp]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	$LN4@SliderCalc

; 2437 : 		{
; 2438 : 			const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));

	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_clamped$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv83[rsp], eax
	mov	edx, DWORD PTR v_max$[rsp]
	xor	ecx, ecx
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	sub	eax, DWORD PTR v_min$[rsp]
	mov	DWORD PTR tv87[rsp], eax
	mov	ecx, DWORD PTR tv83[rsp]
	mov	eax, ecx
	cdq
	mov	ecx, DWORD PTR tv87[rsp]
	idiv	ecx
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR f$1[rsp], xmm0

; 2439 : 			return (1.0f - ImPow(f, 1.0f / power)) * linear_zero_pos;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR f$1[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	jmp	$LN1@SliderCalc

; 2440 : 		}

	jmp	$LN5@SliderCalc
$LN4@SliderCalc:

; 2441 : 		else
; 2442 : 		{
; 2443 : 			const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));

	mov	edx, DWORD PTR v_min$[rsp]
	xor	ecx, ecx
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	ecx, DWORD PTR v_clamped$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv132[rsp], eax
	mov	edx, DWORD PTR v_min$[rsp]
	xor	ecx, ecx
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv136[rsp], eax
	mov	ecx, DWORD PTR tv132[rsp]
	mov	eax, ecx
	cdq
	mov	ecx, DWORD PTR tv136[rsp]
	idiv	ecx
	cvtsi2ss xmm0, eax
	movss	DWORD PTR f$2[rsp], xmm0

; 2444 : 			return linear_zero_pos + ImPow(f, 1.0f / power) * (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR f$2[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	jmp	SHORT $LN1@SliderCalc
$LN5@SliderCalc:
$LN3@SliderCalc:

; 2445 : 		}
; 2446 : 	}
; 2447 : 
; 2448 : 	// Linear slider
; 2449 : 	return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));

	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_clamped$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm1, eax
	divss	xmm0, xmm1
$LN1@SliderCalc:

; 2450 : }

	add	rsp, 88					; 00000058H
	ret	0
??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z ENDP	; ImGui::SliderCalcRatioFromValueT<int,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@NN@ImGui@@YANPEBDHN@Z
_TEXT	SEGMENT
p$ = 32
fmt_start$ = 40
v_str$ = 48
__$ArrayPad$ = 112
format$ = 144
data_type$ = 152
v$ = 160
??$RoundScalarWithFormatT@NN@ImGui@@YANPEBDHN@Z PROC	; ImGui::RoundScalarWithFormatT<double,double>, COMDAT

; 2043 : {

$LN10:
	movsd	QWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2044 : 	const char* fmt_start = ImParseFormatFindStart(format);

	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatFindStart@@YAPEBDPEBD@Z	; ImParseFormatFindStart
	mov	QWORD PTR fmt_start$[rsp], rax

; 2045 : 	if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN5@RoundScala
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN4@RoundScala
$LN5@RoundScala:

; 2046 : 		return v;

	movsd	xmm0, QWORD PTR v$[rsp]
	jmp	$LN1@RoundScala
$LN4@RoundScala:

; 2047 : 	char v_str[64];
; 2048 : 	ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	movsd	xmm3, QWORD PTR v$[rsp]
	movq	r9, xmm3
	mov	r8, QWORD PTR fmt_start$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR v_str$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 2049 : 	const char* p = v_str;

	lea	rax, QWORD PTR v_str$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@RoundScala:

; 2050 : 	while (*p == ' ')

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN3@RoundScala

; 2051 : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN2@RoundScala
$LN3@RoundScala:

; 2052 : 	if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN8@RoundScala
	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN6@RoundScala
$LN8@RoundScala:

; 2053 : 		v = (TYPE)ImAtof(p);

	mov	rcx, QWORD PTR p$[rsp]
	call	?ImAtof@@YANPEBD@Z			; ImAtof
	movsd	QWORD PTR v$[rsp], xmm0
	jmp	SHORT $LN7@RoundScala
$LN6@RoundScala:

; 2054 : 	else
; 2055 : 		ImAtoi(p, (SIGNEDTYPE*)&v);

	lea	rdx, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	??$ImAtoi@N@@YAPEBDPEBDPEAN@Z		; ImAtoi<double>
	npad	1
$LN7@RoundScala:

; 2056 : 	return v;

	movsd	xmm0, QWORD PTR v$[rsp]
$LN1@RoundScala:

; 2057 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
??$RoundScalarWithFormatT@NN@ImGui@@YANPEBDHN@Z ENDP	; ImGui::RoundScalarWithFormatT<double,double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@MM@ImGui@@YAMPEBDHM@Z
_TEXT	SEGMENT
p$ = 32
fmt_start$ = 40
v_str$ = 48
__$ArrayPad$ = 112
format$ = 144
data_type$ = 152
v$ = 160
??$RoundScalarWithFormatT@MM@ImGui@@YAMPEBDHM@Z PROC	; ImGui::RoundScalarWithFormatT<float,float>, COMDAT

; 2043 : {

$LN10:
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2044 : 	const char* fmt_start = ImParseFormatFindStart(format);

	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatFindStart@@YAPEBDPEBD@Z	; ImParseFormatFindStart
	mov	QWORD PTR fmt_start$[rsp], rax

; 2045 : 	if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN5@RoundScala
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN4@RoundScala
$LN5@RoundScala:

; 2046 : 		return v;

	movss	xmm0, DWORD PTR v$[rsp]
	jmp	$LN1@RoundScala
$LN4@RoundScala:

; 2047 : 	char v_str[64];
; 2048 : 	ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	cvtss2sd xmm0, DWORD PTR v$[rsp]
	movaps	xmm3, xmm0
	movq	r9, xmm3
	mov	r8, QWORD PTR fmt_start$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR v_str$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 2049 : 	const char* p = v_str;

	lea	rax, QWORD PTR v_str$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@RoundScala:

; 2050 : 	while (*p == ' ')

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN3@RoundScala

; 2051 : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN2@RoundScala
$LN3@RoundScala:

; 2052 : 	if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN8@RoundScala
	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN6@RoundScala
$LN8@RoundScala:

; 2053 : 		v = (TYPE)ImAtof(p);

	mov	rcx, QWORD PTR p$[rsp]
	call	?ImAtof@@YANPEBD@Z			; ImAtof
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR v$[rsp], xmm0
	jmp	SHORT $LN7@RoundScala
$LN6@RoundScala:

; 2054 : 	else
; 2055 : 		ImAtoi(p, (SIGNEDTYPE*)&v);

	lea	rdx, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	??$ImAtoi@M@@YAPEBDPEBDPEAM@Z		; ImAtoi<float>
	npad	1
$LN7@RoundScala:

; 2056 : 	return v;

	movss	xmm0, DWORD PTR v$[rsp]
$LN1@RoundScala:

; 2057 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
??$RoundScalarWithFormatT@MM@ImGui@@YAMPEBDHM@Z ENDP	; ImGui::RoundScalarWithFormatT<float,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPEBDH_K@Z
_TEXT	SEGMENT
p$ = 32
fmt_start$ = 40
v_str$ = 48
__$ArrayPad$ = 112
format$ = 144
data_type$ = 152
v$ = 160
??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPEBDH_K@Z PROC ; ImGui::RoundScalarWithFormatT<unsigned __int64,__int64>, COMDAT

; 2043 : {

$LN11:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2044 : 	const char* fmt_start = ImParseFormatFindStart(format);

	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatFindStart@@YAPEBDPEBD@Z	; ImParseFormatFindStart
	mov	QWORD PTR fmt_start$[rsp], rax

; 2045 : 	if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN5@RoundScala
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN4@RoundScala
$LN5@RoundScala:

; 2046 : 		return v;

	mov	rax, QWORD PTR v$[rsp]
	jmp	$LN1@RoundScala
$LN4@RoundScala:

; 2047 : 	char v_str[64];
; 2048 : 	ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	mov	r9, QWORD PTR v$[rsp]
	mov	r8, QWORD PTR fmt_start$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR v_str$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 2049 : 	const char* p = v_str;

	lea	rax, QWORD PTR v_str$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@RoundScala:

; 2050 : 	while (*p == ' ')

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN3@RoundScala

; 2051 : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN2@RoundScala
$LN3@RoundScala:

; 2052 : 	if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN8@RoundScala
	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN6@RoundScala
$LN8@RoundScala:

; 2053 : 		v = (TYPE)ImAtof(p);

	mov	rcx, QWORD PTR p$[rsp]
	call	?ImAtof@@YANPEBD@Z			; ImAtof
	xor	eax, eax
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jb	SHORT $LN10@RoundScala
	subsd	xmm0, QWORD PTR __real@43e0000000000000
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jae	SHORT $LN10@RoundScala
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN10@RoundScala:
	cvttsd2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v$[rsp], rax
	jmp	SHORT $LN7@RoundScala
$LN6@RoundScala:

; 2054 : 	else
; 2055 : 		ImAtoi(p, (SIGNEDTYPE*)&v);

	lea	rdx, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	??$ImAtoi@_J@@YAPEBDPEBDPEA_J@Z		; ImAtoi<__int64>
	npad	1
$LN7@RoundScala:

; 2056 : 	return v;

	mov	rax, QWORD PTR v$[rsp]
$LN1@RoundScala:

; 2057 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPEBDH_K@Z ENDP ; ImGui::RoundScalarWithFormatT<unsigned __int64,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPEBDH_J@Z
_TEXT	SEGMENT
p$ = 32
fmt_start$ = 40
v_str$ = 48
__$ArrayPad$ = 112
format$ = 144
data_type$ = 152
v$ = 160
??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPEBDH_J@Z PROC ; ImGui::RoundScalarWithFormatT<__int64,__int64>, COMDAT

; 2043 : {

$LN10:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2044 : 	const char* fmt_start = ImParseFormatFindStart(format);

	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatFindStart@@YAPEBDPEBD@Z	; ImParseFormatFindStart
	mov	QWORD PTR fmt_start$[rsp], rax

; 2045 : 	if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN5@RoundScala
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN4@RoundScala
$LN5@RoundScala:

; 2046 : 		return v;

	mov	rax, QWORD PTR v$[rsp]
	jmp	$LN1@RoundScala
$LN4@RoundScala:

; 2047 : 	char v_str[64];
; 2048 : 	ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	mov	r9, QWORD PTR v$[rsp]
	mov	r8, QWORD PTR fmt_start$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR v_str$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 2049 : 	const char* p = v_str;

	lea	rax, QWORD PTR v_str$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@RoundScala:

; 2050 : 	while (*p == ' ')

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN3@RoundScala

; 2051 : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN2@RoundScala
$LN3@RoundScala:

; 2052 : 	if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN8@RoundScala
	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN6@RoundScala
$LN8@RoundScala:

; 2053 : 		v = (TYPE)ImAtof(p);

	mov	rcx, QWORD PTR p$[rsp]
	call	?ImAtof@@YANPEBD@Z			; ImAtof
	cvttsd2si rax, xmm0
	mov	QWORD PTR v$[rsp], rax
	jmp	SHORT $LN7@RoundScala
$LN6@RoundScala:

; 2054 : 	else
; 2055 : 		ImAtoi(p, (SIGNEDTYPE*)&v);

	lea	rdx, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	??$ImAtoi@_J@@YAPEBDPEBDPEA_J@Z		; ImAtoi<__int64>
	npad	1
$LN7@RoundScala:

; 2056 : 	return v;

	mov	rax, QWORD PTR v$[rsp]
$LN1@RoundScala:

; 2057 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPEBDH_J@Z ENDP ; ImGui::RoundScalarWithFormatT<__int64,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@IH@ImGui@@YAIPEBDHI@Z
_TEXT	SEGMENT
p$ = 32
fmt_start$ = 40
v_str$ = 48
__$ArrayPad$ = 112
format$ = 144
data_type$ = 152
v$ = 160
??$RoundScalarWithFormatT@IH@ImGui@@YAIPEBDHI@Z PROC	; ImGui::RoundScalarWithFormatT<unsigned int,int>, COMDAT

; 2043 : {

$LN10:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2044 : 	const char* fmt_start = ImParseFormatFindStart(format);

	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatFindStart@@YAPEBDPEBD@Z	; ImParseFormatFindStart
	mov	QWORD PTR fmt_start$[rsp], rax

; 2045 : 	if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN5@RoundScala
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN4@RoundScala
$LN5@RoundScala:

; 2046 : 		return v;

	mov	eax, DWORD PTR v$[rsp]
	jmp	$LN1@RoundScala
$LN4@RoundScala:

; 2047 : 	char v_str[64];
; 2048 : 	ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	mov	r9d, DWORD PTR v$[rsp]
	mov	r8, QWORD PTR fmt_start$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR v_str$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 2049 : 	const char* p = v_str;

	lea	rax, QWORD PTR v_str$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@RoundScala:

; 2050 : 	while (*p == ' ')

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN3@RoundScala

; 2051 : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN2@RoundScala
$LN3@RoundScala:

; 2052 : 	if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN8@RoundScala
	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN6@RoundScala
$LN8@RoundScala:

; 2053 : 		v = (TYPE)ImAtof(p);

	mov	rcx, QWORD PTR p$[rsp]
	call	?ImAtof@@YANPEBD@Z			; ImAtof
	cvttsd2si rax, xmm0
	mov	DWORD PTR v$[rsp], eax
	jmp	SHORT $LN7@RoundScala
$LN6@RoundScala:

; 2054 : 	else
; 2055 : 		ImAtoi(p, (SIGNEDTYPE*)&v);

	lea	rdx, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	??$ImAtoi@H@@YAPEBDPEBDPEAH@Z		; ImAtoi<int>
	npad	1
$LN7@RoundScala:

; 2056 : 	return v;

	mov	eax, DWORD PTR v$[rsp]
$LN1@RoundScala:

; 2057 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
??$RoundScalarWithFormatT@IH@ImGui@@YAIPEBDHI@Z ENDP	; ImGui::RoundScalarWithFormatT<unsigned int,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@HH@ImGui@@YAHPEBDHH@Z
_TEXT	SEGMENT
p$ = 32
fmt_start$ = 40
v_str$ = 48
__$ArrayPad$ = 112
format$ = 144
data_type$ = 152
v$ = 160
??$RoundScalarWithFormatT@HH@ImGui@@YAHPEBDHH@Z PROC	; ImGui::RoundScalarWithFormatT<int,int>, COMDAT

; 2043 : {

$LN10:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2044 : 	const char* fmt_start = ImParseFormatFindStart(format);

	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatFindStart@@YAPEBDPEBD@Z	; ImParseFormatFindStart
	mov	QWORD PTR fmt_start$[rsp], rax

; 2045 : 	if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN5@RoundScala
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN4@RoundScala
$LN5@RoundScala:

; 2046 : 		return v;

	mov	eax, DWORD PTR v$[rsp]
	jmp	$LN1@RoundScala
$LN4@RoundScala:

; 2047 : 	char v_str[64];
; 2048 : 	ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	mov	r9d, DWORD PTR v$[rsp]
	mov	r8, QWORD PTR fmt_start$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR v_str$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 2049 : 	const char* p = v_str;

	lea	rax, QWORD PTR v_str$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@RoundScala:

; 2050 : 	while (*p == ' ')

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN3@RoundScala

; 2051 : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN2@RoundScala
$LN3@RoundScala:

; 2052 : 	if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN8@RoundScala
	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN6@RoundScala
$LN8@RoundScala:

; 2053 : 		v = (TYPE)ImAtof(p);

	mov	rcx, QWORD PTR p$[rsp]
	call	?ImAtof@@YANPEBD@Z			; ImAtof
	cvttsd2si eax, xmm0
	mov	DWORD PTR v$[rsp], eax
	jmp	SHORT $LN7@RoundScala
$LN6@RoundScala:

; 2054 : 	else
; 2055 : 		ImAtoi(p, (SIGNEDTYPE*)&v);

	lea	rdx, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	??$ImAtoi@H@@YAPEBDPEBDPEAH@Z		; ImAtoi<int>
	npad	1
$LN7@RoundScala:

; 2056 : 	return v;

	mov	eax, DWORD PTR v$[rsp]
$LN1@RoundScala:

; 2057 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
??$RoundScalarWithFormatT@HH@ImGui@@YAHPEBDHH@Z ENDP	; ImGui::RoundScalarWithFormatT<int,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 225  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 226  :     // allocate _Bytes
; 227  :     if (_Bytes == 0) {

	cmp	QWORD PTR _Bytes$[rsp], 0
	jne	SHORT $LN2@Allocate

; 228  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN3@Allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
$LN1@Allocate:

; 257  :     }
; 258  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 261  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rsp]
	lea	rcx, QWORD PTR _Ptr$[rsp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
	npad	1
$LN2@Deallocate:

; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1

; 290  :     }
; 291  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ; std::forward<char * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
_TEXT	SEGMENT
_My_data$ = 48
_Old_size$ = 56
_New_ptr$ = 64
_New_size$ = 72
_New_capacity$ = 80
_Old_capacity$ = 88
_Old_ptr$1 = 96
_Al$ = 104
_Raw_new$ = 112
this$ = 144
_Size_increase$ = 152
_Fn$ = 160
<_Args_0>$ = 168
<_Args_1>$ = 176
??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>, COMDAT

; 2988 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 2989 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 2990 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 2991 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2992 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 2993 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 2994 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 2999 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 3000 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 3001 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 3002 : 
; 3003 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 3004 :         _ASAN_STRING_REMOVE(*this);
; 3005 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 3006 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 3008 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 15
	jbe	SHORT $LN3@Reallocate

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 3010 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	movzx	ecx, BYTE PTR <_Args_1>$[rsp]
	mov	BYTE PTR [rsp+40], cl
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()

; 3011 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	r8, QWORD PTR _Old_capacity$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3012 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 3013 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3014 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	movzx	ecx, BYTE PTR <_Args_1>$[rsp]
	mov	BYTE PTR [rsp+40], cl
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()

; 3015 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1
$LN4@Reallocate:

; 3016 :         }
; 3017 : 
; 3018 :         _ASAN_STRING_CREATE(*this);
; 3019 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 3020 :     }

	add	rsp, 136				; 00000088H
	ret	0
??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Count$ = 96
_Ch$ = 104
??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z PROC ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator(), COMDAT

; 1532 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1529 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	r8, QWORD PTR _Old_size$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1530 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1531 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1532 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ENDP ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
$T1 = 33
$T2 = 34
_My_data$ = 40
_New_ptr$ = 48
_New_capacity$ = 56
_Alproxy$ = 64
_Al$ = 72
this$ = 96
_Arg$ = 104
_Count$ = 112
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 848  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 858  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 15
	ja	SHORT $LN3@Construct

; 866  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 867  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 868  : 
; 869  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 870  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 871  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 872  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 873  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 884  :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 885  :         }
; 886  : 
; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 890  : 
; 891  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 892  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	add	rax, QWORD PTR _Count$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@Construct:
$LN4@Construct:

; 905  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
_TEXT	SEGMENT
_My_data$ = 48
_Old_size$ = 56
_New_ptr$ = 64
_New_size$ = 72
_New_capacity$ = 80
_Old_capacity$ = 88
_Old_ptr$1 = 96
_Al$ = 104
_Raw_new$ = 112
this$ = 144
_Size_increase$ = 152
_Fn$ = 160
<_Args_0>$ = 168
<_Args_1>$ = 176
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>, COMDAT

; 2988 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 2989 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 2990 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 2991 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2992 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 2993 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 2994 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 2999 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 3000 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 3001 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 3002 : 
; 3003 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 3004 :         _ASAN_STRING_REMOVE(*this);
; 3005 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 3006 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 3008 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 15
	jbe	SHORT $LN3@Reallocate

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 3010 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()

; 3011 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	r8, QWORD PTR _Old_capacity$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3012 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 3013 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3014 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()

; 3015 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1
$LN4@Reallocate:

; 3016 :         }
; 3017 : 
; 3018 :         _ASAN_STRING_CREATE(*this);
; 3019 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 3020 :     }

	add	rsp, 136				; 00000088H
	ret	0
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Ptr$ = 96
_Count$ = 104
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z PROC ; <lambda_65e615be2a453ca0576c979606f46740>::operator(), COMDAT

; 1505 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1502 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	r8, QWORD PTR _Old_size$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1503 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1505 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ENDP ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1116 :     noexcept(sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

	mov	QWORD PTR [rsp+8], rcx

; 1117 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1118 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1119 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1120 : 
; 1121 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1122 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1123 :             _Xlength_error("size is too long for _Size_type");
; 1124 :         }
; 1125 :     }
; 1126 : 
; 1127 :     return static_cast<_Size_type>(_Len);

	mov	rax, QWORD PTR _Len$[rsp]

; 1128 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
_TEXT	SEGMENT
_New_ptr$ = 32
_New_capacity$ = 40
_Old_capacity$ = 48
_Al$ = 56
this$ = 80
_New_size$ = 88
_Fn$ = 96
<_Args_0>$ = 104
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>, COMDAT

; 2959 :     _CONSTEXPR20 basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2960 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 2961 :         // _Fn(_New_ptr, _New_size, _Args...)
; 2962 :         if (_New_size > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _New_size$[rsp], rax
	jbe	SHORT $LN2@Reallocate

; 2963 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 2964 :         }
; 2965 : 
; 2966 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 2967 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 2968 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2969 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 2970 : 
; 2971 :         _Mypair._Myval2._Orphan_all();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 2972 :         _ASAN_STRING_REMOVE(*this);
; 2973 :         _Mypair._Myval2._Mysize = _New_size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 2975 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r9, QWORD PTR <_Args_0>$[rsp]
	mov	r8, QWORD PTR _New_size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
	npad	1

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 15
	jbe	SHORT $LN3@Reallocate

; 2977 :             _Deallocate_for_capacity(_Al, _Mypair._Myval2._Bx._Ptr, _Old_capacity);

	mov	r8, QWORD PTR _Old_capacity$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 2978 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 2979 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 2980 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1
$LN4@Reallocate:

; 2981 :         }
; 2982 : 
; 2983 :         _ASAN_STRING_CREATE(*this);
; 2984 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 2985 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Count$ = 80
_Ptr$ = 88
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z PROC ; <lambda_66f57f934f28d61049862f64df852ff0>::operator(), COMDAT

; 1609 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1607 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1609 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z ENDP ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$_Max_limit@_J@std@@YA_JXZ
_TEXT	SEGMENT
_Unsigned_max$1 = 0
??$_Max_limit@_J@std@@YA_JXZ PROC			; std::_Max_limit<__int64>, COMDAT

; 863  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

$LN3:
	sub	rsp, 24

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

	mov	QWORD PTR _Unsigned_max$1[rsp], -1

; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

	add	rsp, 24
	ret	0
??$_Max_limit@_J@std@@YA_JXZ ENDP			; std::_Max_limit<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 75   :         noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@max
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@max:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 78   : }

	add	rsp, 24
	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
d$1 = 0
b$ = 8
a$ = 16
lhs$ = 48
rhs$ = 56
?TabBarSortItemComparer@@YAHPEBX0@Z PROC		; TabBarSortItemComparer

; 6441 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 6442 : 	const ImGuiTabBarSortItem* a = (const ImGuiTabBarSortItem*)lhs;

	mov	rax, QWORD PTR lhs$[rsp]
	mov	QWORD PTR a$[rsp], rax

; 6443 : 	const ImGuiTabBarSortItem* b = (const ImGuiTabBarSortItem*)rhs;

	mov	rax, QWORD PTR rhs$[rsp]
	mov	QWORD PTR b$[rsp], rax

; 6444 : 	if (int d = (int)(b->Width - a->Width))

	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	cvttss2si eax, xmm0
	mov	DWORD PTR d$1[rsp], eax
	cmp	DWORD PTR d$1[rsp], 0
	je	SHORT $LN2@TabBarSort

; 6445 : 		return d;

	mov	eax, DWORD PTR d$1[rsp]
	jmp	SHORT $LN1@TabBarSort
$LN2@TabBarSort:

; 6446 : 	return (b->Index - a->Index);

	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	eax, DWORD PTR [rax]
	sub	eax, ecx
$LN1@TabBarSort:

; 6447 : }

	add	rsp, 40					; 00000028H
	ret	0
?TabBarSortItemComparer@@YAHPEBX0@Z ENDP		; TabBarSortItemComparer
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
a$ = 0
b$ = 8
lhs$ = 32
rhs$ = 40
?TabItemComparerByVisibleOffset@@YAHPEBX0@Z PROC	; TabItemComparerByVisibleOffset

; 6434 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 6435 : 	const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;

	mov	rax, QWORD PTR lhs$[rsp]
	mov	QWORD PTR a$[rsp], rax

; 6436 : 	const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;

	mov	rax, QWORD PTR rhs$[rsp]
	mov	QWORD PTR b$[rsp], rax

; 6437 : 	return (int)(a->Offset - b->Offset);

	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	subss	xmm0, DWORD PTR [rcx+20]
	cvttss2si eax, xmm0

; 6438 : }

	add	rsp, 24
	ret	0
?TabItemComparerByVisibleOffset@@YAHPEBX0@Z ENDP	; TabItemComparerByVisibleOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv175 = 48
open$ = 49
tab_n$1 = 52
g$ = 56
tab_list_popup_button_width$ = 64
tab$2 = 72
window$ = 80
tab_to_select$ = 88
tv161 = 96
tv179 = 104
tab_name$3 = 112
backup_cursor_pos$ = 120
arrow_col$ = 128
$T4 = 144
$T5 = 152
$T6 = 160
tab_bar$ = 208
?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z PROC ; ImGui::TabBarTabListPopupButton

; 6845 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 184				; 000000b8H

; 6846 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6847 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 6848 : 
; 6849 : 	// We use g.Style.FramePadding.y to match the square ArrowButton size
; 6850 : 	const float tab_list_popup_button_width = g.FontSize + g.Style.FramePadding.y;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	addss	xmm0, DWORD PTR [rcx+5528]
	movss	DWORD PTR tab_list_popup_button_width$[rsp], xmm0

; 6851 : 	const ImVec2 backup_cursor_pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR backup_cursor_pos$[rsp], rax

; 6852 : 	window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x - g.Style.FramePadding.y, tab_bar->BarRect.Min.y);

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	subss	xmm0, DWORD PTR [rcx+5528]
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm2, DWORD PTR [rax+40]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+340], rax

; 6853 : 	tab_bar->BarRect.Min.x += tab_list_popup_button_width;

	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	addss	xmm0, DWORD PTR tab_list_popup_button_width$[rsp]
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	DWORD PTR [rax+36], xmm0

; 6854 : 
; 6855 : 	ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, QWORD PTR arrow_col$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax+5640]
	mov	ecx, 16
	rep movsb

; 6856 : 	arrow_col.w *= 0.5f;

	movss	xmm0, DWORD PTR arrow_col$[rsp+12]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR arrow_col$[rsp+12], xmm0

; 6857 : 	PushStyleColor(ImGuiCol_Text, arrow_col);

	lea	rdx, QWORD PTR arrow_col$[rsp]
	xor	ecx, ecx
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor
	npad	1

; 6858 : 	PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rdx, rax
	mov	ecx, 21
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor
	npad	1

; 6859 : 	bool open = BeginCombo(("##+-v"), NULL, ImGuiComboFlags_NoPreview);

	mov	r8d, 64					; 00000040H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_05HHKHFPOM@?$CD?$CD?$CL?9v@
	call	?BeginCombo@ImGui@@YA_NPEBD0H@Z		; ImGui::BeginCombo
	mov	BYTE PTR open$[rsp], al

; 6860 : 	PopStyleColor(2);

	mov	ecx, 2
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor

; 6861 : 
; 6862 : 	ImGuiTabItem* tab_to_select = NULL;

	mov	QWORD PTR tab_to_select$[rsp], 0

; 6863 : 	if (open)

	movzx	eax, BYTE PTR open$[rsp]
	test	eax, eax
	je	$LN5@TabBarTabL

; 6864 : 	{
; 6865 : 		for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	mov	DWORD PTR tab_n$1[rsp], 0
	jmp	SHORT $LN4@TabBarTabL
$LN2@TabBarTabL:
	mov	eax, DWORD PTR tab_n$1[rsp]
	inc	eax
	mov	DWORD PTR tab_n$1[rsp], eax
$LN4@TabBarTabL:
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR tab_n$1[rsp], eax
	jge	$LN3@TabBarTabL

; 6866 : 		{
; 6867 : 			ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv161[rsp], rax
	mov	edx, DWORD PTR tab_n$1[rsp]
	mov	rcx, QWORD PTR tv161[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	mov	QWORD PTR tab$2[rsp], rax

; 6868 : 			const char* tab_name = tab_bar->GetTabName(tab);

	mov	rdx, QWORD PTR tab$2[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?GetTabName@ImGuiTabBar@@QEBAPEBDPEBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabName
	mov	QWORD PTR tab_name$3[rsp], rax

; 6869 : 			if (Selectable(tab_name, tab_bar->SelectedTabId == tab->ID))

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv179[rsp], rax
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tab$2[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN8@TabBarTabL
	mov	BYTE PTR tv175[rsp], 1
	jmp	SHORT $LN9@TabBarTabL
$LN8@TabBarTabL:
	mov	BYTE PTR tv175[rsp], 0
$LN9@TabBarTabL:
	mov	r9, QWORD PTR tv179[rsp]
	xor	r8d, r8d
	movzx	edx, BYTE PTR tv175[rsp]
	mov	rcx, QWORD PTR tab_name$3[rsp]
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@TabBarTabL

; 6870 : 				tab_to_select = tab;

	mov	rax, QWORD PTR tab$2[rsp]
	mov	QWORD PTR tab_to_select$[rsp], rax
$LN6@TabBarTabL:

; 6871 : 		}

	jmp	$LN2@TabBarTabL
$LN3@TabBarTabL:

; 6872 : 		EndCombo();

	call	?EndCombo@ImGui@@YAXXZ			; ImGui::EndCombo
	npad	1
$LN5@TabBarTabL:

; 6873 : 	}
; 6874 : 
; 6875 : 	window->DC.CursorPos = backup_cursor_pos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR backup_cursor_pos$[rsp]
	mov	QWORD PTR [rax+340], rcx

; 6876 : 	return tab_to_select;

	mov	rax, QWORD PTR tab_to_select$[rsp]

; 6877 : }

	add	rsp, 184				; 000000b8H
	pop	rdi
	pop	rsi
	ret	0
?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z ENDP ; ImGui::TabBarTabListPopupButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
want_clip_rect$ = 48
g$ = 56
select_dir$ = 64
scrolling_buttons_width$ = 68
target_order$1 = 72
window$ = 80
tv135 = 88
selected_order$2 = 92
tv248 = 96
arrow_button_size$ = 104
backup_repeat_rate$ = 112
backup_repeat_delay$ = 116
tab_item$3 = 120
tab_to_select$ = 128
tv251 = 136
backup_cursor_pos$ = 144
arrow_col$ = 152
$T4 = 168
$T5 = 176
$T6 = 184
$T7 = 192
$T8 = 200
$T9 = 208
avail_bar_rect$ = 216
$T10 = 232
$T11 = 248
tab_bar$ = 304
?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z PROC ; ImGui::TabBarScrollingButtons

; 6791 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 280				; 00000118H

; 6792 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6793 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 6794 : 
; 6795 : 	const ImVec2 arrow_button_size(g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5528]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	subss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR arrow_button_size$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 6796 : 	const float scrolling_buttons_width = arrow_button_size.x * 2.0f;

	movss	xmm0, DWORD PTR arrow_button_size$[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR scrolling_buttons_width$[rsp], xmm0

; 6797 : 
; 6798 : 	const ImVec2 backup_cursor_pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR backup_cursor_pos$[rsp], rax

; 6799 : 	//window->DrawList->AddRect(ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y), ImVec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y), IM_COL32(255,0,0,255));
; 6800 : 
; 6801 : 	const ImRect avail_bar_rect = tab_bar->BarRect;

	lea	rax, QWORD PTR avail_bar_rect$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+36]
	mov	ecx, 16
	rep movsb

; 6802 : 	bool want_clip_rect = !avail_bar_rect.Contains(ImRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(scrolling_buttons_width, 0.0f)));

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR scrolling_buttons_width$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T5[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	mov	rdx, rax
	lea	rcx, QWORD PTR avail_bar_rect$[rsp]
	call	?Contains@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Contains
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN9@TabBarScro
	mov	DWORD PTR tv135[rsp], 1
	jmp	SHORT $LN10@TabBarScro
$LN9@TabBarScro:
	mov	DWORD PTR tv135[rsp], 0
$LN10@TabBarScro:
	movzx	eax, BYTE PTR tv135[rsp]
	mov	BYTE PTR want_clip_rect$[rsp], al

; 6803 : 	if (want_clip_rect)

	movzx	eax, BYTE PTR want_clip_rect$[rsp]
	test	eax, eax
	je	SHORT $LN2@TabBarScro

; 6804 : 		PushClipRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max + ImVec2(g.Style.ItemInnerSpacing.x, 0.0f), true);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5548]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR tab_bar$[rsp]
	add	rcx, 44					; 0000002cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T7[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR tab_bar$[rsp]
	add	rcx, 36					; 00000024H
	mov	r8b, 1
	mov	rdx, rax
	call	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z ; ImGui::PushClipRect
	npad	1
$LN2@TabBarScro:

; 6805 : 
; 6806 : 	ImGuiTabItem* tab_to_select = NULL;

	mov	QWORD PTR tab_to_select$[rsp], 0

; 6807 : 
; 6808 : 	int select_dir = 0;

	mov	DWORD PTR select_dir$[rsp], 0

; 6809 : 	ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];

	mov	eax, 16
	imul	rax, rax, 0
	lea	rcx, QWORD PTR arrow_col$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax+5640]
	mov	ecx, 16
	rep movsb

; 6810 : 	arrow_col.w *= 0.5f;

	movss	xmm0, DWORD PTR arrow_col$[rsp+12]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR arrow_col$[rsp+12], xmm0

; 6811 : 
; 6812 : 	PushStyleColor(ImGuiCol_Text, arrow_col);

	lea	rdx, QWORD PTR arrow_col$[rsp]
	xor	ecx, ecx
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor
	npad	1

; 6813 : 	PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rdx, rax
	mov	ecx, 21
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor
	npad	1

; 6814 : 	const float backup_repeat_delay = g.IO.KeyRepeatDelay;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+152]
	movss	DWORD PTR backup_repeat_delay$[rsp], xmm0

; 6815 : 	const float backup_repeat_rate = g.IO.KeyRepeatRate;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+168]
	movss	DWORD PTR backup_repeat_rate$[rsp], xmm0

; 6816 : 	g.IO.KeyRepeatDelay = 0.250f;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [rax+152], xmm0

; 6817 : 	g.IO.KeyRepeatRate = 0.200f;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [rax+168], xmm0

; 6818 : 	window->DC.CursorPos = ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y);

	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rax+44]
	subss	xmm0, DWORD PTR scrolling_buttons_width$[rsp]
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm2, DWORD PTR [rax+40]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+340], rax

; 6819 : 	if (ArrowButtonEx(("##+-<"), ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))

	mov	r9d, 5
	mov	r8, QWORD PTR arrow_button_size$[rsp]
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_05HNDBPIGD@?$CD?$CD?$CL?9?$DM@
	call	?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z ; ImGui::ArrowButtonEx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@TabBarScro

; 6820 : 		select_dir = -1;

	mov	DWORD PTR select_dir$[rsp], -1
$LN3@TabBarScro:

; 6821 : 	window->DC.CursorPos = ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width + arrow_button_size.x, tab_bar->BarRect.Min.y);

	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rax+44]
	subss	xmm0, DWORD PTR scrolling_buttons_width$[rsp]
	addss	xmm0, DWORD PTR arrow_button_size$[rsp]
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm2, DWORD PTR [rax+40]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+340], rax

; 6822 : 	if (ArrowButtonEx(("##+->"), ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))

	mov	r9d, 5
	mov	r8, QWORD PTR arrow_button_size$[rsp]
	mov	edx, 1
	lea	rcx, OFFSET FLAT:??_C@_05EPAHJKOB@?$CD?$CD?$CL?9?$DO@
	call	?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z ; ImGui::ArrowButtonEx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@TabBarScro

; 6823 : 		select_dir = +1;

	mov	DWORD PTR select_dir$[rsp], 1
$LN4@TabBarScro:

; 6824 : 	PopStyleColor(2);

	mov	ecx, 2
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor

; 6825 : 	g.IO.KeyRepeatRate = backup_repeat_rate;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR backup_repeat_rate$[rsp]
	movss	DWORD PTR [rax+168], xmm0

; 6826 : 	g.IO.KeyRepeatDelay = backup_repeat_delay;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR backup_repeat_delay$[rsp]
	movss	DWORD PTR [rax+152], xmm0

; 6827 : 
; 6828 : 	if (want_clip_rect)

	movzx	eax, BYTE PTR want_clip_rect$[rsp]
	test	eax, eax
	je	SHORT $LN5@TabBarScro

; 6829 : 		PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect
	npad	1
$LN5@TabBarScro:

; 6830 : 
; 6831 : 	if (select_dir != 0)

	cmp	DWORD PTR select_dir$[rsp], 0
	je	$LN6@TabBarScro

; 6832 : 		if (ImGuiTabItem* tab_item = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId))

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
	mov	QWORD PTR tab_item$3[rsp], rax
	cmp	QWORD PTR tab_item$3[rsp], 0
	je	SHORT $LN7@TabBarScro

; 6833 : 		{
; 6834 : 			int selected_order = tab_bar->GetTabOrder(tab_item);

	mov	rdx, QWORD PTR tab_item$3[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?GetTabOrder@ImGuiTabBar@@QEBAHPEBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabOrder
	mov	DWORD PTR selected_order$2[rsp], eax

; 6835 : 			int target_order = selected_order + select_dir;

	mov	eax, DWORD PTR select_dir$[rsp]
	mov	ecx, DWORD PTR selected_order$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR target_order$1[rsp], eax

; 6836 : 			tab_to_select = &tab_bar->Tabs[(target_order >= 0 && target_order < tab_bar->Tabs.Size) ? target_order : selected_order]; // If we are at the end of the list, still scroll to make our tab visible

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv251[rsp], rax
	cmp	DWORD PTR target_order$1[rsp], 0
	jl	SHORT $LN11@TabBarScro
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR target_order$1[rsp], eax
	jge	SHORT $LN11@TabBarScro
	mov	eax, DWORD PTR target_order$1[rsp]
	mov	DWORD PTR tv248[rsp], eax
	jmp	SHORT $LN12@TabBarScro
$LN11@TabBarScro:
	mov	eax, DWORD PTR selected_order$2[rsp]
	mov	DWORD PTR tv248[rsp], eax
$LN12@TabBarScro:
	mov	edx, DWORD PTR tv248[rsp]
	mov	rcx, QWORD PTR tv251[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	mov	QWORD PTR tab_to_select$[rsp], rax
$LN7@TabBarScro:
$LN6@TabBarScro:

; 6837 : 		}
; 6838 : 	window->DC.CursorPos = backup_cursor_pos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR backup_cursor_pos$[rsp]
	mov	QWORD PTR [rax+340], rcx

; 6839 : 	tab_bar->BarRect.Max.x -= scrolling_buttons_width + 1.0f;

	movss	xmm0, DWORD PTR scrolling_buttons_width$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm1, DWORD PTR [rax+44]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	DWORD PTR [rax+44], xmm0

; 6840 : 
; 6841 : 	return tab_to_select;

	mov	rax, QWORD PTR tab_to_select$[rsp]

; 6842 : }

	add	rsp, 280				; 00000118H
	pop	rdi
	pop	rsi
	ret	0
?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z ENDP ; ImGui::TabBarScrollingButtons
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv72 = 32
order$ = 36
margin$ = 40
tv81 = 44
tab_x1$ = 48
tab_x2$ = 52
g$ = 56
tab_bar$ = 80
tab$ = 88
?TabBarScrollToTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z PROC ; ImGui::TabBarScrollToTab

; 6770 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 6771 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6772 : 	float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR margin$[rsp], xmm0

; 6773 : 	int order = tab_bar->GetTabOrder(tab);

	mov	rdx, QWORD PTR tab$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?GetTabOrder@ImGuiTabBar@@QEBAHPEBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabOrder
	mov	DWORD PTR order$[rsp], eax

; 6774 : 	float tab_x1 = tab->Offset + (order > 0 ? -margin : 0.0f);

	cmp	DWORD PTR order$[rsp], 0
	jle	SHORT $LN5@TabBarScro
	movss	xmm0, DWORD PTR margin$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv72[rsp], xmm0
	jmp	SHORT $LN6@TabBarScro
$LN5@TabBarScro:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv72[rsp], xmm0
$LN6@TabBarScro:
	mov	rax, QWORD PTR tab$[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	addss	xmm0, DWORD PTR tv72[rsp]
	movss	DWORD PTR tab_x1$[rsp], xmm0

; 6775 : 	float tab_x2 = tab->Offset + tab->Width + (order + 1 < tab_bar->Tabs.Size ? margin : 1.0f);

	mov	eax, DWORD PTR order$[rsp]
	inc	eax
	mov	rcx, QWORD PTR tab_bar$[rsp]
	cmp	eax, DWORD PTR [rcx+16]
	jge	SHORT $LN7@TabBarScro
	movss	xmm0, DWORD PTR margin$[rsp]
	movss	DWORD PTR tv81[rsp], xmm0
	jmp	SHORT $LN8@TabBarScro
$LN7@TabBarScro:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv81[rsp], xmm0
$LN8@TabBarScro:
	mov	rax, QWORD PTR tab$[rsp]
	mov	rcx, QWORD PTR tab$[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	addss	xmm0, DWORD PTR [rcx+24]
	addss	xmm0, DWORD PTR tv81[rsp]
	movss	DWORD PTR tab_x2$[rsp], xmm0

; 6776 : 	if (tab_bar->ScrollingTarget > tab_x1)

	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rax+80]
	comiss	xmm0, DWORD PTR tab_x1$[rsp]
	jbe	SHORT $LN2@TabBarScro

; 6777 : 		tab_bar->ScrollingTarget = tab_x1;

	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR tab_x1$[rsp]
	movss	DWORD PTR [rax+80], xmm0
$LN2@TabBarScro:

; 6778 : 	if (tab_bar->ScrollingTarget + tab_bar->BarRect.GetWidth() < tab_x2)

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 36					; 00000024H
	mov	rcx, rax
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm1, DWORD PTR [rax+80]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR tab_x2$[rsp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@TabBarScro

; 6779 : 		tab_bar->ScrollingTarget = tab_x2 - tab_bar->BarRect.GetWidth();

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 36					; 00000024H
	mov	rcx, rax
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	xmm1, DWORD PTR tab_x2$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	DWORD PTR [rax+80], xmm0
$LN3@TabBarScro:

; 6780 : }

	add	rsp, 72					; 00000048H
	ret	0
?TabBarScrollToTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z ENDP ; ImGui::TabBarScrollToTab
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tab_bar$ = 48
scrolling$ = 56
?TabBarScrollClamp@ImGui@@YAMPEAUImGuiTabBar@@M@Z PROC	; ImGui::TabBarScrollClamp

; 6764 : {

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 6765 : 	scrolling = ImMin(scrolling, tab_bar->OffsetMax - tab_bar->BarRect.GetWidth());

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 36					; 00000024H
	mov	rcx, rax
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm1, DWORD PTR [rax+60]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR scrolling$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR scrolling$[rsp], xmm0

; 6766 : 	return ImMax(scrolling, 0.0f);

	xorps	xmm1, xmm1
	movss	xmm0, DWORD PTR scrolling$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>

; 6767 : }

	add	rsp, 40					; 00000028H
	ret	0
?TabBarScrollClamp@ImGui@@YAMPEAUImGuiTabBar@@M@Z ENDP	; ImGui::TabBarScrollClamp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 0
?TabBarCalcMaxTabWidth@ImGui@@YAMXZ PROC		; ImGui::TabBarCalcMaxTabWidth

; 6722 : {

	sub	rsp, 24

; 6723 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6724 : 	return g.FontSize * 20.0f;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@41a00000

; 6725 : }

	add	rsp, 24
	ret	0
?TabBarCalcMaxTabWidth@ImGui@@YAMXZ ENDP		; ImGui::TabBarCalcMaxTabWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
id$1 = 32
window$2 = 40
tab_bar$ = 64
label$ = 72
?TabBarCalcTabID@ImGui@@YAIPEAUImGuiTabBar@@PEBD@Z PROC	; ImGui::TabBarCalcTabID

; 6707 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6708 : 	if (tab_bar->Flags & ImGuiTabBarFlags_DockNode)

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	je	SHORT $LN2@TabBarCalc

; 6709 : 	{
; 6710 : 		ImGuiID id = ImHashStr(label, 0);

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?ImHashStr@@YAIPEBD_KI@Z		; ImHashStr
	mov	DWORD PTR id$1[rsp], eax

; 6711 : 		KeepAliveID(id);

	mov	ecx, DWORD PTR id$1[rsp]
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID

; 6712 : 		return id;

	mov	eax, DWORD PTR id$1[rsp]
	jmp	SHORT $LN1@TabBarCalc

; 6713 : 	}

	jmp	SHORT $LN3@TabBarCalc
$LN2@TabBarCalc:

; 6714 : 	else
; 6715 : 	{
; 6716 : 		ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$2[rsp], rax

; 6717 : 		return window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$2[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
$LN3@TabBarCalc:
$LN1@TabBarCalc:

; 6718 : 	}
; 6719 : }

	add	rsp, 56					; 00000038H
	ret	0
?TabBarCalcTabID@ImGui@@YAIPEAUImGuiTabBar@@PEBD@Z ENDP	; ImGui::TabBarCalcTabID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv176 = 32
tv215 = 33
tv426 = 34
found_selected_tab_id$ = 35
tab_count_same_width$1 = 36
scroll_track_selected_tab_id$ = 40
tab_n$2 = 44
tab_list_popup_button$ = 48
scrolling_buttons$ = 49
tab_src_n$3 = 52
tab_dst_n$ = 56
width_sort_buffer$ = 64
width_excess$ = 72
tab_n$4 = 76
width_total_contents$ = 80
tab_n$5 = 84
tab_n$6 = 88
tab_n$7 = 92
offset_x$ = 96
g$ = 104
tab$8 = 112
tab2_order$9 = 120
tab2$10 = 128
tv224 = 136
width_avail$ = 140
tv244 = 144
tv293 = 148
width_to_remove_per_tab$11 = 152
tv475 = 156
tab1$12 = 160
most_recently_selected_tab$ = 168
tab$13 = 176
width_to_remove_per_tab_max$14 = 184
tv238 = 188
tab_max_width$15 = 192
tv332 = 196
scrolling_speed$ = 200
tab$16 = 208
tab_to_select$17 = 216
tv305 = 224
tab$18 = 232
tab_to_select$19 = 240
scroll_track_selected_tab$20 = 248
tv74 = 256
tv94 = 264
tv88 = 272
tv137 = 280
tv165 = 288
tv199 = 296
tab_name$21 = 304
tv267 = 312
tv280 = 320
tv323 = 328
tv343 = 336
tv390 = 344
tv494 = 352
$T22 = 360
$T23 = 368
item_tmp$24 = 400
tab_bar$ = 464
?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z PROC	; ImGui::TabBarLayout

; 6539 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 440				; 000001b8H

; 6540 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6541 : 	tab_bar->WantLayout = false;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	BYTE PTR [rax+88], 0

; 6542 : 
; 6543 : 	// Garbage collect
; 6544 : 	int tab_dst_n = 0;

	mov	DWORD PTR tab_dst_n$[rsp], 0

; 6545 : 	for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++)

	mov	DWORD PTR tab_src_n$3[rsp], 0
	jmp	SHORT $LN4@TabBarLayo
$LN2@TabBarLayo:
	mov	eax, DWORD PTR tab_src_n$3[rsp]
	inc	eax
	mov	DWORD PTR tab_src_n$3[rsp], eax
$LN4@TabBarLayo:
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR tab_src_n$3[rsp], eax
	jge	$LN3@TabBarLayo

; 6546 : 	{
; 6547 : 		ImGuiTabItem* tab = &tab_bar->Tabs[tab_src_n];

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv74[rsp], rax
	mov	edx, DWORD PTR tab_src_n$3[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	mov	QWORD PTR tab$16[rsp], rax

; 6548 : 		if (tab->LastFrameVisible < tab_bar->PrevFrameVisible)

	mov	rax, QWORD PTR tab$16[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	cmp	DWORD PTR [rax+16], ecx
	jge	SHORT $LN24@TabBarLayo

; 6549 : 		{
; 6550 : 			if (tab->ID == tab_bar->SelectedTabId)

	mov	rax, QWORD PTR tab$16[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN25@TabBarLayo

; 6551 : 				tab_bar->SelectedTabId = 0;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	DWORD PTR [rax], 0
$LN25@TabBarLayo:

; 6552 : 			continue;

	jmp	$LN2@TabBarLayo
$LN24@TabBarLayo:

; 6553 : 		}
; 6554 : 		if (tab_dst_n != tab_src_n)

	mov	eax, DWORD PTR tab_src_n$3[rsp]
	cmp	DWORD PTR tab_dst_n$[rsp], eax
	je	SHORT $LN26@TabBarLayo

; 6555 : 			tab_bar->Tabs[tab_dst_n] = tab_bar->Tabs[tab_src_n];

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv94[rsp], rax
	mov	edx, DWORD PTR tab_src_n$3[rsp]
	mov	rcx, QWORD PTR tv94[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	lea	rcx, QWORD PTR $T23[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 32					; 00000020H
	rep movsb
	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv88[rsp], rax
	mov	edx, DWORD PTR tab_dst_n$[rsp]
	mov	rcx, QWORD PTR tv88[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	lea	rcx, QWORD PTR $T23[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 32					; 00000020H
	rep movsb
$LN26@TabBarLayo:

; 6556 : 		tab_dst_n++;

	mov	eax, DWORD PTR tab_dst_n$[rsp]
	inc	eax
	mov	DWORD PTR tab_dst_n$[rsp], eax

; 6557 : 	}

	jmp	$LN2@TabBarLayo
$LN3@TabBarLayo:

; 6558 : 	if (tab_bar->Tabs.Size != tab_dst_n)

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR tab_dst_n$[rsp]
	cmp	DWORD PTR [rax+16], ecx
	je	SHORT $LN27@TabBarLayo

; 6559 : 		tab_bar->Tabs.resize(tab_dst_n);

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv137[rsp], rax
	mov	edx, DWORD PTR tab_dst_n$[rsp]
	mov	rcx, QWORD PTR tv137[rsp]
	call	?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z ; ImVector<ImGuiTabItem>::resize
	npad	1
$LN27@TabBarLayo:

; 6560 : 
; 6561 : 	// Setup next selected tab
; 6562 : 	ImGuiID scroll_track_selected_tab_id = 0;

	mov	DWORD PTR scroll_track_selected_tab_id$[rsp], 0

; 6563 : 	if (tab_bar->NextSelectedTabId)

	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN28@TabBarLayo

; 6564 : 	{
; 6565 : 		tab_bar->SelectedTabId = tab_bar->NextSelectedTabId;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR [rcx+32]
	mov	DWORD PTR [rax], ecx

; 6566 : 		tab_bar->NextSelectedTabId = 0;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	DWORD PTR [rax+32], 0

; 6567 : 		scroll_track_selected_tab_id = tab_bar->SelectedTabId;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR scroll_track_selected_tab_id$[rsp], eax
$LN28@TabBarLayo:

; 6568 : 	}
; 6569 : 
; 6570 : 	// Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).
; 6571 : 	if (tab_bar->ReorderRequestTabId != 0)

	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax+76], 0
	je	$LN29@TabBarLayo

; 6572 : 	{
; 6573 : 		if (ImGuiTabItem* tab1 = TabBarFindTabByID(tab_bar, tab_bar->ReorderRequestTabId))

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	edx, DWORD PTR [rax+76]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
	mov	QWORD PTR tab1$12[rsp], rax
	cmp	QWORD PTR tab1$12[rsp], 0
	je	$LN30@TabBarLayo

; 6574 : 		{
; 6575 : 			//IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_Reorderable); // <- this may happen when using debug tools
; 6576 : 			int tab2_order = tab_bar->GetTabOrder(tab1) + tab_bar->ReorderRequestDir;

	mov	rdx, QWORD PTR tab1$12[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?GetTabOrder@ImGuiTabBar@@QEBAHPEBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabOrder
	mov	rcx, QWORD PTR tab_bar$[rsp]
	add	eax, DWORD PTR [rcx+84]
	mov	DWORD PTR tab2_order$9[rsp], eax

; 6577 : 			if (tab2_order >= 0 && tab2_order < tab_bar->Tabs.Size)

	cmp	DWORD PTR tab2_order$9[rsp], 0
	jl	$LN31@TabBarLayo
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR tab2_order$9[rsp], eax
	jge	$LN31@TabBarLayo

; 6578 : 			{
; 6579 : 				ImGuiTabItem* tab2 = &tab_bar->Tabs[tab2_order];

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv165[rsp], rax
	mov	edx, DWORD PTR tab2_order$9[rsp]
	mov	rcx, QWORD PTR tv165[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	mov	QWORD PTR tab2$10[rsp], rax

; 6580 : 				ImGuiTabItem item_tmp = *tab1;

	lea	rax, QWORD PTR item_tmp$24[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR tab1$12[rsp]
	mov	ecx, 32					; 00000020H
	rep movsb

; 6581 : 				*tab1 = *tab2;

	mov	rdi, QWORD PTR tab1$12[rsp]
	mov	rsi, QWORD PTR tab2$10[rsp]
	mov	ecx, 32					; 00000020H
	rep movsb

; 6582 : 				*tab2 = item_tmp;

	lea	rax, QWORD PTR item_tmp$24[rsp]
	mov	rdi, QWORD PTR tab2$10[rsp]
	mov	rsi, rax
	mov	ecx, 32					; 00000020H
	rep movsb

; 6583 : 				if (tab2->ID == tab_bar->SelectedTabId)

	mov	rax, QWORD PTR tab2$10[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN32@TabBarLayo

; 6584 : 					scroll_track_selected_tab_id = tab2->ID;

	mov	rax, QWORD PTR tab2$10[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR scroll_track_selected_tab_id$[rsp], eax
$LN32@TabBarLayo:

; 6585 : 				tab1 = tab2 = NULL;

	mov	QWORD PTR tab2$10[rsp], 0
	mov	rax, QWORD PTR tab2$10[rsp]
	mov	QWORD PTR tab1$12[rsp], rax
$LN31@TabBarLayo:
$LN30@TabBarLayo:

; 6586 : 			}
; 6587 : 			/*if (tab_bar->Flags & ImGuiTabBarFlags_SaveSettings)
; 6588 : 				MarkIniSettingsDirty();*/
; 6589 : 		}
; 6590 : 		tab_bar->ReorderRequestTabId = 0;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	DWORD PTR [rax+76], 0
$LN29@TabBarLayo:

; 6591 : 	}
; 6592 : 
; 6593 : 	// Tab List Popup (will alter tab_bar->BarRect and therefore the available width!)
; 6594 : 	const bool tab_list_popup_button = (tab_bar->Flags & ImGuiTabBarFlags_TabListPopupButton) != 0;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN51@TabBarLayo
	mov	BYTE PTR tv176[rsp], 1
	jmp	SHORT $LN52@TabBarLayo
$LN51@TabBarLayo:
	mov	BYTE PTR tv176[rsp], 0
$LN52@TabBarLayo:
	movzx	eax, BYTE PTR tv176[rsp]
	mov	BYTE PTR tab_list_popup_button$[rsp], al

; 6595 : 	if (tab_list_popup_button)

	movzx	eax, BYTE PTR tab_list_popup_button$[rsp]
	test	eax, eax
	je	SHORT $LN33@TabBarLayo

; 6596 : 		if (ImGuiTabItem* tab_to_select = TabBarTabListPopupButton(tab_bar)) // NB: Will alter BarRect.Max.x!

	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z ; ImGui::TabBarTabListPopupButton
	mov	QWORD PTR tab_to_select$17[rsp], rax
	cmp	QWORD PTR tab_to_select$17[rsp], 0
	je	SHORT $LN34@TabBarLayo

; 6597 : 			scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tab_to_select$17[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR scroll_track_selected_tab_id$[rsp], eax
$LN34@TabBarLayo:
$LN33@TabBarLayo:

; 6598 : 
; 6599 : 	ImVector<ImGuiTabBarSortItem>& width_sort_buffer = g.TabSortByWidthBuffer;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7784				; 00001e68H
	mov	QWORD PTR width_sort_buffer$[rsp], rax

; 6600 : 	width_sort_buffer.resize(tab_bar->Tabs.Size);

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	edx, DWORD PTR [rax+16]
	mov	rcx, QWORD PTR width_sort_buffer$[rsp]
	call	?resize@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z ; ImVector<ImGuiTabBarSortItem>::resize

; 6601 : 
; 6602 : 	// Compute ideal widths
; 6603 : 	float width_total_contents = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR width_total_contents$[rsp], xmm0

; 6604 : 	ImGuiTabItem* most_recently_selected_tab = NULL;

	mov	QWORD PTR most_recently_selected_tab$[rsp], 0

; 6605 : 	bool found_selected_tab_id = false;

	mov	BYTE PTR found_selected_tab_id$[rsp], 0

; 6606 : 	for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	mov	DWORD PTR tab_n$2[rsp], 0
	jmp	SHORT $LN7@TabBarLayo
$LN5@TabBarLayo:
	mov	eax, DWORD PTR tab_n$2[rsp]
	inc	eax
	mov	DWORD PTR tab_n$2[rsp], eax
$LN7@TabBarLayo:
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR tab_n$2[rsp], eax
	jge	$LN6@TabBarLayo

; 6607 : 	{
; 6608 : 		ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv199[rsp], rax
	mov	edx, DWORD PTR tab_n$2[rsp]
	mov	rcx, QWORD PTR tv199[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	mov	QWORD PTR tab$8[rsp], rax

; 6609 : 		IM_ASSERT(tab->LastFrameVisible >= tab_bar->PrevFrameVisible);
; 6610 : 
; 6611 : 		if (most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected)

	cmp	QWORD PTR most_recently_selected_tab$[rsp], 0
	je	SHORT $LN36@TabBarLayo
	mov	rax, QWORD PTR most_recently_selected_tab$[rsp]
	mov	rcx, QWORD PTR tab$8[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jge	SHORT $LN35@TabBarLayo
$LN36@TabBarLayo:

; 6612 : 			most_recently_selected_tab = tab;

	mov	rax, QWORD PTR tab$8[rsp]
	mov	QWORD PTR most_recently_selected_tab$[rsp], rax
$LN35@TabBarLayo:

; 6613 : 		if (tab->ID == tab_bar->SelectedTabId)

	mov	rax, QWORD PTR tab$8[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN37@TabBarLayo

; 6614 : 			found_selected_tab_id = true;

	mov	BYTE PTR found_selected_tab_id$[rsp], 1
$LN37@TabBarLayo:

; 6615 : 
; 6616 : 		// Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.
; 6617 : 		// Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,
; 6618 : 		// and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.
; 6619 : 		const char* tab_name = tab_bar->GetTabName(tab);

	mov	rdx, QWORD PTR tab$8[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?GetTabName@ImGuiTabBar@@QEBAPEBDPEBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabName
	mov	QWORD PTR tab_name$21[rsp], rax

; 6620 : 		tab->WidthContents = TabItemCalcSize(tab_name, (tab->Flags & ImGuiTabItemFlags_NoCloseButton) ? false : true).x;

	mov	rax, QWORD PTR tab$8[rsp]
	mov	eax, DWORD PTR [rax+12]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	je	SHORT $LN53@TabBarLayo
	mov	BYTE PTR tv215[rsp], 0
	jmp	SHORT $LN54@TabBarLayo
$LN53@TabBarLayo:
	mov	BYTE PTR tv215[rsp], 1
$LN54@TabBarLayo:
	movzx	r8d, BYTE PTR tv215[rsp]
	mov	rdx, QWORD PTR tab_name$21[rsp]
	lea	rcx, QWORD PTR $T22[rsp]
	call	?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z ; ImGui::TabItemCalcSize
	mov	rcx, QWORD PTR tab$8[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rcx+28], xmm0

; 6621 : 
; 6622 : 		width_total_contents += (tab_n > 0 ? g.Style.ItemInnerSpacing.x : 0.0f) + tab->WidthContents;

	cmp	DWORD PTR tab_n$2[rsp], 0
	jle	SHORT $LN55@TabBarLayo
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5548]
	movss	DWORD PTR tv224[rsp], xmm0
	jmp	SHORT $LN56@TabBarLayo
$LN55@TabBarLayo:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv224[rsp], xmm0
$LN56@TabBarLayo:
	mov	rax, QWORD PTR tab$8[rsp]
	movss	xmm0, DWORD PTR tv224[rsp]
	addss	xmm0, DWORD PTR [rax+28]
	movss	xmm1, DWORD PTR width_total_contents$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR width_total_contents$[rsp], xmm0

; 6623 : 
; 6624 : 		// Store data so we can build an array sorted by width if we need to shrink tabs down
; 6625 : 		width_sort_buffer[tab_n].Index = tab_n;

	mov	edx, DWORD PTR tab_n$2[rsp]
	mov	rcx, QWORD PTR width_sort_buffer$[rsp]
	call	??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z ; ImVector<ImGuiTabBarSortItem>::operator[]
	mov	ecx, DWORD PTR tab_n$2[rsp]
	mov	DWORD PTR [rax], ecx

; 6626 : 		width_sort_buffer[tab_n].Width = tab->WidthContents;

	mov	rax, QWORD PTR tab$8[rsp]
	movss	xmm0, DWORD PTR [rax+28]
	movss	DWORD PTR tv238[rsp], xmm0
	mov	edx, DWORD PTR tab_n$2[rsp]
	mov	rcx, QWORD PTR width_sort_buffer$[rsp]
	call	??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z ; ImVector<ImGuiTabBarSortItem>::operator[]
	movss	xmm0, DWORD PTR tv238[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 6627 : 	}

	jmp	$LN5@TabBarLayo
$LN6@TabBarLayo:

; 6628 : 
; 6629 : 	// Compute width
; 6630 : 	const float width_avail = tab_bar->BarRect.GetWidth();

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 36					; 00000024H
	mov	rcx, rax
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	DWORD PTR width_avail$[rsp], xmm0

; 6631 : 	float width_excess = (width_avail < width_total_contents) ? (width_total_contents - width_avail) : 0.0f;

	movss	xmm0, DWORD PTR width_total_contents$[rsp]
	comiss	xmm0, DWORD PTR width_avail$[rsp]
	jbe	SHORT $LN57@TabBarLayo
	movss	xmm0, DWORD PTR width_total_contents$[rsp]
	subss	xmm0, DWORD PTR width_avail$[rsp]
	movss	DWORD PTR tv244[rsp], xmm0
	jmp	SHORT $LN58@TabBarLayo
$LN57@TabBarLayo:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv244[rsp], xmm0
$LN58@TabBarLayo:
	movss	xmm0, DWORD PTR tv244[rsp]
	movss	DWORD PTR width_excess$[rsp], xmm0

; 6632 : 	if (width_excess > 0.0f && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyResizeDown))

	movss	xmm0, DWORD PTR width_excess$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN38@TabBarLayo
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	$LN38@TabBarLayo

; 6633 : 	{
; 6634 : 		// If we don't have enough room, resize down the largest tabs first
; 6635 : 		if (tab_bar->Tabs.Size > 1)

	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax+16], 1
	jle	SHORT $LN40@TabBarLayo

; 6636 : 			ImQsort(width_sort_buffer.Data, (size_t)width_sort_buffer.Size, sizeof(ImGuiTabBarSortItem), TabBarSortItemComparer);

	mov	rax, QWORD PTR width_sort_buffer$[rsp]
	movsxd	rax, DWORD PTR [rax]
	lea	r9, OFFSET FLAT:?TabBarSortItemComparer@@YAHPEBX0@Z ; TabBarSortItemComparer
	mov	r8d, 8
	mov	rdx, rax
	mov	rax, QWORD PTR width_sort_buffer$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	qsort
	npad	1
$LN40@TabBarLayo:

; 6637 : 		int tab_count_same_width = 1;

	mov	DWORD PTR tab_count_same_width$1[rsp], 1
$LN8@TabBarLayo:

; 6638 : 		while (width_excess > 0.0f && tab_count_same_width < tab_bar->Tabs.Size)

	movss	xmm0, DWORD PTR width_excess$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN9@TabBarLayo
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR tab_count_same_width$1[rsp], eax
	jge	$LN9@TabBarLayo
$LN10@TabBarLayo:

; 6639 : 		{
; 6640 : 			while (tab_count_same_width < tab_bar->Tabs.Size && width_sort_buffer[0].Width == width_sort_buffer[tab_count_same_width].Width)

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR tab_count_same_width$1[rsp], eax
	jge	SHORT $LN11@TabBarLayo
	xor	edx, edx
	mov	rcx, QWORD PTR width_sort_buffer$[rsp]
	call	??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z ; ImVector<ImGuiTabBarSortItem>::operator[]
	mov	QWORD PTR tv267[rsp], rax
	mov	edx, DWORD PTR tab_count_same_width$1[rsp]
	mov	rcx, QWORD PTR width_sort_buffer$[rsp]
	call	??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z ; ImVector<ImGuiTabBarSortItem>::operator[]
	mov	rcx, QWORD PTR tv267[rsp]
	movss	xmm0, DWORD PTR [rcx+4]
	ucomiss	xmm0, DWORD PTR [rax+4]
	jp	SHORT $LN11@TabBarLayo
	jne	SHORT $LN11@TabBarLayo

; 6641 : 				tab_count_same_width++;

	mov	eax, DWORD PTR tab_count_same_width$1[rsp]
	inc	eax
	mov	DWORD PTR tab_count_same_width$1[rsp], eax
	jmp	SHORT $LN10@TabBarLayo
$LN11@TabBarLayo:

; 6642 : 			float width_to_remove_per_tab_max = (tab_count_same_width < tab_bar->Tabs.Size) ? (width_sort_buffer[0].Width - width_sort_buffer[tab_count_same_width].Width) : (width_sort_buffer[0].Width - 1.0f);

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR tab_count_same_width$1[rsp], eax
	jge	SHORT $LN59@TabBarLayo
	xor	edx, edx
	mov	rcx, QWORD PTR width_sort_buffer$[rsp]
	call	??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z ; ImVector<ImGuiTabBarSortItem>::operator[]
	mov	QWORD PTR tv280[rsp], rax
	mov	edx, DWORD PTR tab_count_same_width$1[rsp]
	mov	rcx, QWORD PTR width_sort_buffer$[rsp]
	call	??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z ; ImVector<ImGuiTabBarSortItem>::operator[]
	mov	rcx, QWORD PTR tv280[rsp]
	movss	xmm0, DWORD PTR [rcx+4]
	subss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv293[rsp], xmm0
	jmp	SHORT $LN60@TabBarLayo
$LN59@TabBarLayo:
	xor	edx, edx
	mov	rcx, QWORD PTR width_sort_buffer$[rsp]
	call	??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z ; ImVector<ImGuiTabBarSortItem>::operator[]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv293[rsp], xmm0
$LN60@TabBarLayo:
	movss	xmm0, DWORD PTR tv293[rsp]
	movss	DWORD PTR width_to_remove_per_tab_max$14[rsp], xmm0

; 6643 : 			float width_to_remove_per_tab = ImMin(width_excess / tab_count_same_width, width_to_remove_per_tab_max);

	cvtsi2ss xmm0, DWORD PTR tab_count_same_width$1[rsp]
	movss	xmm1, DWORD PTR width_excess$[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR width_to_remove_per_tab_max$14[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR width_to_remove_per_tab$11[rsp], xmm0

; 6644 : 			for (int tab_n = 0; tab_n < tab_count_same_width; tab_n++)

	mov	DWORD PTR tab_n$5[rsp], 0
	jmp	SHORT $LN14@TabBarLayo
$LN12@TabBarLayo:
	mov	eax, DWORD PTR tab_n$5[rsp]
	inc	eax
	mov	DWORD PTR tab_n$5[rsp], eax
$LN14@TabBarLayo:
	mov	eax, DWORD PTR tab_count_same_width$1[rsp]
	cmp	DWORD PTR tab_n$5[rsp], eax
	jge	SHORT $LN13@TabBarLayo

; 6645 : 				width_sort_buffer[tab_n].Width -= width_to_remove_per_tab;

	mov	edx, DWORD PTR tab_n$5[rsp]
	mov	rcx, QWORD PTR width_sort_buffer$[rsp]
	call	??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z ; ImVector<ImGuiTabBarSortItem>::operator[]
	add	rax, 4
	mov	QWORD PTR tv305[rsp], rax
	mov	rax, QWORD PTR tv305[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR width_to_remove_per_tab$11[rsp]
	mov	rax, QWORD PTR tv305[rsp]
	movss	DWORD PTR [rax], xmm0
	jmp	SHORT $LN12@TabBarLayo
$LN13@TabBarLayo:

; 6646 : 			width_excess -= width_to_remove_per_tab * tab_count_same_width;

	cvtsi2ss xmm0, DWORD PTR tab_count_same_width$1[rsp]
	movss	xmm1, DWORD PTR width_to_remove_per_tab$11[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR width_excess$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR width_excess$[rsp], xmm0

; 6647 : 		}

	jmp	$LN8@TabBarLayo
$LN9@TabBarLayo:

; 6648 : 		for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	mov	DWORD PTR tab_n$4[rsp], 0
	jmp	SHORT $LN17@TabBarLayo
$LN15@TabBarLayo:
	mov	eax, DWORD PTR tab_n$4[rsp]
	inc	eax
	mov	DWORD PTR tab_n$4[rsp], eax
$LN17@TabBarLayo:
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR tab_n$4[rsp], eax
	jge	SHORT $LN16@TabBarLayo

; 6649 : 			tab_bar->Tabs[width_sort_buffer[tab_n].Index].Width = (float)(int)width_sort_buffer[tab_n].Width;

	mov	edx, DWORD PTR tab_n$4[rsp]
	mov	rcx, QWORD PTR width_sort_buffer$[rsp]
	call	??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z ; ImVector<ImGuiTabBarSortItem>::operator[]
	cvttss2si eax, DWORD PTR [rax+4]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR tv332[rsp], xmm0
	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv323[rsp], rax
	mov	edx, DWORD PTR tab_n$4[rsp]
	mov	rcx, QWORD PTR width_sort_buffer$[rsp]
	call	??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z ; ImVector<ImGuiTabBarSortItem>::operator[]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR tv323[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	movss	xmm0, DWORD PTR tv332[rsp]
	movss	DWORD PTR [rax+24], xmm0
	jmp	SHORT $LN15@TabBarLayo
$LN16@TabBarLayo:

; 6650 : 	}

	jmp	$LN39@TabBarLayo
$LN38@TabBarLayo:

; 6651 : 	else
; 6652 : 	{
; 6653 : 		const float tab_max_width = TabBarCalcMaxTabWidth();

	call	?TabBarCalcMaxTabWidth@ImGui@@YAMXZ	; ImGui::TabBarCalcMaxTabWidth
	movss	DWORD PTR tab_max_width$15[rsp], xmm0

; 6654 : 		for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	mov	DWORD PTR tab_n$6[rsp], 0
	jmp	SHORT $LN20@TabBarLayo
$LN18@TabBarLayo:
	mov	eax, DWORD PTR tab_n$6[rsp]
	inc	eax
	mov	DWORD PTR tab_n$6[rsp], eax
$LN20@TabBarLayo:
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR tab_n$6[rsp], eax
	jge	SHORT $LN19@TabBarLayo

; 6655 : 		{
; 6656 : 			ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv343[rsp], rax
	mov	edx, DWORD PTR tab_n$6[rsp]
	mov	rcx, QWORD PTR tv343[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	mov	QWORD PTR tab$18[rsp], rax

; 6657 : 			tab->Width = ImMin(tab->WidthContents, tab_max_width);

	movss	xmm1, DWORD PTR tab_max_width$15[rsp]
	mov	rax, QWORD PTR tab$18[rsp]
	movss	xmm0, DWORD PTR [rax+28]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	mov	rax, QWORD PTR tab$18[rsp]
	movss	DWORD PTR [rax+24], xmm0

; 6658 : 		}

	jmp	SHORT $LN18@TabBarLayo
$LN19@TabBarLayo:
$LN39@TabBarLayo:

; 6659 : 	}
; 6660 : 
; 6661 : 	// Layout all active tabs
; 6662 : 	float offset_x = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR offset_x$[rsp], xmm0

; 6663 : 	for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	mov	DWORD PTR tab_n$7[rsp], 0
	jmp	SHORT $LN23@TabBarLayo
$LN21@TabBarLayo:
	mov	eax, DWORD PTR tab_n$7[rsp]
	inc	eax
	mov	DWORD PTR tab_n$7[rsp], eax
$LN23@TabBarLayo:
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR tab_n$7[rsp], eax
	jge	$LN22@TabBarLayo

; 6664 : 	{
; 6665 : 		ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv390[rsp], rax
	mov	edx, DWORD PTR tab_n$7[rsp]
	mov	rcx, QWORD PTR tv390[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	mov	QWORD PTR tab$13[rsp], rax

; 6666 : 		tab->Offset = offset_x;

	mov	rax, QWORD PTR tab$13[rsp]
	movss	xmm0, DWORD PTR offset_x$[rsp]
	movss	DWORD PTR [rax+20], xmm0

; 6667 : 		if (scroll_track_selected_tab_id == 0 && g.NavJustMovedToId == tab->ID)

	cmp	DWORD PTR scroll_track_selected_tab_id$[rsp], 0
	jne	SHORT $LN41@TabBarLayo
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR tab$13[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+7064], ecx
	jne	SHORT $LN41@TabBarLayo

; 6668 : 			scroll_track_selected_tab_id = tab->ID;

	mov	rax, QWORD PTR tab$13[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR scroll_track_selected_tab_id$[rsp], eax
$LN41@TabBarLayo:

; 6669 : 		offset_x += tab->Width + g.Style.ItemInnerSpacing.x;

	mov	rax, QWORD PTR tab$13[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	addss	xmm0, DWORD PTR [rcx+5548]
	movss	xmm1, DWORD PTR offset_x$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR offset_x$[rsp], xmm0

; 6670 : 	}

	jmp	$LN21@TabBarLayo
$LN22@TabBarLayo:

; 6671 : 	tab_bar->OffsetMax = ImMax(offset_x - g.Style.ItemInnerSpacing.x, 0.0f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR offset_x$[rsp]
	subss	xmm0, DWORD PTR [rax+5548]
	xorps	xmm1, xmm1
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	DWORD PTR [rax+60], xmm0

; 6672 : 	tab_bar->OffsetNextTab = 0.0f;

	mov	rax, QWORD PTR tab_bar$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+64], xmm0

; 6673 : 
; 6674 : 	// Horizontal scrolling buttons
; 6675 : 	const bool scrolling_buttons = (tab_bar->OffsetMax > tab_bar->BarRect.GetWidth() && tab_bar->Tabs.Size > 1) && !(tab_bar->Flags & ImGuiTabBarFlags_NoTabListScrollingButtons) && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll);

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 36					; 00000024H
	mov	rcx, rax
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm1, DWORD PTR [rax+60]
	comiss	xmm1, xmm0
	jbe	SHORT $LN61@TabBarLayo
	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax+16], 1
	jle	SHORT $LN61@TabBarLayo
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 16
	test	eax, eax
	jne	SHORT $LN61@TabBarLayo
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN61@TabBarLayo
	mov	BYTE PTR tv426[rsp], 1
	jmp	SHORT $LN62@TabBarLayo
$LN61@TabBarLayo:
	mov	BYTE PTR tv426[rsp], 0
$LN62@TabBarLayo:
	movzx	eax, BYTE PTR tv426[rsp]
	mov	BYTE PTR scrolling_buttons$[rsp], al

; 6676 : 	if (scrolling_buttons)

	movzx	eax, BYTE PTR scrolling_buttons$[rsp]
	test	eax, eax
	je	SHORT $LN42@TabBarLayo

; 6677 : 		if (ImGuiTabItem* tab_to_select = TabBarScrollingButtons(tab_bar)) // NB: Will alter BarRect.Max.x!

	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z ; ImGui::TabBarScrollingButtons
	mov	QWORD PTR tab_to_select$19[rsp], rax
	cmp	QWORD PTR tab_to_select$19[rsp], 0
	je	SHORT $LN43@TabBarLayo

; 6678 : 			scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tab_to_select$19[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR scroll_track_selected_tab_id$[rsp], eax
$LN43@TabBarLayo:
$LN42@TabBarLayo:

; 6679 : 
; 6680 : 	// If we have lost the selected tab, select the next most recently active one
; 6681 : 	if (found_selected_tab_id == false)

	movzx	eax, BYTE PTR found_selected_tab_id$[rsp]
	test	eax, eax
	jne	SHORT $LN44@TabBarLayo

; 6682 : 		tab_bar->SelectedTabId = 0;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	DWORD PTR [rax], 0
$LN44@TabBarLayo:

; 6683 : 	if (tab_bar->SelectedTabId == 0 && tab_bar->NextSelectedTabId == 0 && most_recently_selected_tab != NULL)

	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN45@TabBarLayo
	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN45@TabBarLayo
	cmp	QWORD PTR most_recently_selected_tab$[rsp], 0
	je	SHORT $LN45@TabBarLayo

; 6684 : 		scroll_track_selected_tab_id = tab_bar->SelectedTabId = most_recently_selected_tab->ID;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR most_recently_selected_tab$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR scroll_track_selected_tab_id$[rsp], eax
$LN45@TabBarLayo:

; 6685 : 
; 6686 : 	// Lock in visible tab
; 6687 : 	tab_bar->VisibleTabId = tab_bar->SelectedTabId;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+4], ecx

; 6688 : 	tab_bar->VisibleTabWasSubmitted = false;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	BYTE PTR [rax+120], 0

; 6689 : 
; 6690 : 	// Update scrolling
; 6691 : 	if (scroll_track_selected_tab_id)

	cmp	DWORD PTR scroll_track_selected_tab_id$[rsp], 0
	je	SHORT $LN46@TabBarLayo

; 6692 : 		if (ImGuiTabItem* scroll_track_selected_tab = TabBarFindTabByID(tab_bar, scroll_track_selected_tab_id))

	mov	edx, DWORD PTR scroll_track_selected_tab_id$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
	mov	QWORD PTR scroll_track_selected_tab$20[rsp], rax
	cmp	QWORD PTR scroll_track_selected_tab$20[rsp], 0
	je	SHORT $LN47@TabBarLayo

; 6693 : 			TabBarScrollToTab(tab_bar, scroll_track_selected_tab);

	mov	rdx, QWORD PTR scroll_track_selected_tab$20[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarScrollToTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z ; ImGui::TabBarScrollToTab
	npad	1
$LN47@TabBarLayo:
$LN46@TabBarLayo:

; 6694 : 	tab_bar->ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar->ScrollingAnim);

	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm1, DWORD PTR [rax+68]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarScrollClamp@ImGui@@YAMPEAUImGuiTabBar@@M@Z ; ImGui::TabBarScrollClamp
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	DWORD PTR [rax+68], xmm0

; 6695 : 	tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget);

	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm1, DWORD PTR [rax+80]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarScrollClamp@ImGui@@YAMPEAUImGuiTabBar@@M@Z ; ImGui::TabBarScrollClamp
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	DWORD PTR [rax+80], xmm0

; 6696 : 	const float scrolling_speed = (tab_bar->PrevFrameVisible + 1 < g.FrameCount) ? FLT_MAX : (g.IO.DeltaTime * g.FontSize * 70.0f);

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+12]
	inc	eax
	mov	rcx, QWORD PTR g$[rsp]
	cmp	eax, DWORD PTR [rcx+6552]
	jge	SHORT $LN63@TabBarLayo
	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR tv475[rsp], xmm0
	jmp	SHORT $LN64@TabBarLayo
$LN63@TabBarLayo:
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	mulss	xmm0, DWORD PTR [rcx+6408]
	mulss	xmm0, DWORD PTR __real@428c0000
	movss	DWORD PTR tv475[rsp], xmm0
$LN64@TabBarLayo:
	movss	xmm0, DWORD PTR tv475[rsp]
	movss	DWORD PTR scrolling_speed$[rsp], xmm0

; 6697 : 	if (tab_bar->ScrollingAnim != tab_bar->ScrollingTarget)

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rax+68]
	ucomiss	xmm0, DWORD PTR [rcx+80]
	jp	SHORT $LN65@TabBarLayo
	je	SHORT $LN48@TabBarLayo
$LN65@TabBarLayo:

; 6698 : 		tab_bar->ScrollingAnim = ImLinearSweep(tab_bar->ScrollingAnim, tab_bar->ScrollingTarget, scrolling_speed);

	movss	xmm2, DWORD PTR scrolling_speed$[rsp]
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm1, DWORD PTR [rax+80]
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rax+68]
	call	?ImLinearSweep@@YAMMMM@Z		; ImLinearSweep
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	DWORD PTR [rax+68], xmm0
$LN48@TabBarLayo:

; 6699 : 
; 6700 : 	// Clear name buffers
; 6701 : 	if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	jne	SHORT $LN49@TabBarLayo

; 6702 : 		tab_bar->TabsNames.Buf.resize(0);

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv494[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv494[rsp]
	call	?resize@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::resize
	npad	1
$LN49@TabBarLayo:

; 6703 : }

	add	rsp, 440				; 000001b8H
	pop	rdi
	pop	rsi
	ret	0
?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z ENDP	; ImGui::TabBarLayout
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
v$ = 0
plot_data$ = 8
data$ = 32
idx$ = 40
?Plot_ArrayGetter@@YAMPEAXH@Z PROC			; Plot_ArrayGetter

; 5955 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 5956 : 	ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;

	mov	rax, QWORD PTR data$[rsp]
	mov	QWORD PTR plot_data$[rsp], rax

; 5957 : 	const float v = *(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);

	movsxd	rax, DWORD PTR idx$[rsp]
	mov	rcx, QWORD PTR plot_data$[rsp]
	movsxd	rcx, DWORD PTR [rcx+8]
	imul	rax, rcx
	mov	rcx, QWORD PTR plot_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movss	xmm0, DWORD PTR [rax+rcx]
	movss	DWORD PTR v$[rsp], xmm0

; 5958 : 	return v;

	movss	xmm0, DWORD PTR v$[rsp]

; 5959 : }

	add	rsp, 24
	ret	0
?Plot_ArrayGetter@@YAMPEAXH@Z ENDP			; Plot_ArrayGetter
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??0ImGuiPlotArrayGetterData@@QEAA@PEBMH@Z
_TEXT	SEGMENT
this$ = 8
values$ = 16
stride$ = 24
??0ImGuiPlotArrayGetterData@@QEAA@PEBMH@Z PROC		; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData, COMDAT

; 5951 : 	ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR values$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR stride$[rsp]
	mov	DWORD PTR [rax+8], ecx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImGuiPlotArrayGetterData@@QEAA@PEBMH@Z ENDP		; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
$T7 = 96
$T8 = 104
$T9 = 112
$T10 = 120
draw_list$ = 144
pos$ = 152
half_sz$ = 160
bar_w$ = 168
?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1M@Z PROC ; RenderArrowsForVerticalBar

; 4549 : {

	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 4550 : 	ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32_BLACK);

	movss	xmm0, DWORD PTR half_sz$[rsp+4]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR half_sz$[rsp]
	addss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T1[rsp], rax
	movss	xmm0, DWORD PTR pos$[rsp]
	addss	xmm0, DWORD PTR half_sz$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR pos$[rsp+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T2[rsp], rax
	mov	DWORD PTR [rsp+32], -16777216		; ff000000H
	mov	r9d, 1
	mov	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt
	npad	1

; 4551 : 	ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x, pos.y), half_sz, ImGuiDir_Right, IM_COL32_WHITE);

	movss	xmm0, DWORD PTR pos$[rsp]
	addss	xmm0, DWORD PTR half_sz$[rsp]
	movss	xmm2, DWORD PTR pos$[rsp+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], -1			; ffffffffH
	mov	r9d, 1
	mov	r8, QWORD PTR half_sz$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt
	npad	1

; 4552 : 	ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left, IM_COL32_BLACK);

	movss	xmm0, DWORD PTR half_sz$[rsp+4]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR half_sz$[rsp]
	addss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T3[rsp], rax
	movss	xmm0, DWORD PTR pos$[rsp]
	addss	xmm0, DWORD PTR bar_w$[rsp]
	subss	xmm0, DWORD PTR half_sz$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR pos$[rsp+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T4[rsp], rax
	mov	DWORD PTR [rsp+32], -16777216		; ff000000H
	xor	r9d, r9d
	mov	r8, QWORD PTR $T3[rsp]
	mov	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt
	npad	1

; 4553 : 	ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x, pos.y), half_sz, ImGuiDir_Left, IM_COL32_WHITE);

	movss	xmm0, DWORD PTR pos$[rsp]
	addss	xmm0, DWORD PTR bar_w$[rsp]
	subss	xmm0, DWORD PTR half_sz$[rsp]
	movss	xmm2, DWORD PTR pos$[rsp+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], -1			; ffffffffH
	xor	r9d, r9d
	mov	r8, QWORD PTR half_sz$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt
	npad	1

; 4554 : }

	add	rsp, 136				; 00000088H
	ret	0
?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1M@Z ENDP ; RenderArrowsForVerticalBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@H@@YAHHHM@Z PROC				; ImLerp<int>

; 230  : template<typename T> static inline T ImLerp(T a, T b, float t) { return (T)(a + (b - a) * t); }

	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	cvtsi2ss xmm0, DWORD PTR a$[rsp]
	mov	eax, DWORD PTR a$[rsp]
	mov	ecx, DWORD PTR b$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR t$[rsp]
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	ret	0
??$ImLerp@H@@YAHHHM@Z ENDP				; ImLerp<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
t$ = 32
b$ = 36
g$ = 40
r$ = 44
col_a$ = 64
col_b$ = 72
?ImAlphaBlendColor@@YAIII@Z PROC			; ImAlphaBlendColor

; 4502 : {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 4503 : 	float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;

	mov	eax, DWORD PTR col_b$[rsp]
	shr	eax, 24
	and	eax, 255				; 000000ffH
	mov	eax, eax
	cvtsi2ss xmm0, rax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR t$[rsp], xmm0

; 4504 : 	int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);

	mov	eax, DWORD PTR col_b$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR col_a$[rsp]
	and	ecx, 255				; 000000ffH
	movss	xmm2, DWORD PTR t$[rsp]
	mov	edx, eax
	call	??$ImLerp@H@@YAHHHM@Z			; ImLerp<int>
	mov	DWORD PTR r$[rsp], eax

; 4505 : 	int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);

	mov	eax, DWORD PTR col_b$[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR col_a$[rsp]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	movss	xmm2, DWORD PTR t$[rsp]
	mov	edx, eax
	call	??$ImLerp@H@@YAHHHM@Z			; ImLerp<int>
	mov	DWORD PTR g$[rsp], eax

; 4506 : 	int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);

	mov	eax, DWORD PTR col_b$[rsp]
	shr	eax, 16
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR col_a$[rsp]
	shr	ecx, 16
	and	ecx, 255				; 000000ffH
	movss	xmm2, DWORD PTR t$[rsp]
	mov	edx, eax
	call	??$ImLerp@H@@YAHHHM@Z			; ImLerp<int>
	mov	DWORD PTR b$[rsp], eax

; 4507 : 	return IM_COL32(r, g, b, 0xFF);

	mov	eax, DWORD PTR b$[rsp]
	shl	eax, 16
	or	eax, -16777216				; ff000000H
	mov	ecx, DWORD PTR g$[rsp]
	shl	ecx, 8
	or	eax, ecx
	or	eax, DWORD PTR r$[rsp]

; 4508 : }

	add	rsp, 56					; 00000038H
	ret	0
?ImAlphaBlendColor@@YAIII@Z ENDP			; ImAlphaBlendColor
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Ffmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ
text$yd	SEGMENT
??__Ffmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ PROC ; `ImGui::ColorEdit4'::`19'::`dynamic atexit destructor for 'fmt_table_float'', COMDAT
	sub	rsp, 40					; 00000028H
	mov	eax, 128				; 00000080H
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	add	rcx, rax
	mov	rax, rcx
	lea	r9, OFFSET FLAT:??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	r8d, 12
	mov	edx, 32					; 00000020H
	mov	rcx, rax
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ffmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ ENDP ; `ImGui::ColorEdit4'::`19'::`dynamic atexit destructor for 'fmt_table_float''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Ffmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ
text$yd	SEGMENT
??__Ffmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ PROC ; `ImGui::ColorEdit4'::`19'::`dynamic atexit destructor for 'fmt_table_int'', COMDAT
	sub	rsp, 40					; 00000028H
	mov	eax, 128				; 00000080H
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	add	rcx, rax
	mov	rax, rcx
	lea	r9, OFFSET FLAT:??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	r8d, 12
	mov	edx, 32					; 00000020H
	mov	rcx, rax
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ffmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ ENDP ; `ImGui::ColorEdit4'::`19'::`dynamic atexit destructor for 'fmt_table_int''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ
text$yd	SEGMENT
??__Fids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ PROC ; `ImGui::ColorEdit4'::`19'::`dynamic atexit destructor for 'ids'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	r9, OFFSET FLAT:??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	r8d, 4
	mov	edx, 32					; 00000020H
	lea	rcx, OFFSET FLAT:?ids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ ENDP ; `ImGui::ColorEdit4'::`19'::`dynamic atexit destructor for 'ids''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
str$ = 48
state$ = 56
ctext$ = 64
len$ = 72
?stb_textedit_paste@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z PROC ; ImGuiStb::stb_textedit_paste

; 1373 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1374 : 	return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE*)ctext, len);

	mov	r9d, DWORD PTR len$[rsp]
	mov	r8, QWORD PTR ctext$[rsp]
	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_paste_internal@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z ; ImGuiStb::stb_textedit_paste_internal

; 1375 : }

	add	rsp, 40					; 00000028H
	ret	0
?stb_textedit_paste@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z ENDP ; ImGuiStb::stb_textedit_paste
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
state$ = 48
is_single_line$ = 56
?stb_textedit_initialize_state@ImGuiStb@@YAXPEAUSTB_TexteditState@1@H@Z PROC ; ImGuiStb::stb_textedit_initialize_state

; 1363 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1364 : 	stb_textedit_clear_state(state, is_single_line);

	mov	edx, DWORD PTR is_single_line$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_clear_state@ImGuiStb@@YAXPEAUSTB_TexteditState@1@H@Z ; ImGuiStb::stb_textedit_clear_state
	npad	1

; 1365 : }

	add	rsp, 40					; 00000028H
	ret	0
?stb_textedit_initialize_state@ImGuiStb@@YAXPEAUSTB_TexteditState@1@H@Z ENDP ; ImGuiStb::stb_textedit_initialize_state
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
state$ = 8
is_single_line$ = 16
?stb_textedit_clear_state@ImGuiStb@@YAXPEAUSTB_TexteditState@1@H@Z PROC ; ImGuiStb::stb_textedit_clear_state

; 1346 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 1347 : 	state->undostate.undo_point = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	WORD PTR [rcx+3606], ax

; 1348 : 	state->undostate.undo_char_point = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax+3612], 0

; 1349 : 	state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;

	mov	eax, 99					; 00000063H
	mov	rcx, QWORD PTR state$[rsp]
	mov	WORD PTR [rcx+3608], ax

; 1350 : 	state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;

	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax+3616], 999		; 000003e7H

; 1351 : 	state->select_end = state->select_start = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax+8], 0

; 1352 : 	state->cursor = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax], 0

; 1353 : 	state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 1354 : 	state->preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+20], xmm0

; 1355 : 	state->cursor_at_end_of_line = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+13], 0

; 1356 : 	state->initialized = 1;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+14], 1

; 1357 : 	state->single_line = (unsigned char)is_single_line;

	mov	rax, QWORD PTR state$[rsp]
	movzx	ecx, BYTE PTR is_single_line$[rsp]
	mov	BYTE PTR [rax+16], cl

; 1358 : 	state->insert_mode = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+12], 0

; 1359 : }

	ret	0
?stb_textedit_clear_state@ImGuiStb@@YAXPEAUSTB_TexteditState@1@H@Z ENDP ; ImGuiStb::stb_textedit_clear_state
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
r$ = 32
state$ = 64
pos$ = 72
insert_len$ = 80
delete_len$ = 88
?stb_text_createundo@ImGuiStb@@YAPEAGPEAUStbUndoState@1@HHH@Z PROC ; ImGuiStb::stb_text_createundo

; 1178 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1179 : 	StbUndoRecord* r = stb_text_create_undo_record(state, insert_len);

	mov	edx, DWORD PTR insert_len$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_text_create_undo_record@ImGuiStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z ; ImGuiStb::stb_text_create_undo_record
	mov	QWORD PTR r$[rsp], rax

; 1180 : 	if (r == NULL)

	cmp	QWORD PTR r$[rsp], 0
	jne	SHORT $LN2@stb_text_c

; 1181 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@stb_text_c
$LN2@stb_text_c:

; 1182 : 
; 1183 : 	r->where = pos;

	mov	rax, QWORD PTR r$[rsp]
	mov	ecx, DWORD PTR pos$[rsp]
	mov	DWORD PTR [rax], ecx

; 1184 : 	r->insert_length = (STB_TEXTEDIT_POSITIONTYPE)insert_len;

	mov	rax, QWORD PTR r$[rsp]
	mov	ecx, DWORD PTR insert_len$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 1185 : 	r->delete_length = (STB_TEXTEDIT_POSITIONTYPE)delete_len;

	mov	rax, QWORD PTR r$[rsp]
	mov	ecx, DWORD PTR delete_len$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 1186 : 
; 1187 : 	if (insert_len == 0) {

	cmp	DWORD PTR insert_len$[rsp], 0
	jne	SHORT $LN3@stb_text_c

; 1188 : 		r->char_storage = -1;

	mov	rax, QWORD PTR r$[rsp]
	mov	DWORD PTR [rax+12], -1

; 1189 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@stb_text_c

; 1190 : 	}

	jmp	SHORT $LN4@stb_text_c
$LN3@stb_text_c:

; 1191 : 	else {
; 1192 : 		r->char_storage = state->undo_char_point;

	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+3588]
	mov	DWORD PTR [rax+12], ecx

; 1193 : 		state->undo_char_point += insert_len;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax+3588]
	add	eax, DWORD PTR insert_len$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx+3588], eax

; 1194 : 		return &state->undo_char[r->char_storage];

	mov	rax, QWORD PTR r$[rsp]
	movsxd	rax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR state$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2+1584]
$LN4@stb_text_c:
$LN1@stb_text_c:

; 1195 : 	}
; 1196 : }

	add	rsp, 56					; 00000038H
	ret	0
?stb_text_createundo@ImGuiStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ENDP ; ImGuiStb::stb_text_createundo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
tv84 = 32
state$ = 64
numchars$ = 72
?stb_text_create_undo_record@ImGuiStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z PROC ; ImGuiStb::stb_text_create_undo_record

; 1154 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1155 : 	// any time we create a new undo record, we discard redo
; 1156 : 	stb_textedit_flush_redo(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_flush_redo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z ; ImGuiStb::stb_textedit_flush_redo
	npad	1

; 1157 : 
; 1158 : 	// if we have no free records, we have to make room, by sliding the
; 1159 : 	// existing records down
; 1160 : 	if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	mov	rax, QWORD PTR state$[rsp]
	movsx	eax, WORD PTR [rax+3582]
	cmp	eax, 99					; 00000063H
	jne	SHORT $LN4@stb_text_c

; 1161 : 		stb_textedit_discard_undo(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_discard_undo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z ; ImGuiStb::stb_textedit_discard_undo
	npad	1
$LN4@stb_text_c:

; 1162 : 
; 1163 : 	// if the characters to store won't possibly fit in the buffer, we can't undo
; 1164 : 	if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {

	cmp	DWORD PTR numchars$[rsp], 999		; 000003e7H
	jle	SHORT $LN5@stb_text_c

; 1165 : 		state->undo_point = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	WORD PTR [rcx+3582], ax

; 1166 : 		state->undo_char_point = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax+3588], 0

; 1167 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@stb_text_c
$LN5@stb_text_c:
$LN2@stb_text_c:

; 1168 : 	}
; 1169 : 
; 1170 : 	// if we don't have enough free characters in the buffer, we have to make room
; 1171 : 	while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax+3588]
	add	eax, DWORD PTR numchars$[rsp]
	cmp	eax, 999				; 000003e7H
	jle	SHORT $LN3@stb_text_c

; 1172 : 		stb_textedit_discard_undo(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_discard_undo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z ; ImGuiStb::stb_textedit_discard_undo
	npad	1
	jmp	SHORT $LN2@stb_text_c
$LN3@stb_text_c:

; 1173 : 
; 1174 : 	return &state->undo_rec[state->undo_point++];

	mov	rax, QWORD PTR state$[rsp]
	movsx	rax, WORD PTR [rax+3582]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR state$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, WORD PTR [rax+3582]
	inc	ax
	mov	rcx, QWORD PTR state$[rsp]
	mov	WORD PTR [rcx+3582], ax
	mov	rax, QWORD PTR tv84[rsp]
$LN1@stb_text_c:

; 1175 : }

	add	rsp, 56					; 00000038H
	ret	0
?stb_text_create_undo_record@ImGuiStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z ENDP ; ImGuiStb::stb_text_create_undo_record
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
i$1 = 32
k$ = 36
n$2 = 40
tv132 = 48
move_size$3 = 56
buf_begin$4 = 64
buf_end$5 = 72
state$ = 96
?stb_textedit_discard_redo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z PROC ; ImGuiStb::stb_textedit_discard_redo

; 1124 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1125 : 	int k = STB_TEXTEDIT_UNDOSTATECOUNT - 1;

	mov	DWORD PTR k$[rsp], 98			; 00000062H

; 1126 : 
; 1127 : 	if (state->redo_point <= k) {

	mov	rax, QWORD PTR state$[rsp]
	movsx	eax, WORD PTR [rax+3584]
	cmp	eax, DWORD PTR k$[rsp]
	jg	$LN5@stb_texted

; 1128 : 		// if the k'th undo state has characters, clean those up
; 1129 : 		if (state->undo_rec[k].char_storage >= 0) {

	movsxd	rax, DWORD PTR k$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR state$[rsp]
	cmp	DWORD PTR [rcx+rax+12], 0
	jl	$LN6@stb_texted

; 1130 : 			int n = state->undo_rec[k].insert_length, i;

	movsxd	rax, DWORD PTR k$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rcx+rax+4]
	mov	DWORD PTR n$2[rsp], eax

; 1131 : 			// move the remaining redo character data to the end of the buffer
; 1132 : 			state->redo_char_point += n;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax+3592]
	add	eax, DWORD PTR n$2[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx+3592], eax

; 1133 : 			STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point - n, (size_t)((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point) * sizeof(STB_TEXTEDIT_CHARTYPE)));

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, 999				; 000003e7H
	sub	ecx, DWORD PTR [rax+3592]
	mov	eax, ecx
	cdqe
	shl	rax, 1
	mov	rcx, QWORD PTR state$[rsp]
	movsxd	rcx, DWORD PTR [rcx+3592]
	mov	rdx, QWORD PTR state$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx*2+1584]
	movsxd	rdx, DWORD PTR n$2[rsp]
	shl	rdx, 1
	sub	rcx, rdx
	mov	rdx, QWORD PTR state$[rsp]
	movsxd	rdx, DWORD PTR [rdx+3592]
	mov	r8, QWORD PTR state$[rsp]
	lea	rdx, QWORD PTR [r8+rdx*2+1584]
	mov	QWORD PTR tv132[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv132[rsp]
	mov	rcx, rax
	call	memmove
	npad	1

; 1134 : 			// adjust the position of all the other records to account for above memmove
; 1135 : 			for (i = state->redo_point; i < k; ++i)

	mov	rax, QWORD PTR state$[rsp]
	movsx	eax, WORD PTR [rax+3584]
	mov	DWORD PTR i$1[rsp], eax
	jmp	SHORT $LN4@stb_texted
$LN2@stb_texted:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@stb_texted:
	mov	eax, DWORD PTR k$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@stb_texted

; 1136 : 				if (state->undo_rec[i].char_storage >= 0)

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR state$[rsp]
	cmp	DWORD PTR [rcx+rax+12], 0
	jl	SHORT $LN7@stb_texted

; 1137 : 					state->undo_rec[i].char_storage += n;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rcx+rax+12]
	add	eax, DWORD PTR n$2[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rdx+rcx+12], eax
$LN7@stb_texted:
	jmp	SHORT $LN2@stb_texted
$LN3@stb_texted:
$LN6@stb_texted:

; 1138 : 		}
; 1139 : 		// now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
; 1140 : 		// {DEAR IMGUI]
; 1141 : 		size_t move_size = (size_t)((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));

	mov	rax, QWORD PTR state$[rsp]
	movsx	eax, WORD PTR [rax+3584]
	mov	ecx, 99					; 00000063H
	sub	ecx, eax
	mov	eax, ecx
	dec	eax
	cdqe
	imul	rax, rax, 16
	mov	QWORD PTR move_size$3[rsp], rax

; 1142 : 		const char* buf_begin = (char*)state->undo_rec; (void)buf_begin;

	mov	rax, QWORD PTR state$[rsp]
	mov	QWORD PTR buf_begin$4[rsp], rax

; 1143 : 		const char* buf_end = (char*)state->undo_rec + sizeof(state->undo_rec); (void)buf_end;

	mov	rax, QWORD PTR state$[rsp]
	add	rax, 1584				; 00000630H
	mov	QWORD PTR buf_end$5[rsp], rax

; 1144 : 		IM_ASSERT(((char*)(state->undo_rec + state->redo_point)) >= buf_begin);
; 1145 : 		IM_ASSERT(((char*)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);
; 1146 : 		STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point + 1, state->undo_rec + state->redo_point, move_size);

	mov	rax, QWORD PTR state$[rsp]
	movsx	rax, WORD PTR [rax+3584]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR state$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR state$[rsp]
	movsx	rcx, WORD PTR [rcx+3584]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR state$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx+16]
	mov	r8, QWORD PTR move_size$3[rsp]
	mov	rdx, rax
	call	memmove

; 1147 : 
; 1148 : 		// now move redo_point to point to the new one
; 1149 : 		++state->redo_point;

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, WORD PTR [rax+3584]
	inc	ax
	mov	rcx, QWORD PTR state$[rsp]
	mov	WORD PTR [rcx+3584], ax
$LN5@stb_texted:

; 1150 : 	}
; 1151 : }

	add	rsp, 88					; 00000058H
	ret	0
?stb_textedit_discard_redo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z ENDP ; ImGuiStb::stb_textedit_discard_redo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
i$1 = 32
n$2 = 36
tv89 = 40
tv154 = 48
state$ = 80
?stb_textedit_discard_undo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z PROC ; ImGuiStb::stb_textedit_discard_undo

; 1102 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1103 : 	if (state->undo_point > 0) {

	mov	rax, QWORD PTR state$[rsp]
	movsx	eax, WORD PTR [rax+3582]
	test	eax, eax
	jle	$LN5@stb_texted

; 1104 : 		// if the 0th undo state has characters, clean those up
; 1105 : 		if (state->undo_rec[0].char_storage >= 0) {

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR state$[rsp]
	cmp	DWORD PTR [rcx+rax+12], 0
	jl	$LN6@stb_texted

; 1106 : 			int n = state->undo_rec[0].insert_length, i;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rcx+rax+4]
	mov	DWORD PTR n$2[rsp], eax

; 1107 : 			// delete n characters from all other records
; 1108 : 			state->undo_char_point -= n;

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR n$2[rsp]
	mov	eax, DWORD PTR [rax+3588]
	sub	eax, ecx
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx+3588], eax

; 1109 : 			STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t)(state->undo_char_point * sizeof(STB_TEXTEDIT_CHARTYPE)));

	mov	rax, QWORD PTR state$[rsp]
	movsxd	rax, DWORD PTR [rax+3588]
	shl	rax, 1
	movsxd	rcx, DWORD PTR n$2[rsp]
	mov	rdx, QWORD PTR state$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx*2+1584]
	mov	rdx, QWORD PTR state$[rsp]
	add	rdx, 1584				; 00000630H
	mov	QWORD PTR tv89[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv89[rsp]
	mov	rcx, rax
	call	memmove
	npad	1

; 1110 : 			for (i = 0; i < state->undo_point; ++i)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@stb_texted
$LN2@stb_texted:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@stb_texted:
	mov	rax, QWORD PTR state$[rsp]
	movsx	eax, WORD PTR [rax+3582]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@stb_texted

; 1111 : 				if (state->undo_rec[i].char_storage >= 0)

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR state$[rsp]
	cmp	DWORD PTR [rcx+rax+12], 0
	jl	SHORT $LN7@stb_texted

; 1112 : 					state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR n$2[rsp]
	mov	eax, DWORD PTR [rcx+rax+12]
	sub	eax, edx
	movsxd	rcx, DWORD PTR i$1[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rdx+rcx+12], eax
$LN7@stb_texted:
	jmp	SHORT $LN2@stb_texted
$LN3@stb_texted:
$LN6@stb_texted:

; 1113 : 		}
; 1114 : 		--state->undo_point;

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, WORD PTR [rax+3582]
	dec	ax
	mov	rcx, QWORD PTR state$[rsp]
	mov	WORD PTR [rcx+3582], ax

; 1115 : 		STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec + 1, (size_t)(state->undo_point * sizeof(state->undo_rec[0])));

	mov	rax, QWORD PTR state$[rsp]
	movsx	rax, WORD PTR [rax+3582]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR state$[rsp]
	add	rcx, 16
	mov	rdx, QWORD PTR state$[rsp]
	mov	QWORD PTR tv154[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv154[rsp]
	mov	rcx, rax
	call	memmove
	npad	1
$LN5@stb_texted:

; 1116 : 	}
; 1117 : }

	add	rsp, 72					; 00000048H
	ret	0
?stb_textedit_discard_undo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z ENDP ; ImGuiStb::stb_textedit_discard_undo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
state$ = 8
?stb_textedit_flush_redo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z PROC ; ImGuiStb::stb_textedit_flush_redo

; 1095 : {

	mov	QWORD PTR [rsp+8], rcx

; 1096 : 	state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;

	mov	eax, 99					; 00000063H
	mov	rcx, QWORD PTR state$[rsp]
	mov	WORD PTR [rcx+3584], ax

; 1097 : 	state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;

	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax+3592], 999		; 000003e7H

; 1098 : }

	ret	0
?stb_textedit_flush_redo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z ENDP ; ImGuiStb::stb_textedit_flush_redo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
tv64 = 48
ch$1 = 52
i$2 = 56
i$3 = 60
c$4 = 64
x$5 = 68
x$6 = 72
tv252 = 76
tv279 = 80
start$7 = 84
dx$8 = 88
goal_x$9 = 92
sel$10 = 96
tv307 = 100
tv333 = 104
dx$11 = 108
goal_x$12 = 112
sel$13 = 116
tv441 = 120
n$14 = 124
n$15 = 128
n$16 = 132
find$17 = 136
find$18 = 160
row$19 = 184
row$20 = 208
__$ArrayPad$ = 232
str$ = 256
state$ = 264
key$ = 272
?stb_textedit_key@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z PROC ; ImGuiStb::stb_textedit_key

; 731  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 248				; 000000f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
$LN103@stb_texted:
$retry$106:

; 732  : retry:
; 733  : 	switch (key) {

	mov	eax, DWORD PTR key$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 196608		; 00030000H
	jg	SHORT $LN102@stb_texted
	cmp	DWORD PTR tv64[rsp], 196608		; 00030000H
	je	$LN34@stb_texted
	mov	eax, DWORD PTR tv64[rsp]
	sub	eax, 65536				; 00010000H
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 13
	ja	SHORT $LN18@stb_texted
	movsxd	rax, DWORD PTR tv64[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN105@stb_texted[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN102@stb_texted:
	mov	eax, DWORD PTR tv64[rsp]
	sub	eax, 196609				; 00030001H
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 12
	ja	SHORT $LN18@stb_texted
	movsxd	rax, DWORD PTR tv64[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN104@stb_texted[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN18@stb_texted:

; 734  : 	default: {
; 735  : 		int c = STB_TEXTEDIT_KEYTOTEXT(key);

	mov	ecx, DWORD PTR key$[rsp]
	call	?STB_TEXTEDIT_KEYTOTEXT@ImGuiStb@@YAHH@Z ; ImGuiStb::STB_TEXTEDIT_KEYTOTEXT
	mov	DWORD PTR c$4[rsp], eax

; 736  : 		if (c > 0) {

	cmp	DWORD PTR c$4[rsp], 0
	jle	$LN19@stb_texted

; 737  : 			STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE)c;

	movzx	eax, WORD PTR c$4[rsp]
	mov	WORD PTR ch$1[rsp], ax

; 738  : 
; 739  : 			// can't add newline in single-line mode
; 740  : 			if (c == '\n' && state->single_line)

	cmp	DWORD PTR c$4[rsp], 10
	jne	SHORT $LN20@stb_texted
	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	test	eax, eax
	je	SHORT $LN20@stb_texted

; 741  : 				break;

	jmp	$LN2@stb_texted
$LN20@stb_texted:

; 742  : 
; 743  : 			if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+12]
	test	eax, eax
	je	$LN21@stb_texted
	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	jne	$LN21@stb_texted
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPEBUImGuiInputTextState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	mov	rcx, QWORD PTR state$[rsp]
	cmp	DWORD PTR [rcx], eax
	jge	$LN21@stb_texted

; 744  : 				stb_text_makeundo_replace(str, state, state->cursor, 1, 1);

	mov	DWORD PTR [rsp+32], 1
	mov	r9d, 1
	mov	rax, QWORD PTR state$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_text_makeundo_replace@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z ; ImGuiStb::stb_text_makeundo_replace

; 745  : 				STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);

	mov	r8d, 1
	mov	rax, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPEAUImGuiInputTextState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_DELETECHARS
	npad	1

; 746  : 				if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {

	mov	r9d, 1
	lea	r8, QWORD PTR ch$1[rsp]
	mov	rax, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@stb_texted

; 747  : 					++state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 748  : 					state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0
$LN23@stb_texted:

; 749  : 				}
; 750  : 			}

	jmp	SHORT $LN22@stb_texted
$LN21@stb_texted:

; 751  : 			else {
; 752  : 				stb_textedit_delete_selection(str, state); // implicitly clamps

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_delete_selection@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_delete_selection
	npad	1

; 753  : 				if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {

	mov	r9d, 1
	lea	r8, QWORD PTR ch$1[rsp]
	mov	rax, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@stb_texted

; 754  : 					stb_text_makeundo_insert(state, state->cursor, 1);

	mov	r8d, 1
	mov	rax, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_text_makeundo_insert@ImGuiStb@@YAXPEAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_text_makeundo_insert

; 755  : 					++state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 756  : 					state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0
$LN24@stb_texted:
$LN22@stb_texted:
$LN19@stb_texted:

; 757  : 				}
; 758  : 			}
; 759  : 		}
; 760  : 		break;

	jmp	$LN2@stb_texted
$LN25@stb_texted:

; 761  : 	}
; 762  : 
; 763  : #ifdef STB_TEXTEDIT_K_INSERT
; 764  : 	case STB_TEXTEDIT_K_INSERT:
; 765  : 		state->insert_mode = !state->insert_mode;
; 766  : 		break;
; 767  : #endif
; 768  : 
; 769  : 	case STB_TEXTEDIT_K_UNDO:
; 770  : 		stb_text_undo(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_text_undo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_text_undo

; 771  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 772  : 		break;

	jmp	$LN2@stb_texted
$LN26@stb_texted:

; 773  : 
; 774  : 	case STB_TEXTEDIT_K_REDO:
; 775  : 		stb_text_redo(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_text_redo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_text_redo

; 776  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 777  : 		break;

	jmp	$LN2@stb_texted
$LN27@stb_texted:

; 778  : 
; 779  : 	case STB_TEXTEDIT_K_LEFT:
; 780  : 		// if currently there's a selection, move cursor to start of selection
; 781  : 		if (STB_TEXT_HAS_SELECTION(state))

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN28@stb_texted

; 782  : 			stb_textedit_move_to_first(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_move_to_first@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_first
	npad	1
	jmp	SHORT $LN29@stb_texted
$LN28@stb_texted:

; 783  : 		else
; 784  : 			if (state->cursor > 0)

	mov	rax, QWORD PTR state$[rsp]
	cmp	DWORD PTR [rax], 0
	jle	SHORT $LN30@stb_texted

; 785  : 				--state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax
$LN30@stb_texted:
$LN29@stb_texted:

; 786  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 787  : 		break;

	jmp	$LN2@stb_texted
$LN31@stb_texted:

; 788  : 
; 789  : 	case STB_TEXTEDIT_K_RIGHT:
; 790  : 		// if currently there's a selection, move cursor to end of selection
; 791  : 		if (STB_TEXT_HAS_SELECTION(state))

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN32@stb_texted

; 792  : 			stb_textedit_move_to_last(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_move_to_last@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_last
	npad	1
	jmp	SHORT $LN33@stb_texted
$LN32@stb_texted:

; 793  : 		else
; 794  : 			++state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax
$LN33@stb_texted:

; 795  : 		stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 796  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 797  : 		break;

	jmp	$LN2@stb_texted
$LN34@stb_texted:

; 798  : 
; 799  : 	case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
; 800  : 		stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 801  : 		stb_textedit_prep_selection_at_cursor(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	npad	1

; 802  : 		// move selection left
; 803  : 		if (state->select_end > 0)

	mov	rax, QWORD PTR state$[rsp]
	cmp	DWORD PTR [rax+8], 0
	jle	SHORT $LN35@stb_texted

; 804  : 			--state->select_end;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax+8]
	dec	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx+8], eax
$LN35@stb_texted:

; 805  : 		state->cursor = state->select_end;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax], ecx

; 806  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 807  : 		break;

	jmp	$LN2@stb_texted
$LN36@stb_texted:

; 808  : 
; 809  : #ifdef STB_TEXTEDIT_MOVEWORDLEFT
; 810  : 	case STB_TEXTEDIT_K_WORDLEFT:
; 811  : 		if (STB_TEXT_HAS_SELECTION(state))

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN37@stb_texted

; 812  : 			stb_textedit_move_to_first(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_move_to_first@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_first
	npad	1
	jmp	SHORT $LN38@stb_texted
$LN37@stb_texted:

; 813  : 		else {
; 814  : 			state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);

	mov	rax, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 815  : 			stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	npad	1
$LN38@stb_texted:

; 816  : 		}
; 817  : 		break;

	jmp	$LN2@stb_texted
$LN39@stb_texted:

; 818  : 
; 819  : 	case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
; 820  : 		if (!STB_TEXT_HAS_SELECTION(state))

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN40@stb_texted

; 821  : 			stb_textedit_prep_selection_at_cursor(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	npad	1
$LN40@stb_texted:

; 822  : 
; 823  : 		state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);

	mov	rax, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 824  : 		state->select_end = state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+8], ecx

; 825  : 
; 826  : 		stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	npad	1

; 827  : 		break;

	jmp	$LN2@stb_texted
$LN41@stb_texted:

; 828  : #endif
; 829  : 
; 830  : #ifdef STB_TEXTEDIT_MOVEWORDRIGHT
; 831  : 	case STB_TEXTEDIT_K_WORDRIGHT:
; 832  : 		if (STB_TEXT_HAS_SELECTION(state))

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN42@stb_texted

; 833  : 			stb_textedit_move_to_last(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_move_to_last@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_last
	npad	1
	jmp	SHORT $LN43@stb_texted
$LN42@stb_texted:

; 834  : 		else {
; 835  : 			state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);

	mov	rax, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 836  : 			stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	npad	1
$LN43@stb_texted:

; 837  : 		}
; 838  : 		break;

	jmp	$LN2@stb_texted
$LN44@stb_texted:

; 839  : 
; 840  : 	case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
; 841  : 		if (!STB_TEXT_HAS_SELECTION(state))

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN45@stb_texted

; 842  : 			stb_textedit_prep_selection_at_cursor(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	npad	1
$LN45@stb_texted:

; 843  : 
; 844  : 		state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);

	mov	rax, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 845  : 		state->select_end = state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+8], ecx

; 846  : 
; 847  : 		stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	npad	1

; 848  : 		break;

	jmp	$LN2@stb_texted
$LN46@stb_texted:

; 849  : #endif
; 850  : 
; 851  : 	case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
; 852  : 		stb_textedit_prep_selection_at_cursor(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor

; 853  : 		// move selection right
; 854  : 		++state->select_end;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 855  : 		stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 856  : 		state->cursor = state->select_end;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax], ecx

; 857  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 858  : 		break;

	jmp	$LN2@stb_texted
$LN47@stb_texted:
$LN48@stb_texted:

; 859  : 
; 860  : 	case STB_TEXTEDIT_K_DOWN:
; 861  : 	case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT: {
; 862  : 		StbFindState find;
; 863  : 		StbTexteditRow row;
; 864  : 		int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

	mov	eax, DWORD PTR key$[rsp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $LN94@stb_texted
	mov	DWORD PTR tv252[rsp], 1
	jmp	SHORT $LN95@stb_texted
$LN94@stb_texted:
	mov	DWORD PTR tv252[rsp], 0
$LN95@stb_texted:
	mov	eax, DWORD PTR tv252[rsp]
	mov	DWORD PTR sel$10[rsp], eax

; 865  : 
; 866  : 		if (state->single_line) {

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	test	eax, eax
	je	SHORT $LN49@stb_texted

; 867  : 			// on windows, up&down in single-line behave like left&right
; 868  : 			key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);

	mov	eax, DWORD PTR key$[rsp]
	and	eax, 131072				; 00020000H
	or	eax, 65537				; 00010001H
	mov	DWORD PTR key$[rsp], eax

; 869  : 			goto retry;

	jmp	$retry$106
$LN49@stb_texted:

; 870  : 		}
; 871  : 
; 872  : 		if (sel)

	cmp	DWORD PTR sel$10[rsp], 0
	je	SHORT $LN50@stb_texted

; 873  : 			stb_textedit_prep_selection_at_cursor(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	npad	1
	jmp	SHORT $LN51@stb_texted
$LN50@stb_texted:

; 874  : 		else if (STB_TEXT_HAS_SELECTION(state))

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN52@stb_texted

; 875  : 			stb_textedit_move_to_last(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_move_to_last@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_last
	npad	1
$LN52@stb_texted:
$LN51@stb_texted:

; 876  : 
; 877  : 		// compute current position of cursor point
; 878  : 		stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 879  : 		stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	r9d, eax
	mov	rax, QWORD PTR state$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR find$18[rsp]
	call	?stb_textedit_find_charpos@ImGuiStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z ; ImGuiStb::stb_textedit_find_charpos
	npad	1

; 880  : 
; 881  : 		// now find character position down a row
; 882  : 		if (find.length) {

	cmp	DWORD PTR find$18[rsp+16], 0
	je	$LN53@stb_texted

; 883  : 			float goal_x = state->has_preferred_x ? state->preferred_x : find.x;

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+15]
	test	eax, eax
	je	SHORT $LN96@stb_texted
	mov	rax, QWORD PTR state$[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	movss	DWORD PTR tv279[rsp], xmm0
	jmp	SHORT $LN97@stb_texted
$LN96@stb_texted:
	movss	xmm0, DWORD PTR find$18[rsp]
	movss	DWORD PTR tv279[rsp], xmm0
$LN97@stb_texted:
	movss	xmm0, DWORD PTR tv279[rsp]
	movss	DWORD PTR goal_x$9[rsp], xmm0

; 884  : 			float x;
; 885  : 			int start = find.first_char + find.length;

	mov	eax, DWORD PTR find$18[rsp+16]
	mov	ecx, DWORD PTR find$18[rsp+12]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR start$7[rsp], eax

; 886  : 			state->cursor = start;

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR start$7[rsp]
	mov	DWORD PTR [rax], ecx

; 887  : 			STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);

	mov	rax, QWORD PTR state$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR row$19[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 888  : 			x = row.x0;

	movss	xmm0, DWORD PTR row$19[rsp]
	movss	DWORD PTR x$5[rsp], xmm0

; 889  : 			for (i = 0; i < row.num_chars; ++i) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN6@stb_texted
$LN4@stb_texted:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN6@stb_texted:
	mov	eax, DWORD PTR row$19[rsp+20]
	cmp	DWORD PTR i$2[rsp], eax
	jge	SHORT $LN5@stb_texted

; 890  : 				float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);

	mov	r8d, DWORD PTR i$2[rsp]
	mov	edx, DWORD PTR start$7[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPEAUImGuiInputTextState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_GETWIDTH
	movss	DWORD PTR dx$8[rsp], xmm0

; 891  : #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
; 892  : 				if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)

	movss	xmm0, DWORD PTR dx$8[rsp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	jp	SHORT $LN54@stb_texted
	jne	SHORT $LN54@stb_texted

; 893  : 					break;

	jmp	SHORT $LN5@stb_texted
$LN54@stb_texted:

; 894  : #endif
; 895  : 				x += dx;

	movss	xmm0, DWORD PTR x$5[rsp]
	addss	xmm0, DWORD PTR dx$8[rsp]
	movss	DWORD PTR x$5[rsp], xmm0

; 896  : 				if (x > goal_x)

	movss	xmm0, DWORD PTR x$5[rsp]
	comiss	xmm0, DWORD PTR goal_x$9[rsp]
	jbe	SHORT $LN55@stb_texted

; 897  : 					break;

	jmp	SHORT $LN5@stb_texted
$LN55@stb_texted:

; 898  : 				++state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 899  : 			}

	jmp	SHORT $LN4@stb_texted
$LN5@stb_texted:

; 900  : 			stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 901  : 
; 902  : 			state->has_preferred_x = 1;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 1

; 903  : 			state->preferred_x = goal_x;

	mov	rax, QWORD PTR state$[rsp]
	movss	xmm0, DWORD PTR goal_x$9[rsp]
	movss	DWORD PTR [rax+20], xmm0

; 904  : 
; 905  : 			if (sel)

	cmp	DWORD PTR sel$10[rsp], 0
	je	SHORT $LN56@stb_texted

; 906  : 				state->select_end = state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+8], ecx
$LN56@stb_texted:
$LN53@stb_texted:

; 907  : 		}
; 908  : 		break;

	jmp	$LN2@stb_texted
$LN57@stb_texted:
$LN58@stb_texted:

; 909  : 	}
; 910  : 
; 911  : 	case STB_TEXTEDIT_K_UP:
; 912  : 	case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT: {
; 913  : 		StbFindState find;
; 914  : 		StbTexteditRow row;
; 915  : 		int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

	mov	eax, DWORD PTR key$[rsp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $LN98@stb_texted
	mov	DWORD PTR tv307[rsp], 1
	jmp	SHORT $LN99@stb_texted
$LN98@stb_texted:
	mov	DWORD PTR tv307[rsp], 0
$LN99@stb_texted:
	mov	eax, DWORD PTR tv307[rsp]
	mov	DWORD PTR sel$13[rsp], eax

; 916  : 
; 917  : 		if (state->single_line) {

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	test	eax, eax
	je	SHORT $LN59@stb_texted

; 918  : 			// on windows, up&down become left&right
; 919  : 			key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);

	mov	eax, DWORD PTR key$[rsp]
	and	eax, 131072				; 00020000H
	bts	eax, 16
	mov	DWORD PTR key$[rsp], eax

; 920  : 			goto retry;

	jmp	$LN103@stb_texted
$LN59@stb_texted:

; 921  : 		}
; 922  : 
; 923  : 		if (sel)

	cmp	DWORD PTR sel$13[rsp], 0
	je	SHORT $LN60@stb_texted

; 924  : 			stb_textedit_prep_selection_at_cursor(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	npad	1
	jmp	SHORT $LN61@stb_texted
$LN60@stb_texted:

; 925  : 		else if (STB_TEXT_HAS_SELECTION(state))

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN62@stb_texted

; 926  : 			stb_textedit_move_to_first(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_move_to_first@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_first
	npad	1
$LN62@stb_texted:
$LN61@stb_texted:

; 927  : 
; 928  : 		// compute current position of cursor point
; 929  : 		stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 930  : 		stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	r9d, eax
	mov	rax, QWORD PTR state$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR find$17[rsp]
	call	?stb_textedit_find_charpos@ImGuiStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z ; ImGuiStb::stb_textedit_find_charpos
	npad	1

; 931  : 
; 932  : 		// can only go up if there's a previous row
; 933  : 		if (find.prev_first != find.first_char) {

	mov	eax, DWORD PTR find$17[rsp+12]
	cmp	DWORD PTR find$17[rsp+20], eax
	je	$LN63@stb_texted

; 934  : 			// now find character position up a row
; 935  : 			float goal_x = state->has_preferred_x ? state->preferred_x : find.x;

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+15]
	test	eax, eax
	je	SHORT $LN100@stb_texted
	mov	rax, QWORD PTR state$[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	movss	DWORD PTR tv333[rsp], xmm0
	jmp	SHORT $LN101@stb_texted
$LN100@stb_texted:
	movss	xmm0, DWORD PTR find$17[rsp]
	movss	DWORD PTR tv333[rsp], xmm0
$LN101@stb_texted:
	movss	xmm0, DWORD PTR tv333[rsp]
	movss	DWORD PTR goal_x$12[rsp], xmm0

; 936  : 			float x;
; 937  : 			state->cursor = find.prev_first;

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR find$17[rsp+20]
	mov	DWORD PTR [rax], ecx

; 938  : 			STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);

	mov	rax, QWORD PTR state$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR row$20[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 939  : 			x = row.x0;

	movss	xmm0, DWORD PTR row$20[rsp]
	movss	DWORD PTR x$6[rsp], xmm0

; 940  : 			for (i = 0; i < row.num_chars; ++i) {

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN9@stb_texted
$LN7@stb_texted:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN9@stb_texted:
	mov	eax, DWORD PTR row$20[rsp+20]
	cmp	DWORD PTR i$3[rsp], eax
	jge	SHORT $LN8@stb_texted

; 941  : 				float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);

	mov	r8d, DWORD PTR i$3[rsp]
	mov	edx, DWORD PTR find$17[rsp+20]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPEAUImGuiInputTextState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_GETWIDTH
	movss	DWORD PTR dx$11[rsp], xmm0

; 942  : #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
; 943  : 				if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)

	movss	xmm0, DWORD PTR dx$11[rsp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	jp	SHORT $LN64@stb_texted
	jne	SHORT $LN64@stb_texted

; 944  : 					break;

	jmp	SHORT $LN8@stb_texted
$LN64@stb_texted:

; 945  : #endif
; 946  : 				x += dx;

	movss	xmm0, DWORD PTR x$6[rsp]
	addss	xmm0, DWORD PTR dx$11[rsp]
	movss	DWORD PTR x$6[rsp], xmm0

; 947  : 				if (x > goal_x)

	movss	xmm0, DWORD PTR x$6[rsp]
	comiss	xmm0, DWORD PTR goal_x$12[rsp]
	jbe	SHORT $LN65@stb_texted

; 948  : 					break;

	jmp	SHORT $LN8@stb_texted
$LN65@stb_texted:

; 949  : 				++state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 950  : 			}

	jmp	$LN7@stb_texted
$LN8@stb_texted:

; 951  : 			stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 952  : 
; 953  : 			state->has_preferred_x = 1;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 1

; 954  : 			state->preferred_x = goal_x;

	mov	rax, QWORD PTR state$[rsp]
	movss	xmm0, DWORD PTR goal_x$12[rsp]
	movss	DWORD PTR [rax+20], xmm0

; 955  : 
; 956  : 			if (sel)

	cmp	DWORD PTR sel$13[rsp], 0
	je	SHORT $LN66@stb_texted

; 957  : 				state->select_end = state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+8], ecx
$LN66@stb_texted:
$LN63@stb_texted:

; 958  : 		}
; 959  : 		break;

	jmp	$LN2@stb_texted
$LN67@stb_texted:
$LN68@stb_texted:

; 960  : 	}
; 961  : 
; 962  : 	case STB_TEXTEDIT_K_DELETE:
; 963  : 	case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
; 964  : 		if (STB_TEXT_HAS_SELECTION(state))

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN69@stb_texted

; 965  : 			stb_textedit_delete_selection(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_delete_selection@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_delete_selection
	npad	1
	jmp	SHORT $LN70@stb_texted
$LN69@stb_texted:

; 966  : 		else {
; 967  : 			int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPEBUImGuiInputTextState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	mov	DWORD PTR n$16[rsp], eax

; 968  : 			if (state->cursor < n)

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR n$16[rsp]
	cmp	DWORD PTR [rax], ecx
	jge	SHORT $LN71@stb_texted

; 969  : 				stb_textedit_delete(str, state, state->cursor, 1);

	mov	r9d, 1
	mov	rax, QWORD PTR state$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_textedit_delete
	npad	1
$LN71@stb_texted:
$LN70@stb_texted:

; 970  : 		}
; 971  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 972  : 		break;

	jmp	$LN2@stb_texted
$LN72@stb_texted:
$LN73@stb_texted:

; 973  : 
; 974  : 	case STB_TEXTEDIT_K_BACKSPACE:
; 975  : 	case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
; 976  : 		if (STB_TEXT_HAS_SELECTION(state))

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN74@stb_texted

; 977  : 			stb_textedit_delete_selection(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_delete_selection@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_delete_selection
	npad	1
	jmp	SHORT $LN75@stb_texted
$LN74@stb_texted:

; 978  : 		else {
; 979  : 			stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	npad	1

; 980  : 			if (state->cursor > 0) {

	mov	rax, QWORD PTR state$[rsp]
	cmp	DWORD PTR [rax], 0
	jle	SHORT $LN76@stb_texted

; 981  : 				stb_textedit_delete(str, state, state->cursor - 1, 1);

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	r9d, 1
	mov	r8d, eax
	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_textedit_delete

; 982  : 				--state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax
$LN76@stb_texted:
$LN75@stb_texted:

; 983  : 			}
; 984  : 		}
; 985  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 986  : 		break;

	jmp	$LN2@stb_texted
$LN77@stb_texted:

; 987  : 
; 988  : #ifdef STB_TEXTEDIT_K_TEXTSTART2
; 989  : 	case STB_TEXTEDIT_K_TEXTSTART2:
; 990  : #endif
; 991  : 	case STB_TEXTEDIT_K_TEXTSTART:
; 992  : 		state->cursor = state->select_start = state->select_end = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax+8], 0
	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax], 0

; 993  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 994  : 		break;

	jmp	$LN2@stb_texted
$LN78@stb_texted:

; 995  : 
; 996  : #ifdef STB_TEXTEDIT_K_TEXTEND2
; 997  : 	case STB_TEXTEDIT_K_TEXTEND2:
; 998  : #endif
; 999  : 	case STB_TEXTEDIT_K_TEXTEND:
; 1000 : 		state->cursor = STB_TEXTEDIT_STRINGLEN(str);

	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPEBUImGuiInputTextState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 1001 : 		state->select_start = state->select_end = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax+8], 0
	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax+4], 0

; 1002 : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 1003 : 		break;

	jmp	$LN2@stb_texted
$LN79@stb_texted:

; 1004 : 
; 1005 : #ifdef STB_TEXTEDIT_K_TEXTSTART2
; 1006 : 	case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
; 1007 : #endif
; 1008 : 	case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
; 1009 : 		stb_textedit_prep_selection_at_cursor(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor

; 1010 : 		state->cursor = state->select_end = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax+8], 0
	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax], 0

; 1011 : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 1012 : 		break;

	jmp	$LN2@stb_texted
$LN80@stb_texted:

; 1013 : 
; 1014 : #ifdef STB_TEXTEDIT_K_TEXTEND2
; 1015 : 	case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
; 1016 : #endif
; 1017 : 	case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
; 1018 : 		stb_textedit_prep_selection_at_cursor(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor

; 1019 : 		state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);

	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPEBUImGuiInputTextState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	mov	DWORD PTR tv441[rsp], eax
	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR tv441[rsp]
	mov	DWORD PTR [rax+8], ecx
	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR tv441[rsp]
	mov	DWORD PTR [rax], ecx

; 1020 : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 1021 : 		break;

	jmp	$LN2@stb_texted
$LN81@stb_texted:

; 1022 : 
; 1023 : 
; 1024 : #ifdef STB_TEXTEDIT_K_LINESTART2
; 1025 : 	case STB_TEXTEDIT_K_LINESTART2:
; 1026 : #endif
; 1027 : 	case STB_TEXTEDIT_K_LINESTART:
; 1028 : 		stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 1029 : 		stb_textedit_move_to_first(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_move_to_first@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_first
	npad	1

; 1030 : 		if (state->single_line)

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	test	eax, eax
	je	SHORT $LN82@stb_texted

; 1031 : 			state->cursor = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax], 0
	jmp	SHORT $LN83@stb_texted
$LN82@stb_texted:
$LN10@stb_texted:

; 1032 : 		else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor - 1) != STB_TEXTEDIT_NEWLINE)

	mov	rax, QWORD PTR state$[rsp]
	cmp	DWORD PTR [rax], 0
	jle	SHORT $LN11@stb_texted
	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	edx, eax
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	movzx	eax, ax
	movzx	ecx, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImGuiStb@@3GA
	cmp	eax, ecx
	je	SHORT $LN11@stb_texted

; 1033 : 			--state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN10@stb_texted
$LN11@stb_texted:
$LN83@stb_texted:

; 1034 : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 1035 : 		break;

	jmp	$LN2@stb_texted
$LN84@stb_texted:

; 1036 : 
; 1037 : #ifdef STB_TEXTEDIT_K_LINEEND2
; 1038 : 	case STB_TEXTEDIT_K_LINEEND2:
; 1039 : #endif
; 1040 : 	case STB_TEXTEDIT_K_LINEEND: {
; 1041 : 		int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPEBUImGuiInputTextState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	mov	DWORD PTR n$14[rsp], eax

; 1042 : 		stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 1043 : 		stb_textedit_move_to_first(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_move_to_first@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_first
	npad	1

; 1044 : 		if (state->single_line)

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	test	eax, eax
	je	SHORT $LN85@stb_texted

; 1045 : 			state->cursor = n;

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR n$14[rsp]
	mov	DWORD PTR [rax], ecx
	jmp	SHORT $LN86@stb_texted
$LN85@stb_texted:
$LN12@stb_texted:

; 1046 : 		else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR n$14[rsp]
	cmp	DWORD PTR [rax], ecx
	jge	SHORT $LN13@stb_texted
	mov	rax, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	movzx	eax, ax
	movzx	ecx, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImGuiStb@@3GA
	cmp	eax, ecx
	je	SHORT $LN13@stb_texted

; 1047 : 			++state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN12@stb_texted
$LN13@stb_texted:
$LN86@stb_texted:

; 1048 : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 1049 : 		break;

	jmp	$LN2@stb_texted
$LN87@stb_texted:

; 1050 : 	}
; 1051 : 
; 1052 : #ifdef STB_TEXTEDIT_K_LINESTART2
; 1053 : 	case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
; 1054 : #endif
; 1055 : 	case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
; 1056 : 		stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 1057 : 		stb_textedit_prep_selection_at_cursor(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	npad	1

; 1058 : 		if (state->single_line)

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	test	eax, eax
	je	SHORT $LN88@stb_texted

; 1059 : 			state->cursor = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	DWORD PTR [rax], 0
	jmp	SHORT $LN89@stb_texted
$LN88@stb_texted:
$LN14@stb_texted:

; 1060 : 		else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor - 1) != STB_TEXTEDIT_NEWLINE)

	mov	rax, QWORD PTR state$[rsp]
	cmp	DWORD PTR [rax], 0
	jle	SHORT $LN15@stb_texted
	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	edx, eax
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	movzx	eax, ax
	movzx	ecx, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImGuiStb@@3GA
	cmp	eax, ecx
	je	SHORT $LN15@stb_texted

; 1061 : 			--state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN14@stb_texted
$LN15@stb_texted:
$LN89@stb_texted:

; 1062 : 		state->select_end = state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+8], ecx

; 1063 : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 1064 : 		break;

	jmp	$LN2@stb_texted
$LN90@stb_texted:

; 1065 : 
; 1066 : #ifdef STB_TEXTEDIT_K_LINEEND2
; 1067 : 	case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
; 1068 : #endif
; 1069 : 	case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
; 1070 : 		int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPEBUImGuiInputTextState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	mov	DWORD PTR n$15[rsp], eax

; 1071 : 		stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 1072 : 		stb_textedit_prep_selection_at_cursor(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	npad	1

; 1073 : 		if (state->single_line)

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	test	eax, eax
	je	SHORT $LN91@stb_texted

; 1074 : 			state->cursor = n;

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR n$15[rsp]
	mov	DWORD PTR [rax], ecx
	jmp	SHORT $LN92@stb_texted
$LN91@stb_texted:
$LN16@stb_texted:

; 1075 : 		else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR n$15[rsp]
	cmp	DWORD PTR [rax], ecx
	jge	SHORT $LN17@stb_texted
	mov	rax, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	movzx	eax, ax
	movzx	ecx, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImGuiStb@@3GA
	cmp	eax, ecx
	je	SHORT $LN17@stb_texted

; 1076 : 			++state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN16@stb_texted
$LN17@stb_texted:
$LN92@stb_texted:

; 1077 : 		state->select_end = state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+8], ecx

; 1078 : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0
$LN2@stb_texted:

; 1079 : 		break;
; 1080 : 	}
; 1081 : 
; 1082 : 													  // @TODO:
; 1083 : 													  //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1084 : 													  //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1085 : 	}
; 1086 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 248				; 000000f8H
	ret	0
	npad	3
$LN105@stb_texted:
	DD	$LN27@stb_texted
	DD	$LN31@stb_texted
	DD	$LN57@stb_texted
	DD	$LN47@stb_texted
	DD	$LN81@stb_texted
	DD	$LN84@stb_texted
	DD	$LN77@stb_texted
	DD	$LN78@stb_texted
	DD	$LN67@stb_texted
	DD	$LN72@stb_texted
	DD	$LN25@stb_texted
	DD	$LN26@stb_texted
	DD	$LN36@stb_texted
	DD	$LN41@stb_texted
$LN104@stb_texted:
	DD	$LN46@stb_texted
	DD	$LN58@stb_texted
	DD	$LN48@stb_texted
	DD	$LN87@stb_texted
	DD	$LN90@stb_texted
	DD	$LN79@stb_texted
	DD	$LN80@stb_texted
	DD	$LN68@stb_texted
	DD	$LN73@stb_texted
	DD	$LN18@stb_texted
	DD	$LN18@stb_texted
	DD	$LN39@stb_texted
	DD	$LN44@stb_texted
?stb_textedit_key@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ENDP ; ImGuiStb::stb_textedit_key
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
str$ = 48
state$ = 56
text$ = 64
len$ = 72
?stb_textedit_paste_internal@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z PROC ; ImGuiStb::stb_textedit_paste_internal

; 708  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 709  : 	// if there's a selection, the paste should delete it
; 710  : 	stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 711  : 	stb_textedit_delete_selection(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_delete_selection@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_delete_selection
	npad	1

; 712  : 	// try to insert the characters
; 713  : 	if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {

	mov	r9d, DWORD PTR len$[rsp]
	mov	r8, QWORD PTR text$[rsp]
	mov	rax, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@stb_texted

; 714  : 		stb_text_makeundo_insert(state, state->cursor, len);

	mov	r8d, DWORD PTR len$[rsp]
	mov	rax, QWORD PTR state$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_text_makeundo_insert@ImGuiStb@@YAXPEAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_text_makeundo_insert

; 715  : 		state->cursor += len;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax]
	add	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 716  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 717  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@stb_texted
$LN2@stb_texted:

; 718  : 	}
; 719  : 	// remove the undo since we didn't actually insert the characters
; 720  : 	if (state->undostate.undo_point)

	mov	rax, QWORD PTR state$[rsp]
	movsx	eax, WORD PTR [rax+3606]
	test	eax, eax
	je	SHORT $LN3@stb_texted

; 721  : 		--state->undostate.undo_point;

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, WORD PTR [rax+3606]
	dec	ax
	mov	rcx, QWORD PTR state$[rsp]
	mov	WORD PTR [rcx+3606], ax
$LN3@stb_texted:

; 722  : 	return 0;

	xor	eax, eax
$LN1@stb_texted:

; 723  : }

	add	rsp, 40					; 00000028H
	ret	0
?stb_textedit_paste_internal@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z ENDP ; ImGuiStb::stb_textedit_paste_internal
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
str$ = 48
state$ = 56
?stb_textedit_cut@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_cut

; 697  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 698  : 	if (STB_TEXT_HAS_SELECTION(state)) {

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN2@stb_texted

; 699  : 		stb_textedit_delete_selection(str, state); // implicitly clamps

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_delete_selection@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_delete_selection

; 700  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 701  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@stb_texted
$LN2@stb_texted:

; 702  : 	}
; 703  : 	return 0;

	xor	eax, eax
$LN1@stb_texted:

; 704  : }

	add	rsp, 40					; 00000028H
	ret	0
?stb_textedit_cut@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_cut
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
state$ = 8
?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_prep_selection_at_cursor

; 688  : {

	mov	QWORD PTR [rsp+8], rcx

; 689  : 	if (!STB_TEXT_HAS_SELECTION(state))

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN2@stb_texted

; 690  : 		state->select_start = state->select_end = state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+8], ecx
	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+4], ecx
	jmp	SHORT $LN3@stb_texted
$LN2@stb_texted:

; 691  : 	else
; 692  : 		state->cursor = state->select_end;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax], ecx
$LN3@stb_texted:

; 693  : }

	ret	0
?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_prep_selection_at_cursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
str$ = 48
state$ = 56
?stb_textedit_move_to_last@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_move_to_last

; 637  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 638  : 	if (STB_TEXT_HAS_SELECTION(state)) {

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN2@stb_texted

; 639  : 		stb_textedit_sortselection(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_sortselection@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_sortselection

; 640  : 		stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 641  : 		state->cursor = state->select_end;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax], ecx

; 642  : 		state->select_start = state->select_end;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+4], ecx

; 643  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0
$LN2@stb_texted:

; 644  : 	}
; 645  : }

	add	rsp, 40					; 00000028H
	ret	0
?stb_textedit_move_to_last@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_move_to_last
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
state$ = 48
?stb_textedit_move_to_first@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_move_to_first

; 626  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 627  : 	if (STB_TEXT_HAS_SELECTION(state)) {

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN2@stb_texted

; 628  : 		stb_textedit_sortselection(state);

	mov	rcx, QWORD PTR state$[rsp]
	call	?stb_textedit_sortselection@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_sortselection

; 629  : 		state->cursor = state->select_start;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax], ecx

; 630  : 		state->select_end = state->select_start;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax+8], ecx

; 631  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0
$LN2@stb_texted:

; 632  : 	}
; 633  : }

	add	rsp, 40					; 00000028H
	ret	0
?stb_textedit_move_to_first@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_move_to_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
temp$1 = 0
state$ = 32
?stb_textedit_sortselection@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_sortselection

; 616  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 617  : 	if (state->select_end < state->select_start) {

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax+8], ecx
	jge	SHORT $LN2@stb_texted

; 618  : 		int temp = state->select_end;

	mov	rax, QWORD PTR state$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR temp$1[rsp], eax

; 619  : 		state->select_end = state->select_start;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax+8], ecx

; 620  : 		state->select_start = temp;

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR temp$1[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN2@stb_texted:

; 621  : 	}
; 622  : }

	add	rsp, 24
	ret	0
?stb_textedit_sortselection@ImGuiStb@@YAXPEAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_sortselection
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
str$ = 48
state$ = 56
?stb_textedit_delete_selection@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_delete_selection

; 599  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 600  : 	stb_textedit_clamp(str, state);

	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	npad	1

; 601  : 	if (STB_TEXT_HAS_SELECTION(state)) {

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	$LN2@stb_texted

; 602  : 		if (state->select_start < state->select_end) {

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	jge	SHORT $LN3@stb_texted

; 603  : 			stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	eax, DWORD PTR [rax+8]
	sub	eax, ecx
	mov	r9d, eax
	mov	rax, QWORD PTR state$[rsp]
	mov	r8d, DWORD PTR [rax+4]
	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_textedit_delete

; 604  : 			state->select_end = state->cursor = state->select_start;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+8], ecx

; 605  : 		}

	jmp	SHORT $LN4@stb_texted
$LN3@stb_texted:

; 606  : 		else {
; 607  : 			stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+4]
	sub	eax, ecx
	mov	r9d, eax
	mov	rax, QWORD PTR state$[rsp]
	mov	r8d, DWORD PTR [rax+8]
	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_textedit_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_textedit_delete

; 608  : 			state->select_start = state->cursor = state->select_end;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+4], ecx
$LN4@stb_texted:

; 609  : 		}
; 610  : 		state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0
$LN2@stb_texted:

; 611  : 	}
; 612  : }

	add	rsp, 40					; 00000028H
	ret	0
?stb_textedit_delete_selection@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_delete_selection
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
str$ = 48
state$ = 56
where$ = 64
len$ = 72
?stb_textedit_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z PROC ; ImGuiStb::stb_textedit_delete

; 591  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 592  : 	stb_text_makeundo_delete(str, state, where, len);

	mov	r9d, DWORD PTR len$[rsp]
	mov	r8d, DWORD PTR where$[rsp]
	mov	rdx, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_text_makeundo_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_text_makeundo_delete

; 593  : 	STB_TEXTEDIT_DELETECHARS(str, where, len);

	mov	r8d, DWORD PTR len$[rsp]
	mov	edx, DWORD PTR where$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPEAUImGuiInputTextState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_DELETECHARS

; 594  : 	state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 595  : }

	add	rsp, 40					; 00000028H
	ret	0
?stb_textedit_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ENDP ; ImGuiStb::stb_textedit_delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
n$ = 32
str$ = 64
state$ = 72
?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_clamp

; 577  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 578  : 	int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPEBUImGuiInputTextState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	mov	DWORD PTR n$[rsp], eax

; 579  : 	if (STB_TEXT_HAS_SELECTION(state)) {

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN2@stb_texted

; 580  : 		if (state->select_start > n) state->select_start = n;

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	cmp	DWORD PTR [rax+4], ecx
	jle	SHORT $LN3@stb_texted
	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN3@stb_texted:

; 581  : 		if (state->select_end > n) state->select_end = n;

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jle	SHORT $LN4@stb_texted
	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	mov	DWORD PTR [rax+8], ecx
$LN4@stb_texted:

; 582  : 		// if clamping forced them to be equal, move the cursor to match
; 583  : 		if (state->select_start == state->select_end)

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN5@stb_texted

; 584  : 			state->cursor = state->select_start;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax], ecx
$LN5@stb_texted:
$LN2@stb_texted:

; 585  : 	}
; 586  : 	if (state->cursor > n) state->cursor = n;

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	cmp	DWORD PTR [rax], ecx
	jle	SHORT $LN6@stb_texted
	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	mov	DWORD PTR [rax], ecx
$LN6@stb_texted:

; 587  : }

	add	rsp, 56					; 00000038H
	ret	0
?stb_textedit_clamp@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_clamp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
i$ = 32
prev_start$ = 36
z$ = 40
first$ = 44
tv146 = 48
tv148 = 52
r$ = 56
__$ArrayPad$ = 80
find$ = 112
str$ = 120
n$ = 128
single_line$ = 136
?stb_textedit_find_charpos@ImGuiStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z PROC ; ImGuiStb::stb_textedit_find_charpos

; 517  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 518  : 	StbTexteditRow r;
; 519  : 	int prev_start = 0;

	mov	DWORD PTR prev_start$[rsp], 0

; 520  : 	int z = STB_TEXTEDIT_STRINGLEN(str);

	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPEBUImGuiInputTextState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	mov	DWORD PTR z$[rsp], eax

; 521  : 	int i = 0, first;

	mov	DWORD PTR i$[rsp], 0

; 522  : 
; 523  : 	if (n == z) {

	mov	eax, DWORD PTR z$[rsp]
	cmp	DWORD PTR n$[rsp], eax
	jne	$LN10@stb_texted

; 524  : 		// if it's at the end, then find the last line -- simpler than trying to
; 525  : 		// explicitly handle this case in the regular code
; 526  : 		if (single_line) {

	cmp	DWORD PTR single_line$[rsp], 0
	je	SHORT $LN11@stb_texted

; 527  : 			STB_TEXTEDIT_LAYOUTROW(&r, str, 0);

	xor	r8d, r8d
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR r$[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 528  : 			find->y = 0;

	mov	rax, QWORD PTR find$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0

; 529  : 			find->first_char = 0;

	mov	rax, QWORD PTR find$[rsp]
	mov	DWORD PTR [rax+12], 0

; 530  : 			find->length = z;

	mov	rax, QWORD PTR find$[rsp]
	mov	ecx, DWORD PTR z$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 531  : 			find->height = r.ymax - r.ymin;

	movss	xmm0, DWORD PTR r$[rsp+16]
	subss	xmm0, DWORD PTR r$[rsp+12]
	mov	rax, QWORD PTR find$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 532  : 			find->x = r.x1;

	mov	rax, QWORD PTR find$[rsp]
	movss	xmm0, DWORD PTR r$[rsp+4]
	movss	DWORD PTR [rax], xmm0

; 533  : 		}

	jmp	$LN12@stb_texted
$LN11@stb_texted:

; 534  : 		else {
; 535  : 			find->y = 0;

	mov	rax, QWORD PTR find$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0

; 536  : 			find->x = 0;

	mov	rax, QWORD PTR find$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0

; 537  : 			find->height = 1;

	mov	rax, QWORD PTR find$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+8], xmm0
$LN2@stb_texted:

; 538  : 			while (i < z) {

	mov	eax, DWORD PTR z$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stb_texted

; 539  : 				STB_TEXTEDIT_LAYOUTROW(&r, str, i);

	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR r$[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 540  : 				prev_start = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR prev_start$[rsp], eax

; 541  : 				i += r.num_chars;

	mov	eax, DWORD PTR r$[rsp+20]
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax

; 542  : 			}

	jmp	SHORT $LN2@stb_texted
$LN3@stb_texted:

; 543  : 			find->first_char = i;

	mov	rax, QWORD PTR find$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 544  : 			find->length = 0;

	mov	rax, QWORD PTR find$[rsp]
	mov	DWORD PTR [rax+16], 0

; 545  : 			find->prev_first = prev_start;

	mov	rax, QWORD PTR find$[rsp]
	mov	ecx, DWORD PTR prev_start$[rsp]
	mov	DWORD PTR [rax+20], ecx
$LN12@stb_texted:

; 546  : 		}
; 547  : 		return;

	jmp	$LN1@stb_texted
$LN10@stb_texted:

; 548  : 	}
; 549  : 
; 550  : 	// search rows to find the one that straddles character n
; 551  : 	find->y = 0;

	mov	rax, QWORD PTR find$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
$LN4@stb_texted:

; 552  : 
; 553  : 	for (;;) {
; 554  : 		STB_TEXTEDIT_LAYOUTROW(&r, str, i);

	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR r$[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW
	npad	1

; 555  : 		if (n < i + r.num_chars)

	mov	eax, DWORD PTR r$[rsp+20]
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	DWORD PTR n$[rsp], eax
	jge	SHORT $LN13@stb_texted

; 556  : 			break;

	jmp	SHORT $LN5@stb_texted
$LN13@stb_texted:

; 557  : 		prev_start = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR prev_start$[rsp], eax

; 558  : 		i += r.num_chars;

	mov	eax, DWORD PTR r$[rsp+20]
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax

; 559  : 		find->y += r.baseline_y_delta;

	mov	rax, QWORD PTR find$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR r$[rsp+8]
	mov	rax, QWORD PTR find$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 560  : 	}

	jmp	SHORT $LN4@stb_texted
$LN5@stb_texted:

; 561  : 
; 562  : 	find->first_char = first = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR first$[rsp], eax
	mov	rax, QWORD PTR find$[rsp]
	mov	ecx, DWORD PTR first$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 563  : 	find->length = r.num_chars;

	mov	rax, QWORD PTR find$[rsp]
	mov	ecx, DWORD PTR r$[rsp+20]
	mov	DWORD PTR [rax+16], ecx

; 564  : 	find->height = r.ymax - r.ymin;

	movss	xmm0, DWORD PTR r$[rsp+16]
	subss	xmm0, DWORD PTR r$[rsp+12]
	mov	rax, QWORD PTR find$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 565  : 	find->prev_first = prev_start;

	mov	rax, QWORD PTR find$[rsp]
	mov	ecx, DWORD PTR prev_start$[rsp]
	mov	DWORD PTR [rax+20], ecx

; 566  : 
; 567  : 	// now scan to find xpos
; 568  : 	find->x = r.x0;

	mov	rax, QWORD PTR find$[rsp]
	movss	xmm0, DWORD PTR r$[rsp]
	movss	DWORD PTR [rax], xmm0

; 569  : 	for (i = 0; first + i < n; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN9@stb_texted
$LN7@stb_texted:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN9@stb_texted:
	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR first$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR n$[rsp]
	jge	SHORT $LN8@stb_texted

; 570  : 		find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);

	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, DWORD PTR first$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPEAUImGuiInputTextState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_GETWIDTH
	movss	DWORD PTR tv148[rsp], xmm0
	mov	rax, QWORD PTR find$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv146[rsp], xmm0
	movss	xmm0, DWORD PTR tv146[rsp]
	addss	xmm0, DWORD PTR tv148[rsp]
	mov	rax, QWORD PTR find$[rsp]
	movss	DWORD PTR [rax], xmm0
	jmp	SHORT $LN7@stb_texted
$LN8@stb_texted:
$LN1@stb_texted:

; 571  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?stb_textedit_find_charpos@ImGuiStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z ENDP ; ImGuiStb::stb_textedit_find_charpos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
i$ = 32
p$ = 40
str$ = 64
state$ = 72
where$ = 80
old_length$ = 88
new_length$ = 96
?stb_text_makeundo_replace@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z PROC ; ImGuiStb::stb_text_makeundo_replace

; 1335 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1336 : 	int i;
; 1337 : 	STB_TEXTEDIT_CHARTYPE* p = stb_text_createundo(&state->undostate, where, old_length, new_length);

	mov	rax, QWORD PTR state$[rsp]
	add	rax, 24
	mov	r9d, DWORD PTR new_length$[rsp]
	mov	r8d, DWORD PTR old_length$[rsp]
	mov	edx, DWORD PTR where$[rsp]
	mov	rcx, rax
	call	?stb_text_createundo@ImGuiStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImGuiStb::stb_text_createundo
	mov	QWORD PTR p$[rsp], rax

; 1338 : 	if (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN5@stb_text_m

; 1339 : 		for (i = 0; i < old_length; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stb_text_m
$LN2@stb_text_m:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stb_text_m:
	mov	eax, DWORD PTR old_length$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stb_text_m

; 1340 : 			p[i] = STB_TEXTEDIT_GETCHAR(str, where + i);

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR where$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	WORD PTR [rdx+rcx*2], ax
	jmp	SHORT $LN2@stb_text_m
$LN3@stb_text_m:
$LN5@stb_text_m:

; 1341 : 	}
; 1342 : }

	add	rsp, 56					; 00000038H
	ret	0
?stb_text_makeundo_replace@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z ENDP ; ImGuiStb::stb_text_makeundo_replace
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
state$ = 48
where$ = 56
length$ = 64
?stb_text_makeundo_insert@ImGuiStb@@YAXPEAUSTB_TexteditState@1@HH@Z PROC ; ImGuiStb::stb_text_makeundo_insert

; 1320 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1321 : 	stb_text_createundo(&state->undostate, where, 0, length);

	mov	rax, QWORD PTR state$[rsp]
	add	rax, 24
	mov	r9d, DWORD PTR length$[rsp]
	xor	r8d, r8d
	mov	edx, DWORD PTR where$[rsp]
	mov	rcx, rax
	call	?stb_text_createundo@ImGuiStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImGuiStb::stb_text_createundo
	npad	1

; 1322 : }

	add	rsp, 40					; 00000028H
	ret	0
?stb_text_makeundo_insert@ImGuiStb@@YAXPEAUSTB_TexteditState@1@HH@Z ENDP ; ImGuiStb::stb_text_makeundo_insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
i$ = 32
p$ = 40
str$ = 64
state$ = 72
where$ = 80
length$ = 88
?stb_text_makeundo_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z PROC ; ImGuiStb::stb_text_makeundo_delete

; 1325 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1326 : 	int i;
; 1327 : 	STB_TEXTEDIT_CHARTYPE* p = stb_text_createundo(&state->undostate, where, length, 0);

	mov	rax, QWORD PTR state$[rsp]
	add	rax, 24
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	mov	edx, DWORD PTR where$[rsp]
	mov	rcx, rax
	call	?stb_text_createundo@ImGuiStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImGuiStb::stb_text_createundo
	mov	QWORD PTR p$[rsp], rax

; 1328 : 	if (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN5@stb_text_m

; 1329 : 		for (i = 0; i < length; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stb_text_m
$LN2@stb_text_m:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stb_text_m:
	mov	eax, DWORD PTR length$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stb_text_m

; 1330 : 			p[i] = STB_TEXTEDIT_GETCHAR(str, where + i);

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR where$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	WORD PTR [rdx+rcx*2], ax
	jmp	SHORT $LN2@stb_text_m
$LN3@stb_text_m:
$LN5@stb_text_m:

; 1331 : 	}
; 1332 : }

	add	rsp, 56					; 00000038H
	ret	0
?stb_text_makeundo_delete@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ENDP ; ImGuiStb::stb_text_makeundo_delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
s$ = 32
u$ = 40
i$1 = 48
tv144 = 52
r$ = 56
__$ArrayPad$ = 72
str$ = 112
state$ = 120
?stb_text_redo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_text_redo

; 1268 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1269 : 	StbUndoState* s = &state->undostate;

	mov	rax, QWORD PTR state$[rsp]
	add	rax, 24
	mov	QWORD PTR s$[rsp], rax

; 1270 : 	StbUndoRecord* u, r;
; 1271 : 	if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, WORD PTR [rax+3584]
	cmp	eax, 99					; 00000063H
	jne	SHORT $LN5@stb_text_r

; 1272 : 		return;

	jmp	$LN1@stb_text_r
$LN5@stb_text_r:

; 1273 : 
; 1274 : 	// we need to do two things: apply the redo record, and create an undo record
; 1275 : 	u = &s->undo_rec[s->undo_point];

	mov	rax, QWORD PTR s$[rsp]
	movsx	rax, WORD PTR [rax+3582]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR s$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR u$[rsp], rax

; 1276 : 	r = s->undo_rec[s->redo_point];

	mov	rax, QWORD PTR s$[rsp]
	movsx	rax, WORD PTR [rax+3584]
	imul	rax, rax, 16
	lea	rcx, QWORD PTR r$[rsp]
	mov	rdx, QWORD PTR s$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax]
	mov	ecx, 16
	rep movsb

; 1277 : 
; 1278 : 	// we KNOW there must be room for the undo record, because the redo record
; 1279 : 	// was derived from an undo record
; 1280 : 
; 1281 : 	u->delete_length = r.insert_length;

	mov	rax, QWORD PTR u$[rsp]
	mov	ecx, DWORD PTR r$[rsp+4]
	mov	DWORD PTR [rax+8], ecx

; 1282 : 	u->insert_length = r.delete_length;

	mov	rax, QWORD PTR u$[rsp]
	mov	ecx, DWORD PTR r$[rsp+8]
	mov	DWORD PTR [rax+4], ecx

; 1283 : 	u->where = r.where;

	mov	rax, QWORD PTR u$[rsp]
	mov	ecx, DWORD PTR r$[rsp]
	mov	DWORD PTR [rax], ecx

; 1284 : 	u->char_storage = -1;

	mov	rax, QWORD PTR u$[rsp]
	mov	DWORD PTR [rax+12], -1

; 1285 : 
; 1286 : 	if (r.delete_length) {

	cmp	DWORD PTR r$[rsp+8], 0
	je	$LN6@stb_text_r

; 1287 : 		// the redo record requires us to delete characters, so the undo record
; 1288 : 		// needs to store the characters
; 1289 : 
; 1290 : 		if (s->undo_char_point + u->insert_length > s->redo_char_point) {

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+3588]
	mov	rcx, QWORD PTR u$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	rcx, QWORD PTR s$[rsp]
	cmp	eax, DWORD PTR [rcx+3592]
	jle	SHORT $LN7@stb_text_r

; 1291 : 			u->insert_length = 0;

	mov	rax, QWORD PTR u$[rsp]
	mov	DWORD PTR [rax+4], 0

; 1292 : 			u->delete_length = 0;

	mov	rax, QWORD PTR u$[rsp]
	mov	DWORD PTR [rax+8], 0

; 1293 : 		}

	jmp	$LN8@stb_text_r
$LN7@stb_text_r:

; 1294 : 		else {
; 1295 : 			int i;
; 1296 : 			u->char_storage = s->undo_char_point;

	mov	rax, QWORD PTR u$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR [rcx+3588]
	mov	DWORD PTR [rax+12], ecx

; 1297 : 			s->undo_char_point = s->undo_char_point + u->insert_length;

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+3588]
	mov	rcx, QWORD PTR u$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+3588], eax

; 1298 : 
; 1299 : 			// now save the characters
; 1300 : 			for (i = 0; i < u->insert_length; ++i)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@stb_text_r
$LN2@stb_text_r:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@stb_text_r:
	mov	rax, QWORD PTR u$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@stb_text_r

; 1301 : 				s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);

	mov	rax, QWORD PTR u$[rsp]
	mov	eax, DWORD PTR [rax]
	add	eax, DWORD PTR i$1[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	mov	WORD PTR tv144[rsp], ax
	mov	rax, QWORD PTR u$[rsp]
	mov	eax, DWORD PTR [rax+12]
	add	eax, DWORD PTR i$1[rsp]
	cdqe
	mov	rcx, QWORD PTR s$[rsp]
	movzx	edx, WORD PTR tv144[rsp]
	mov	WORD PTR [rcx+rax*2+1584], dx
	jmp	SHORT $LN2@stb_text_r
$LN3@stb_text_r:
$LN8@stb_text_r:

; 1302 : 		}
; 1303 : 
; 1304 : 		STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);

	mov	r8d, DWORD PTR r$[rsp+8]
	mov	edx, DWORD PTR r$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPEAUImGuiInputTextState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_DELETECHARS
	npad	1
$LN6@stb_text_r:

; 1305 : 	}
; 1306 : 
; 1307 : 	if (r.insert_length) {

	cmp	DWORD PTR r$[rsp+4], 0
	je	SHORT $LN9@stb_text_r

; 1308 : 		// easy case: need to insert n characters
; 1309 : 		STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);

	movsxd	rax, DWORD PTR r$[rsp+12]
	mov	rcx, QWORD PTR s$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2+1584]
	mov	r9d, DWORD PTR r$[rsp+4]
	mov	r8, rax
	mov	edx, DWORD PTR r$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS

; 1310 : 		s->redo_char_point += r.insert_length;

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+3592]
	add	eax, DWORD PTR r$[rsp+4]
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+3592], eax
$LN9@stb_text_r:

; 1311 : 	}
; 1312 : 
; 1313 : 	state->cursor = r.where + r.insert_length;

	mov	eax, DWORD PTR r$[rsp+4]
	mov	ecx, DWORD PTR r$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 1314 : 
; 1315 : 	s->undo_point++;

	mov	rax, QWORD PTR s$[rsp]
	movzx	eax, WORD PTR [rax+3582]
	inc	ax
	mov	rcx, QWORD PTR s$[rsp]
	mov	WORD PTR [rcx+3582], ax

; 1316 : 	s->redo_point++;

	mov	rax, QWORD PTR s$[rsp]
	movzx	eax, WORD PTR [rax+3584]
	inc	ax
	mov	rcx, QWORD PTR s$[rsp]
	mov	WORD PTR [rcx+3584], ax
$LN1@stb_text_r:

; 1317 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?stb_text_redo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_text_redo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
s$ = 32
i$1 = 40
r$ = 48
tv158 = 56
u$ = 64
__$ArrayPad$ = 80
str$ = 128
state$ = 136
?stb_text_undo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_text_undo

; 1199 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1200 : 	StbUndoState* s = &state->undostate;

	mov	rax, QWORD PTR state$[rsp]
	add	rax, 24
	mov	QWORD PTR s$[rsp], rax

; 1201 : 	StbUndoRecord u, * r;
; 1202 : 	if (s->undo_point == 0)

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, WORD PTR [rax+3582]
	test	eax, eax
	jne	SHORT $LN7@stb_text_u

; 1203 : 		return;

	jmp	$LN1@stb_text_u
$LN7@stb_text_u:

; 1204 : 
; 1205 : 	// we need to do two things: apply the undo record, and create a redo record
; 1206 : 	u = s->undo_rec[s->undo_point - 1];

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, WORD PTR [rax+3582]
	dec	eax
	cdqe
	imul	rax, rax, 16
	lea	rcx, QWORD PTR u$[rsp]
	mov	rdx, QWORD PTR s$[rsp]
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rdx+rax]
	mov	ecx, 16
	rep movsb

; 1207 : 	r = &s->undo_rec[s->redo_point - 1];

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, WORD PTR [rax+3584]
	dec	eax
	cdqe
	imul	rax, rax, 16
	mov	rcx, QWORD PTR s$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR r$[rsp], rax

; 1208 : 	r->char_storage = -1;

	mov	rax, QWORD PTR r$[rsp]
	mov	DWORD PTR [rax+12], -1

; 1209 : 
; 1210 : 	r->insert_length = u.delete_length;

	mov	rax, QWORD PTR r$[rsp]
	mov	ecx, DWORD PTR u$[rsp+8]
	mov	DWORD PTR [rax+4], ecx

; 1211 : 	r->delete_length = u.insert_length;

	mov	rax, QWORD PTR r$[rsp]
	mov	ecx, DWORD PTR u$[rsp+4]
	mov	DWORD PTR [rax+8], ecx

; 1212 : 	r->where = u.where;

	mov	rax, QWORD PTR r$[rsp]
	mov	ecx, DWORD PTR u$[rsp]
	mov	DWORD PTR [rax], ecx

; 1213 : 
; 1214 : 	if (u.delete_length) {

	cmp	DWORD PTR u$[rsp+8], 0
	je	$LN8@stb_text_u

; 1215 : 		// if the undo record says to delete characters, then the redo record will
; 1216 : 		// need to re-insert the characters that get deleted, so we need to store
; 1217 : 		// them.
; 1218 : 
; 1219 : 		// there are three cases:
; 1220 : 		//    there's enough room to store the characters
; 1221 : 		//    characters stored for *redoing* don't leave room for redo
; 1222 : 		//    characters stored for *undoing* don't leave room for redo
; 1223 : 		// if the last is true, we have to bail
; 1224 : 
; 1225 : 		if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+3588]
	add	eax, DWORD PTR u$[rsp+8]
	cmp	eax, 999				; 000003e7H
	jl	SHORT $LN9@stb_text_u

; 1226 : 			// the undo records take up too much character space; there's no space to store the redo characters
; 1227 : 			r->insert_length = 0;

	mov	rax, QWORD PTR r$[rsp]
	mov	DWORD PTR [rax+4], 0

; 1228 : 		}

	jmp	$LN10@stb_text_u
$LN9@stb_text_u:
$LN2@stb_text_u:

; 1229 : 		else {
; 1230 : 			int i;
; 1231 : 
; 1232 : 			// there's definitely room to store the characters eventually
; 1233 : 			while (s->undo_char_point + u.delete_length > s->redo_char_point) {

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+3588]
	add	eax, DWORD PTR u$[rsp+8]
	mov	rcx, QWORD PTR s$[rsp]
	cmp	eax, DWORD PTR [rcx+3592]
	jle	SHORT $LN3@stb_text_u

; 1234 : 				// should never happen:
; 1235 : 				if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, WORD PTR [rax+3584]
	cmp	eax, 99					; 00000063H
	jne	SHORT $LN11@stb_text_u

; 1236 : 					return;

	jmp	$LN1@stb_text_u
$LN11@stb_text_u:

; 1237 : 				// there's currently not enough room, so discard a redo record
; 1238 : 				stb_textedit_discard_redo(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stb_textedit_discard_redo@ImGuiStb@@YAXPEAUStbUndoState@1@@Z ; ImGuiStb::stb_textedit_discard_redo
	npad	1

; 1239 : 			}

	jmp	SHORT $LN2@stb_text_u
$LN3@stb_text_u:

; 1240 : 			r = &s->undo_rec[s->redo_point - 1];

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, WORD PTR [rax+3584]
	dec	eax
	cdqe
	imul	rax, rax, 16
	mov	rcx, QWORD PTR s$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR r$[rsp], rax

; 1241 : 
; 1242 : 			r->char_storage = s->redo_char_point - u.delete_length;

	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR u$[rsp+8]
	mov	eax, DWORD PTR [rax+3592]
	sub	eax, ecx
	mov	rcx, QWORD PTR r$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 1243 : 			s->redo_char_point = s->redo_char_point - u.delete_length;

	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR u$[rsp+8]
	mov	eax, DWORD PTR [rax+3592]
	sub	eax, ecx
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+3592], eax

; 1244 : 
; 1245 : 			// now save the characters
; 1246 : 			for (i = 0; i < u.delete_length; ++i)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@stb_text_u
$LN4@stb_text_u:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@stb_text_u:
	mov	eax, DWORD PTR u$[rsp+8]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN5@stb_text_u

; 1247 : 				s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);

	mov	eax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR u$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	mov	WORD PTR tv158[rsp], ax
	mov	rax, QWORD PTR r$[rsp]
	mov	eax, DWORD PTR [rax+12]
	add	eax, DWORD PTR i$1[rsp]
	cdqe
	mov	rcx, QWORD PTR s$[rsp]
	movzx	edx, WORD PTR tv158[rsp]
	mov	WORD PTR [rcx+rax*2+1584], dx
	jmp	SHORT $LN4@stb_text_u
$LN5@stb_text_u:
$LN10@stb_text_u:

; 1248 : 		}
; 1249 : 
; 1250 : 		// now we can carry out the deletion
; 1251 : 		STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);

	mov	r8d, DWORD PTR u$[rsp+8]
	mov	edx, DWORD PTR u$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPEAUImGuiInputTextState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_DELETECHARS
	npad	1
$LN8@stb_text_u:

; 1252 : 	}
; 1253 : 
; 1254 : 	// check type of recorded action:
; 1255 : 	if (u.insert_length) {

	cmp	DWORD PTR u$[rsp+4], 0
	je	SHORT $LN12@stb_text_u

; 1256 : 		// easy case: was a deletion, so we need to insert n characters
; 1257 : 		STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);

	movsxd	rax, DWORD PTR u$[rsp+12]
	mov	rcx, QWORD PTR s$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2+1584]
	mov	r9d, DWORD PTR u$[rsp+4]
	mov	r8, rax
	mov	edx, DWORD PTR u$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS

; 1258 : 		s->undo_char_point -= u.insert_length;

	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR u$[rsp+4]
	mov	eax, DWORD PTR [rax+3588]
	sub	eax, ecx
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+3588], eax
$LN12@stb_text_u:

; 1259 : 	}
; 1260 : 
; 1261 : 	state->cursor = u.where + u.insert_length;

	mov	eax, DWORD PTR u$[rsp+4]
	mov	ecx, DWORD PTR u$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 1262 : 
; 1263 : 	s->undo_point--;

	mov	rax, QWORD PTR s$[rsp]
	movzx	eax, WORD PTR [rax+3582]
	dec	ax
	mov	rcx, QWORD PTR s$[rsp]
	mov	WORD PTR [rcx+3582], ax

; 1264 : 	s->redo_point--;

	mov	rax, QWORD PTR s$[rsp]
	movzx	eax, WORD PTR [rax+3584]
	dec	ax
	mov	rcx, QWORD PTR s$[rsp]
	mov	WORD PTR [rcx+3584], ax
$LN1@stb_text_u:

; 1265 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?stb_text_undo@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_text_undo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
p$ = 32
r$1 = 40
__$ArrayPad$ = 64
str$ = 96
state$ = 104
x$ = 112
y$ = 120
?stb_textedit_drag@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z PROC ; ImGuiStb::stb_textedit_drag

; 475  : {

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 476  : 	int p = 0;

	mov	DWORD PTR p$[rsp], 0

; 477  : 
; 478  : 	// In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
; 479  : 	// goes off the top or bottom of the text
; 480  : 	if (state->single_line)

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	test	eax, eax
	je	SHORT $LN2@stb_texted

; 481  : 	{
; 482  : 		StbTexteditRow r;
; 483  : 		STB_TEXTEDIT_LAYOUTROW(&r, str, 0);

	xor	r8d, r8d
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR r$1[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 484  : 		y = r.ymin;

	movss	xmm0, DWORD PTR r$1[rsp+12]
	movss	DWORD PTR y$[rsp], xmm0
$LN2@stb_texted:

; 485  : 	}
; 486  : 
; 487  : 	if (state->select_start == state->select_end)

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN3@stb_texted

; 488  : 		state->select_start = state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+4], ecx
$LN3@stb_texted:

; 489  : 
; 490  : 	p = stb_text_locate_coord(str, x, y);

	movss	xmm2, DWORD PTR y$[rsp]
	movss	xmm1, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_text_locate_coord@ImGuiStb@@YAHPEAUImGuiInputTextState@@MM@Z ; ImGuiStb::stb_text_locate_coord
	mov	DWORD PTR p$[rsp], eax

; 491  : 	state->cursor = state->select_end = p;

	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR p$[rsp]
	mov	DWORD PTR [rax+8], ecx
	mov	rax, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR p$[rsp]
	mov	DWORD PTR [rax], ecx

; 492  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	ret	0
?stb_textedit_drag@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z ENDP ; ImGuiStb::stb_textedit_drag
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
r$1 = 32
__$ArrayPad$ = 56
str$ = 80
state$ = 88
x$ = 96
y$ = 104
?stb_textedit_click@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z PROC ; ImGuiStb::stb_textedit_click

; 457  : {

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 458  : 	// In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
; 459  : 	// goes off the top or bottom of the text
; 460  : 	if (state->single_line)

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	test	eax, eax
	je	SHORT $LN2@stb_texted

; 461  : 	{
; 462  : 		StbTexteditRow r;
; 463  : 		STB_TEXTEDIT_LAYOUTROW(&r, str, 0);

	xor	r8d, r8d
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR r$1[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 464  : 		y = r.ymin;

	movss	xmm0, DWORD PTR r$1[rsp+12]
	movss	DWORD PTR y$[rsp], xmm0
$LN2@stb_texted:

; 465  : 	}
; 466  : 
; 467  : 	state->cursor = stb_text_locate_coord(str, x, y);

	movss	xmm2, DWORD PTR y$[rsp]
	movss	xmm1, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?stb_text_locate_coord@ImGuiStb@@YAHPEAUImGuiInputTextState@@MM@Z ; ImGuiStb::stb_text_locate_coord
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rcx], eax

; 468  : 	state->select_start = state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+4], ecx

; 469  : 	state->select_end = state->cursor;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+8], ecx

; 470  : 	state->has_preferred_x = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+15], 0

; 471  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 72					; 00000048H
	ret	0
?stb_textedit_click@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z ENDP ; ImGuiStb::stb_textedit_click
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imstb_textedit.h
_TEXT	SEGMENT
i$ = 32
k$ = 36
base_y$ = 40
n$ = 44
prev_x$ = 48
w$1 = 52
r$ = 56
__$ArrayPad$ = 80
str$ = 112
x$ = 120
y$ = 128
?stb_text_locate_coord@ImGuiStb@@YAHPEAUImGuiInputTextState@@MM@Z PROC ; ImGuiStb::stb_text_locate_coord

; 397  : {

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 398  : 	StbTexteditRow r;
; 399  : 	int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPEBUImGuiInputTextState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	mov	DWORD PTR n$[rsp], eax

; 400  : 	float base_y = 0, prev_x;

	xorps	xmm0, xmm0
	movss	DWORD PTR base_y$[rsp], xmm0

; 401  : 	int i = 0, k;

	mov	DWORD PTR i$[rsp], 0

; 402  : 
; 403  : 	r.x0 = r.x1 = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR r$[rsp+4], xmm0
	movss	xmm0, DWORD PTR r$[rsp+4]
	movss	DWORD PTR r$[rsp], xmm0

; 404  : 	r.ymin = r.ymax = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR r$[rsp+16], xmm0
	movss	xmm0, DWORD PTR r$[rsp+16]
	movss	DWORD PTR r$[rsp+12], xmm0

; 405  : 	r.num_chars = 0;

	mov	DWORD PTR r$[rsp+20], 0
$LN2@stb_text_l:

; 406  : 
; 407  : 	// search rows to find one that straddles 'y'
; 408  : 	while (i < n) {

	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@stb_text_l

; 409  : 		STB_TEXTEDIT_LAYOUTROW(&r, str, i);

	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR r$[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW
	npad	1

; 410  : 		if (r.num_chars <= 0)

	cmp	DWORD PTR r$[rsp+20], 0
	jg	SHORT $LN7@stb_text_l

; 411  : 			return n;

	mov	eax, DWORD PTR n$[rsp]
	jmp	$LN1@stb_text_l
$LN7@stb_text_l:

; 412  : 
; 413  : 		if (i == 0 && y < base_y + r.ymin)

	cmp	DWORD PTR i$[rsp], 0
	jne	SHORT $LN8@stb_text_l
	movss	xmm0, DWORD PTR base_y$[rsp]
	addss	xmm0, DWORD PTR r$[rsp+12]
	comiss	xmm0, DWORD PTR y$[rsp]
	jbe	SHORT $LN8@stb_text_l

; 414  : 			return 0;

	xor	eax, eax
	jmp	$LN1@stb_text_l
$LN8@stb_text_l:

; 415  : 
; 416  : 		if (y < base_y + r.ymax)

	movss	xmm0, DWORD PTR base_y$[rsp]
	addss	xmm0, DWORD PTR r$[rsp+16]
	comiss	xmm0, DWORD PTR y$[rsp]
	jbe	SHORT $LN9@stb_text_l

; 417  : 			break;

	jmp	SHORT $LN3@stb_text_l
$LN9@stb_text_l:

; 418  : 
; 419  : 		i += r.num_chars;

	mov	eax, DWORD PTR r$[rsp+20]
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax

; 420  : 		base_y += r.baseline_y_delta;

	movss	xmm0, DWORD PTR base_y$[rsp]
	addss	xmm0, DWORD PTR r$[rsp+8]
	movss	DWORD PTR base_y$[rsp], xmm0

; 421  : 	}

	jmp	$LN2@stb_text_l
$LN3@stb_text_l:

; 422  : 
; 423  : 	// below all text, return 'after' last character
; 424  : 	if (i >= n)

	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jl	SHORT $LN10@stb_text_l

; 425  : 		return n;

	mov	eax, DWORD PTR n$[rsp]
	jmp	$LN1@stb_text_l
$LN10@stb_text_l:

; 426  : 
; 427  : 	// check if it's before the beginning of the line
; 428  : 	if (x < r.x0)

	movss	xmm0, DWORD PTR r$[rsp]
	comiss	xmm0, DWORD PTR x$[rsp]
	jbe	SHORT $LN11@stb_text_l

; 429  : 		return i;

	mov	eax, DWORD PTR i$[rsp]
	jmp	$LN1@stb_text_l
$LN11@stb_text_l:

; 430  : 
; 431  : 	// check if it's before the end of the line
; 432  : 	if (x < r.x1) {

	movss	xmm0, DWORD PTR r$[rsp+4]
	comiss	xmm0, DWORD PTR x$[rsp]
	jbe	$LN12@stb_text_l

; 433  : 		// search characters in row for one that straddles 'x'
; 434  : 		prev_x = r.x0;

	movss	xmm0, DWORD PTR r$[rsp]
	movss	DWORD PTR prev_x$[rsp], xmm0

; 435  : 		for (k = 0; k < r.num_chars; ++k) {

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN6@stb_text_l
$LN4@stb_text_l:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN6@stb_text_l:
	mov	eax, DWORD PTR r$[rsp+20]
	cmp	DWORD PTR k$[rsp], eax
	jge	$LN5@stb_text_l

; 436  : 			float w = STB_TEXTEDIT_GETWIDTH(str, i, k);

	mov	r8d, DWORD PTR k$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPEAUImGuiInputTextState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_GETWIDTH
	movss	DWORD PTR w$1[rsp], xmm0

; 437  : 			if (x < prev_x + w) {

	movss	xmm0, DWORD PTR prev_x$[rsp]
	addss	xmm0, DWORD PTR w$1[rsp]
	comiss	xmm0, DWORD PTR x$[rsp]
	jbe	SHORT $LN13@stb_text_l

; 438  : 				if (x < prev_x + w / 2)

	movss	xmm0, DWORD PTR w$1[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR prev_x$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	comiss	xmm0, DWORD PTR x$[rsp]
	jbe	SHORT $LN14@stb_text_l

; 439  : 					return k + i;

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR k$[rsp]
	add	ecx, eax
	mov	eax, ecx
	jmp	SHORT $LN1@stb_text_l
	jmp	SHORT $LN15@stb_text_l
$LN14@stb_text_l:

; 440  : 				else
; 441  : 					return k + i + 1;

	mov	eax, DWORD PTR k$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	jmp	SHORT $LN1@stb_text_l
$LN15@stb_text_l:
$LN13@stb_text_l:

; 442  : 			}
; 443  : 			prev_x += w;

	movss	xmm0, DWORD PTR prev_x$[rsp]
	addss	xmm0, DWORD PTR w$1[rsp]
	movss	DWORD PTR prev_x$[rsp], xmm0

; 444  : 		}

	jmp	$LN4@stb_text_l
$LN5@stb_text_l:
$LN12@stb_text_l:

; 445  : 		// shouldn't happen, but if it does, fall through to end-of-line case
; 446  : 	}
; 447  : 
; 448  : 	// if the last character is a newline, return that. otherwise return 'after' the last character
; 449  : 	if (STB_TEXTEDIT_GETCHAR(str, i + r.num_chars - 1) == STB_TEXTEDIT_NEWLINE)

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR r$[rsp+20]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	edx, eax
	mov	rcx, QWORD PTR str$[rsp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	movzx	eax, ax
	movzx	ecx, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImGuiStb@@3GA
	cmp	eax, ecx
	jne	SHORT $LN16@stb_text_l

; 450  : 		return i + r.num_chars - 1;

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR r$[rsp+20]
	lea	eax, DWORD PTR [rax+rcx-1]
	jmp	SHORT $LN1@stb_text_l
	jmp	SHORT $LN17@stb_text_l
$LN16@stb_text_l:

; 451  : 	else
; 452  : 		return i + r.num_chars;

	mov	eax, DWORD PTR r$[rsp+20]
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, eax
	mov	eax, ecx
$LN17@stb_text_l:
$LN1@stb_text_l:

; 453  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?stb_text_locate_coord@ImGuiStb@@YAHPEAUImGuiInputTextState@@MM@Z ENDP ; ImGuiStb::stb_text_locate_coord
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv66 = 0
tv67 = 4
v$ = 32
mn$ = 40
mx$ = 48
??$ImClamp@H@@YAHHHH@Z PROC				; ImClamp<int>

; 229  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	mov	eax, DWORD PTR mn$[rsp]
	cmp	DWORD PTR v$[rsp], eax
	jge	SHORT $LN5@ImClamp
	mov	eax, DWORD PTR mn$[rsp]
	mov	DWORD PTR tv67[rsp], eax
	jmp	SHORT $LN6@ImClamp
$LN5@ImClamp:
	mov	eax, DWORD PTR mx$[rsp]
	cmp	DWORD PTR v$[rsp], eax
	jle	SHORT $LN3@ImClamp
	mov	eax, DWORD PTR mx$[rsp]
	mov	DWORD PTR tv66[rsp], eax
	jmp	SHORT $LN4@ImClamp
$LN3@ImClamp:
	mov	eax, DWORD PTR v$[rsp]
	mov	DWORD PTR tv66[rsp], eax
$LN4@ImClamp:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR tv67[rsp], eax
$LN6@ImClamp:
	mov	eax, DWORD PTR tv67[rsp]
	add	rsp, 24
	ret	0
??$ImClamp@H@@YAHHHH@Z ENDP				; ImClamp<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv67 = 32
is_resizable$ = 33
text_len$ = 36
new_text_len_utf8$ = 40
text$ = 48
tv135 = 56
tv153 = 64
tv174 = 72
obj$ = 96
pos$ = 104
new_text$ = 112
new_text_len$ = 120
?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z PROC ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS

; 3396 : 	{

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 3397 : 		const bool is_resizable = (obj->UserFlags & ImGuiInputTextFlags_CallbackResize) != 0;

	mov	rax, QWORD PTR obj$[rsp]
	mov	eax, DWORD PTR [rax+3704]
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN7@STB_TEXTED
	mov	BYTE PTR tv67[rsp], 1
	jmp	SHORT $LN8@STB_TEXTED
$LN7@STB_TEXTED:
	mov	BYTE PTR tv67[rsp], 0
$LN8@STB_TEXTED:
	movzx	eax, BYTE PTR tv67[rsp]
	mov	BYTE PTR is_resizable$[rsp], al

; 3398 : 		const int text_len = obj->CurLenW;

	mov	rax, QWORD PTR obj$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR text_len$[rsp], eax

; 3399 : 		IM_ASSERT(pos <= text_len);
; 3400 : 
; 3401 : 		const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);

	movsxd	rax, DWORD PTR new_text_len$[rsp]
	mov	rcx, QWORD PTR new_text$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rdx, rax
	mov	rcx, QWORD PTR new_text$[rsp]
	call	?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z ; ImTextCountUtf8BytesFromStr
	mov	DWORD PTR new_text_len_utf8$[rsp], eax

; 3402 : 		if (!is_resizable && (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufCapacityA))

	movzx	eax, BYTE PTR is_resizable$[rsp]
	test	eax, eax
	jne	SHORT $LN2@STB_TEXTED
	mov	rax, QWORD PTR obj$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	ecx, DWORD PTR new_text_len_utf8$[rsp]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	rcx, QWORD PTR obj$[rsp]
	cmp	eax, DWORD PTR [rcx+76]
	jle	SHORT $LN2@STB_TEXTED

; 3403 : 			return false;

	xor	al, al
	jmp	$LN1@STB_TEXTED
$LN2@STB_TEXTED:

; 3404 : 
; 3405 : 		// Grow internal buffer if needed
; 3406 : 		if (new_text_len + text_len + 1 > obj->TextW.Size)

	mov	eax, DWORD PTR new_text_len$[rsp]
	mov	ecx, DWORD PTR text_len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	rcx, QWORD PTR obj$[rsp]
	cmp	eax, DWORD PTR [rcx+8]
	jle	SHORT $LN3@STB_TEXTED

; 3407 : 		{
; 3408 : 			if (!is_resizable)

	movzx	eax, BYTE PTR is_resizable$[rsp]
	test	eax, eax
	jne	SHORT $LN4@STB_TEXTED

; 3409 : 				return false;

	xor	al, al
	jmp	$LN1@STB_TEXTED
$LN4@STB_TEXTED:

; 3410 : 			IM_ASSERT(text_len < obj->TextW.Size);
; 3411 : 			obj->TextW.resize(text_len + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1);

	mov	rax, QWORD PTR obj$[rsp]
	add	rax, 8
	mov	QWORD PTR tv135[rsp], rax
	mov	edx, DWORD PTR new_text_len$[rsp]
	mov	ecx, 256				; 00000100H
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	ecx, DWORD PTR new_text_len$[rsp]
	shl	ecx, 2
	mov	r8d, eax
	mov	edx, 32					; 00000020H
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	ecx, DWORD PTR text_len$[rsp]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	edx, eax
	mov	rcx, QWORD PTR tv135[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize
	npad	1
$LN3@STB_TEXTED:

; 3412 : 		}
; 3413 : 
; 3414 : 		ImWchar* text = obj->TextW.Data;

	mov	rax, QWORD PTR obj$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR text$[rsp], rax

; 3415 : 		if (pos != text_len)

	mov	eax, DWORD PTR text_len$[rsp]
	cmp	DWORD PTR pos$[rsp], eax
	je	SHORT $LN5@STB_TEXTED

; 3416 : 			memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));

	mov	eax, DWORD PTR pos$[rsp]
	mov	ecx, DWORD PTR text_len$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cdqe
	shl	rax, 1
	movsxd	rcx, DWORD PTR pos$[rsp]
	mov	rdx, QWORD PTR text$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx*2]
	movsxd	rdx, DWORD PTR pos$[rsp]
	mov	r8, QWORD PTR text$[rsp]
	lea	rdx, QWORD PTR [r8+rdx*2]
	movsxd	r8, DWORD PTR new_text_len$[rsp]
	lea	rdx, QWORD PTR [rdx+r8*2]
	mov	QWORD PTR tv153[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv153[rsp]
	mov	rcx, rax
	call	memmove
	npad	1
$LN5@STB_TEXTED:

; 3417 : 		memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));

	movsxd	rax, DWORD PTR new_text_len$[rsp]
	shl	rax, 1
	movsxd	rcx, DWORD PTR pos$[rsp]
	mov	rdx, QWORD PTR text$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx*2]
	mov	r8, rax
	mov	rdx, QWORD PTR new_text$[rsp]
	call	memcpy

; 3418 : 
; 3419 : 		obj->CurLenW += new_text_len;

	mov	rax, QWORD PTR obj$[rsp]
	mov	eax, DWORD PTR [rax+32]
	add	eax, DWORD PTR new_text_len$[rsp]
	mov	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 3420 : 		obj->CurLenA += new_text_len_utf8;

	mov	rax, QWORD PTR obj$[rsp]
	mov	eax, DWORD PTR [rax+28]
	add	eax, DWORD PTR new_text_len_utf8$[rsp]
	mov	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 3421 : 		obj->TextW[obj->CurLenW] = '\0';

	mov	rax, QWORD PTR obj$[rsp]
	add	rax, 8
	mov	QWORD PTR tv174[rsp], rax
	mov	rax, QWORD PTR obj$[rsp]
	mov	edx, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR tv174[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	xor	ecx, ecx
	mov	WORD PTR [rax], cx

; 3422 : 
; 3423 : 		return true;

	mov	al, 1
$LN1@STB_TEXTED:

; 3424 : 	}

	add	rsp, 88					; 00000058H
	ret	0
?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ENDP ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
c$1 = 32
tv95 = 36
tv80 = 40
tv78 = 44
dst$ = 48
src$ = 56
obj$ = 80
pos$ = 88
n$ = 96
?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPEAUImGuiInputTextState@@HH@Z PROC ; ImGuiStb::STB_TEXTEDIT_DELETECHARS

; 3381 : 	{

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3382 : 		ImWchar* dst = obj->TextW.Data + pos;

	movsxd	rax, DWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR obj$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR dst$[rsp], rax

; 3383 : 
; 3384 : 		// We maintain our buffer length in both UTF-8 and wchar formats
; 3385 : 		obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rdx, rax
	mov	rcx, QWORD PTR dst$[rsp]
	call	?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z ; ImTextCountUtf8BytesFromStr
	mov	DWORD PTR tv80[rsp], eax
	mov	rax, QWORD PTR obj$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR tv78[rsp], eax
	mov	eax, DWORD PTR tv80[rsp]
	mov	ecx, DWORD PTR tv78[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 3386 : 		obj->CurLenW -= n;

	mov	rax, QWORD PTR obj$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	mov	eax, DWORD PTR [rax+32]
	sub	eax, ecx
	mov	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 3387 : 
; 3388 : 		// Offset remaining text (FIXME-OPT: Use memmove)
; 3389 : 		const ImWchar* src = obj->TextW.Data + pos + n;

	movsxd	rax, DWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR obj$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [rcx+rax*2]
	movsxd	rcx, DWORD PTR n$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR src$[rsp], rax
$LN2@STB_TEXTED:

; 3390 : 		while (ImWchar c = *src++)

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv95[rsp], ax
	mov	rax, QWORD PTR src$[rsp]
	add	rax, 2
	mov	QWORD PTR src$[rsp], rax
	movzx	eax, WORD PTR tv95[rsp]
	mov	WORD PTR c$1[rsp], ax
	movzx	eax, WORD PTR c$1[rsp]
	test	eax, eax
	je	SHORT $LN3@STB_TEXTED

; 3391 : 			*dst++ = c;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, WORD PTR c$1[rsp]
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR dst$[rsp]
	add	rax, 2
	mov	QWORD PTR dst$[rsp], rax
	jmp	SHORT $LN2@STB_TEXTED
$LN3@STB_TEXTED:

; 3392 : 		*dst = '\0';

	xor	eax, eax
	mov	rcx, QWORD PTR dst$[rsp]
	mov	WORD PTR [rcx], ax

; 3393 : 	}

	add	rsp, 72					; 00000048H
	ret	0
?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPEAUImGuiInputTextState@@HH@Z ENDP ; ImGuiStb::STB_TEXTEDIT_DELETECHARS
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
len$ = 32
tv73 = 36
obj$ = 64
idx$ = 72
?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z PROC ; ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

; 3375 : 	static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx) { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	eax, DWORD PTR idx$[rsp]
	inc	eax
	mov	DWORD PTR idx$[rsp], eax
	mov	rax, QWORD PTR obj$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR len$[rsp], eax
$LN2@STB_TEXTED:
	mov	eax, DWORD PTR len$[rsp]
	cmp	DWORD PTR idx$[rsp], eax
	jge	SHORT $LN3@STB_TEXTED
	mov	edx, DWORD PTR idx$[rsp]
	mov	rcx, QWORD PTR obj$[rsp]
	call	?is_word_boundary_from_right@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImGuiStb::is_word_boundary_from_right
	test	eax, eax
	jne	SHORT $LN3@STB_TEXTED
	mov	eax, DWORD PTR idx$[rsp]
	inc	eax
	mov	DWORD PTR idx$[rsp], eax
	jmp	SHORT $LN2@STB_TEXTED
$LN3@STB_TEXTED:
	mov	eax, DWORD PTR len$[rsp]
	cmp	DWORD PTR idx$[rsp], eax
	jle	SHORT $LN5@STB_TEXTED
	mov	eax, DWORD PTR len$[rsp]
	mov	DWORD PTR tv73[rsp], eax
	jmp	SHORT $LN6@STB_TEXTED
$LN5@STB_TEXTED:
	mov	eax, DWORD PTR idx$[rsp]
	mov	DWORD PTR tv73[rsp], eax
$LN6@STB_TEXTED:
	mov	eax, DWORD PTR tv73[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z ENDP ; ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv72 = 32
obj$ = 64
idx$ = 72
?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z PROC ; ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL

; 3370 : 	static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx) { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	eax, DWORD PTR idx$[rsp]
	dec	eax
	mov	DWORD PTR idx$[rsp], eax
$LN2@STB_TEXTED:
	cmp	DWORD PTR idx$[rsp], 0
	jl	SHORT $LN3@STB_TEXTED
	mov	edx, DWORD PTR idx$[rsp]
	mov	rcx, QWORD PTR obj$[rsp]
	call	?is_word_boundary_from_right@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImGuiStb::is_word_boundary_from_right
	test	eax, eax
	jne	SHORT $LN3@STB_TEXTED
	mov	eax, DWORD PTR idx$[rsp]
	dec	eax
	mov	DWORD PTR idx$[rsp], eax
	jmp	SHORT $LN2@STB_TEXTED
$LN3@STB_TEXTED:
	cmp	DWORD PTR idx$[rsp], 0
	jge	SHORT $LN5@STB_TEXTED
	mov	DWORD PTR tv72[rsp], 0
	jmp	SHORT $LN6@STB_TEXTED
$LN5@STB_TEXTED:
	mov	eax, DWORD PTR idx$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@STB_TEXTED:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z ENDP ; ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv88 = 32
tv89 = 36
tv72 = 40
tv81 = 48
obj$ = 80
idx$ = 88
?is_word_boundary_from_right@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z PROC ; ImGuiStb::is_word_boundary_from_right

; 3369 : 	static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx) { return idx > 0 ? (is_separator(obj->TextW[idx - 1]) && !is_separator(obj->TextW[idx])) : 1; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	cmp	DWORD PTR idx$[rsp], 0
	jle	SHORT $LN5@is_word_bo
	mov	rax, QWORD PTR obj$[rsp]
	add	rax, 8
	mov	QWORD PTR tv72[rsp], rax
	mov	eax, DWORD PTR idx$[rsp]
	dec	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv72[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	movzx	eax, WORD PTR [rax]
	mov	ecx, eax
	call	?is_separator@ImGuiStb@@YA_NI@Z		; ImGuiStb::is_separator
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@is_word_bo
	mov	rax, QWORD PTR obj$[rsp]
	add	rax, 8
	mov	QWORD PTR tv81[rsp], rax
	mov	edx, DWORD PTR idx$[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	movzx	eax, WORD PTR [rax]
	mov	ecx, eax
	call	?is_separator@ImGuiStb@@YA_NI@Z		; ImGuiStb::is_separator
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@is_word_bo
	mov	DWORD PTR tv88[rsp], 1
	jmp	SHORT $LN4@is_word_bo
$LN3@is_word_bo:
	mov	DWORD PTR tv88[rsp], 0
$LN4@is_word_bo:
	mov	eax, DWORD PTR tv88[rsp]
	mov	DWORD PTR tv89[rsp], eax
	jmp	SHORT $LN6@is_word_bo
$LN5@is_word_bo:
	mov	DWORD PTR tv89[rsp], 1
$LN6@is_word_bo:
	mov	eax, DWORD PTR tv89[rsp]
	add	rsp, 72					; 00000048H
	ret	0
?is_word_boundary_from_right@ImGuiStb@@YAHPEAUImGuiInputTextState@@H@Z ENDP ; ImGuiStb::is_word_boundary_from_right
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv77 = 32
c$ = 64
?is_separator@ImGuiStb@@YA_NI@Z PROC			; ImGuiStb::is_separator

; 3368 : 	static bool is_separator(unsigned int c) { return ImCharIsBlankW(c) || c == ',' || c == ';' || c == '(' || c == ')' || c == '{' || c == '}' || c == '[' || c == ']' || c == '|'; }

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	mov	ecx, DWORD PTR c$[rsp]
	call	?ImCharIsBlankW@@YA_NI@Z		; ImCharIsBlankW
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@is_separat
	cmp	DWORD PTR c$[rsp], 44			; 0000002cH
	je	SHORT $LN3@is_separat
	cmp	DWORD PTR c$[rsp], 59			; 0000003bH
	je	SHORT $LN3@is_separat
	cmp	DWORD PTR c$[rsp], 40			; 00000028H
	je	SHORT $LN3@is_separat
	cmp	DWORD PTR c$[rsp], 41			; 00000029H
	je	SHORT $LN3@is_separat
	cmp	DWORD PTR c$[rsp], 123			; 0000007bH
	je	SHORT $LN3@is_separat
	cmp	DWORD PTR c$[rsp], 125			; 0000007dH
	je	SHORT $LN3@is_separat
	cmp	DWORD PTR c$[rsp], 91			; 0000005bH
	je	SHORT $LN3@is_separat
	cmp	DWORD PTR c$[rsp], 93			; 0000005dH
	je	SHORT $LN3@is_separat
	cmp	DWORD PTR c$[rsp], 124			; 0000007cH
	je	SHORT $LN3@is_separat
	mov	DWORD PTR tv77[rsp], 0
	jmp	SHORT $LN4@is_separat
$LN3@is_separat:
	mov	DWORD PTR tv77[rsp], 1
$LN4@is_separat:
	movzx	eax, BYTE PTR tv77[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?is_separator@ImGuiStb@@YA_NI@Z ENDP			; ImGuiStb::is_separator
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
size$ = 48
text$ = 56
text_remaining$ = 64
r$ = 96
obj$ = 104
line_start_idx$ = 112
?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z PROC ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 3356 : 	{

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 3357 : 		const ImWchar* text = obj->TextW.Data;

	mov	rax, QWORD PTR obj$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR text$[rsp], rax

; 3358 : 		const ImWchar* text_remaining = NULL;

	mov	QWORD PTR text_remaining$[rsp], 0

; 3359 : 		const ImVec2 size = InputTextCalcTextSizeW(text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);

	mov	rax, QWORD PTR obj$[rsp]
	movsxd	rax, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR text$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	movsxd	rcx, DWORD PTR line_start_idx$[rsp]
	mov	rdx, QWORD PTR text$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx*2]
	mov	BYTE PTR [rsp+40], 1
	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR text_remaining$[rsp]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR size$[rsp]
	call	?InputTextCalcTextSizeW@@YA?AUImVec2@@PEBG0PEAPEBGPEAU1@_N@Z ; InputTextCalcTextSizeW

; 3360 : 		r->x0 = 0.0f;

	mov	rax, QWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0

; 3361 : 		r->x1 = size.x;

	mov	rax, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR size$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 3362 : 		r->baseline_y_delta = size.y;

	mov	rax, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR size$[rsp+4]
	movss	DWORD PTR [rax+8], xmm0

; 3363 : 		r->ymin = 0.0f;

	mov	rax, QWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+12], xmm0

; 3364 : 		r->ymax = size.y;

	mov	rax, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR size$[rsp+4]
	movss	DWORD PTR [rax+16], xmm0

; 3365 : 		r->num_chars = (int)(text_remaining - (text + line_start_idx));

	movsxd	rax, DWORD PTR line_start_idx$[rsp]
	mov	rcx, QWORD PTR text$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rcx, QWORD PTR text_remaining$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 1
	mov	rcx, QWORD PTR r$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 3366 : 	}

	add	rsp, 88					; 00000058H
	ret	0
?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ENDP ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv65 = 0
key$ = 32
?STB_TEXTEDIT_KEYTOTEXT@ImGuiStb@@YAHH@Z PROC		; ImGuiStb::STB_TEXTEDIT_KEYTOTEXT

; 3353 : 	static int     STB_TEXTEDIT_KEYTOTEXT(int key) { return key >= 0x10000 ? 0 : key; }

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	cmp	DWORD PTR key$[rsp], 65536		; 00010000H
	jl	SHORT $LN3@STB_TEXTED
	mov	DWORD PTR tv65[rsp], 0
	jmp	SHORT $LN4@STB_TEXTED
$LN3@STB_TEXTED:
	mov	eax, DWORD PTR key$[rsp]
	mov	DWORD PTR tv65[rsp], eax
$LN4@STB_TEXTED:
	mov	eax, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
?STB_TEXTEDIT_KEYTOTEXT@ImGuiStb@@YAHH@Z ENDP		; ImGuiStb::STB_TEXTEDIT_KEYTOTEXT
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
c$ = 32
tv70 = 40
tv78 = 48
obj$ = 80
line_start_idx$ = 88
char_idx$ = 96
?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPEAUImGuiInputTextState@@HH@Z PROC ; ImGuiStb::STB_TEXTEDIT_GETWIDTH

; 3352 : 	static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx) { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR obj$[rsp]
	add	rax, 8
	mov	QWORD PTR tv70[rsp], rax
	mov	eax, DWORD PTR char_idx$[rsp]
	mov	ecx, DWORD PTR line_start_idx$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR tv70[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR c$[rsp], ax
	movzx	eax, WORD PTR c$[rsp]
	cmp	eax, 10
	jne	SHORT $LN2@STB_TEXTED
	movss	xmm0, DWORD PTR __real@bf800000
	jmp	SHORT $LN1@STB_TEXTED
$LN2@STB_TEXTED:
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv78[rsp], rax
	movzx	edx, WORD PTR c$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	?GetCharAdvance@ImFont@@QEBAMG@Z	; ImFont::GetCharAdvance
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rcx+6408]
	divss	xmm1, DWORD PTR [rax+20]
	mulss	xmm0, xmm1
$LN1@STB_TEXTED:
	add	rsp, 72					; 00000048H
	ret	0
?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPEAUImGuiInputTextState@@HH@Z ENDP ; ImGuiStb::STB_TEXTEDIT_GETWIDTH
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv69 = 32
obj$ = 64
idx$ = 72
?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z PROC ; ImGuiStb::STB_TEXTEDIT_GETCHAR

; 3351 : 	static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx) { return obj->TextW[idx]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR obj$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	edx, DWORD PTR idx$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??A?$ImVector@G@@QEBAAEBGH@Z		; ImVector<unsigned short>::operator[]
	movzx	eax, WORD PTR [rax]
	add	rsp, 56					; 00000038H
	ret	0
?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPEBUImGuiInputTextState@@H@Z ENDP ; ImGuiStb::STB_TEXTEDIT_GETCHAR
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
obj$ = 8
?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPEBUImGuiInputTextState@@@Z PROC ; ImGuiStb::STB_TEXTEDIT_STRINGLEN

; 3350 : 	static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj) { return obj->CurLenW; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR obj$[rsp]
	mov	eax, DWORD PTR [rax+32]
	ret	0
?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPEBUImGuiInputTextState@@@Z ENDP ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
user_data$ = 32
str$1 = 40
tv84 = 48
data$ = 80
?InputTextCallback@@YAHPEAUImGuiInputTextCallbackData@@@Z PROC ; InputTextCallback

; 3232 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3233 : 	InputTextCallback_UserData* user_data = (InputTextCallback_UserData*)data->UserData;

	mov	rax, QWORD PTR data$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR user_data$[rsp], rax

; 3234 : 	if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)

	mov	rax, QWORD PTR data$[rsp]
	cmp	DWORD PTR [rax+4], 262144		; 00040000H
	jne	SHORT $LN2@InputTextC

; 3235 : 	{
; 3236 : 		// Resize string callback
; 3237 : 		// If for some reason we refuse the new length (BufTextLen) and/or capacity (BufSize) we need to set them back to what we want.
; 3238 : 		std::string* str = user_data->Str;

	mov	rax, QWORD PTR user_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR str$1[rsp], rax

; 3239 : 		IM_ASSERT(data->Buf == str->c_str());
; 3240 : 		str->resize(data->BufTextLen);

	mov	rax, QWORD PTR data$[rsp]
	movsxd	rax, DWORD PTR [rax+36]
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, QWORD PTR str$1[rsp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 3241 : 		data->Buf = (char*)str->c_str();

	mov	rcx, QWORD PTR str$1[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 3242 : 	}

	jmp	SHORT $LN3@InputTextC
$LN2@InputTextC:

; 3243 : 	else if (user_data->ChainCallback)

	mov	rax, QWORD PTR user_data$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN4@InputTextC

; 3244 : 	{
; 3245 : 		// Forward to user callback, if any
; 3246 : 		data->UserData = user_data->ChainCallbackUserData;

	mov	rax, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR user_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+8], rcx

; 3247 : 		return user_data->ChainCallback(data);

	mov	rax, QWORD PTR user_data$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv84[rsp], rax
	mov	rcx, QWORD PTR data$[rsp]
	call	QWORD PTR tv84[rsp]
	jmp	SHORT $LN1@InputTextC
$LN4@InputTextC:
$LN3@InputTextC:

; 3248 : 	}
; 3249 : 	return 0;

	xor	eax, eax
$LN1@InputTextC:

; 3250 : }

	add	rsp, 72					; 00000048H
	ret	0
?InputTextCallback@@YAHPEAUImGuiInputTextCallbackData@@@Z ENDP ; InputTextCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
v$ = 0
negative$ = 4
tv83 = 8
tv80 = 12
src$ = 32
output$ = 40
??$ImAtoi@H@@YAPEBDPEBDPEAH@Z PROC			; ImAtoi<int>

; 2030 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2031 : 	int negative = 0;

	mov	DWORD PTR negative$[rsp], 0

; 2032 : 	if (*src == '-') { negative = 1; src++; }

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN4@ImAtoi
	mov	DWORD PTR negative$[rsp], 1
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN4@ImAtoi:

; 2033 : 	if (*src == '+') { src++; }

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN5@ImAtoi
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN5@ImAtoi:

; 2034 : 	TYPE v = 0;

	mov	DWORD PTR v$[rsp], 0
$LN2@ImAtoi:

; 2035 : 	while (*src >= '0' && *src <= '9')

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@ImAtoi
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN3@ImAtoi

; 2036 : 		v = (v * 10) + (*src++ - '0');

	imul	eax, DWORD PTR v$[rsp], 10
	mov	rcx, QWORD PTR src$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	lea	eax, DWORD PTR [rax+rcx-48]
	mov	DWORD PTR tv80[rsp], eax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
	mov	eax, DWORD PTR tv80[rsp]
	mov	DWORD PTR v$[rsp], eax
	jmp	SHORT $LN2@ImAtoi
$LN3@ImAtoi:

; 2037 : 	*output = negative ? -v : v;

	cmp	DWORD PTR negative$[rsp], 0
	je	SHORT $LN7@ImAtoi
	mov	eax, DWORD PTR v$[rsp]
	neg	eax
	mov	DWORD PTR tv83[rsp], eax
	jmp	SHORT $LN8@ImAtoi
$LN7@ImAtoi:
	mov	eax, DWORD PTR v$[rsp]
	mov	DWORD PTR tv83[rsp], eax
$LN8@ImAtoi:
	mov	rax, QWORD PTR output$[rsp]
	mov	ecx, DWORD PTR tv83[rsp]
	mov	DWORD PTR [rax], ecx

; 2038 : 	return src;

	mov	rax, QWORD PTR src$[rsp]

; 2039 : }

	add	rsp, 24
	ret	0
??$ImAtoi@H@@YAPEBDPEBDPEAH@Z ENDP			; ImAtoi<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMin@_K@@YA_K_K0@Z PROC				; ImMin<unsigned __int64>

; 227  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR rhs$[rsp]
	cmp	QWORD PTR lhs$[rsp], rax
	jae	SHORT $LN3@ImMin
	mov	rax, QWORD PTR lhs$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@ImMin
$LN3@ImMin:
	mov	rax, QWORD PTR rhs$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@ImMin:
	mov	rax, QWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMin@_K@@YA_K_K0@Z ENDP				; ImMin<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$SliderBehaviorT@NNN@ImGui@@YA_NAEBUImRect@@IHPEANNNPEBDMHPEAU1@@Z
_TEXT	SEGMENT
is_decimal$ = 48
set_new_value$1 = 49
is_power$ = 50
delta$2 = 52
clicked_t$3 = 56
tv70 = 60
tv74 = 61
value_changed$ = 62
grab_sz$ = 64
axis$ = 68
linear_zero_pos$ = 72
a$4 = 76
grab_pos$ = 80
v_new$5 = 88
g$ = 96
slider_sz$ = 104
a$6 = 108
grab_t$ = 112
tv67 = 116
tv193 = 120
slider_usable_sz$ = 124
tv219 = 128
tv250 = 132
tv299 = 136
slider_usable_pos_min$ = 140
v_range$ = 144
tv231 = 152
tv84 = 156
tv398 = 160
tv415 = 164
mouse_abs_pos$7 = 168
decimal_precision$8 = 172
slider_usable_pos_max$ = 176
tv95 = 184
style$ = 192
tv174 = 200
tv184 = 208
linear_dist_min_to_0$9 = 216
delta2$10 = 224
v_new_off_f$11 = 232
v_new_off_round$12 = 240
v_new_off_floor$13 = 248
grab_padding$ = 256
tv88 = 264
tv81 = 272
tv150 = 280
tv160 = 288
tv177 = 296
tv187 = 304
linear_dist_max_to_0$14 = 312
tv211 = 320
$T15 = 328
$T16 = 344
bb$ = 400
id$ = 408
data_type$ = 416
v$ = 424
v_min$ = 432
v_max$ = 440
format$ = 448
power$ = 456
flags$ = 464
out_grab_bb$ = 472
??$SliderBehaviorT@NNN@ImGui@@YA_NAEBUImRect@@IHPEANNNPEBDMHPEAU1@@Z PROC ; ImGui::SliderBehaviorT<double,double,double>, COMDAT

; 2455 : {

$LN69:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 376				; 00000178H

; 2456 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2457 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 2458 : 
; 2459 : 	const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN44@SliderBeha
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN45@SliderBeha
$LN44@SliderBeha:
	mov	DWORD PTR tv67[rsp], 0
$LN45@SliderBeha:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR axis$[rsp], eax

; 2460 : 	const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN46@SliderBeha
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN46@SliderBeha
	mov	BYTE PTR tv70[rsp], 0
	jmp	SHORT $LN47@SliderBeha
$LN46@SliderBeha:
	mov	BYTE PTR tv70[rsp], 1
$LN47@SliderBeha:
	movzx	eax, BYTE PTR tv70[rsp]
	mov	BYTE PTR is_decimal$[rsp], al

; 2461 : 	const bool is_power = (power != 1.0f) && is_decimal;

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN68@SliderBeha
	je	SHORT $LN48@SliderBeha
$LN68@SliderBeha:
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN48@SliderBeha
	mov	BYTE PTR tv74[rsp], 1
	jmp	SHORT $LN49@SliderBeha
$LN48@SliderBeha:
	mov	BYTE PTR tv74[rsp], 0
$LN49@SliderBeha:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2462 : 
; 2463 : 	const float grab_padding = 2.0f;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR grab_padding$[rsp], xmm0

; 2464 : 	const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	QWORD PTR tv81[rsp], rax
	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv88[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv88[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	movss	DWORD PTR tv84[rsp], xmm0
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv81[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	movss	xmm1, DWORD PTR tv84[rsp]
	subss	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR slider_sz$[rsp], xmm0

; 2465 : 	float grab_sz = style.GrabMinSize;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+108]
	movss	DWORD PTR grab_sz$[rsp], xmm0

; 2466 : 	SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);

	movsd	xmm0, QWORD PTR v_max$[rsp]
	comisd	xmm0, QWORD PTR v_min$[rsp]
	jbe	SHORT $LN50@SliderBeha
	movsd	xmm0, QWORD PTR v_max$[rsp]
	subsd	xmm0, QWORD PTR v_min$[rsp]
	movsd	QWORD PTR tv95[rsp], xmm0
	jmp	SHORT $LN51@SliderBeha
$LN50@SliderBeha:
	movsd	xmm0, QWORD PTR v_min$[rsp]
	subsd	xmm0, QWORD PTR v_max$[rsp]
	movsd	QWORD PTR tv95[rsp], xmm0
$LN51@SliderBeha:
	movsd	xmm0, QWORD PTR tv95[rsp]
	movsd	QWORD PTR v_range$[rsp], xmm0

; 2467 : 	if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN2@SliderBeha
	movsd	xmm0, QWORD PTR v_range$[rsp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN2@SliderBeha

; 2468 : 		grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit

	cvtss2sd xmm0, DWORD PTR slider_sz$[rsp]
	movsd	xmm1, QWORD PTR v_range$[rsp]
	addsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+108]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR grab_sz$[rsp], xmm0
$LN2@SliderBeha:

; 2469 : 	grab_sz = ImMin(grab_sz, slider_sz);

	movss	xmm1, DWORD PTR slider_sz$[rsp]
	movss	xmm0, DWORD PTR grab_sz$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR grab_sz$[rsp], xmm0

; 2470 : 	const float slider_usable_sz = slider_sz - grab_sz;

	movss	xmm0, DWORD PTR slider_sz$[rsp]
	subss	xmm0, DWORD PTR grab_sz$[rsp]
	movss	DWORD PTR slider_usable_sz$[rsp], xmm0

; 2471 : 	const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;

	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv150[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv150[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	addss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	movss	DWORD PTR slider_usable_pos_min$[rsp], xmm0

; 2472 : 	const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	QWORD PTR tv160[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv160[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	movss	DWORD PTR slider_usable_pos_max$[rsp], xmm0

; 2473 : 
; 2474 : 	// For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
; 2475 : 	float linear_zero_pos;   // 0.0->1.0f
; 2476 : 	if (is_power && v_min * v_max < 0.0f)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN3@SliderBeha
	movsd	xmm0, QWORD PTR v_min$[rsp]
	mulsd	xmm0, QWORD PTR v_max$[rsp]
	xorps	xmm1, xmm1
	comisd	xmm1, xmm0
	jbe	$LN3@SliderBeha

; 2477 : 	{
; 2478 : 		// Different sign
; 2479 : 		const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);

	cvtss2sd xmm0, DWORD PTR power$[rsp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR tv177[rsp], xmm0
	movsd	xmm0, QWORD PTR v_min$[rsp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN52@SliderBeha
	movsd	xmm0, QWORD PTR v_min$[rsp]
	movsd	QWORD PTR tv174[rsp], xmm0
	jmp	SHORT $LN53@SliderBeha
$LN52@SliderBeha:
	movsd	xmm0, QWORD PTR v_min$[rsp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR tv174[rsp], xmm0
$LN53@SliderBeha:
	movsd	xmm1, QWORD PTR tv177[rsp]
	movsd	xmm0, QWORD PTR tv174[rsp]
	call	?ImPow@@YANNN@Z				; ImPow
	movsd	QWORD PTR linear_dist_min_to_0$9[rsp], xmm0

; 2480 : 		const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);

	cvtss2sd xmm0, DWORD PTR power$[rsp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR tv187[rsp], xmm0
	movsd	xmm0, QWORD PTR v_max$[rsp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN54@SliderBeha
	movsd	xmm0, QWORD PTR v_max$[rsp]
	movsd	QWORD PTR tv184[rsp], xmm0
	jmp	SHORT $LN55@SliderBeha
$LN54@SliderBeha:
	movsd	xmm0, QWORD PTR v_max$[rsp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR tv184[rsp], xmm0
$LN55@SliderBeha:
	movsd	xmm1, QWORD PTR tv187[rsp]
	movsd	xmm0, QWORD PTR tv184[rsp]
	call	?ImPow@@YANNN@Z				; ImPow
	movsd	QWORD PTR linear_dist_max_to_0$14[rsp], xmm0

; 2481 : 		linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));

	movsd	xmm0, QWORD PTR linear_dist_min_to_0$9[rsp]
	addsd	xmm0, QWORD PTR linear_dist_max_to_0$14[rsp]
	movsd	xmm1, QWORD PTR linear_dist_min_to_0$9[rsp]
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR linear_zero_pos$[rsp], xmm0

; 2482 : 	}

	jmp	SHORT $LN4@SliderBeha
$LN3@SliderBeha:

; 2483 : 	else
; 2484 : 	{
; 2485 : 		// Same sign
; 2486 : 		linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR v_min$[rsp]
	jbe	SHORT $LN56@SliderBeha
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv193[rsp], xmm0
	jmp	SHORT $LN57@SliderBeha
$LN56@SliderBeha:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv193[rsp], xmm0
$LN57@SliderBeha:
	movss	xmm0, DWORD PTR tv193[rsp]
	movss	DWORD PTR linear_zero_pos$[rsp], xmm0
$LN4@SliderBeha:

; 2487 : 	}
; 2488 : 
; 2489 : 	// Process interacting with the slider
; 2490 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 2491 : 	if (g.ActiveId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	$LN5@SliderBeha

; 2492 : 	{
; 2493 : 		bool set_new_value = false;

	mov	BYTE PTR set_new_value$1[rsp], 0

; 2494 : 		float clicked_t = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2495 : 		if (g.ActiveIdSource == ImGuiInputSource_Mouse)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN6@SliderBeha

; 2496 : 		{
; 2497 : 			if (!g.IO.MouseDown[0])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	jne	SHORT $LN8@SliderBeha

; 2498 : 			{
; 2499 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 2500 : 			}

	jmp	$LN9@SliderBeha
$LN8@SliderBeha:

; 2501 : 			else
; 2502 : 			{
; 2503 : 				const float mouse_abs_pos = g.IO.MousePos[axis];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	QWORD PTR tv211[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv211[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR mouse_abs_pos$7[rsp], xmm0

; 2504 : 				clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

	movss	xmm0, DWORD PTR slider_usable_sz$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN58@SliderBeha
	movss	xmm0, DWORD PTR mouse_abs_pos$7[rsp]
	subss	xmm0, DWORD PTR slider_usable_pos_min$[rsp]
	divss	xmm0, DWORD PTR slider_usable_sz$[rsp]
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR tv219[rsp], xmm0
	jmp	SHORT $LN59@SliderBeha
$LN58@SliderBeha:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv219[rsp], xmm0
$LN59@SliderBeha:
	movss	xmm0, DWORD PTR tv219[rsp]
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2505 : 				if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN10@SliderBeha

; 2506 : 					clicked_t = 1.0f - clicked_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR clicked_t$3[rsp], xmm0
$LN10@SliderBeha:

; 2507 : 				set_new_value = true;

	mov	BYTE PTR set_new_value$1[rsp], 1
$LN9@SliderBeha:

; 2508 : 			}
; 2509 : 		}

	jmp	$LN7@SliderBeha
$LN6@SliderBeha:

; 2510 : 		else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	$LN11@SliderBeha

; 2511 : 		{
; 2512 : 			const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	mov	r8d, 5
	mov	edx, 3
	lea	rcx, QWORD PTR delta2$10[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d

; 2513 : 			float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;

	cmp	DWORD PTR axis$[rsp], 0
	jne	SHORT $LN60@SliderBeha
	movss	xmm0, DWORD PTR delta2$10[rsp]
	movss	DWORD PTR tv231[rsp], xmm0
	jmp	SHORT $LN61@SliderBeha
$LN60@SliderBeha:
	movss	xmm0, DWORD PTR delta2$10[rsp+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv231[rsp], xmm0
$LN61@SliderBeha:
	movss	xmm0, DWORD PTR tv231[rsp]
	movss	DWORD PTR delta$2[rsp], xmm0

; 2514 : 			if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7036], ecx
	jne	SHORT $LN12@SliderBeha
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	test	eax, eax
	jne	SHORT $LN12@SliderBeha

; 2515 : 			{
; 2516 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 2517 : 			}

	jmp	$LN13@SliderBeha
$LN12@SliderBeha:

; 2518 : 			else if (delta != 0.0f)

	movss	xmm0, DWORD PTR delta$2[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN67@SliderBeha
	je	$LN14@SliderBeha
$LN67@SliderBeha:

; 2519 : 			{
; 2520 : 				clicked_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movsd	xmm3, QWORD PTR v_max$[rsp]
	movsd	xmm2, QWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm1, QWORD PTR [rax]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z ; ImGui::SliderCalcRatioFromValueT<double,double>
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2521 : 				const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN62@SliderBeha
	mov	edx, 3
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	DWORD PTR tv250[rsp], eax
	jmp	SHORT $LN63@SliderBeha
$LN62@SliderBeha:
	mov	DWORD PTR tv250[rsp], 0
$LN63@SliderBeha:
	mov	eax, DWORD PTR tv250[rsp]
	mov	DWORD PTR decimal_precision$8[rsp], eax

; 2522 : 				if ((decimal_precision > 0) || is_power)

	cmp	DWORD PTR decimal_precision$8[rsp], 0
	jg	SHORT $LN17@SliderBeha
	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN15@SliderBeha
$LN17@SliderBeha:

; 2523 : 				{
; 2524 : 					delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR delta$2[rsp], xmm0

; 2525 : 					if (IsNavInputDown(ImGuiNavInput_TweakSlow))

	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@SliderBeha

; 2526 : 						delta /= 10.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN18@SliderBeha:

; 2527 : 				}

	jmp	$LN16@SliderBeha
$LN15@SliderBeha:

; 2528 : 				else
; 2529 : 				{
; 2530 : 					if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))

	movsd	xmm0, QWORD PTR v_range$[rsp]
	comisd	xmm0, QWORD PTR __real@c059000000000000
	jb	SHORT $LN22@SliderBeha
	movsd	xmm0, QWORD PTR __real@4059000000000000
	comisd	xmm0, QWORD PTR v_range$[rsp]
	jae	SHORT $LN21@SliderBeha
$LN22@SliderBeha:
	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@SliderBeha
$LN21@SliderBeha:

; 2531 : 						delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta$2[rsp]
	jbe	SHORT $LN64@SliderBeha
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv299[rsp], xmm0
	jmp	SHORT $LN65@SliderBeha
$LN64@SliderBeha:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv299[rsp], xmm0
$LN65@SliderBeha:
	cvtsd2ss xmm0, QWORD PTR v_range$[rsp]
	movss	xmm1, DWORD PTR tv299[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR delta$2[rsp], xmm0
	jmp	SHORT $LN20@SliderBeha
$LN19@SliderBeha:

; 2532 : 					else
; 2533 : 						delta /= 100.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN20@SliderBeha:
$LN16@SliderBeha:

; 2534 : 				}
; 2535 : 				if (IsNavInputDown(ImGuiNavInput_TweakFast))

	mov	ecx, 15
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@SliderBeha

; 2536 : 					delta *= 10.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN23@SliderBeha:

; 2537 : 				set_new_value = true;

	mov	BYTE PTR set_new_value$1[rsp], 1

; 2538 : 				if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN27@SliderBeha
	movss	xmm0, DWORD PTR delta$2[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN26@SliderBeha
$LN27@SliderBeha:
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR clicked_t$3[rsp]
	jb	SHORT $LN24@SliderBeha
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta$2[rsp]
	jbe	SHORT $LN24@SliderBeha
$LN26@SliderBeha:

; 2539 : 					set_new_value = false;

	mov	BYTE PTR set_new_value$1[rsp], 0
	jmp	SHORT $LN25@SliderBeha
$LN24@SliderBeha:

; 2540 : 				else
; 2541 : 					clicked_t = ImSaturate(clicked_t + delta);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	addss	xmm0, DWORD PTR delta$2[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR clicked_t$3[rsp], xmm0
$LN25@SliderBeha:
$LN14@SliderBeha:
$LN13@SliderBeha:
$LN11@SliderBeha:
$LN7@SliderBeha:

; 2542 : 			}
; 2543 : 		}
; 2544 : 
; 2545 : 		if (set_new_value)

	movzx	eax, BYTE PTR set_new_value$1[rsp]
	test	eax, eax
	je	$LN28@SliderBeha

; 2546 : 		{
; 2547 : 			TYPE v_new;
; 2548 : 			if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN29@SliderBeha

; 2549 : 			{
; 2550 : 				// Account for power curve scale on both sides of the zero
; 2551 : 				if (clicked_t < linear_zero_pos)

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	comiss	xmm0, DWORD PTR clicked_t$3[rsp]
	jbe	SHORT $LN31@SliderBeha

; 2552 : 				{
; 2553 : 					// Negative: rescale to the negative range before powering
; 2554 : 					float a = 1.0f - (clicked_t / linear_zero_pos);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	divss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR a$6[rsp], xmm0

; 2555 : 					a = ImPow(a, power);

	movss	xmm1, DWORD PTR power$[rsp]
	movss	xmm0, DWORD PTR a$6[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR a$6[rsp], xmm0

; 2556 : 					v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);

	xorps	xmm1, xmm1
	movsd	xmm0, QWORD PTR v_max$[rsp]
	call	??$ImMin@N@@YANNN@Z			; ImMin<double>
	movss	xmm2, DWORD PTR a$6[rsp]
	movsd	xmm1, QWORD PTR v_min$[rsp]
	call	??$ImLerp@N@@YANNNM@Z			; ImLerp<double>
	movsd	QWORD PTR v_new$5[rsp], xmm0

; 2557 : 				}

	jmp	$LN32@SliderBeha
$LN31@SliderBeha:

; 2558 : 				else
; 2559 : 				{
; 2560 : 					// Positive: rescale to the positive range before powering
; 2561 : 					float a;
; 2562 : 					if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	call	?ImFabs@@YAMM@Z				; ImFabs
	comiss	xmm0, DWORD PTR __real@358637bd
	jbe	SHORT $LN33@SliderBeha

; 2563 : 						a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	subss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	divss	xmm0, xmm1
	movss	DWORD PTR a$4[rsp], xmm0
	jmp	SHORT $LN34@SliderBeha
$LN33@SliderBeha:

; 2564 : 					else
; 2565 : 						a = clicked_t;

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR a$4[rsp], xmm0
$LN34@SliderBeha:

; 2566 : 					a = ImPow(a, power);

	movss	xmm1, DWORD PTR power$[rsp]
	movss	xmm0, DWORD PTR a$4[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR a$4[rsp], xmm0

; 2567 : 					v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);

	xorps	xmm1, xmm1
	movsd	xmm0, QWORD PTR v_min$[rsp]
	call	??$ImMax@N@@YANNN@Z			; ImMax<double>
	movss	xmm2, DWORD PTR a$4[rsp]
	movsd	xmm1, QWORD PTR v_max$[rsp]
	call	??$ImLerp@N@@YANNNM@Z			; ImLerp<double>
	movsd	QWORD PTR v_new$5[rsp], xmm0
$LN32@SliderBeha:

; 2568 : 				}
; 2569 : 			}

	jmp	$LN30@SliderBeha
$LN29@SliderBeha:

; 2570 : 			else
; 2571 : 			{
; 2572 : 				// Linear slider
; 2573 : 				if (is_decimal)

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN35@SliderBeha

; 2574 : 				{
; 2575 : 					v_new = ImLerp(v_min, v_max, clicked_t);

	movss	xmm2, DWORD PTR clicked_t$3[rsp]
	movsd	xmm1, QWORD PTR v_max$[rsp]
	movsd	xmm0, QWORD PTR v_min$[rsp]
	call	??$ImLerp@N@@YANNNM@Z			; ImLerp<double>
	movsd	QWORD PTR v_new$5[rsp], xmm0

; 2576 : 				}

	jmp	$LN36@SliderBeha
$LN35@SliderBeha:

; 2577 : 				else
; 2578 : 				{
; 2579 : 					// For integer values we want the clicking position to match the grab box so we round above
; 2580 : 					// This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2581 : 					FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;

	movsd	xmm0, QWORD PTR v_max$[rsp]
	subsd	xmm0, QWORD PTR v_min$[rsp]
	cvtss2sd xmm1, DWORD PTR clicked_t$3[rsp]
	mulsd	xmm0, xmm1
	movsd	QWORD PTR v_new_off_f$11[rsp], xmm0

; 2582 : 					TYPE v_new_off_floor = (TYPE)(v_new_off_f);

	movsd	xmm0, QWORD PTR v_new_off_f$11[rsp]
	movsd	QWORD PTR v_new_off_floor$13[rsp], xmm0

; 2583 : 					TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);

	movsd	xmm0, QWORD PTR v_new_off_f$11[rsp]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR v_new_off_round$12[rsp], xmm0

; 2584 : 					if (!is_decimal && v_new_off_floor < v_new_off_round)

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN37@SliderBeha
	movsd	xmm0, QWORD PTR v_new_off_round$12[rsp]
	comisd	xmm0, QWORD PTR v_new_off_floor$13[rsp]
	jbe	SHORT $LN37@SliderBeha

; 2585 : 						v_new = v_min + v_new_off_round;

	movsd	xmm0, QWORD PTR v_min$[rsp]
	addsd	xmm0, QWORD PTR v_new_off_round$12[rsp]
	movsd	QWORD PTR v_new$5[rsp], xmm0
	jmp	SHORT $LN38@SliderBeha
$LN37@SliderBeha:

; 2586 : 					else
; 2587 : 						v_new = v_min + v_new_off_floor;

	movsd	xmm0, QWORD PTR v_min$[rsp]
	addsd	xmm0, QWORD PTR v_new_off_floor$13[rsp]
	movsd	QWORD PTR v_new$5[rsp], xmm0
$LN38@SliderBeha:
$LN36@SliderBeha:
$LN30@SliderBeha:

; 2588 : 				}
; 2589 : 			}
; 2590 : 
; 2591 : 			// Round to user desired precision based on format string
; 2592 : 			v_new = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_new);

	movsd	xmm2, QWORD PTR v_new$5[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	??$RoundScalarWithFormatT@NN@ImGui@@YANPEBDHN@Z ; ImGui::RoundScalarWithFormatT<double,double>
	movsd	QWORD PTR v_new$5[rsp], xmm0

; 2593 : 
; 2594 : 			// Apply result
; 2595 : 			if (*v != v_new)

	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	ucomisd	xmm0, QWORD PTR v_new$5[rsp]
	jp	SHORT $LN66@SliderBeha
	je	SHORT $LN39@SliderBeha
$LN66@SliderBeha:

; 2596 : 			{
; 2597 : 				*v = v_new;

	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm0, QWORD PTR v_new$5[rsp]
	movsd	QWORD PTR [rax], xmm0

; 2598 : 				value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN39@SliderBeha:
$LN28@SliderBeha:
$LN5@SliderBeha:

; 2599 : 			}
; 2600 : 		}
; 2601 : 	}
; 2602 : 
; 2603 : 	// Output grab position so it can be displayed by the caller
; 2604 : 	float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movsd	xmm3, QWORD PTR v_max$[rsp]
	movsd	xmm2, QWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm1, QWORD PTR [rax]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z ; ImGui::SliderCalcRatioFromValueT<double,double>
	movss	DWORD PTR grab_t$[rsp], xmm0

; 2605 : 	if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN40@SliderBeha

; 2606 : 		grab_t = 1.0f - grab_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR grab_t$[rsp]
	movss	DWORD PTR grab_t$[rsp], xmm0
$LN40@SliderBeha:

; 2607 : 	const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);

	movss	xmm2, DWORD PTR grab_t$[rsp]
	movss	xmm1, DWORD PTR slider_usable_pos_max$[rsp]
	movss	xmm0, DWORD PTR slider_usable_pos_min$[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR grab_pos$[rsp], xmm0

; 2608 : 	if (axis == ImGuiAxis_X)

	cmp	DWORD PTR axis$[rsp], 0
	jne	$LN41@SliderBeha

; 2609 : 		*out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR grab_pos$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	addss	xmm2, DWORD PTR __real@40000000
	movss	xmm3, DWORD PTR grab_sz$[rsp]
	mulss	xmm3, DWORD PTR __real@3f000000
	movss	xmm4, DWORD PTR grab_pos$[rsp]
	subss	xmm4, xmm3
	movaps	xmm3, xmm4
	movss	DWORD PTR tv398[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv398[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rdi, QWORD PTR out_grab_bb$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	jmp	$LN42@SliderBeha
$LN41@SliderBeha:

; 2610 : 	else
; 2611 : 		*out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);

	movss	xmm0, DWORD PTR grab_sz$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR grab_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR grab_sz$[rsp]
	mulss	xmm2, DWORD PTR __real@3f000000
	movss	xmm3, DWORD PTR grab_pos$[rsp]
	subss	xmm3, xmm2
	movaps	xmm2, xmm3
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm3, DWORD PTR [rax]
	addss	xmm3, DWORD PTR __real@40000000
	movss	DWORD PTR tv415[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv415[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rdi, QWORD PTR out_grab_bb$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN42@SliderBeha:

; 2612 : 
; 2613 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]

; 2614 : }

	add	rsp, 376				; 00000178H
	pop	rdi
	pop	rsi
	ret	0
??$SliderBehaviorT@NNN@ImGui@@YA_NAEBUImRect@@IHPEANNNPEBDMHPEAU1@@Z ENDP ; ImGui::SliderBehaviorT<double,double,double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$SliderBehaviorT@MMM@ImGui@@YA_NAEBUImRect@@IHPEAMMMPEBDMHPEAU1@@Z
_TEXT	SEGMENT
is_decimal$ = 48
set_new_value$1 = 49
is_power$ = 50
delta$2 = 52
clicked_t$3 = 56
tv70 = 60
tv74 = 61
value_changed$ = 62
grab_sz$ = 64
axis$ = 68
v_new$4 = 72
linear_zero_pos$ = 76
v_range$ = 80
a$5 = 84
grab_pos$ = 88
g$ = 96
slider_sz$ = 104
a$6 = 108
grab_t$ = 112
tv95 = 116
tv171 = 120
tv180 = 124
linear_dist_min_to_0$7 = 128
tv188 = 132
slider_usable_sz$ = 136
tv214 = 140
tv226 = 144
tv245 = 148
tv294 = 152
v_new_off_f$8 = 156
v_new_off_round$9 = 160
v_new_off_floor$10 = 164
slider_usable_pos_min$ = 168
tv67 = 172
tv174 = 176
tv183 = 180
linear_dist_max_to_0$11 = 184
mouse_abs_pos$12 = 188
decimal_precision$13 = 192
slider_usable_pos_max$ = 196
tv391 = 200
tv408 = 204
tv84 = 208
style$ = 216
delta2$14 = 224
grab_padding$ = 232
tv88 = 240
tv81 = 248
tv148 = 256
tv158 = 264
tv206 = 272
$T15 = 280
$T16 = 296
bb$ = 352
id$ = 360
data_type$ = 368
v$ = 376
v_min$ = 384
v_max$ = 392
format$ = 400
power$ = 408
flags$ = 416
out_grab_bb$ = 424
??$SliderBehaviorT@MMM@ImGui@@YA_NAEBUImRect@@IHPEAMMMPEBDMHPEAU1@@Z PROC ; ImGui::SliderBehaviorT<float,float,float>, COMDAT

; 2455 : {

$LN69:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 328				; 00000148H

; 2456 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2457 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 2458 : 
; 2459 : 	const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN44@SliderBeha
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN45@SliderBeha
$LN44@SliderBeha:
	mov	DWORD PTR tv67[rsp], 0
$LN45@SliderBeha:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR axis$[rsp], eax

; 2460 : 	const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN46@SliderBeha
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN46@SliderBeha
	mov	BYTE PTR tv70[rsp], 0
	jmp	SHORT $LN47@SliderBeha
$LN46@SliderBeha:
	mov	BYTE PTR tv70[rsp], 1
$LN47@SliderBeha:
	movzx	eax, BYTE PTR tv70[rsp]
	mov	BYTE PTR is_decimal$[rsp], al

; 2461 : 	const bool is_power = (power != 1.0f) && is_decimal;

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN68@SliderBeha
	je	SHORT $LN48@SliderBeha
$LN68@SliderBeha:
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN48@SliderBeha
	mov	BYTE PTR tv74[rsp], 1
	jmp	SHORT $LN49@SliderBeha
$LN48@SliderBeha:
	mov	BYTE PTR tv74[rsp], 0
$LN49@SliderBeha:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2462 : 
; 2463 : 	const float grab_padding = 2.0f;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR grab_padding$[rsp], xmm0

; 2464 : 	const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	QWORD PTR tv81[rsp], rax
	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv88[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv88[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	movss	DWORD PTR tv84[rsp], xmm0
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv81[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	movss	xmm1, DWORD PTR tv84[rsp]
	subss	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR slider_sz$[rsp], xmm0

; 2465 : 	float grab_sz = style.GrabMinSize;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+108]
	movss	DWORD PTR grab_sz$[rsp], xmm0

; 2466 : 	SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);

	movss	xmm0, DWORD PTR v_max$[rsp]
	comiss	xmm0, DWORD PTR v_min$[rsp]
	jbe	SHORT $LN50@SliderBeha
	movss	xmm0, DWORD PTR v_max$[rsp]
	subss	xmm0, DWORD PTR v_min$[rsp]
	movss	DWORD PTR tv95[rsp], xmm0
	jmp	SHORT $LN51@SliderBeha
$LN50@SliderBeha:
	movss	xmm0, DWORD PTR v_min$[rsp]
	subss	xmm0, DWORD PTR v_max$[rsp]
	movss	DWORD PTR tv95[rsp], xmm0
$LN51@SliderBeha:
	movss	xmm0, DWORD PTR tv95[rsp]
	movss	DWORD PTR v_range$[rsp], xmm0

; 2467 : 	if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN2@SliderBeha
	movss	xmm0, DWORD PTR v_range$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN2@SliderBeha

; 2468 : 		grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit

	movss	xmm0, DWORD PTR v_range$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR slider_sz$[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+108]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR grab_sz$[rsp], xmm0
$LN2@SliderBeha:

; 2469 : 	grab_sz = ImMin(grab_sz, slider_sz);

	movss	xmm1, DWORD PTR slider_sz$[rsp]
	movss	xmm0, DWORD PTR grab_sz$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR grab_sz$[rsp], xmm0

; 2470 : 	const float slider_usable_sz = slider_sz - grab_sz;

	movss	xmm0, DWORD PTR slider_sz$[rsp]
	subss	xmm0, DWORD PTR grab_sz$[rsp]
	movss	DWORD PTR slider_usable_sz$[rsp], xmm0

; 2471 : 	const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;

	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv148[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv148[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	addss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	movss	DWORD PTR slider_usable_pos_min$[rsp], xmm0

; 2472 : 	const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	QWORD PTR tv158[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv158[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	movss	DWORD PTR slider_usable_pos_max$[rsp], xmm0

; 2473 : 
; 2474 : 	// For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
; 2475 : 	float linear_zero_pos;   // 0.0->1.0f
; 2476 : 	if (is_power && v_min * v_max < 0.0f)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN3@SliderBeha
	movss	xmm0, DWORD PTR v_min$[rsp]
	mulss	xmm0, DWORD PTR v_max$[rsp]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	$LN3@SliderBeha

; 2477 : 	{
; 2478 : 		// Different sign
; 2479 : 		const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR tv174[rsp], xmm0
	movss	xmm0, DWORD PTR v_min$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN52@SliderBeha
	movss	xmm0, DWORD PTR v_min$[rsp]
	movss	DWORD PTR tv171[rsp], xmm0
	jmp	SHORT $LN53@SliderBeha
$LN52@SliderBeha:
	movss	xmm0, DWORD PTR v_min$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv171[rsp], xmm0
$LN53@SliderBeha:
	movss	xmm1, DWORD PTR tv174[rsp]
	movss	xmm0, DWORD PTR tv171[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR linear_dist_min_to_0$7[rsp], xmm0

; 2480 : 		const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR tv183[rsp], xmm0
	movss	xmm0, DWORD PTR v_max$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN54@SliderBeha
	movss	xmm0, DWORD PTR v_max$[rsp]
	movss	DWORD PTR tv180[rsp], xmm0
	jmp	SHORT $LN55@SliderBeha
$LN54@SliderBeha:
	movss	xmm0, DWORD PTR v_max$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv180[rsp], xmm0
$LN55@SliderBeha:
	movss	xmm1, DWORD PTR tv183[rsp]
	movss	xmm0, DWORD PTR tv180[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR linear_dist_max_to_0$11[rsp], xmm0

; 2481 : 		linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));

	movss	xmm0, DWORD PTR linear_dist_min_to_0$7[rsp]
	addss	xmm0, DWORD PTR linear_dist_max_to_0$11[rsp]
	movss	xmm1, DWORD PTR linear_dist_min_to_0$7[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR linear_zero_pos$[rsp], xmm0

; 2482 : 	}

	jmp	SHORT $LN4@SliderBeha
$LN3@SliderBeha:

; 2483 : 	else
; 2484 : 	{
; 2485 : 		// Same sign
; 2486 : 		linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR v_min$[rsp]
	jbe	SHORT $LN56@SliderBeha
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv188[rsp], xmm0
	jmp	SHORT $LN57@SliderBeha
$LN56@SliderBeha:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv188[rsp], xmm0
$LN57@SliderBeha:
	movss	xmm0, DWORD PTR tv188[rsp]
	movss	DWORD PTR linear_zero_pos$[rsp], xmm0
$LN4@SliderBeha:

; 2487 : 	}
; 2488 : 
; 2489 : 	// Process interacting with the slider
; 2490 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 2491 : 	if (g.ActiveId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	$LN5@SliderBeha

; 2492 : 	{
; 2493 : 		bool set_new_value = false;

	mov	BYTE PTR set_new_value$1[rsp], 0

; 2494 : 		float clicked_t = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2495 : 		if (g.ActiveIdSource == ImGuiInputSource_Mouse)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN6@SliderBeha

; 2496 : 		{
; 2497 : 			if (!g.IO.MouseDown[0])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	jne	SHORT $LN8@SliderBeha

; 2498 : 			{
; 2499 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 2500 : 			}

	jmp	$LN9@SliderBeha
$LN8@SliderBeha:

; 2501 : 			else
; 2502 : 			{
; 2503 : 				const float mouse_abs_pos = g.IO.MousePos[axis];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	QWORD PTR tv206[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv206[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR mouse_abs_pos$12[rsp], xmm0

; 2504 : 				clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

	movss	xmm0, DWORD PTR slider_usable_sz$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN58@SliderBeha
	movss	xmm0, DWORD PTR mouse_abs_pos$12[rsp]
	subss	xmm0, DWORD PTR slider_usable_pos_min$[rsp]
	divss	xmm0, DWORD PTR slider_usable_sz$[rsp]
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR tv214[rsp], xmm0
	jmp	SHORT $LN59@SliderBeha
$LN58@SliderBeha:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv214[rsp], xmm0
$LN59@SliderBeha:
	movss	xmm0, DWORD PTR tv214[rsp]
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2505 : 				if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN10@SliderBeha

; 2506 : 					clicked_t = 1.0f - clicked_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR clicked_t$3[rsp], xmm0
$LN10@SliderBeha:

; 2507 : 				set_new_value = true;

	mov	BYTE PTR set_new_value$1[rsp], 1
$LN9@SliderBeha:

; 2508 : 			}
; 2509 : 		}

	jmp	$LN7@SliderBeha
$LN6@SliderBeha:

; 2510 : 		else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	$LN11@SliderBeha

; 2511 : 		{
; 2512 : 			const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	mov	r8d, 5
	mov	edx, 3
	lea	rcx, QWORD PTR delta2$14[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d

; 2513 : 			float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;

	cmp	DWORD PTR axis$[rsp], 0
	jne	SHORT $LN60@SliderBeha
	movss	xmm0, DWORD PTR delta2$14[rsp]
	movss	DWORD PTR tv226[rsp], xmm0
	jmp	SHORT $LN61@SliderBeha
$LN60@SliderBeha:
	movss	xmm0, DWORD PTR delta2$14[rsp+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv226[rsp], xmm0
$LN61@SliderBeha:
	movss	xmm0, DWORD PTR tv226[rsp]
	movss	DWORD PTR delta$2[rsp], xmm0

; 2514 : 			if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7036], ecx
	jne	SHORT $LN12@SliderBeha
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	test	eax, eax
	jne	SHORT $LN12@SliderBeha

; 2515 : 			{
; 2516 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 2517 : 			}

	jmp	$LN13@SliderBeha
$LN12@SliderBeha:

; 2518 : 			else if (delta != 0.0f)

	movss	xmm0, DWORD PTR delta$2[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN67@SliderBeha
	je	$LN14@SliderBeha
$LN67@SliderBeha:

; 2519 : 			{
; 2520 : 				clicked_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR v_max$[rsp]
	movss	xmm2, DWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z ; ImGui::SliderCalcRatioFromValueT<float,float>
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2521 : 				const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN62@SliderBeha
	mov	edx, 3
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	DWORD PTR tv245[rsp], eax
	jmp	SHORT $LN63@SliderBeha
$LN62@SliderBeha:
	mov	DWORD PTR tv245[rsp], 0
$LN63@SliderBeha:
	mov	eax, DWORD PTR tv245[rsp]
	mov	DWORD PTR decimal_precision$13[rsp], eax

; 2522 : 				if ((decimal_precision > 0) || is_power)

	cmp	DWORD PTR decimal_precision$13[rsp], 0
	jg	SHORT $LN17@SliderBeha
	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN15@SliderBeha
$LN17@SliderBeha:

; 2523 : 				{
; 2524 : 					delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR delta$2[rsp], xmm0

; 2525 : 					if (IsNavInputDown(ImGuiNavInput_TweakSlow))

	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@SliderBeha

; 2526 : 						delta /= 10.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN18@SliderBeha:

; 2527 : 				}

	jmp	$LN16@SliderBeha
$LN15@SliderBeha:

; 2528 : 				else
; 2529 : 				{
; 2530 : 					if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))

	movss	xmm0, DWORD PTR v_range$[rsp]
	comiss	xmm0, DWORD PTR __real@c2c80000
	jb	SHORT $LN22@SliderBeha
	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR v_range$[rsp]
	jae	SHORT $LN21@SliderBeha
$LN22@SliderBeha:
	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@SliderBeha
$LN21@SliderBeha:

; 2531 : 						delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta$2[rsp]
	jbe	SHORT $LN64@SliderBeha
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv294[rsp], xmm0
	jmp	SHORT $LN65@SliderBeha
$LN64@SliderBeha:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv294[rsp], xmm0
$LN65@SliderBeha:
	movss	xmm0, DWORD PTR tv294[rsp]
	divss	xmm0, DWORD PTR v_range$[rsp]
	movss	DWORD PTR delta$2[rsp], xmm0
	jmp	SHORT $LN20@SliderBeha
$LN19@SliderBeha:

; 2532 : 					else
; 2533 : 						delta /= 100.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN20@SliderBeha:
$LN16@SliderBeha:

; 2534 : 				}
; 2535 : 				if (IsNavInputDown(ImGuiNavInput_TweakFast))

	mov	ecx, 15
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@SliderBeha

; 2536 : 					delta *= 10.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN23@SliderBeha:

; 2537 : 				set_new_value = true;

	mov	BYTE PTR set_new_value$1[rsp], 1

; 2538 : 				if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN27@SliderBeha
	movss	xmm0, DWORD PTR delta$2[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN26@SliderBeha
$LN27@SliderBeha:
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR clicked_t$3[rsp]
	jb	SHORT $LN24@SliderBeha
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta$2[rsp]
	jbe	SHORT $LN24@SliderBeha
$LN26@SliderBeha:

; 2539 : 					set_new_value = false;

	mov	BYTE PTR set_new_value$1[rsp], 0
	jmp	SHORT $LN25@SliderBeha
$LN24@SliderBeha:

; 2540 : 				else
; 2541 : 					clicked_t = ImSaturate(clicked_t + delta);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	addss	xmm0, DWORD PTR delta$2[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR clicked_t$3[rsp], xmm0
$LN25@SliderBeha:
$LN14@SliderBeha:
$LN13@SliderBeha:
$LN11@SliderBeha:
$LN7@SliderBeha:

; 2542 : 			}
; 2543 : 		}
; 2544 : 
; 2545 : 		if (set_new_value)

	movzx	eax, BYTE PTR set_new_value$1[rsp]
	test	eax, eax
	je	$LN28@SliderBeha

; 2546 : 		{
; 2547 : 			TYPE v_new;
; 2548 : 			if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN29@SliderBeha

; 2549 : 			{
; 2550 : 				// Account for power curve scale on both sides of the zero
; 2551 : 				if (clicked_t < linear_zero_pos)

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	comiss	xmm0, DWORD PTR clicked_t$3[rsp]
	jbe	SHORT $LN31@SliderBeha

; 2552 : 				{
; 2553 : 					// Negative: rescale to the negative range before powering
; 2554 : 					float a = 1.0f - (clicked_t / linear_zero_pos);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	divss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR a$6[rsp], xmm0

; 2555 : 					a = ImPow(a, power);

	movss	xmm1, DWORD PTR power$[rsp]
	movss	xmm0, DWORD PTR a$6[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR a$6[rsp], xmm0

; 2556 : 					v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);

	xorps	xmm1, xmm1
	movss	xmm0, DWORD PTR v_max$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	xmm2, DWORD PTR a$6[rsp]
	movss	xmm1, DWORD PTR v_min$[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR v_new$4[rsp], xmm0

; 2557 : 				}

	jmp	$LN32@SliderBeha
$LN31@SliderBeha:

; 2558 : 				else
; 2559 : 				{
; 2560 : 					// Positive: rescale to the positive range before powering
; 2561 : 					float a;
; 2562 : 					if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	call	?ImFabs@@YAMM@Z				; ImFabs
	comiss	xmm0, DWORD PTR __real@358637bd
	jbe	SHORT $LN33@SliderBeha

; 2563 : 						a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	subss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	divss	xmm0, xmm1
	movss	DWORD PTR a$5[rsp], xmm0
	jmp	SHORT $LN34@SliderBeha
$LN33@SliderBeha:

; 2564 : 					else
; 2565 : 						a = clicked_t;

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR a$5[rsp], xmm0
$LN34@SliderBeha:

; 2566 : 					a = ImPow(a, power);

	movss	xmm1, DWORD PTR power$[rsp]
	movss	xmm0, DWORD PTR a$5[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR a$5[rsp], xmm0

; 2567 : 					v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);

	xorps	xmm1, xmm1
	movss	xmm0, DWORD PTR v_min$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	xmm2, DWORD PTR a$5[rsp]
	movss	xmm1, DWORD PTR v_max$[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR v_new$4[rsp], xmm0
$LN32@SliderBeha:

; 2568 : 				}
; 2569 : 			}

	jmp	$LN30@SliderBeha
$LN29@SliderBeha:

; 2570 : 			else
; 2571 : 			{
; 2572 : 				// Linear slider
; 2573 : 				if (is_decimal)

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN35@SliderBeha

; 2574 : 				{
; 2575 : 					v_new = ImLerp(v_min, v_max, clicked_t);

	movss	xmm2, DWORD PTR clicked_t$3[rsp]
	movss	xmm1, DWORD PTR v_max$[rsp]
	movss	xmm0, DWORD PTR v_min$[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR v_new$4[rsp], xmm0

; 2576 : 				}

	jmp	$LN36@SliderBeha
$LN35@SliderBeha:

; 2577 : 				else
; 2578 : 				{
; 2579 : 					// For integer values we want the clicking position to match the grab box so we round above
; 2580 : 					// This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2581 : 					FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;

	movss	xmm0, DWORD PTR v_max$[rsp]
	subss	xmm0, DWORD PTR v_min$[rsp]
	mulss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR v_new_off_f$8[rsp], xmm0

; 2582 : 					TYPE v_new_off_floor = (TYPE)(v_new_off_f);

	movss	xmm0, DWORD PTR v_new_off_f$8[rsp]
	movss	DWORD PTR v_new_off_floor$10[rsp], xmm0

; 2583 : 					TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);

	movss	xmm0, DWORD PTR v_new_off_f$8[rsp]
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR v_new_off_round$9[rsp], xmm0

; 2584 : 					if (!is_decimal && v_new_off_floor < v_new_off_round)

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN37@SliderBeha
	movss	xmm0, DWORD PTR v_new_off_round$9[rsp]
	comiss	xmm0, DWORD PTR v_new_off_floor$10[rsp]
	jbe	SHORT $LN37@SliderBeha

; 2585 : 						v_new = v_min + v_new_off_round;

	movss	xmm0, DWORD PTR v_min$[rsp]
	addss	xmm0, DWORD PTR v_new_off_round$9[rsp]
	movss	DWORD PTR v_new$4[rsp], xmm0
	jmp	SHORT $LN38@SliderBeha
$LN37@SliderBeha:

; 2586 : 					else
; 2587 : 						v_new = v_min + v_new_off_floor;

	movss	xmm0, DWORD PTR v_min$[rsp]
	addss	xmm0, DWORD PTR v_new_off_floor$10[rsp]
	movss	DWORD PTR v_new$4[rsp], xmm0
$LN38@SliderBeha:
$LN36@SliderBeha:
$LN30@SliderBeha:

; 2588 : 				}
; 2589 : 			}
; 2590 : 
; 2591 : 			// Round to user desired precision based on format string
; 2592 : 			v_new = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_new);

	movss	xmm2, DWORD PTR v_new$4[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	??$RoundScalarWithFormatT@MM@ImGui@@YAMPEBDHM@Z ; ImGui::RoundScalarWithFormatT<float,float>
	movss	DWORD PTR v_new$4[rsp], xmm0

; 2593 : 
; 2594 : 			// Apply result
; 2595 : 			if (*v != v_new)

	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	ucomiss	xmm0, DWORD PTR v_new$4[rsp]
	jp	SHORT $LN66@SliderBeha
	je	SHORT $LN39@SliderBeha
$LN66@SliderBeha:

; 2596 : 			{
; 2597 : 				*v = v_new;

	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR v_new$4[rsp]
	movss	DWORD PTR [rax], xmm0

; 2598 : 				value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN39@SliderBeha:
$LN28@SliderBeha:
$LN5@SliderBeha:

; 2599 : 			}
; 2600 : 		}
; 2601 : 	}
; 2602 : 
; 2603 : 	// Output grab position so it can be displayed by the caller
; 2604 : 	float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR v_max$[rsp]
	movss	xmm2, DWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z ; ImGui::SliderCalcRatioFromValueT<float,float>
	movss	DWORD PTR grab_t$[rsp], xmm0

; 2605 : 	if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN40@SliderBeha

; 2606 : 		grab_t = 1.0f - grab_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR grab_t$[rsp]
	movss	DWORD PTR grab_t$[rsp], xmm0
$LN40@SliderBeha:

; 2607 : 	const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);

	movss	xmm2, DWORD PTR grab_t$[rsp]
	movss	xmm1, DWORD PTR slider_usable_pos_max$[rsp]
	movss	xmm0, DWORD PTR slider_usable_pos_min$[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR grab_pos$[rsp], xmm0

; 2608 : 	if (axis == ImGuiAxis_X)

	cmp	DWORD PTR axis$[rsp], 0
	jne	$LN41@SliderBeha

; 2609 : 		*out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR grab_pos$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	addss	xmm2, DWORD PTR __real@40000000
	movss	xmm3, DWORD PTR grab_sz$[rsp]
	mulss	xmm3, DWORD PTR __real@3f000000
	movss	xmm4, DWORD PTR grab_pos$[rsp]
	subss	xmm4, xmm3
	movaps	xmm3, xmm4
	movss	DWORD PTR tv391[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv391[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rdi, QWORD PTR out_grab_bb$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	jmp	$LN42@SliderBeha
$LN41@SliderBeha:

; 2610 : 	else
; 2611 : 		*out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);

	movss	xmm0, DWORD PTR grab_sz$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR grab_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR grab_sz$[rsp]
	mulss	xmm2, DWORD PTR __real@3f000000
	movss	xmm3, DWORD PTR grab_pos$[rsp]
	subss	xmm3, xmm2
	movaps	xmm2, xmm3
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm3, DWORD PTR [rax]
	addss	xmm3, DWORD PTR __real@40000000
	movss	DWORD PTR tv408[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv408[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rdi, QWORD PTR out_grab_bb$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN42@SliderBeha:

; 2612 : 
; 2613 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]

; 2614 : }

	add	rsp, 328				; 00000148H
	pop	rdi
	pop	rsi
	ret	0
??$SliderBehaviorT@MMM@ImGui@@YA_NAEBUImRect@@IHPEAMMMPEBDMHPEAU1@@Z ENDP ; ImGui::SliderBehaviorT<float,float,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$SliderBehaviorT@_K_JN@ImGui@@YA_NAEBUImRect@@IHPEA_K_K2PEBDMHPEAU1@@Z
_TEXT	SEGMENT
is_decimal$ = 48
set_new_value$1 = 49
is_power$ = 50
delta$2 = 52
clicked_t$3 = 56
tv70 = 60
tv74 = 61
value_changed$ = 62
grab_sz$ = 64
axis$ = 68
linear_zero_pos$ = 72
a$4 = 76
grab_pos$ = 80
v_new$5 = 88
g$ = 96
slider_sz$ = 104
a$6 = 108
grab_t$ = 112
tv67 = 116
tv198 = 120
slider_usable_sz$ = 124
tv224 = 128
tv255 = 132
tv306 = 136
slider_usable_pos_min$ = 140
v_range$ = 144
tv236 = 152
tv84 = 156
tv408 = 160
tv425 = 164
mouse_abs_pos$7 = 168
decimal_precision$8 = 172
slider_usable_pos_max$ = 176
tv95 = 184
style$ = 192
tv176 = 200
tv188 = 208
linear_dist_min_to_0$9 = 216
delta2$10 = 224
v_new_off_f$11 = 232
v_new_off_round$12 = 240
v_new_off_floor$13 = 248
grab_padding$ = 256
tv88 = 264
tv81 = 272
tv149 = 280
tv159 = 288
tv179 = 296
tv191 = 304
linear_dist_max_to_0$14 = 312
tv216 = 320
$T15 = 328
$T16 = 344
bb$ = 400
id$ = 408
data_type$ = 416
v$ = 424
v_min$ = 432
v_max$ = 440
format$ = 448
power$ = 456
flags$ = 464
out_grab_bb$ = 472
??$SliderBehaviorT@_K_JN@ImGui@@YA_NAEBUImRect@@IHPEA_K_K2PEBDMHPEAU1@@Z PROC ; ImGui::SliderBehaviorT<unsigned __int64,__int64,double>, COMDAT

; 2455 : {

$LN84:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 376				; 00000178H

; 2456 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2457 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 2458 : 
; 2459 : 	const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN44@SliderBeha
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN45@SliderBeha
$LN44@SliderBeha:
	mov	DWORD PTR tv67[rsp], 0
$LN45@SliderBeha:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR axis$[rsp], eax

; 2460 : 	const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN46@SliderBeha
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN46@SliderBeha
	mov	BYTE PTR tv70[rsp], 0
	jmp	SHORT $LN47@SliderBeha
$LN46@SliderBeha:
	mov	BYTE PTR tv70[rsp], 1
$LN47@SliderBeha:
	movzx	eax, BYTE PTR tv70[rsp]
	mov	BYTE PTR is_decimal$[rsp], al

; 2461 : 	const bool is_power = (power != 1.0f) && is_decimal;

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN83@SliderBeha
	je	SHORT $LN48@SliderBeha
$LN83@SliderBeha:
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN48@SliderBeha
	mov	BYTE PTR tv74[rsp], 1
	jmp	SHORT $LN49@SliderBeha
$LN48@SliderBeha:
	mov	BYTE PTR tv74[rsp], 0
$LN49@SliderBeha:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2462 : 
; 2463 : 	const float grab_padding = 2.0f;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR grab_padding$[rsp], xmm0

; 2464 : 	const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	QWORD PTR tv81[rsp], rax
	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv88[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv88[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	movss	DWORD PTR tv84[rsp], xmm0
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv81[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	movss	xmm1, DWORD PTR tv84[rsp]
	subss	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR slider_sz$[rsp], xmm0

; 2465 : 	float grab_sz = style.GrabMinSize;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+108]
	movss	DWORD PTR grab_sz$[rsp], xmm0

; 2466 : 	SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);

	mov	rax, QWORD PTR v_max$[rsp]
	cmp	QWORD PTR v_min$[rsp], rax
	jae	SHORT $LN50@SliderBeha
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv95[rsp], rax
	jmp	SHORT $LN51@SliderBeha
$LN50@SliderBeha:
	mov	rax, QWORD PTR v_max$[rsp]
	mov	rcx, QWORD PTR v_min$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv95[rsp], rax
$LN51@SliderBeha:
	mov	rax, QWORD PTR tv95[rsp]
	mov	QWORD PTR v_range$[rsp], rax

; 2467 : 	if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN2@SliderBeha
	cmp	QWORD PTR v_range$[rsp], 0
	jl	SHORT $LN2@SliderBeha

; 2468 : 		grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit

	mov	rax, QWORD PTR v_range$[rsp]
	inc	rax
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR slider_sz$[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+108]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR grab_sz$[rsp], xmm0
$LN2@SliderBeha:

; 2469 : 	grab_sz = ImMin(grab_sz, slider_sz);

	movss	xmm1, DWORD PTR slider_sz$[rsp]
	movss	xmm0, DWORD PTR grab_sz$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR grab_sz$[rsp], xmm0

; 2470 : 	const float slider_usable_sz = slider_sz - grab_sz;

	movss	xmm0, DWORD PTR slider_sz$[rsp]
	subss	xmm0, DWORD PTR grab_sz$[rsp]
	movss	DWORD PTR slider_usable_sz$[rsp], xmm0

; 2471 : 	const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;

	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv149[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv149[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	addss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	movss	DWORD PTR slider_usable_pos_min$[rsp], xmm0

; 2472 : 	const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	QWORD PTR tv159[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv159[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	movss	DWORD PTR slider_usable_pos_max$[rsp], xmm0

; 2473 : 
; 2474 : 	// For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
; 2475 : 	float linear_zero_pos;   // 0.0->1.0f
; 2476 : 	if (is_power && v_min * v_max < 0.0f)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN3@SliderBeha
	mov	rax, QWORD PTR v_min$[rsp]
	imul	rax, QWORD PTR v_max$[rsp]
	test	rax, rax
	jl	SHORT $LN81@SliderBeha
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN82@SliderBeha
$LN81@SliderBeha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN82@SliderBeha:
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	$LN3@SliderBeha

; 2477 : 	{
; 2478 : 		// Different sign
; 2479 : 		const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);

	cvtss2sd xmm0, DWORD PTR power$[rsp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR tv179[rsp], xmm0
	cmp	QWORD PTR v_min$[rsp], 0
	jb	SHORT $LN52@SliderBeha
	mov	rax, QWORD PTR v_min$[rsp]
	test	rax, rax
	jl	SHORT $LN79@SliderBeha
	cvtsi2sd xmm0, rax
	jmp	SHORT $LN80@SliderBeha
$LN79@SliderBeha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm1, rcx
	addsd	xmm1, xmm1
	movaps	xmm0, xmm1
$LN80@SliderBeha:
	movsd	QWORD PTR tv176[rsp], xmm0
	jmp	SHORT $LN53@SliderBeha
$LN52@SliderBeha:
	mov	rax, QWORD PTR v_min$[rsp]
	test	rax, rax
	jl	SHORT $LN77@SliderBeha
	cvtsi2sd xmm0, rax
	jmp	SHORT $LN78@SliderBeha
$LN77@SliderBeha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm1, rcx
	addsd	xmm1, xmm1
	movaps	xmm0, xmm1
$LN78@SliderBeha:
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR tv176[rsp], xmm0
$LN53@SliderBeha:
	movsd	xmm1, QWORD PTR tv179[rsp]
	movsd	xmm0, QWORD PTR tv176[rsp]
	call	?ImPow@@YANNN@Z				; ImPow
	movsd	QWORD PTR linear_dist_min_to_0$9[rsp], xmm0

; 2480 : 		const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);

	cvtss2sd xmm0, DWORD PTR power$[rsp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR tv191[rsp], xmm0
	cmp	QWORD PTR v_max$[rsp], 0
	jb	SHORT $LN54@SliderBeha
	mov	rax, QWORD PTR v_max$[rsp]
	test	rax, rax
	jl	SHORT $LN75@SliderBeha
	cvtsi2sd xmm0, rax
	jmp	SHORT $LN76@SliderBeha
$LN75@SliderBeha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm1, rcx
	addsd	xmm1, xmm1
	movaps	xmm0, xmm1
$LN76@SliderBeha:
	movsd	QWORD PTR tv188[rsp], xmm0
	jmp	SHORT $LN55@SliderBeha
$LN54@SliderBeha:
	mov	rax, QWORD PTR v_max$[rsp]
	test	rax, rax
	jl	SHORT $LN73@SliderBeha
	cvtsi2sd xmm0, rax
	jmp	SHORT $LN74@SliderBeha
$LN73@SliderBeha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm1, rcx
	addsd	xmm1, xmm1
	movaps	xmm0, xmm1
$LN74@SliderBeha:
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR tv188[rsp], xmm0
$LN55@SliderBeha:
	movsd	xmm1, QWORD PTR tv191[rsp]
	movsd	xmm0, QWORD PTR tv188[rsp]
	call	?ImPow@@YANNN@Z				; ImPow
	movsd	QWORD PTR linear_dist_max_to_0$14[rsp], xmm0

; 2481 : 		linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));

	movsd	xmm0, QWORD PTR linear_dist_min_to_0$9[rsp]
	addsd	xmm0, QWORD PTR linear_dist_max_to_0$14[rsp]
	movsd	xmm1, QWORD PTR linear_dist_min_to_0$9[rsp]
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR linear_zero_pos$[rsp], xmm0

; 2482 : 	}

	jmp	SHORT $LN4@SliderBeha
$LN3@SliderBeha:

; 2483 : 	else
; 2484 : 	{
; 2485 : 		// Same sign
; 2486 : 		linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

	mov	rax, QWORD PTR v_min$[rsp]
	test	rax, rax
	jl	SHORT $LN71@SliderBeha
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN72@SliderBeha
$LN71@SliderBeha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN72@SliderBeha:
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN56@SliderBeha
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv198[rsp], xmm0
	jmp	SHORT $LN57@SliderBeha
$LN56@SliderBeha:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv198[rsp], xmm0
$LN57@SliderBeha:
	movss	xmm0, DWORD PTR tv198[rsp]
	movss	DWORD PTR linear_zero_pos$[rsp], xmm0
$LN4@SliderBeha:

; 2487 : 	}
; 2488 : 
; 2489 : 	// Process interacting with the slider
; 2490 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 2491 : 	if (g.ActiveId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	$LN5@SliderBeha

; 2492 : 	{
; 2493 : 		bool set_new_value = false;

	mov	BYTE PTR set_new_value$1[rsp], 0

; 2494 : 		float clicked_t = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2495 : 		if (g.ActiveIdSource == ImGuiInputSource_Mouse)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN6@SliderBeha

; 2496 : 		{
; 2497 : 			if (!g.IO.MouseDown[0])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	jne	SHORT $LN8@SliderBeha

; 2498 : 			{
; 2499 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 2500 : 			}

	jmp	$LN9@SliderBeha
$LN8@SliderBeha:

; 2501 : 			else
; 2502 : 			{
; 2503 : 				const float mouse_abs_pos = g.IO.MousePos[axis];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	QWORD PTR tv216[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv216[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR mouse_abs_pos$7[rsp], xmm0

; 2504 : 				clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

	movss	xmm0, DWORD PTR slider_usable_sz$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN58@SliderBeha
	movss	xmm0, DWORD PTR mouse_abs_pos$7[rsp]
	subss	xmm0, DWORD PTR slider_usable_pos_min$[rsp]
	divss	xmm0, DWORD PTR slider_usable_sz$[rsp]
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR tv224[rsp], xmm0
	jmp	SHORT $LN59@SliderBeha
$LN58@SliderBeha:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv224[rsp], xmm0
$LN59@SliderBeha:
	movss	xmm0, DWORD PTR tv224[rsp]
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2505 : 				if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN10@SliderBeha

; 2506 : 					clicked_t = 1.0f - clicked_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR clicked_t$3[rsp], xmm0
$LN10@SliderBeha:

; 2507 : 				set_new_value = true;

	mov	BYTE PTR set_new_value$1[rsp], 1
$LN9@SliderBeha:

; 2508 : 			}
; 2509 : 		}

	jmp	$LN7@SliderBeha
$LN6@SliderBeha:

; 2510 : 		else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	$LN11@SliderBeha

; 2511 : 		{
; 2512 : 			const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	mov	r8d, 5
	mov	edx, 3
	lea	rcx, QWORD PTR delta2$10[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d

; 2513 : 			float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;

	cmp	DWORD PTR axis$[rsp], 0
	jne	SHORT $LN60@SliderBeha
	movss	xmm0, DWORD PTR delta2$10[rsp]
	movss	DWORD PTR tv236[rsp], xmm0
	jmp	SHORT $LN61@SliderBeha
$LN60@SliderBeha:
	movss	xmm0, DWORD PTR delta2$10[rsp+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv236[rsp], xmm0
$LN61@SliderBeha:
	movss	xmm0, DWORD PTR tv236[rsp]
	movss	DWORD PTR delta$2[rsp], xmm0

; 2514 : 			if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7036], ecx
	jne	SHORT $LN12@SliderBeha
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	test	eax, eax
	jne	SHORT $LN12@SliderBeha

; 2515 : 			{
; 2516 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 2517 : 			}

	jmp	$LN13@SliderBeha
$LN12@SliderBeha:

; 2518 : 			else if (delta != 0.0f)

	movss	xmm0, DWORD PTR delta$2[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN70@SliderBeha
	je	$LN14@SliderBeha
$LN70@SliderBeha:

; 2519 : 			{
; 2520 : 				clicked_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9, QWORD PTR v_max$[rsp]
	mov	r8, QWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z ; ImGui::SliderCalcRatioFromValueT<unsigned __int64,double>
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2521 : 				const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN62@SliderBeha
	mov	edx, 3
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	DWORD PTR tv255[rsp], eax
	jmp	SHORT $LN63@SliderBeha
$LN62@SliderBeha:
	mov	DWORD PTR tv255[rsp], 0
$LN63@SliderBeha:
	mov	eax, DWORD PTR tv255[rsp]
	mov	DWORD PTR decimal_precision$8[rsp], eax

; 2522 : 				if ((decimal_precision > 0) || is_power)

	cmp	DWORD PTR decimal_precision$8[rsp], 0
	jg	SHORT $LN17@SliderBeha
	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN15@SliderBeha
$LN17@SliderBeha:

; 2523 : 				{
; 2524 : 					delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR delta$2[rsp], xmm0

; 2525 : 					if (IsNavInputDown(ImGuiNavInput_TweakSlow))

	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@SliderBeha

; 2526 : 						delta /= 10.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN18@SliderBeha:

; 2527 : 				}

	jmp	$LN16@SliderBeha
$LN15@SliderBeha:

; 2528 : 				else
; 2529 : 				{
; 2530 : 					if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))

	cvtsi2ss xmm0, QWORD PTR v_range$[rsp]
	comiss	xmm0, DWORD PTR __real@c2c80000
	jb	SHORT $LN22@SliderBeha
	cvtsi2ss xmm0, QWORD PTR v_range$[rsp]
	movss	xmm1, DWORD PTR __real@42c80000
	comiss	xmm1, xmm0
	jae	SHORT $LN21@SliderBeha
$LN22@SliderBeha:
	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@SliderBeha
$LN21@SliderBeha:

; 2531 : 						delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta$2[rsp]
	jbe	SHORT $LN64@SliderBeha
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv306[rsp], xmm0
	jmp	SHORT $LN65@SliderBeha
$LN64@SliderBeha:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv306[rsp], xmm0
$LN65@SliderBeha:
	cvtsi2ss xmm0, QWORD PTR v_range$[rsp]
	movss	xmm1, DWORD PTR tv306[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR delta$2[rsp], xmm0
	jmp	SHORT $LN20@SliderBeha
$LN19@SliderBeha:

; 2532 : 					else
; 2533 : 						delta /= 100.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN20@SliderBeha:
$LN16@SliderBeha:

; 2534 : 				}
; 2535 : 				if (IsNavInputDown(ImGuiNavInput_TweakFast))

	mov	ecx, 15
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@SliderBeha

; 2536 : 					delta *= 10.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN23@SliderBeha:

; 2537 : 				set_new_value = true;

	mov	BYTE PTR set_new_value$1[rsp], 1

; 2538 : 				if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN27@SliderBeha
	movss	xmm0, DWORD PTR delta$2[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN26@SliderBeha
$LN27@SliderBeha:
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR clicked_t$3[rsp]
	jb	SHORT $LN24@SliderBeha
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta$2[rsp]
	jbe	SHORT $LN24@SliderBeha
$LN26@SliderBeha:

; 2539 : 					set_new_value = false;

	mov	BYTE PTR set_new_value$1[rsp], 0
	jmp	SHORT $LN25@SliderBeha
$LN24@SliderBeha:

; 2540 : 				else
; 2541 : 					clicked_t = ImSaturate(clicked_t + delta);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	addss	xmm0, DWORD PTR delta$2[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR clicked_t$3[rsp], xmm0
$LN25@SliderBeha:
$LN14@SliderBeha:
$LN13@SliderBeha:
$LN11@SliderBeha:
$LN7@SliderBeha:

; 2542 : 			}
; 2543 : 		}
; 2544 : 
; 2545 : 		if (set_new_value)

	movzx	eax, BYTE PTR set_new_value$1[rsp]
	test	eax, eax
	je	$LN28@SliderBeha

; 2546 : 		{
; 2547 : 			TYPE v_new;
; 2548 : 			if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN29@SliderBeha

; 2549 : 			{
; 2550 : 				// Account for power curve scale on both sides of the zero
; 2551 : 				if (clicked_t < linear_zero_pos)

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	comiss	xmm0, DWORD PTR clicked_t$3[rsp]
	jbe	SHORT $LN31@SliderBeha

; 2552 : 				{
; 2553 : 					// Negative: rescale to the negative range before powering
; 2554 : 					float a = 1.0f - (clicked_t / linear_zero_pos);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	divss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR a$6[rsp], xmm0

; 2555 : 					a = ImPow(a, power);

	movss	xmm1, DWORD PTR power$[rsp]
	movss	xmm0, DWORD PTR a$6[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR a$6[rsp], xmm0

; 2556 : 					v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);

	xor	edx, edx
	mov	rcx, QWORD PTR v_max$[rsp]
	call	??$ImMin@_K@@YA_K_K0@Z			; ImMin<unsigned __int64>
	movss	xmm2, DWORD PTR a$6[rsp]
	mov	rdx, QWORD PTR v_min$[rsp]
	mov	rcx, rax
	call	??$ImLerp@_K@@YA_K_K0M@Z		; ImLerp<unsigned __int64>
	mov	QWORD PTR v_new$5[rsp], rax

; 2557 : 				}

	jmp	$LN32@SliderBeha
$LN31@SliderBeha:

; 2558 : 				else
; 2559 : 				{
; 2560 : 					// Positive: rescale to the positive range before powering
; 2561 : 					float a;
; 2562 : 					if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	call	?ImFabs@@YAMM@Z				; ImFabs
	comiss	xmm0, DWORD PTR __real@358637bd
	jbe	SHORT $LN33@SliderBeha

; 2563 : 						a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	subss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	divss	xmm0, xmm1
	movss	DWORD PTR a$4[rsp], xmm0
	jmp	SHORT $LN34@SliderBeha
$LN33@SliderBeha:

; 2564 : 					else
; 2565 : 						a = clicked_t;

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR a$4[rsp], xmm0
$LN34@SliderBeha:

; 2566 : 					a = ImPow(a, power);

	movss	xmm1, DWORD PTR power$[rsp]
	movss	xmm0, DWORD PTR a$4[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR a$4[rsp], xmm0

; 2567 : 					v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);

	xor	edx, edx
	mov	rcx, QWORD PTR v_min$[rsp]
	call	??$ImMax@_K@@YA_K_K0@Z			; ImMax<unsigned __int64>
	movss	xmm2, DWORD PTR a$4[rsp]
	mov	rdx, QWORD PTR v_max$[rsp]
	mov	rcx, rax
	call	??$ImLerp@_K@@YA_K_K0M@Z		; ImLerp<unsigned __int64>
	mov	QWORD PTR v_new$5[rsp], rax
$LN32@SliderBeha:

; 2568 : 				}
; 2569 : 			}

	jmp	$LN30@SliderBeha
$LN29@SliderBeha:

; 2570 : 			else
; 2571 : 			{
; 2572 : 				// Linear slider
; 2573 : 				if (is_decimal)

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN35@SliderBeha

; 2574 : 				{
; 2575 : 					v_new = ImLerp(v_min, v_max, clicked_t);

	movss	xmm2, DWORD PTR clicked_t$3[rsp]
	mov	rdx, QWORD PTR v_max$[rsp]
	mov	rcx, QWORD PTR v_min$[rsp]
	call	??$ImLerp@_K@@YA_K_K0M@Z		; ImLerp<unsigned __int64>
	mov	QWORD PTR v_new$5[rsp], rax

; 2576 : 				}

	jmp	$LN36@SliderBeha
$LN35@SliderBeha:

; 2577 : 				else
; 2578 : 				{
; 2579 : 					// For integer values we want the clicking position to match the grab box so we round above
; 2580 : 					// This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2581 : 					FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;

	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jl	SHORT $LN68@SliderBeha
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN69@SliderBeha
$LN68@SliderBeha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN69@SliderBeha:
	mulss	xmm0, DWORD PTR clicked_t$3[rsp]
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR v_new_off_f$11[rsp], xmm0

; 2582 : 					TYPE v_new_off_floor = (TYPE)(v_new_off_f);

	xor	eax, eax
	movsd	xmm0, QWORD PTR v_new_off_f$11[rsp]
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jb	SHORT $LN67@SliderBeha
	subsd	xmm0, QWORD PTR __real@43e0000000000000
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jae	SHORT $LN67@SliderBeha
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN67@SliderBeha:
	cvttsd2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_new_off_floor$13[rsp], rax

; 2583 : 					TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);

	movsd	xmm0, QWORD PTR v_new_off_f$11[rsp]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	xor	eax, eax
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jb	SHORT $LN66@SliderBeha
	subsd	xmm0, QWORD PTR __real@43e0000000000000
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jae	SHORT $LN66@SliderBeha
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN66@SliderBeha:
	cvttsd2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_new_off_round$12[rsp], rax

; 2584 : 					if (!is_decimal && v_new_off_floor < v_new_off_round)

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN37@SliderBeha
	mov	rax, QWORD PTR v_new_off_round$12[rsp]
	cmp	QWORD PTR v_new_off_floor$13[rsp], rax
	jae	SHORT $LN37@SliderBeha

; 2585 : 						v_new = v_min + v_new_off_round;

	mov	rax, QWORD PTR v_new_off_round$12[rsp]
	mov	rcx, QWORD PTR v_min$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_new$5[rsp], rax
	jmp	SHORT $LN38@SliderBeha
$LN37@SliderBeha:

; 2586 : 					else
; 2587 : 						v_new = v_min + v_new_off_floor;

	mov	rax, QWORD PTR v_new_off_floor$13[rsp]
	mov	rcx, QWORD PTR v_min$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_new$5[rsp], rax
$LN38@SliderBeha:
$LN36@SliderBeha:
$LN30@SliderBeha:

; 2588 : 				}
; 2589 : 			}
; 2590 : 
; 2591 : 			// Round to user desired precision based on format string
; 2592 : 			v_new = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_new);

	mov	r8, QWORD PTR v_new$5[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPEBDH_K@Z ; ImGui::RoundScalarWithFormatT<unsigned __int64,__int64>
	mov	QWORD PTR v_new$5[rsp], rax

; 2593 : 
; 2594 : 			// Apply result
; 2595 : 			if (*v != v_new)

	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_new$5[rsp]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN39@SliderBeha

; 2596 : 			{
; 2597 : 				*v = v_new;

	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_new$5[rsp]
	mov	QWORD PTR [rax], rcx

; 2598 : 				value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN39@SliderBeha:
$LN28@SliderBeha:
$LN5@SliderBeha:

; 2599 : 			}
; 2600 : 		}
; 2601 : 	}
; 2602 : 
; 2603 : 	// Output grab position so it can be displayed by the caller
; 2604 : 	float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9, QWORD PTR v_max$[rsp]
	mov	r8, QWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z ; ImGui::SliderCalcRatioFromValueT<unsigned __int64,double>
	movss	DWORD PTR grab_t$[rsp], xmm0

; 2605 : 	if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN40@SliderBeha

; 2606 : 		grab_t = 1.0f - grab_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR grab_t$[rsp]
	movss	DWORD PTR grab_t$[rsp], xmm0
$LN40@SliderBeha:

; 2607 : 	const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);

	movss	xmm2, DWORD PTR grab_t$[rsp]
	movss	xmm1, DWORD PTR slider_usable_pos_max$[rsp]
	movss	xmm0, DWORD PTR slider_usable_pos_min$[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR grab_pos$[rsp], xmm0

; 2608 : 	if (axis == ImGuiAxis_X)

	cmp	DWORD PTR axis$[rsp], 0
	jne	$LN41@SliderBeha

; 2609 : 		*out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR grab_pos$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	addss	xmm2, DWORD PTR __real@40000000
	movss	xmm3, DWORD PTR grab_sz$[rsp]
	mulss	xmm3, DWORD PTR __real@3f000000
	movss	xmm4, DWORD PTR grab_pos$[rsp]
	subss	xmm4, xmm3
	movaps	xmm3, xmm4
	movss	DWORD PTR tv408[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv408[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rdi, QWORD PTR out_grab_bb$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	jmp	$LN42@SliderBeha
$LN41@SliderBeha:

; 2610 : 	else
; 2611 : 		*out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);

	movss	xmm0, DWORD PTR grab_sz$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR grab_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR grab_sz$[rsp]
	mulss	xmm2, DWORD PTR __real@3f000000
	movss	xmm3, DWORD PTR grab_pos$[rsp]
	subss	xmm3, xmm2
	movaps	xmm2, xmm3
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm3, DWORD PTR [rax]
	addss	xmm3, DWORD PTR __real@40000000
	movss	DWORD PTR tv425[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv425[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rdi, QWORD PTR out_grab_bb$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN42@SliderBeha:

; 2612 : 
; 2613 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]

; 2614 : }

	add	rsp, 376				; 00000178H
	pop	rdi
	pop	rsi
	ret	0
??$SliderBehaviorT@_K_JN@ImGui@@YA_NAEBUImRect@@IHPEA_K_K2PEBDMHPEAU1@@Z ENDP ; ImGui::SliderBehaviorT<unsigned __int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$SliderBehaviorT@_J_JN@ImGui@@YA_NAEBUImRect@@IHPEA_J_J2PEBDMHPEAU1@@Z
_TEXT	SEGMENT
is_decimal$ = 48
set_new_value$1 = 49
is_power$ = 50
delta$2 = 52
clicked_t$3 = 56
tv70 = 60
tv74 = 61
value_changed$ = 62
grab_sz$ = 64
axis$ = 68
linear_zero_pos$ = 72
a$4 = 76
grab_pos$ = 80
v_new$5 = 88
g$ = 96
slider_sz$ = 104
a$6 = 108
grab_t$ = 112
tv67 = 116
tv198 = 120
slider_usable_sz$ = 124
tv224 = 128
tv255 = 132
tv306 = 136
slider_usable_pos_min$ = 140
v_range$ = 144
tv236 = 152
tv84 = 156
tv408 = 160
tv425 = 164
mouse_abs_pos$7 = 168
decimal_precision$8 = 172
slider_usable_pos_max$ = 176
tv95 = 184
style$ = 192
tv176 = 200
tv188 = 208
linear_dist_min_to_0$9 = 216
delta2$10 = 224
v_new_off_f$11 = 232
v_new_off_round$12 = 240
v_new_off_floor$13 = 248
grab_padding$ = 256
tv88 = 264
tv81 = 272
tv149 = 280
tv159 = 288
tv179 = 296
tv191 = 304
linear_dist_max_to_0$14 = 312
tv216 = 320
$T15 = 328
$T16 = 344
bb$ = 400
id$ = 408
data_type$ = 416
v$ = 424
v_min$ = 432
v_max$ = 440
format$ = 448
power$ = 456
flags$ = 464
out_grab_bb$ = 472
??$SliderBehaviorT@_J_JN@ImGui@@YA_NAEBUImRect@@IHPEA_J_J2PEBDMHPEAU1@@Z PROC ; ImGui::SliderBehaviorT<__int64,__int64,double>, COMDAT

; 2455 : {

$LN68:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 376				; 00000178H

; 2456 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2457 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 2458 : 
; 2459 : 	const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN44@SliderBeha
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN45@SliderBeha
$LN44@SliderBeha:
	mov	DWORD PTR tv67[rsp], 0
$LN45@SliderBeha:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR axis$[rsp], eax

; 2460 : 	const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN46@SliderBeha
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN46@SliderBeha
	mov	BYTE PTR tv70[rsp], 0
	jmp	SHORT $LN47@SliderBeha
$LN46@SliderBeha:
	mov	BYTE PTR tv70[rsp], 1
$LN47@SliderBeha:
	movzx	eax, BYTE PTR tv70[rsp]
	mov	BYTE PTR is_decimal$[rsp], al

; 2461 : 	const bool is_power = (power != 1.0f) && is_decimal;

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN67@SliderBeha
	je	SHORT $LN48@SliderBeha
$LN67@SliderBeha:
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN48@SliderBeha
	mov	BYTE PTR tv74[rsp], 1
	jmp	SHORT $LN49@SliderBeha
$LN48@SliderBeha:
	mov	BYTE PTR tv74[rsp], 0
$LN49@SliderBeha:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2462 : 
; 2463 : 	const float grab_padding = 2.0f;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR grab_padding$[rsp], xmm0

; 2464 : 	const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	QWORD PTR tv81[rsp], rax
	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv88[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv88[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	movss	DWORD PTR tv84[rsp], xmm0
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv81[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	movss	xmm1, DWORD PTR tv84[rsp]
	subss	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR slider_sz$[rsp], xmm0

; 2465 : 	float grab_sz = style.GrabMinSize;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+108]
	movss	DWORD PTR grab_sz$[rsp], xmm0

; 2466 : 	SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);

	mov	rax, QWORD PTR v_max$[rsp]
	cmp	QWORD PTR v_min$[rsp], rax
	jge	SHORT $LN50@SliderBeha
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv95[rsp], rax
	jmp	SHORT $LN51@SliderBeha
$LN50@SliderBeha:
	mov	rax, QWORD PTR v_max$[rsp]
	mov	rcx, QWORD PTR v_min$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv95[rsp], rax
$LN51@SliderBeha:
	mov	rax, QWORD PTR tv95[rsp]
	mov	QWORD PTR v_range$[rsp], rax

; 2467 : 	if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN2@SliderBeha
	cmp	QWORD PTR v_range$[rsp], 0
	jl	SHORT $LN2@SliderBeha

; 2468 : 		grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit

	mov	rax, QWORD PTR v_range$[rsp]
	inc	rax
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR slider_sz$[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+108]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR grab_sz$[rsp], xmm0
$LN2@SliderBeha:

; 2469 : 	grab_sz = ImMin(grab_sz, slider_sz);

	movss	xmm1, DWORD PTR slider_sz$[rsp]
	movss	xmm0, DWORD PTR grab_sz$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR grab_sz$[rsp], xmm0

; 2470 : 	const float slider_usable_sz = slider_sz - grab_sz;

	movss	xmm0, DWORD PTR slider_sz$[rsp]
	subss	xmm0, DWORD PTR grab_sz$[rsp]
	movss	DWORD PTR slider_usable_sz$[rsp], xmm0

; 2471 : 	const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;

	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv149[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv149[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	addss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	movss	DWORD PTR slider_usable_pos_min$[rsp], xmm0

; 2472 : 	const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	QWORD PTR tv159[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv159[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	movss	DWORD PTR slider_usable_pos_max$[rsp], xmm0

; 2473 : 
; 2474 : 	// For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
; 2475 : 	float linear_zero_pos;   // 0.0->1.0f
; 2476 : 	if (is_power && v_min * v_max < 0.0f)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN3@SliderBeha
	mov	rax, QWORD PTR v_min$[rsp]
	imul	rax, QWORD PTR v_max$[rsp]
	cvtsi2ss xmm0, rax
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	$LN3@SliderBeha

; 2477 : 	{
; 2478 : 		// Different sign
; 2479 : 		const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);

	cvtss2sd xmm0, DWORD PTR power$[rsp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR tv179[rsp], xmm0
	cmp	QWORD PTR v_min$[rsp], 0
	jl	SHORT $LN52@SliderBeha
	cvtsi2sd xmm0, QWORD PTR v_min$[rsp]
	movsd	QWORD PTR tv176[rsp], xmm0
	jmp	SHORT $LN53@SliderBeha
$LN52@SliderBeha:
	cvtsi2sd xmm0, QWORD PTR v_min$[rsp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR tv176[rsp], xmm0
$LN53@SliderBeha:
	movsd	xmm1, QWORD PTR tv179[rsp]
	movsd	xmm0, QWORD PTR tv176[rsp]
	call	?ImPow@@YANNN@Z				; ImPow
	movsd	QWORD PTR linear_dist_min_to_0$9[rsp], xmm0

; 2480 : 		const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);

	cvtss2sd xmm0, DWORD PTR power$[rsp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR tv191[rsp], xmm0
	cmp	QWORD PTR v_max$[rsp], 0
	jl	SHORT $LN54@SliderBeha
	cvtsi2sd xmm0, QWORD PTR v_max$[rsp]
	movsd	QWORD PTR tv188[rsp], xmm0
	jmp	SHORT $LN55@SliderBeha
$LN54@SliderBeha:
	cvtsi2sd xmm0, QWORD PTR v_max$[rsp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR tv188[rsp], xmm0
$LN55@SliderBeha:
	movsd	xmm1, QWORD PTR tv191[rsp]
	movsd	xmm0, QWORD PTR tv188[rsp]
	call	?ImPow@@YANNN@Z				; ImPow
	movsd	QWORD PTR linear_dist_max_to_0$14[rsp], xmm0

; 2481 : 		linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));

	movsd	xmm0, QWORD PTR linear_dist_min_to_0$9[rsp]
	addsd	xmm0, QWORD PTR linear_dist_max_to_0$14[rsp]
	movsd	xmm1, QWORD PTR linear_dist_min_to_0$9[rsp]
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR linear_zero_pos$[rsp], xmm0

; 2482 : 	}

	jmp	SHORT $LN4@SliderBeha
$LN3@SliderBeha:

; 2483 : 	else
; 2484 : 	{
; 2485 : 		// Same sign
; 2486 : 		linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

	cvtsi2ss xmm0, QWORD PTR v_min$[rsp]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN56@SliderBeha
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv198[rsp], xmm0
	jmp	SHORT $LN57@SliderBeha
$LN56@SliderBeha:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv198[rsp], xmm0
$LN57@SliderBeha:
	movss	xmm0, DWORD PTR tv198[rsp]
	movss	DWORD PTR linear_zero_pos$[rsp], xmm0
$LN4@SliderBeha:

; 2487 : 	}
; 2488 : 
; 2489 : 	// Process interacting with the slider
; 2490 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 2491 : 	if (g.ActiveId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	$LN5@SliderBeha

; 2492 : 	{
; 2493 : 		bool set_new_value = false;

	mov	BYTE PTR set_new_value$1[rsp], 0

; 2494 : 		float clicked_t = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2495 : 		if (g.ActiveIdSource == ImGuiInputSource_Mouse)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN6@SliderBeha

; 2496 : 		{
; 2497 : 			if (!g.IO.MouseDown[0])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	jne	SHORT $LN8@SliderBeha

; 2498 : 			{
; 2499 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 2500 : 			}

	jmp	$LN9@SliderBeha
$LN8@SliderBeha:

; 2501 : 			else
; 2502 : 			{
; 2503 : 				const float mouse_abs_pos = g.IO.MousePos[axis];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	QWORD PTR tv216[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv216[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR mouse_abs_pos$7[rsp], xmm0

; 2504 : 				clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

	movss	xmm0, DWORD PTR slider_usable_sz$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN58@SliderBeha
	movss	xmm0, DWORD PTR mouse_abs_pos$7[rsp]
	subss	xmm0, DWORD PTR slider_usable_pos_min$[rsp]
	divss	xmm0, DWORD PTR slider_usable_sz$[rsp]
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR tv224[rsp], xmm0
	jmp	SHORT $LN59@SliderBeha
$LN58@SliderBeha:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv224[rsp], xmm0
$LN59@SliderBeha:
	movss	xmm0, DWORD PTR tv224[rsp]
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2505 : 				if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN10@SliderBeha

; 2506 : 					clicked_t = 1.0f - clicked_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR clicked_t$3[rsp], xmm0
$LN10@SliderBeha:

; 2507 : 				set_new_value = true;

	mov	BYTE PTR set_new_value$1[rsp], 1
$LN9@SliderBeha:

; 2508 : 			}
; 2509 : 		}

	jmp	$LN7@SliderBeha
$LN6@SliderBeha:

; 2510 : 		else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	$LN11@SliderBeha

; 2511 : 		{
; 2512 : 			const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	mov	r8d, 5
	mov	edx, 3
	lea	rcx, QWORD PTR delta2$10[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d

; 2513 : 			float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;

	cmp	DWORD PTR axis$[rsp], 0
	jne	SHORT $LN60@SliderBeha
	movss	xmm0, DWORD PTR delta2$10[rsp]
	movss	DWORD PTR tv236[rsp], xmm0
	jmp	SHORT $LN61@SliderBeha
$LN60@SliderBeha:
	movss	xmm0, DWORD PTR delta2$10[rsp+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv236[rsp], xmm0
$LN61@SliderBeha:
	movss	xmm0, DWORD PTR tv236[rsp]
	movss	DWORD PTR delta$2[rsp], xmm0

; 2514 : 			if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7036], ecx
	jne	SHORT $LN12@SliderBeha
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	test	eax, eax
	jne	SHORT $LN12@SliderBeha

; 2515 : 			{
; 2516 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 2517 : 			}

	jmp	$LN13@SliderBeha
$LN12@SliderBeha:

; 2518 : 			else if (delta != 0.0f)

	movss	xmm0, DWORD PTR delta$2[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN66@SliderBeha
	je	$LN14@SliderBeha
$LN66@SliderBeha:

; 2519 : 			{
; 2520 : 				clicked_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9, QWORD PTR v_max$[rsp]
	mov	r8, QWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z ; ImGui::SliderCalcRatioFromValueT<__int64,double>
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2521 : 				const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN62@SliderBeha
	mov	edx, 3
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	DWORD PTR tv255[rsp], eax
	jmp	SHORT $LN63@SliderBeha
$LN62@SliderBeha:
	mov	DWORD PTR tv255[rsp], 0
$LN63@SliderBeha:
	mov	eax, DWORD PTR tv255[rsp]
	mov	DWORD PTR decimal_precision$8[rsp], eax

; 2522 : 				if ((decimal_precision > 0) || is_power)

	cmp	DWORD PTR decimal_precision$8[rsp], 0
	jg	SHORT $LN17@SliderBeha
	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN15@SliderBeha
$LN17@SliderBeha:

; 2523 : 				{
; 2524 : 					delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR delta$2[rsp], xmm0

; 2525 : 					if (IsNavInputDown(ImGuiNavInput_TweakSlow))

	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@SliderBeha

; 2526 : 						delta /= 10.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN18@SliderBeha:

; 2527 : 				}

	jmp	$LN16@SliderBeha
$LN15@SliderBeha:

; 2528 : 				else
; 2529 : 				{
; 2530 : 					if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))

	cvtsi2ss xmm0, QWORD PTR v_range$[rsp]
	comiss	xmm0, DWORD PTR __real@c2c80000
	jb	SHORT $LN22@SliderBeha
	cvtsi2ss xmm0, QWORD PTR v_range$[rsp]
	movss	xmm1, DWORD PTR __real@42c80000
	comiss	xmm1, xmm0
	jae	SHORT $LN21@SliderBeha
$LN22@SliderBeha:
	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@SliderBeha
$LN21@SliderBeha:

; 2531 : 						delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta$2[rsp]
	jbe	SHORT $LN64@SliderBeha
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv306[rsp], xmm0
	jmp	SHORT $LN65@SliderBeha
$LN64@SliderBeha:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv306[rsp], xmm0
$LN65@SliderBeha:
	cvtsi2ss xmm0, QWORD PTR v_range$[rsp]
	movss	xmm1, DWORD PTR tv306[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR delta$2[rsp], xmm0
	jmp	SHORT $LN20@SliderBeha
$LN19@SliderBeha:

; 2532 : 					else
; 2533 : 						delta /= 100.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN20@SliderBeha:
$LN16@SliderBeha:

; 2534 : 				}
; 2535 : 				if (IsNavInputDown(ImGuiNavInput_TweakFast))

	mov	ecx, 15
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@SliderBeha

; 2536 : 					delta *= 10.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN23@SliderBeha:

; 2537 : 				set_new_value = true;

	mov	BYTE PTR set_new_value$1[rsp], 1

; 2538 : 				if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN27@SliderBeha
	movss	xmm0, DWORD PTR delta$2[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN26@SliderBeha
$LN27@SliderBeha:
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR clicked_t$3[rsp]
	jb	SHORT $LN24@SliderBeha
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta$2[rsp]
	jbe	SHORT $LN24@SliderBeha
$LN26@SliderBeha:

; 2539 : 					set_new_value = false;

	mov	BYTE PTR set_new_value$1[rsp], 0
	jmp	SHORT $LN25@SliderBeha
$LN24@SliderBeha:

; 2540 : 				else
; 2541 : 					clicked_t = ImSaturate(clicked_t + delta);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	addss	xmm0, DWORD PTR delta$2[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR clicked_t$3[rsp], xmm0
$LN25@SliderBeha:
$LN14@SliderBeha:
$LN13@SliderBeha:
$LN11@SliderBeha:
$LN7@SliderBeha:

; 2542 : 			}
; 2543 : 		}
; 2544 : 
; 2545 : 		if (set_new_value)

	movzx	eax, BYTE PTR set_new_value$1[rsp]
	test	eax, eax
	je	$LN28@SliderBeha

; 2546 : 		{
; 2547 : 			TYPE v_new;
; 2548 : 			if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN29@SliderBeha

; 2549 : 			{
; 2550 : 				// Account for power curve scale on both sides of the zero
; 2551 : 				if (clicked_t < linear_zero_pos)

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	comiss	xmm0, DWORD PTR clicked_t$3[rsp]
	jbe	SHORT $LN31@SliderBeha

; 2552 : 				{
; 2553 : 					// Negative: rescale to the negative range before powering
; 2554 : 					float a = 1.0f - (clicked_t / linear_zero_pos);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	divss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR a$6[rsp], xmm0

; 2555 : 					a = ImPow(a, power);

	movss	xmm1, DWORD PTR power$[rsp]
	movss	xmm0, DWORD PTR a$6[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR a$6[rsp], xmm0

; 2556 : 					v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);

	xor	edx, edx
	mov	rcx, QWORD PTR v_max$[rsp]
	call	??$ImMin@_J@@YA_J_J0@Z			; ImMin<__int64>
	movss	xmm2, DWORD PTR a$6[rsp]
	mov	rdx, QWORD PTR v_min$[rsp]
	mov	rcx, rax
	call	??$ImLerp@_J@@YA_J_J0M@Z		; ImLerp<__int64>
	mov	QWORD PTR v_new$5[rsp], rax

; 2557 : 				}

	jmp	$LN32@SliderBeha
$LN31@SliderBeha:

; 2558 : 				else
; 2559 : 				{
; 2560 : 					// Positive: rescale to the positive range before powering
; 2561 : 					float a;
; 2562 : 					if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	call	?ImFabs@@YAMM@Z				; ImFabs
	comiss	xmm0, DWORD PTR __real@358637bd
	jbe	SHORT $LN33@SliderBeha

; 2563 : 						a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	subss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	divss	xmm0, xmm1
	movss	DWORD PTR a$4[rsp], xmm0
	jmp	SHORT $LN34@SliderBeha
$LN33@SliderBeha:

; 2564 : 					else
; 2565 : 						a = clicked_t;

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR a$4[rsp], xmm0
$LN34@SliderBeha:

; 2566 : 					a = ImPow(a, power);

	movss	xmm1, DWORD PTR power$[rsp]
	movss	xmm0, DWORD PTR a$4[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR a$4[rsp], xmm0

; 2567 : 					v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);

	xor	edx, edx
	mov	rcx, QWORD PTR v_min$[rsp]
	call	??$ImMax@_J@@YA_J_J0@Z			; ImMax<__int64>
	movss	xmm2, DWORD PTR a$4[rsp]
	mov	rdx, QWORD PTR v_max$[rsp]
	mov	rcx, rax
	call	??$ImLerp@_J@@YA_J_J0M@Z		; ImLerp<__int64>
	mov	QWORD PTR v_new$5[rsp], rax
$LN32@SliderBeha:

; 2568 : 				}
; 2569 : 			}

	jmp	$LN30@SliderBeha
$LN29@SliderBeha:

; 2570 : 			else
; 2571 : 			{
; 2572 : 				// Linear slider
; 2573 : 				if (is_decimal)

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN35@SliderBeha

; 2574 : 				{
; 2575 : 					v_new = ImLerp(v_min, v_max, clicked_t);

	movss	xmm2, DWORD PTR clicked_t$3[rsp]
	mov	rdx, QWORD PTR v_max$[rsp]
	mov	rcx, QWORD PTR v_min$[rsp]
	call	??$ImLerp@_J@@YA_J_J0M@Z		; ImLerp<__int64>
	mov	QWORD PTR v_new$5[rsp], rax

; 2576 : 				}

	jmp	$LN36@SliderBeha
$LN35@SliderBeha:

; 2577 : 				else
; 2578 : 				{
; 2579 : 					// For integer values we want the clicking position to match the grab box so we round above
; 2580 : 					// This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2581 : 					FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;

	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2ss xmm0, rax
	mulss	xmm0, DWORD PTR clicked_t$3[rsp]
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR v_new_off_f$11[rsp], xmm0

; 2582 : 					TYPE v_new_off_floor = (TYPE)(v_new_off_f);

	cvttsd2si rax, QWORD PTR v_new_off_f$11[rsp]
	mov	QWORD PTR v_new_off_floor$13[rsp], rax

; 2583 : 					TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);

	movsd	xmm0, QWORD PTR v_new_off_f$11[rsp]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvttsd2si rax, xmm0
	mov	QWORD PTR v_new_off_round$12[rsp], rax

; 2584 : 					if (!is_decimal && v_new_off_floor < v_new_off_round)

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN37@SliderBeha
	mov	rax, QWORD PTR v_new_off_round$12[rsp]
	cmp	QWORD PTR v_new_off_floor$13[rsp], rax
	jge	SHORT $LN37@SliderBeha

; 2585 : 						v_new = v_min + v_new_off_round;

	mov	rax, QWORD PTR v_new_off_round$12[rsp]
	mov	rcx, QWORD PTR v_min$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_new$5[rsp], rax
	jmp	SHORT $LN38@SliderBeha
$LN37@SliderBeha:

; 2586 : 					else
; 2587 : 						v_new = v_min + v_new_off_floor;

	mov	rax, QWORD PTR v_new_off_floor$13[rsp]
	mov	rcx, QWORD PTR v_min$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_new$5[rsp], rax
$LN38@SliderBeha:
$LN36@SliderBeha:
$LN30@SliderBeha:

; 2588 : 				}
; 2589 : 			}
; 2590 : 
; 2591 : 			// Round to user desired precision based on format string
; 2592 : 			v_new = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_new);

	mov	r8, QWORD PTR v_new$5[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPEBDH_J@Z ; ImGui::RoundScalarWithFormatT<__int64,__int64>
	mov	QWORD PTR v_new$5[rsp], rax

; 2593 : 
; 2594 : 			// Apply result
; 2595 : 			if (*v != v_new)

	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_new$5[rsp]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN39@SliderBeha

; 2596 : 			{
; 2597 : 				*v = v_new;

	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_new$5[rsp]
	mov	QWORD PTR [rax], rcx

; 2598 : 				value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN39@SliderBeha:
$LN28@SliderBeha:
$LN5@SliderBeha:

; 2599 : 			}
; 2600 : 		}
; 2601 : 	}
; 2602 : 
; 2603 : 	// Output grab position so it can be displayed by the caller
; 2604 : 	float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9, QWORD PTR v_max$[rsp]
	mov	r8, QWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z ; ImGui::SliderCalcRatioFromValueT<__int64,double>
	movss	DWORD PTR grab_t$[rsp], xmm0

; 2605 : 	if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN40@SliderBeha

; 2606 : 		grab_t = 1.0f - grab_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR grab_t$[rsp]
	movss	DWORD PTR grab_t$[rsp], xmm0
$LN40@SliderBeha:

; 2607 : 	const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);

	movss	xmm2, DWORD PTR grab_t$[rsp]
	movss	xmm1, DWORD PTR slider_usable_pos_max$[rsp]
	movss	xmm0, DWORD PTR slider_usable_pos_min$[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR grab_pos$[rsp], xmm0

; 2608 : 	if (axis == ImGuiAxis_X)

	cmp	DWORD PTR axis$[rsp], 0
	jne	$LN41@SliderBeha

; 2609 : 		*out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR grab_pos$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	addss	xmm2, DWORD PTR __real@40000000
	movss	xmm3, DWORD PTR grab_sz$[rsp]
	mulss	xmm3, DWORD PTR __real@3f000000
	movss	xmm4, DWORD PTR grab_pos$[rsp]
	subss	xmm4, xmm3
	movaps	xmm3, xmm4
	movss	DWORD PTR tv408[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv408[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rdi, QWORD PTR out_grab_bb$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	jmp	$LN42@SliderBeha
$LN41@SliderBeha:

; 2610 : 	else
; 2611 : 		*out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);

	movss	xmm0, DWORD PTR grab_sz$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR grab_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR grab_sz$[rsp]
	mulss	xmm2, DWORD PTR __real@3f000000
	movss	xmm3, DWORD PTR grab_pos$[rsp]
	subss	xmm3, xmm2
	movaps	xmm2, xmm3
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm3, DWORD PTR [rax]
	addss	xmm3, DWORD PTR __real@40000000
	movss	DWORD PTR tv425[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv425[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rdi, QWORD PTR out_grab_bb$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN42@SliderBeha:

; 2612 : 
; 2613 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]

; 2614 : }

	add	rsp, 376				; 00000178H
	pop	rdi
	pop	rsi
	ret	0
??$SliderBehaviorT@_J_JN@ImGui@@YA_NAEBUImRect@@IHPEA_J_J2PEBDMHPEAU1@@Z ENDP ; ImGui::SliderBehaviorT<__int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$SliderBehaviorT@IHM@ImGui@@YA_NAEBUImRect@@IHPEAIIIPEBDMHPEAU1@@Z
_TEXT	SEGMENT
is_decimal$ = 48
set_new_value$1 = 49
is_power$ = 50
delta$2 = 52
clicked_t$3 = 56
tv70 = 60
tv74 = 61
value_changed$ = 62
grab_sz$ = 64
axis$ = 68
v_new$4 = 72
linear_zero_pos$ = 76
v_range$ = 80
a$5 = 84
grab_pos$ = 88
g$ = 96
slider_sz$ = 104
a$6 = 108
grab_t$ = 112
tv95 = 116
tv175 = 120
tv186 = 124
linear_dist_min_to_0$7 = 128
tv195 = 132
slider_usable_sz$ = 136
tv221 = 140
tv233 = 144
tv252 = 148
tv303 = 152
v_new_off_f$8 = 156
v_new_off_round$9 = 160
v_new_off_floor$10 = 164
slider_usable_pos_min$ = 168
tv67 = 172
tv178 = 176
tv189 = 180
linear_dist_max_to_0$11 = 184
mouse_abs_pos$12 = 188
decimal_precision$13 = 192
slider_usable_pos_max$ = 196
tv404 = 200
tv421 = 204
tv84 = 208
style$ = 216
delta2$14 = 224
grab_padding$ = 232
tv88 = 240
tv81 = 248
tv149 = 256
tv159 = 264
tv213 = 272
$T15 = 280
$T16 = 296
bb$ = 352
id$ = 360
data_type$ = 368
v$ = 376
v_min$ = 384
v_max$ = 392
format$ = 400
power$ = 408
flags$ = 416
out_grab_bb$ = 424
??$SliderBehaviorT@IHM@ImGui@@YA_NAEBUImRect@@IHPEAIIIPEBDMHPEAU1@@Z PROC ; ImGui::SliderBehaviorT<unsigned int,int,float>, COMDAT

; 2455 : {

$LN68:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 328				; 00000148H

; 2456 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2457 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 2458 : 
; 2459 : 	const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN44@SliderBeha
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN45@SliderBeha
$LN44@SliderBeha:
	mov	DWORD PTR tv67[rsp], 0
$LN45@SliderBeha:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR axis$[rsp], eax

; 2460 : 	const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN46@SliderBeha
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN46@SliderBeha
	mov	BYTE PTR tv70[rsp], 0
	jmp	SHORT $LN47@SliderBeha
$LN46@SliderBeha:
	mov	BYTE PTR tv70[rsp], 1
$LN47@SliderBeha:
	movzx	eax, BYTE PTR tv70[rsp]
	mov	BYTE PTR is_decimal$[rsp], al

; 2461 : 	const bool is_power = (power != 1.0f) && is_decimal;

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN67@SliderBeha
	je	SHORT $LN48@SliderBeha
$LN67@SliderBeha:
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN48@SliderBeha
	mov	BYTE PTR tv74[rsp], 1
	jmp	SHORT $LN49@SliderBeha
$LN48@SliderBeha:
	mov	BYTE PTR tv74[rsp], 0
$LN49@SliderBeha:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2462 : 
; 2463 : 	const float grab_padding = 2.0f;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR grab_padding$[rsp], xmm0

; 2464 : 	const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	QWORD PTR tv81[rsp], rax
	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv88[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv88[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	movss	DWORD PTR tv84[rsp], xmm0
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv81[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	movss	xmm1, DWORD PTR tv84[rsp]
	subss	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR slider_sz$[rsp], xmm0

; 2465 : 	float grab_sz = style.GrabMinSize;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+108]
	movss	DWORD PTR grab_sz$[rsp], xmm0

; 2466 : 	SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);

	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_min$[rsp], eax
	jae	SHORT $LN50@SliderBeha
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv95[rsp], eax
	jmp	SHORT $LN51@SliderBeha
$LN50@SliderBeha:
	mov	eax, DWORD PTR v_max$[rsp]
	mov	ecx, DWORD PTR v_min$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv95[rsp], eax
$LN51@SliderBeha:
	mov	eax, DWORD PTR tv95[rsp]
	mov	DWORD PTR v_range$[rsp], eax

; 2467 : 	if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN2@SliderBeha
	cmp	DWORD PTR v_range$[rsp], 0
	jl	SHORT $LN2@SliderBeha

; 2468 : 		grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit

	mov	eax, DWORD PTR v_range$[rsp]
	inc	eax
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR slider_sz$[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+108]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR grab_sz$[rsp], xmm0
$LN2@SliderBeha:

; 2469 : 	grab_sz = ImMin(grab_sz, slider_sz);

	movss	xmm1, DWORD PTR slider_sz$[rsp]
	movss	xmm0, DWORD PTR grab_sz$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR grab_sz$[rsp], xmm0

; 2470 : 	const float slider_usable_sz = slider_sz - grab_sz;

	movss	xmm0, DWORD PTR slider_sz$[rsp]
	subss	xmm0, DWORD PTR grab_sz$[rsp]
	movss	DWORD PTR slider_usable_sz$[rsp], xmm0

; 2471 : 	const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;

	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv149[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv149[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	addss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	movss	DWORD PTR slider_usable_pos_min$[rsp], xmm0

; 2472 : 	const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	QWORD PTR tv159[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv159[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	movss	DWORD PTR slider_usable_pos_max$[rsp], xmm0

; 2473 : 
; 2474 : 	// For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
; 2475 : 	float linear_zero_pos;   // 0.0->1.0f
; 2476 : 	if (is_power && v_min * v_max < 0.0f)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN3@SliderBeha
	mov	eax, DWORD PTR v_min$[rsp]
	imul	eax, DWORD PTR v_max$[rsp]
	mov	eax, eax
	cvtsi2ss xmm0, rax
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	$LN3@SliderBeha

; 2477 : 	{
; 2478 : 		// Different sign
; 2479 : 		const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR tv178[rsp], xmm0
	cmp	DWORD PTR v_min$[rsp], 0
	jb	SHORT $LN52@SliderBeha
	mov	eax, DWORD PTR v_min$[rsp]
	cvtsi2ss xmm0, rax
	movss	DWORD PTR tv175[rsp], xmm0
	jmp	SHORT $LN53@SliderBeha
$LN52@SliderBeha:
	mov	eax, DWORD PTR v_min$[rsp]
	cvtsi2ss xmm0, rax
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv175[rsp], xmm0
$LN53@SliderBeha:
	movss	xmm1, DWORD PTR tv178[rsp]
	movss	xmm0, DWORD PTR tv175[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR linear_dist_min_to_0$7[rsp], xmm0

; 2480 : 		const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR tv189[rsp], xmm0
	cmp	DWORD PTR v_max$[rsp], 0
	jb	SHORT $LN54@SliderBeha
	mov	eax, DWORD PTR v_max$[rsp]
	cvtsi2ss xmm0, rax
	movss	DWORD PTR tv186[rsp], xmm0
	jmp	SHORT $LN55@SliderBeha
$LN54@SliderBeha:
	mov	eax, DWORD PTR v_max$[rsp]
	cvtsi2ss xmm0, rax
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv186[rsp], xmm0
$LN55@SliderBeha:
	movss	xmm1, DWORD PTR tv189[rsp]
	movss	xmm0, DWORD PTR tv186[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR linear_dist_max_to_0$11[rsp], xmm0

; 2481 : 		linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));

	movss	xmm0, DWORD PTR linear_dist_min_to_0$7[rsp]
	addss	xmm0, DWORD PTR linear_dist_max_to_0$11[rsp]
	movss	xmm1, DWORD PTR linear_dist_min_to_0$7[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR linear_zero_pos$[rsp], xmm0

; 2482 : 	}

	jmp	SHORT $LN4@SliderBeha
$LN3@SliderBeha:

; 2483 : 	else
; 2484 : 	{
; 2485 : 		// Same sign
; 2486 : 		linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

	mov	eax, DWORD PTR v_min$[rsp]
	cvtsi2ss xmm0, rax
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN56@SliderBeha
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv195[rsp], xmm0
	jmp	SHORT $LN57@SliderBeha
$LN56@SliderBeha:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv195[rsp], xmm0
$LN57@SliderBeha:
	movss	xmm0, DWORD PTR tv195[rsp]
	movss	DWORD PTR linear_zero_pos$[rsp], xmm0
$LN4@SliderBeha:

; 2487 : 	}
; 2488 : 
; 2489 : 	// Process interacting with the slider
; 2490 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 2491 : 	if (g.ActiveId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	$LN5@SliderBeha

; 2492 : 	{
; 2493 : 		bool set_new_value = false;

	mov	BYTE PTR set_new_value$1[rsp], 0

; 2494 : 		float clicked_t = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2495 : 		if (g.ActiveIdSource == ImGuiInputSource_Mouse)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN6@SliderBeha

; 2496 : 		{
; 2497 : 			if (!g.IO.MouseDown[0])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	jne	SHORT $LN8@SliderBeha

; 2498 : 			{
; 2499 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 2500 : 			}

	jmp	$LN9@SliderBeha
$LN8@SliderBeha:

; 2501 : 			else
; 2502 : 			{
; 2503 : 				const float mouse_abs_pos = g.IO.MousePos[axis];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	QWORD PTR tv213[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv213[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR mouse_abs_pos$12[rsp], xmm0

; 2504 : 				clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

	movss	xmm0, DWORD PTR slider_usable_sz$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN58@SliderBeha
	movss	xmm0, DWORD PTR mouse_abs_pos$12[rsp]
	subss	xmm0, DWORD PTR slider_usable_pos_min$[rsp]
	divss	xmm0, DWORD PTR slider_usable_sz$[rsp]
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR tv221[rsp], xmm0
	jmp	SHORT $LN59@SliderBeha
$LN58@SliderBeha:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv221[rsp], xmm0
$LN59@SliderBeha:
	movss	xmm0, DWORD PTR tv221[rsp]
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2505 : 				if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN10@SliderBeha

; 2506 : 					clicked_t = 1.0f - clicked_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR clicked_t$3[rsp], xmm0
$LN10@SliderBeha:

; 2507 : 				set_new_value = true;

	mov	BYTE PTR set_new_value$1[rsp], 1
$LN9@SliderBeha:

; 2508 : 			}
; 2509 : 		}

	jmp	$LN7@SliderBeha
$LN6@SliderBeha:

; 2510 : 		else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	$LN11@SliderBeha

; 2511 : 		{
; 2512 : 			const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	mov	r8d, 5
	mov	edx, 3
	lea	rcx, QWORD PTR delta2$14[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d

; 2513 : 			float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;

	cmp	DWORD PTR axis$[rsp], 0
	jne	SHORT $LN60@SliderBeha
	movss	xmm0, DWORD PTR delta2$14[rsp]
	movss	DWORD PTR tv233[rsp], xmm0
	jmp	SHORT $LN61@SliderBeha
$LN60@SliderBeha:
	movss	xmm0, DWORD PTR delta2$14[rsp+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv233[rsp], xmm0
$LN61@SliderBeha:
	movss	xmm0, DWORD PTR tv233[rsp]
	movss	DWORD PTR delta$2[rsp], xmm0

; 2514 : 			if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7036], ecx
	jne	SHORT $LN12@SliderBeha
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	test	eax, eax
	jne	SHORT $LN12@SliderBeha

; 2515 : 			{
; 2516 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 2517 : 			}

	jmp	$LN13@SliderBeha
$LN12@SliderBeha:

; 2518 : 			else if (delta != 0.0f)

	movss	xmm0, DWORD PTR delta$2[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN66@SliderBeha
	je	$LN14@SliderBeha
$LN66@SliderBeha:

; 2519 : 			{
; 2520 : 				clicked_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR v_max$[rsp]
	mov	r8d, DWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z ; ImGui::SliderCalcRatioFromValueT<unsigned int,float>
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2521 : 				const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN62@SliderBeha
	mov	edx, 3
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	DWORD PTR tv252[rsp], eax
	jmp	SHORT $LN63@SliderBeha
$LN62@SliderBeha:
	mov	DWORD PTR tv252[rsp], 0
$LN63@SliderBeha:
	mov	eax, DWORD PTR tv252[rsp]
	mov	DWORD PTR decimal_precision$13[rsp], eax

; 2522 : 				if ((decimal_precision > 0) || is_power)

	cmp	DWORD PTR decimal_precision$13[rsp], 0
	jg	SHORT $LN17@SliderBeha
	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN15@SliderBeha
$LN17@SliderBeha:

; 2523 : 				{
; 2524 : 					delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR delta$2[rsp], xmm0

; 2525 : 					if (IsNavInputDown(ImGuiNavInput_TweakSlow))

	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@SliderBeha

; 2526 : 						delta /= 10.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN18@SliderBeha:

; 2527 : 				}

	jmp	$LN16@SliderBeha
$LN15@SliderBeha:

; 2528 : 				else
; 2529 : 				{
; 2530 : 					if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))

	cvtsi2ss xmm0, DWORD PTR v_range$[rsp]
	comiss	xmm0, DWORD PTR __real@c2c80000
	jb	SHORT $LN22@SliderBeha
	cvtsi2ss xmm0, DWORD PTR v_range$[rsp]
	movss	xmm1, DWORD PTR __real@42c80000
	comiss	xmm1, xmm0
	jae	SHORT $LN21@SliderBeha
$LN22@SliderBeha:
	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@SliderBeha
$LN21@SliderBeha:

; 2531 : 						delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta$2[rsp]
	jbe	SHORT $LN64@SliderBeha
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv303[rsp], xmm0
	jmp	SHORT $LN65@SliderBeha
$LN64@SliderBeha:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv303[rsp], xmm0
$LN65@SliderBeha:
	cvtsi2ss xmm0, DWORD PTR v_range$[rsp]
	movss	xmm1, DWORD PTR tv303[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR delta$2[rsp], xmm0
	jmp	SHORT $LN20@SliderBeha
$LN19@SliderBeha:

; 2532 : 					else
; 2533 : 						delta /= 100.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN20@SliderBeha:
$LN16@SliderBeha:

; 2534 : 				}
; 2535 : 				if (IsNavInputDown(ImGuiNavInput_TweakFast))

	mov	ecx, 15
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@SliderBeha

; 2536 : 					delta *= 10.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN23@SliderBeha:

; 2537 : 				set_new_value = true;

	mov	BYTE PTR set_new_value$1[rsp], 1

; 2538 : 				if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN27@SliderBeha
	movss	xmm0, DWORD PTR delta$2[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN26@SliderBeha
$LN27@SliderBeha:
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR clicked_t$3[rsp]
	jb	SHORT $LN24@SliderBeha
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta$2[rsp]
	jbe	SHORT $LN24@SliderBeha
$LN26@SliderBeha:

; 2539 : 					set_new_value = false;

	mov	BYTE PTR set_new_value$1[rsp], 0
	jmp	SHORT $LN25@SliderBeha
$LN24@SliderBeha:

; 2540 : 				else
; 2541 : 					clicked_t = ImSaturate(clicked_t + delta);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	addss	xmm0, DWORD PTR delta$2[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR clicked_t$3[rsp], xmm0
$LN25@SliderBeha:
$LN14@SliderBeha:
$LN13@SliderBeha:
$LN11@SliderBeha:
$LN7@SliderBeha:

; 2542 : 			}
; 2543 : 		}
; 2544 : 
; 2545 : 		if (set_new_value)

	movzx	eax, BYTE PTR set_new_value$1[rsp]
	test	eax, eax
	je	$LN28@SliderBeha

; 2546 : 		{
; 2547 : 			TYPE v_new;
; 2548 : 			if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN29@SliderBeha

; 2549 : 			{
; 2550 : 				// Account for power curve scale on both sides of the zero
; 2551 : 				if (clicked_t < linear_zero_pos)

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	comiss	xmm0, DWORD PTR clicked_t$3[rsp]
	jbe	SHORT $LN31@SliderBeha

; 2552 : 				{
; 2553 : 					// Negative: rescale to the negative range before powering
; 2554 : 					float a = 1.0f - (clicked_t / linear_zero_pos);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	divss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR a$6[rsp], xmm0

; 2555 : 					a = ImPow(a, power);

	movss	xmm1, DWORD PTR power$[rsp]
	movss	xmm0, DWORD PTR a$6[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR a$6[rsp], xmm0

; 2556 : 					v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);

	xor	edx, edx
	mov	ecx, DWORD PTR v_max$[rsp]
	call	??$ImMin@I@@YAIII@Z			; ImMin<unsigned int>
	movss	xmm2, DWORD PTR a$6[rsp]
	mov	edx, DWORD PTR v_min$[rsp]
	mov	ecx, eax
	call	??$ImLerp@I@@YAIIIM@Z			; ImLerp<unsigned int>
	mov	DWORD PTR v_new$4[rsp], eax

; 2557 : 				}

	jmp	$LN32@SliderBeha
$LN31@SliderBeha:

; 2558 : 				else
; 2559 : 				{
; 2560 : 					// Positive: rescale to the positive range before powering
; 2561 : 					float a;
; 2562 : 					if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	call	?ImFabs@@YAMM@Z				; ImFabs
	comiss	xmm0, DWORD PTR __real@358637bd
	jbe	SHORT $LN33@SliderBeha

; 2563 : 						a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	subss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	divss	xmm0, xmm1
	movss	DWORD PTR a$5[rsp], xmm0
	jmp	SHORT $LN34@SliderBeha
$LN33@SliderBeha:

; 2564 : 					else
; 2565 : 						a = clicked_t;

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR a$5[rsp], xmm0
$LN34@SliderBeha:

; 2566 : 					a = ImPow(a, power);

	movss	xmm1, DWORD PTR power$[rsp]
	movss	xmm0, DWORD PTR a$5[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR a$5[rsp], xmm0

; 2567 : 					v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);

	xor	edx, edx
	mov	ecx, DWORD PTR v_min$[rsp]
	call	??$ImMax@I@@YAIII@Z			; ImMax<unsigned int>
	movss	xmm2, DWORD PTR a$5[rsp]
	mov	edx, DWORD PTR v_max$[rsp]
	mov	ecx, eax
	call	??$ImLerp@I@@YAIIIM@Z			; ImLerp<unsigned int>
	mov	DWORD PTR v_new$4[rsp], eax
$LN32@SliderBeha:

; 2568 : 				}
; 2569 : 			}

	jmp	$LN30@SliderBeha
$LN29@SliderBeha:

; 2570 : 			else
; 2571 : 			{
; 2572 : 				// Linear slider
; 2573 : 				if (is_decimal)

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN35@SliderBeha

; 2574 : 				{
; 2575 : 					v_new = ImLerp(v_min, v_max, clicked_t);

	movss	xmm2, DWORD PTR clicked_t$3[rsp]
	mov	edx, DWORD PTR v_max$[rsp]
	mov	ecx, DWORD PTR v_min$[rsp]
	call	??$ImLerp@I@@YAIIIM@Z			; ImLerp<unsigned int>
	mov	DWORD PTR v_new$4[rsp], eax

; 2576 : 				}

	jmp	$LN36@SliderBeha
$LN35@SliderBeha:

; 2577 : 				else
; 2578 : 				{
; 2579 : 					// For integer values we want the clicking position to match the grab box so we round above
; 2580 : 					// This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2581 : 					FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;

	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	cvtsi2ss xmm0, rax
	mulss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR v_new_off_f$8[rsp], xmm0

; 2582 : 					TYPE v_new_off_floor = (TYPE)(v_new_off_f);

	cvttss2si rax, DWORD PTR v_new_off_f$8[rsp]
	mov	DWORD PTR v_new_off_floor$10[rsp], eax

; 2583 : 					TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);

	movss	xmm0, DWORD PTR v_new_off_f$8[rsp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si rax, xmm0
	mov	DWORD PTR v_new_off_round$9[rsp], eax

; 2584 : 					if (!is_decimal && v_new_off_floor < v_new_off_round)

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN37@SliderBeha
	mov	eax, DWORD PTR v_new_off_round$9[rsp]
	cmp	DWORD PTR v_new_off_floor$10[rsp], eax
	jae	SHORT $LN37@SliderBeha

; 2585 : 						v_new = v_min + v_new_off_round;

	mov	eax, DWORD PTR v_new_off_round$9[rsp]
	mov	ecx, DWORD PTR v_min$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v_new$4[rsp], eax
	jmp	SHORT $LN38@SliderBeha
$LN37@SliderBeha:

; 2586 : 					else
; 2587 : 						v_new = v_min + v_new_off_floor;

	mov	eax, DWORD PTR v_new_off_floor$10[rsp]
	mov	ecx, DWORD PTR v_min$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v_new$4[rsp], eax
$LN38@SliderBeha:
$LN36@SliderBeha:
$LN30@SliderBeha:

; 2588 : 				}
; 2589 : 			}
; 2590 : 
; 2591 : 			// Round to user desired precision based on format string
; 2592 : 			v_new = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_new);

	mov	r8d, DWORD PTR v_new$4[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	??$RoundScalarWithFormatT@IH@ImGui@@YAIPEBDHI@Z ; ImGui::RoundScalarWithFormatT<unsigned int,int>
	mov	DWORD PTR v_new$4[rsp], eax

; 2593 : 
; 2594 : 			// Apply result
; 2595 : 			if (*v != v_new)

	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_new$4[rsp]
	cmp	DWORD PTR [rax], ecx
	je	SHORT $LN39@SliderBeha

; 2596 : 			{
; 2597 : 				*v = v_new;

	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_new$4[rsp]
	mov	DWORD PTR [rax], ecx

; 2598 : 				value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN39@SliderBeha:
$LN28@SliderBeha:
$LN5@SliderBeha:

; 2599 : 			}
; 2600 : 		}
; 2601 : 	}
; 2602 : 
; 2603 : 	// Output grab position so it can be displayed by the caller
; 2604 : 	float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR v_max$[rsp]
	mov	r8d, DWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z ; ImGui::SliderCalcRatioFromValueT<unsigned int,float>
	movss	DWORD PTR grab_t$[rsp], xmm0

; 2605 : 	if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN40@SliderBeha

; 2606 : 		grab_t = 1.0f - grab_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR grab_t$[rsp]
	movss	DWORD PTR grab_t$[rsp], xmm0
$LN40@SliderBeha:

; 2607 : 	const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);

	movss	xmm2, DWORD PTR grab_t$[rsp]
	movss	xmm1, DWORD PTR slider_usable_pos_max$[rsp]
	movss	xmm0, DWORD PTR slider_usable_pos_min$[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR grab_pos$[rsp], xmm0

; 2608 : 	if (axis == ImGuiAxis_X)

	cmp	DWORD PTR axis$[rsp], 0
	jne	$LN41@SliderBeha

; 2609 : 		*out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR grab_pos$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	addss	xmm2, DWORD PTR __real@40000000
	movss	xmm3, DWORD PTR grab_sz$[rsp]
	mulss	xmm3, DWORD PTR __real@3f000000
	movss	xmm4, DWORD PTR grab_pos$[rsp]
	subss	xmm4, xmm3
	movaps	xmm3, xmm4
	movss	DWORD PTR tv404[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv404[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rdi, QWORD PTR out_grab_bb$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	jmp	$LN42@SliderBeha
$LN41@SliderBeha:

; 2610 : 	else
; 2611 : 		*out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);

	movss	xmm0, DWORD PTR grab_sz$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR grab_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR grab_sz$[rsp]
	mulss	xmm2, DWORD PTR __real@3f000000
	movss	xmm3, DWORD PTR grab_pos$[rsp]
	subss	xmm3, xmm2
	movaps	xmm2, xmm3
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm3, DWORD PTR [rax]
	addss	xmm3, DWORD PTR __real@40000000
	movss	DWORD PTR tv421[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv421[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rdi, QWORD PTR out_grab_bb$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN42@SliderBeha:

; 2612 : 
; 2613 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]

; 2614 : }

	add	rsp, 328				; 00000148H
	pop	rdi
	pop	rsi
	ret	0
??$SliderBehaviorT@IHM@ImGui@@YA_NAEBUImRect@@IHPEAIIIPEBDMHPEAU1@@Z ENDP ; ImGui::SliderBehaviorT<unsigned int,int,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$SliderBehaviorT@HHM@ImGui@@YA_NAEBUImRect@@IHPEAHHHPEBDMHPEAU1@@Z
_TEXT	SEGMENT
is_decimal$ = 48
set_new_value$1 = 49
is_power$ = 50
delta$2 = 52
clicked_t$3 = 56
tv70 = 60
tv74 = 61
value_changed$ = 62
grab_sz$ = 64
axis$ = 68
v_new$4 = 72
linear_zero_pos$ = 76
v_range$ = 80
a$5 = 84
grab_pos$ = 88
g$ = 96
slider_sz$ = 104
a$6 = 108
grab_t$ = 112
tv95 = 116
tv175 = 120
tv186 = 124
linear_dist_min_to_0$7 = 128
tv195 = 132
slider_usable_sz$ = 136
tv221 = 140
tv233 = 144
tv252 = 148
tv303 = 152
v_new_off_f$8 = 156
v_new_off_round$9 = 160
v_new_off_floor$10 = 164
slider_usable_pos_min$ = 168
tv67 = 172
tv178 = 176
tv189 = 180
linear_dist_max_to_0$11 = 184
mouse_abs_pos$12 = 188
decimal_precision$13 = 192
slider_usable_pos_max$ = 196
tv404 = 200
tv421 = 204
tv84 = 208
style$ = 216
delta2$14 = 224
grab_padding$ = 232
tv88 = 240
tv81 = 248
tv149 = 256
tv159 = 264
tv213 = 272
$T15 = 280
$T16 = 296
bb$ = 352
id$ = 360
data_type$ = 368
v$ = 376
v_min$ = 384
v_max$ = 392
format$ = 400
power$ = 408
flags$ = 416
out_grab_bb$ = 424
??$SliderBehaviorT@HHM@ImGui@@YA_NAEBUImRect@@IHPEAHHHPEBDMHPEAU1@@Z PROC ; ImGui::SliderBehaviorT<int,int,float>, COMDAT

; 2455 : {

$LN68:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 328				; 00000148H

; 2456 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2457 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 2458 : 
; 2459 : 	const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN44@SliderBeha
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN45@SliderBeha
$LN44@SliderBeha:
	mov	DWORD PTR tv67[rsp], 0
$LN45@SliderBeha:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR axis$[rsp], eax

; 2460 : 	const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN46@SliderBeha
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN46@SliderBeha
	mov	BYTE PTR tv70[rsp], 0
	jmp	SHORT $LN47@SliderBeha
$LN46@SliderBeha:
	mov	BYTE PTR tv70[rsp], 1
$LN47@SliderBeha:
	movzx	eax, BYTE PTR tv70[rsp]
	mov	BYTE PTR is_decimal$[rsp], al

; 2461 : 	const bool is_power = (power != 1.0f) && is_decimal;

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN67@SliderBeha
	je	SHORT $LN48@SliderBeha
$LN67@SliderBeha:
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN48@SliderBeha
	mov	BYTE PTR tv74[rsp], 1
	jmp	SHORT $LN49@SliderBeha
$LN48@SliderBeha:
	mov	BYTE PTR tv74[rsp], 0
$LN49@SliderBeha:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2462 : 
; 2463 : 	const float grab_padding = 2.0f;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR grab_padding$[rsp], xmm0

; 2464 : 	const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	QWORD PTR tv81[rsp], rax
	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv88[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv88[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	movss	DWORD PTR tv84[rsp], xmm0
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv81[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	movss	xmm1, DWORD PTR tv84[rsp]
	subss	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR slider_sz$[rsp], xmm0

; 2465 : 	float grab_sz = style.GrabMinSize;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+108]
	movss	DWORD PTR grab_sz$[rsp], xmm0

; 2466 : 	SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);

	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_min$[rsp], eax
	jge	SHORT $LN50@SliderBeha
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv95[rsp], eax
	jmp	SHORT $LN51@SliderBeha
$LN50@SliderBeha:
	mov	eax, DWORD PTR v_max$[rsp]
	mov	ecx, DWORD PTR v_min$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv95[rsp], eax
$LN51@SliderBeha:
	mov	eax, DWORD PTR tv95[rsp]
	mov	DWORD PTR v_range$[rsp], eax

; 2467 : 	if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN2@SliderBeha
	cmp	DWORD PTR v_range$[rsp], 0
	jl	SHORT $LN2@SliderBeha

; 2468 : 		grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit

	mov	eax, DWORD PTR v_range$[rsp]
	inc	eax
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR slider_sz$[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+108]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR grab_sz$[rsp], xmm0
$LN2@SliderBeha:

; 2469 : 	grab_sz = ImMin(grab_sz, slider_sz);

	movss	xmm1, DWORD PTR slider_sz$[rsp]
	movss	xmm0, DWORD PTR grab_sz$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR grab_sz$[rsp], xmm0

; 2470 : 	const float slider_usable_sz = slider_sz - grab_sz;

	movss	xmm0, DWORD PTR slider_sz$[rsp]
	subss	xmm0, DWORD PTR grab_sz$[rsp]
	movss	DWORD PTR slider_usable_sz$[rsp], xmm0

; 2471 : 	const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;

	mov	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR tv149[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv149[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	addss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	movss	DWORD PTR slider_usable_pos_min$[rsp], xmm0

; 2472 : 	const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	mov	QWORD PTR tv159[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv159[rsp]
	call	??AImVec2@@QEBAM_K@Z			; ImVec2::operator[]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	movss	DWORD PTR slider_usable_pos_max$[rsp], xmm0

; 2473 : 
; 2474 : 	// For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
; 2475 : 	float linear_zero_pos;   // 0.0->1.0f
; 2476 : 	if (is_power && v_min * v_max < 0.0f)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN3@SliderBeha
	mov	eax, DWORD PTR v_min$[rsp]
	imul	eax, DWORD PTR v_max$[rsp]
	cvtsi2ss xmm0, eax
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	$LN3@SliderBeha

; 2477 : 	{
; 2478 : 		// Different sign
; 2479 : 		const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR tv178[rsp], xmm0
	cmp	DWORD PTR v_min$[rsp], 0
	jl	SHORT $LN52@SliderBeha
	cvtsi2ss xmm0, DWORD PTR v_min$[rsp]
	movss	DWORD PTR tv175[rsp], xmm0
	jmp	SHORT $LN53@SliderBeha
$LN52@SliderBeha:
	cvtsi2ss xmm0, DWORD PTR v_min$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv175[rsp], xmm0
$LN53@SliderBeha:
	movss	xmm1, DWORD PTR tv178[rsp]
	movss	xmm0, DWORD PTR tv175[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR linear_dist_min_to_0$7[rsp], xmm0

; 2480 : 		const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR tv189[rsp], xmm0
	cmp	DWORD PTR v_max$[rsp], 0
	jl	SHORT $LN54@SliderBeha
	cvtsi2ss xmm0, DWORD PTR v_max$[rsp]
	movss	DWORD PTR tv186[rsp], xmm0
	jmp	SHORT $LN55@SliderBeha
$LN54@SliderBeha:
	cvtsi2ss xmm0, DWORD PTR v_max$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv186[rsp], xmm0
$LN55@SliderBeha:
	movss	xmm1, DWORD PTR tv189[rsp]
	movss	xmm0, DWORD PTR tv186[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR linear_dist_max_to_0$11[rsp], xmm0

; 2481 : 		linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));

	movss	xmm0, DWORD PTR linear_dist_min_to_0$7[rsp]
	addss	xmm0, DWORD PTR linear_dist_max_to_0$11[rsp]
	movss	xmm1, DWORD PTR linear_dist_min_to_0$7[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR linear_zero_pos$[rsp], xmm0

; 2482 : 	}

	jmp	SHORT $LN4@SliderBeha
$LN3@SliderBeha:

; 2483 : 	else
; 2484 : 	{
; 2485 : 		// Same sign
; 2486 : 		linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

	cvtsi2ss xmm0, DWORD PTR v_min$[rsp]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN56@SliderBeha
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv195[rsp], xmm0
	jmp	SHORT $LN57@SliderBeha
$LN56@SliderBeha:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv195[rsp], xmm0
$LN57@SliderBeha:
	movss	xmm0, DWORD PTR tv195[rsp]
	movss	DWORD PTR linear_zero_pos$[rsp], xmm0
$LN4@SliderBeha:

; 2487 : 	}
; 2488 : 
; 2489 : 	// Process interacting with the slider
; 2490 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 2491 : 	if (g.ActiveId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	$LN5@SliderBeha

; 2492 : 	{
; 2493 : 		bool set_new_value = false;

	mov	BYTE PTR set_new_value$1[rsp], 0

; 2494 : 		float clicked_t = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2495 : 		if (g.ActiveIdSource == ImGuiInputSource_Mouse)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN6@SliderBeha

; 2496 : 		{
; 2497 : 			if (!g.IO.MouseDown[0])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	jne	SHORT $LN8@SliderBeha

; 2498 : 			{
; 2499 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 2500 : 			}

	jmp	$LN9@SliderBeha
$LN8@SliderBeha:

; 2501 : 			else
; 2502 : 			{
; 2503 : 				const float mouse_abs_pos = g.IO.MousePos[axis];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	QWORD PTR tv213[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv213[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR mouse_abs_pos$12[rsp], xmm0

; 2504 : 				clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

	movss	xmm0, DWORD PTR slider_usable_sz$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN58@SliderBeha
	movss	xmm0, DWORD PTR mouse_abs_pos$12[rsp]
	subss	xmm0, DWORD PTR slider_usable_pos_min$[rsp]
	divss	xmm0, DWORD PTR slider_usable_sz$[rsp]
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR tv221[rsp], xmm0
	jmp	SHORT $LN59@SliderBeha
$LN58@SliderBeha:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv221[rsp], xmm0
$LN59@SliderBeha:
	movss	xmm0, DWORD PTR tv221[rsp]
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2505 : 				if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN10@SliderBeha

; 2506 : 					clicked_t = 1.0f - clicked_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR clicked_t$3[rsp], xmm0
$LN10@SliderBeha:

; 2507 : 				set_new_value = true;

	mov	BYTE PTR set_new_value$1[rsp], 1
$LN9@SliderBeha:

; 2508 : 			}
; 2509 : 		}

	jmp	$LN7@SliderBeha
$LN6@SliderBeha:

; 2510 : 		else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	$LN11@SliderBeha

; 2511 : 		{
; 2512 : 			const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	mov	r8d, 5
	mov	edx, 3
	lea	rcx, QWORD PTR delta2$14[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d

; 2513 : 			float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;

	cmp	DWORD PTR axis$[rsp], 0
	jne	SHORT $LN60@SliderBeha
	movss	xmm0, DWORD PTR delta2$14[rsp]
	movss	DWORD PTR tv233[rsp], xmm0
	jmp	SHORT $LN61@SliderBeha
$LN60@SliderBeha:
	movss	xmm0, DWORD PTR delta2$14[rsp+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv233[rsp], xmm0
$LN61@SliderBeha:
	movss	xmm0, DWORD PTR tv233[rsp]
	movss	DWORD PTR delta$2[rsp], xmm0

; 2514 : 			if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7036], ecx
	jne	SHORT $LN12@SliderBeha
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	test	eax, eax
	jne	SHORT $LN12@SliderBeha

; 2515 : 			{
; 2516 : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1

; 2517 : 			}

	jmp	$LN13@SliderBeha
$LN12@SliderBeha:

; 2518 : 			else if (delta != 0.0f)

	movss	xmm0, DWORD PTR delta$2[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN66@SliderBeha
	je	$LN14@SliderBeha
$LN66@SliderBeha:

; 2519 : 			{
; 2520 : 				clicked_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR v_max$[rsp]
	mov	r8d, DWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z ; ImGui::SliderCalcRatioFromValueT<int,float>
	movss	DWORD PTR clicked_t$3[rsp], xmm0

; 2521 : 				const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN62@SliderBeha
	mov	edx, 3
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	DWORD PTR tv252[rsp], eax
	jmp	SHORT $LN63@SliderBeha
$LN62@SliderBeha:
	mov	DWORD PTR tv252[rsp], 0
$LN63@SliderBeha:
	mov	eax, DWORD PTR tv252[rsp]
	mov	DWORD PTR decimal_precision$13[rsp], eax

; 2522 : 				if ((decimal_precision > 0) || is_power)

	cmp	DWORD PTR decimal_precision$13[rsp], 0
	jg	SHORT $LN17@SliderBeha
	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN15@SliderBeha
$LN17@SliderBeha:

; 2523 : 				{
; 2524 : 					delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR delta$2[rsp], xmm0

; 2525 : 					if (IsNavInputDown(ImGuiNavInput_TweakSlow))

	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@SliderBeha

; 2526 : 						delta /= 10.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN18@SliderBeha:

; 2527 : 				}

	jmp	$LN16@SliderBeha
$LN15@SliderBeha:

; 2528 : 				else
; 2529 : 				{
; 2530 : 					if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))

	cvtsi2ss xmm0, DWORD PTR v_range$[rsp]
	comiss	xmm0, DWORD PTR __real@c2c80000
	jb	SHORT $LN22@SliderBeha
	cvtsi2ss xmm0, DWORD PTR v_range$[rsp]
	movss	xmm1, DWORD PTR __real@42c80000
	comiss	xmm1, xmm0
	jae	SHORT $LN21@SliderBeha
$LN22@SliderBeha:
	mov	ecx, 14
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@SliderBeha
$LN21@SliderBeha:

; 2531 : 						delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta$2[rsp]
	jbe	SHORT $LN64@SliderBeha
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv303[rsp], xmm0
	jmp	SHORT $LN65@SliderBeha
$LN64@SliderBeha:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv303[rsp], xmm0
$LN65@SliderBeha:
	cvtsi2ss xmm0, DWORD PTR v_range$[rsp]
	movss	xmm1, DWORD PTR tv303[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR delta$2[rsp], xmm0
	jmp	SHORT $LN20@SliderBeha
$LN19@SliderBeha:

; 2532 : 					else
; 2533 : 						delta /= 100.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN20@SliderBeha:
$LN16@SliderBeha:

; 2534 : 				}
; 2535 : 				if (IsNavInputDown(ImGuiNavInput_TweakFast))

	mov	ecx, 15
	call	?IsNavInputDown@ImGui@@YA_NH@Z		; ImGui::IsNavInputDown
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@SliderBeha

; 2536 : 					delta *= 10.0f;

	movss	xmm0, DWORD PTR delta$2[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR delta$2[rsp], xmm0
$LN23@SliderBeha:

; 2537 : 				set_new_value = true;

	mov	BYTE PTR set_new_value$1[rsp], 1

; 2538 : 				if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN27@SliderBeha
	movss	xmm0, DWORD PTR delta$2[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN26@SliderBeha
$LN27@SliderBeha:
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR clicked_t$3[rsp]
	jb	SHORT $LN24@SliderBeha
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR delta$2[rsp]
	jbe	SHORT $LN24@SliderBeha
$LN26@SliderBeha:

; 2539 : 					set_new_value = false;

	mov	BYTE PTR set_new_value$1[rsp], 0
	jmp	SHORT $LN25@SliderBeha
$LN24@SliderBeha:

; 2540 : 				else
; 2541 : 					clicked_t = ImSaturate(clicked_t + delta);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	addss	xmm0, DWORD PTR delta$2[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR clicked_t$3[rsp], xmm0
$LN25@SliderBeha:
$LN14@SliderBeha:
$LN13@SliderBeha:
$LN11@SliderBeha:
$LN7@SliderBeha:

; 2542 : 			}
; 2543 : 		}
; 2544 : 
; 2545 : 		if (set_new_value)

	movzx	eax, BYTE PTR set_new_value$1[rsp]
	test	eax, eax
	je	$LN28@SliderBeha

; 2546 : 		{
; 2547 : 			TYPE v_new;
; 2548 : 			if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN29@SliderBeha

; 2549 : 			{
; 2550 : 				// Account for power curve scale on both sides of the zero
; 2551 : 				if (clicked_t < linear_zero_pos)

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	comiss	xmm0, DWORD PTR clicked_t$3[rsp]
	jbe	SHORT $LN31@SliderBeha

; 2552 : 				{
; 2553 : 					// Negative: rescale to the negative range before powering
; 2554 : 					float a = 1.0f - (clicked_t / linear_zero_pos);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	divss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR a$6[rsp], xmm0

; 2555 : 					a = ImPow(a, power);

	movss	xmm1, DWORD PTR power$[rsp]
	movss	xmm0, DWORD PTR a$6[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR a$6[rsp], xmm0

; 2556 : 					v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);

	xor	edx, edx
	mov	ecx, DWORD PTR v_max$[rsp]
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	movss	xmm2, DWORD PTR a$6[rsp]
	mov	edx, DWORD PTR v_min$[rsp]
	mov	ecx, eax
	call	??$ImLerp@H@@YAHHHM@Z			; ImLerp<int>
	mov	DWORD PTR v_new$4[rsp], eax

; 2557 : 				}

	jmp	$LN32@SliderBeha
$LN31@SliderBeha:

; 2558 : 				else
; 2559 : 				{
; 2560 : 					// Positive: rescale to the positive range before powering
; 2561 : 					float a;
; 2562 : 					if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	call	?ImFabs@@YAMM@Z				; ImFabs
	comiss	xmm0, DWORD PTR __real@358637bd
	jbe	SHORT $LN33@SliderBeha

; 2563 : 						a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	subss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR linear_zero_pos$[rsp]
	divss	xmm0, xmm1
	movss	DWORD PTR a$5[rsp], xmm0
	jmp	SHORT $LN34@SliderBeha
$LN33@SliderBeha:

; 2564 : 					else
; 2565 : 						a = clicked_t;

	movss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR a$5[rsp], xmm0
$LN34@SliderBeha:

; 2566 : 					a = ImPow(a, power);

	movss	xmm1, DWORD PTR power$[rsp]
	movss	xmm0, DWORD PTR a$5[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR a$5[rsp], xmm0

; 2567 : 					v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);

	xor	edx, edx
	mov	ecx, DWORD PTR v_min$[rsp]
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	movss	xmm2, DWORD PTR a$5[rsp]
	mov	edx, DWORD PTR v_max$[rsp]
	mov	ecx, eax
	call	??$ImLerp@H@@YAHHHM@Z			; ImLerp<int>
	mov	DWORD PTR v_new$4[rsp], eax
$LN32@SliderBeha:

; 2568 : 				}
; 2569 : 			}

	jmp	$LN30@SliderBeha
$LN29@SliderBeha:

; 2570 : 			else
; 2571 : 			{
; 2572 : 				// Linear slider
; 2573 : 				if (is_decimal)

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN35@SliderBeha

; 2574 : 				{
; 2575 : 					v_new = ImLerp(v_min, v_max, clicked_t);

	movss	xmm2, DWORD PTR clicked_t$3[rsp]
	mov	edx, DWORD PTR v_max$[rsp]
	mov	ecx, DWORD PTR v_min$[rsp]
	call	??$ImLerp@H@@YAHHHM@Z			; ImLerp<int>
	mov	DWORD PTR v_new$4[rsp], eax

; 2576 : 				}

	jmp	$LN36@SliderBeha
$LN35@SliderBeha:

; 2577 : 				else
; 2578 : 				{
; 2579 : 					// For integer values we want the clicking position to match the grab box so we round above
; 2580 : 					// This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2581 : 					FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;

	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR clicked_t$3[rsp]
	movss	DWORD PTR v_new_off_f$8[rsp], xmm0

; 2582 : 					TYPE v_new_off_floor = (TYPE)(v_new_off_f);

	cvttss2si eax, DWORD PTR v_new_off_f$8[rsp]
	mov	DWORD PTR v_new_off_floor$10[rsp], eax

; 2583 : 					TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);

	movss	xmm0, DWORD PTR v_new_off_f$8[rsp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR v_new_off_round$9[rsp], eax

; 2584 : 					if (!is_decimal && v_new_off_floor < v_new_off_round)

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN37@SliderBeha
	mov	eax, DWORD PTR v_new_off_round$9[rsp]
	cmp	DWORD PTR v_new_off_floor$10[rsp], eax
	jge	SHORT $LN37@SliderBeha

; 2585 : 						v_new = v_min + v_new_off_round;

	mov	eax, DWORD PTR v_new_off_round$9[rsp]
	mov	ecx, DWORD PTR v_min$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v_new$4[rsp], eax
	jmp	SHORT $LN38@SliderBeha
$LN37@SliderBeha:

; 2586 : 					else
; 2587 : 						v_new = v_min + v_new_off_floor;

	mov	eax, DWORD PTR v_new_off_floor$10[rsp]
	mov	ecx, DWORD PTR v_min$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v_new$4[rsp], eax
$LN38@SliderBeha:
$LN36@SliderBeha:
$LN30@SliderBeha:

; 2588 : 				}
; 2589 : 			}
; 2590 : 
; 2591 : 			// Round to user desired precision based on format string
; 2592 : 			v_new = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_new);

	mov	r8d, DWORD PTR v_new$4[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	??$RoundScalarWithFormatT@HH@ImGui@@YAHPEBDHH@Z ; ImGui::RoundScalarWithFormatT<int,int>
	mov	DWORD PTR v_new$4[rsp], eax

; 2593 : 
; 2594 : 			// Apply result
; 2595 : 			if (*v != v_new)

	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_new$4[rsp]
	cmp	DWORD PTR [rax], ecx
	je	SHORT $LN39@SliderBeha

; 2596 : 			{
; 2597 : 				*v = v_new;

	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_new$4[rsp]
	mov	DWORD PTR [rax], ecx

; 2598 : 				value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN39@SliderBeha:
$LN28@SliderBeha:
$LN5@SliderBeha:

; 2599 : 			}
; 2600 : 		}
; 2601 : 	}
; 2602 : 
; 2603 : 	// Output grab position so it can be displayed by the caller
; 2604 : 	float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR linear_zero_pos$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR v_max$[rsp]
	mov	r8d, DWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z ; ImGui::SliderCalcRatioFromValueT<int,float>
	movss	DWORD PTR grab_t$[rsp], xmm0

; 2605 : 	if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN40@SliderBeha

; 2606 : 		grab_t = 1.0f - grab_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR grab_t$[rsp]
	movss	DWORD PTR grab_t$[rsp], xmm0
$LN40@SliderBeha:

; 2607 : 	const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);

	movss	xmm2, DWORD PTR grab_t$[rsp]
	movss	xmm1, DWORD PTR slider_usable_pos_max$[rsp]
	movss	xmm0, DWORD PTR slider_usable_pos_min$[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR grab_pos$[rsp], xmm0

; 2608 : 	if (axis == ImGuiAxis_X)

	cmp	DWORD PTR axis$[rsp], 0
	jne	$LN41@SliderBeha

; 2609 : 		*out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR grab_pos$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	addss	xmm2, DWORD PTR __real@40000000
	movss	xmm3, DWORD PTR grab_sz$[rsp]
	mulss	xmm3, DWORD PTR __real@3f000000
	movss	xmm4, DWORD PTR grab_pos$[rsp]
	subss	xmm4, xmm3
	movaps	xmm3, xmm4
	movss	DWORD PTR tv404[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv404[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rdi, QWORD PTR out_grab_bb$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	jmp	$LN42@SliderBeha
$LN41@SliderBeha:

; 2610 : 	else
; 2611 : 		*out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);

	movss	xmm0, DWORD PTR grab_sz$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR grab_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR grab_sz$[rsp]
	mulss	xmm2, DWORD PTR __real@3f000000
	movss	xmm3, DWORD PTR grab_pos$[rsp]
	subss	xmm3, xmm2
	movaps	xmm2, xmm3
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm3, DWORD PTR [rax]
	addss	xmm3, DWORD PTR __real@40000000
	movss	DWORD PTR tv421[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv421[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rdi, QWORD PTR out_grab_bb$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN42@SliderBeha:

; 2612 : 
; 2613 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]

; 2614 : }

	add	rsp, 328				; 00000148H
	pop	rdi
	pop	rsi
	ret	0
??$SliderBehaviorT@HHM@ImGui@@YA_NAEBUImRect@@IHPEAHHHPEBDMHPEAU1@@Z ENDP ; ImGui::SliderBehaviorT<int,int,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMax@H@@YAHHH@Z PROC				; ImMax<int>

; 228  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	mov	eax, DWORD PTR rhs$[rsp]
	cmp	DWORD PTR lhs$[rsp], eax
	jl	SHORT $LN3@ImMax
	mov	eax, DWORD PTR lhs$[rsp]
	mov	DWORD PTR tv65[rsp], eax
	jmp	SHORT $LN4@ImMax
$LN3@ImMax:
	mov	eax, DWORD PTR rhs$[rsp]
	mov	DWORD PTR tv65[rsp], eax
$LN4@ImMax:
	mov	eax, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMax@H@@YAHHH@Z ENDP				; ImMax<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDMH@Z
_TEXT	SEGMENT
has_min_max$ = 48
is_decimal$ = 49
adjust_delta$ = 52
is_power$ = 56
tv69 = 57
tv71 = 58
tv79 = 59
g$ = 64
v_cur$ = 72
is_just_activated$ = 80
is_already_past_limits_and_pushing_outward$ = 81
is_drag_direction_change_with_power$ = 82
axis$ = 84
tv66 = 88
tv159 = 92
tv187 = 96
tv197 = 100
decimal_precision$1 = 104
v_old_norm_curved$2 = 112
v_old_ref_for_accum_remainder$ = 120
tv141 = 128
tv171 = 136
tv225 = 144
v_new_norm_curved$3 = 152
tv260 = 160
v_cur_norm_curved$4 = 168
$T5 = 176
data_type$ = 208
v$ = 216
v_speed$ = 224
v_min$ = 232
v_max$ = 240
format$ = 248
power$ = 256
flags$ = 264
??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDMH@Z PROC	; ImGui::DragBehaviorT<double,double,double>, COMDAT

; 2081 : {

$LN50:
	movsd	QWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 200				; 000000c8H

; 2082 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2083 : 	const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN26@DragBehavi
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN27@DragBehavi
$LN26@DragBehavi:
	mov	DWORD PTR tv66[rsp], 0
$LN27@DragBehavi:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR axis$[rsp], eax

; 2084 : 	const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN28@DragBehavi
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN28@DragBehavi
	mov	BYTE PTR tv69[rsp], 0
	jmp	SHORT $LN29@DragBehavi
$LN28@DragBehavi:
	mov	BYTE PTR tv69[rsp], 1
$LN29@DragBehavi:
	movzx	eax, BYTE PTR tv69[rsp]
	mov	BYTE PTR is_decimal$[rsp], al

; 2085 : 	const bool has_min_max = (v_min != v_max);

	movsd	xmm0, QWORD PTR v_min$[rsp]
	ucomisd	xmm0, QWORD PTR v_max$[rsp]
	jp	SHORT $LN49@DragBehavi
	je	SHORT $LN30@DragBehavi
$LN49@DragBehavi:
	mov	BYTE PTR tv71[rsp], 1
	jmp	SHORT $LN31@DragBehavi
$LN30@DragBehavi:
	mov	BYTE PTR tv71[rsp], 0
$LN31@DragBehavi:
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR has_min_max$[rsp], al

; 2086 : 	const bool is_power = (power != 1.0f && is_decimal && has_min_max && (v_max - v_min < FLT_MAX));

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN48@DragBehavi
	je	SHORT $LN32@DragBehavi
$LN48@DragBehavi:
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN32@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN32@DragBehavi
	movsd	xmm0, QWORD PTR v_max$[rsp]
	subsd	xmm0, QWORD PTR v_min$[rsp]
	movsd	xmm1, QWORD PTR __real@47efffffe0000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN32@DragBehavi
	mov	BYTE PTR tv79[rsp], 1
	jmp	SHORT $LN33@DragBehavi
$LN32@DragBehavi:
	mov	BYTE PTR tv79[rsp], 0
$LN33@DragBehavi:
	movzx	eax, BYTE PTR tv79[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2087 : 
; 2088 : 	// Default tweak speed
; 2089 : 	if (v_speed == 0.0f && has_min_max && (v_max - v_min < FLT_MAX))

	movss	xmm0, DWORD PTR v_speed$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN2@DragBehavi
	jne	SHORT $LN2@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN2@DragBehavi
	movsd	xmm0, QWORD PTR v_max$[rsp]
	subsd	xmm0, QWORD PTR v_min$[rsp]
	movsd	xmm1, QWORD PTR __real@47efffffe0000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN2@DragBehavi

; 2090 : 		v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	movsd	xmm0, QWORD PTR v_max$[rsp]
	subsd	xmm0, QWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	cvtss2sd xmm1, DWORD PTR [rax+11696]
	mulsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR v_speed$[rsp], xmm0
$LN2@DragBehavi:

; 2091 : 
; 2092 : 	// Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
; 2093 : 	float adjust_delta = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2094 : 	if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f * 1.0f)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN3@DragBehavi
	xor	ecx, ecx
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	$LN3@DragBehavi
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+3304]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN3@DragBehavi

; 2095 : 	{
; 2096 : 		adjust_delta = g.IO.MouseDelta[axis];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 968				; 000003c8H
	mov	QWORD PTR tv141[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv141[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2097 : 		if (g.IO.KeyAlt)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+324]
	test	eax, eax
	je	SHORT $LN5@DragBehavi

; 2098 : 			adjust_delta *= 1.0f / 100.0f;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN5@DragBehavi:

; 2099 : 		if (g.IO.KeyShift)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	je	SHORT $LN6@DragBehavi

; 2100 : 			adjust_delta *= 10.0f;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN6@DragBehavi:

; 2101 : 	}

	jmp	$LN4@DragBehavi
$LN3@DragBehavi:

; 2102 : 	else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	$LN7@DragBehavi

; 2103 : 	{
; 2104 : 		int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN34@DragBehavi
	mov	edx, 3
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	DWORD PTR tv159[rsp], eax
	jmp	SHORT $LN35@DragBehavi
$LN34@DragBehavi:
	mov	DWORD PTR tv159[rsp], 0
$LN35@DragBehavi:
	mov	eax, DWORD PTR tv159[rsp]
	mov	DWORD PTR decimal_precision$1[rsp], eax

; 2105 : 		adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3dcccccd
	mov	r8d, 5
	mov	edx, 3
	lea	rcx, QWORD PTR $T5[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
	mov	QWORD PTR tv171[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv171[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2106 : 		v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

	mov	ecx, DWORD PTR decimal_precision$1[rsp]
	call	?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR v_speed$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR v_speed$[rsp], xmm0
$LN7@DragBehavi:
$LN4@DragBehavi:

; 2107 : 	}
; 2108 : 	adjust_delta *= v_speed;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR v_speed$[rsp]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2109 : 
; 2110 : 	// For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 2111 : 	if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN8@DragBehavi

; 2112 : 		adjust_delta = -adjust_delta;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN8@DragBehavi:

; 2113 : 
; 2114 : 	// Clear current value on activation
; 2115 : 	// Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 2116 : 	bool is_just_activated = g.ActiveIdIsJustActivated;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	mov	BYTE PTR is_just_activated$[rsp], al

; 2117 : 	bool is_already_past_limits_and_pushing_outward = has_min_max && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN39@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	comisd	xmm0, QWORD PTR v_max$[rsp]
	jb	SHORT $LN36@DragBehavi
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN38@DragBehavi
$LN36@DragBehavi:
	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm0, QWORD PTR v_min$[rsp]
	comisd	xmm0, QWORD PTR [rax]
	jb	SHORT $LN37@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN39@DragBehavi
$LN38@DragBehavi:
	mov	DWORD PTR tv187[rsp], 1
	jmp	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
$LN37@DragBehavi:
	mov	DWORD PTR tv187[rsp], 0
$LN40@DragBehavi:
	movzx	eax, BYTE PTR tv187[rsp]
	mov	BYTE PTR is_already_past_limits_and_pushing_outward$[rsp], al

; 2118 : 	bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN44@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN41@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11672]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN43@DragBehavi
$LN41@DragBehavi:
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN42@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+11672]
	jbe	SHORT $LN44@DragBehavi
$LN43@DragBehavi:
	mov	DWORD PTR tv197[rsp], 1
	jmp	SHORT $LN45@DragBehavi
$LN44@DragBehavi:
$LN42@DragBehavi:
	mov	DWORD PTR tv197[rsp], 0
$LN45@DragBehavi:
	movzx	eax, BYTE PTR tv197[rsp]
	mov	BYTE PTR is_drag_direction_change_with_power$[rsp], al

; 2119 : 	if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)

	movzx	eax, BYTE PTR is_just_activated$[rsp]
	test	eax, eax
	jne	SHORT $LN11@DragBehavi
	movzx	eax, BYTE PTR is_already_past_limits_and_pushing_outward$[rsp]
	test	eax, eax
	jne	SHORT $LN11@DragBehavi
	movzx	eax, BYTE PTR is_drag_direction_change_with_power$[rsp]
	test	eax, eax
	je	SHORT $LN9@DragBehavi
$LN11@DragBehavi:

; 2120 : 	{
; 2121 : 		g.DragCurrentAccum = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+11672], xmm0

; 2122 : 		g.DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 2123 : 	}

	jmp	SHORT $LN10@DragBehavi
$LN9@DragBehavi:

; 2124 : 	else if (adjust_delta != 0.0f)

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN47@DragBehavi
	je	SHORT $LN12@DragBehavi
$LN47@DragBehavi:

; 2125 : 	{
; 2126 : 		g.DragCurrentAccum += adjust_delta;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11672]
	addss	xmm0, DWORD PTR adjust_delta$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0

; 2127 : 		g.DragCurrentAccumDirty = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 1
$LN12@DragBehavi:
$LN10@DragBehavi:

; 2128 : 	}
; 2129 : 
; 2130 : 	if (!g.DragCurrentAccumDirty)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+11668]
	test	eax, eax
	jne	SHORT $LN13@DragBehavi

; 2131 : 		return false;

	xor	al, al
	jmp	$LN1@DragBehavi
$LN13@DragBehavi:

; 2132 : 
; 2133 : 	TYPE v_cur = *v;

	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR v_cur$[rsp], xmm0

; 2134 : 	FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

	xorps	xmm0, xmm0
	movsd	QWORD PTR v_old_ref_for_accum_remainder$[rsp], xmm0

; 2135 : 
; 2136 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN14@DragBehavi

; 2137 : 	{
; 2138 : 		// Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
; 2139 : 		FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

	cvtss2sd xmm0, DWORD PTR power$[rsp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	xmm1, QWORD PTR v_cur$[rsp]
	subsd	xmm1, QWORD PTR v_min$[rsp]
	movsd	xmm2, QWORD PTR v_max$[rsp]
	subsd	xmm2, QWORD PTR v_min$[rsp]
	divsd	xmm1, xmm2
	movsd	QWORD PTR tv225[rsp], xmm1
	movaps	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv225[rsp]
	call	?ImPow@@YANNN@Z				; ImPow
	movsd	QWORD PTR v_old_norm_curved$2[rsp], xmm0

; 2140 : 		FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));

	mov	rax, QWORD PTR g$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+11672]
	movsd	xmm1, QWORD PTR v_max$[rsp]
	subsd	xmm1, QWORD PTR v_min$[rsp]
	divsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR v_old_norm_curved$2[rsp]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR v_new_norm_curved$3[rsp], xmm0

; 2141 : 		v_cur = v_min + (TYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);

	cvtsd2ss xmm0, QWORD PTR v_new_norm_curved$3[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	xmm1, DWORD PTR power$[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	cvtss2sd xmm0, xmm0
	movsd	xmm1, QWORD PTR v_max$[rsp]
	subsd	xmm1, QWORD PTR v_min$[rsp]
	mulsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR v_min$[rsp]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR v_cur$[rsp], xmm0

; 2142 : 		v_old_ref_for_accum_remainder = v_old_norm_curved;

	movsd	xmm0, QWORD PTR v_old_norm_curved$2[rsp]
	movsd	QWORD PTR v_old_ref_for_accum_remainder$[rsp], xmm0

; 2143 : 	}

	jmp	SHORT $LN15@DragBehavi
$LN14@DragBehavi:

; 2144 : 	else
; 2145 : 	{
; 2146 : 		v_cur += (TYPE)g.DragCurrentAccum;

	mov	rax, QWORD PTR g$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+11672]
	movsd	xmm1, QWORD PTR v_cur$[rsp]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR v_cur$[rsp], xmm0
$LN15@DragBehavi:

; 2147 : 	}
; 2148 : 
; 2149 : 	// Round to user desired precision based on format string
; 2150 : 	v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

	movsd	xmm2, QWORD PTR v_cur$[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	??$RoundScalarWithFormatT@NN@ImGui@@YANPEBDHN@Z ; ImGui::RoundScalarWithFormatT<double,double>
	movsd	QWORD PTR v_cur$[rsp], xmm0

; 2151 : 
; 2152 : 	// Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 2153 : 	g.DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 2154 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN16@DragBehavi

; 2155 : 	{
; 2156 : 		FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

	cvtss2sd xmm0, DWORD PTR power$[rsp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	xmm1, QWORD PTR v_cur$[rsp]
	subsd	xmm1, QWORD PTR v_min$[rsp]
	movsd	xmm2, QWORD PTR v_max$[rsp]
	subsd	xmm2, QWORD PTR v_min$[rsp]
	divsd	xmm1, xmm2
	movsd	QWORD PTR tv260[rsp], xmm1
	movaps	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv260[rsp]
	call	?ImPow@@YANNN@Z				; ImPow
	movsd	QWORD PTR v_cur_norm_curved$4[rsp], xmm0

; 2157 : 		g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);

	movsd	xmm0, QWORD PTR v_cur_norm_curved$4[rsp]
	subsd	xmm0, QWORD PTR v_old_ref_for_accum_remainder$[rsp]
	cvtsd2ss xmm0, xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0

; 2158 : 	}

	jmp	SHORT $LN17@DragBehavi
$LN16@DragBehavi:

; 2159 : 	else
; 2160 : 	{
; 2161 : 		g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm0, QWORD PTR v_cur$[rsp]
	subsd	xmm0, QWORD PTR [rax]
	cvtsd2ss xmm0, xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0
$LN17@DragBehavi:

; 2162 : 	}
; 2163 : 
; 2164 : 	// Lose zero sign for float/double
; 2165 : 	if (v_cur == (TYPE)-0)

	movsd	xmm0, QWORD PTR v_cur$[rsp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	jp	SHORT $LN18@DragBehavi
	jne	SHORT $LN18@DragBehavi

; 2166 : 		v_cur = (TYPE)0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR v_cur$[rsp], xmm0
$LN18@DragBehavi:

; 2167 : 
; 2168 : 	// Clamp values (+ handle overflow/wrap-around for integer types)
; 2169 : 	if (*v != v_cur && has_min_max)

	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	ucomisd	xmm0, QWORD PTR v_cur$[rsp]
	jp	SHORT $LN46@DragBehavi
	je	$LN19@DragBehavi
$LN46@DragBehavi:
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	$LN19@DragBehavi

; 2170 : 	{
; 2171 : 		if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))

	movsd	xmm0, QWORD PTR v_min$[rsp]
	comisd	xmm0, QWORD PTR v_cur$[rsp]
	ja	SHORT $LN21@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm0, QWORD PTR v_cur$[rsp]
	comisd	xmm0, QWORD PTR [rax]
	jbe	SHORT $LN20@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN20@DragBehavi
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN20@DragBehavi
$LN21@DragBehavi:

; 2172 : 			v_cur = v_min;

	movsd	xmm0, QWORD PTR v_min$[rsp]
	movsd	QWORD PTR v_cur$[rsp], xmm0
$LN20@DragBehavi:

; 2173 : 		if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))

	movsd	xmm0, QWORD PTR v_cur$[rsp]
	comisd	xmm0, QWORD PTR v_max$[rsp]
	ja	SHORT $LN23@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	comisd	xmm0, QWORD PTR v_cur$[rsp]
	jbe	SHORT $LN22@DragBehavi
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN22@DragBehavi
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN22@DragBehavi
$LN23@DragBehavi:

; 2174 : 			v_cur = v_max;

	movsd	xmm0, QWORD PTR v_max$[rsp]
	movsd	QWORD PTR v_cur$[rsp], xmm0
$LN22@DragBehavi:
$LN19@DragBehavi:

; 2175 : 	}
; 2176 : 
; 2177 : 	// Apply result
; 2178 : 	if (*v == v_cur)

	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	ucomisd	xmm0, QWORD PTR v_cur$[rsp]
	jp	SHORT $LN24@DragBehavi
	jne	SHORT $LN24@DragBehavi

; 2179 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@DragBehavi
$LN24@DragBehavi:

; 2180 : 	*v = v_cur;

	mov	rax, QWORD PTR v$[rsp]
	movsd	xmm0, QWORD PTR v_cur$[rsp]
	movsd	QWORD PTR [rax], xmm0

; 2181 : 	return true;

	mov	al, 1
$LN1@DragBehavi:

; 2182 : }

	add	rsp, 200				; 000000c8H
	ret	0
??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDMH@Z ENDP	; ImGui::DragBehaviorT<double,double,double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDMH@Z
_TEXT	SEGMENT
has_min_max$ = 48
is_decimal$ = 49
v_cur$ = 52
adjust_delta$ = 56
is_power$ = 60
tv69 = 61
tv71 = 62
tv79 = 63
g$ = 64
is_just_activated$ = 72
is_already_past_limits_and_pushing_outward$ = 73
is_drag_direction_change_with_power$ = 74
axis$ = 76
tv66 = 80
tv157 = 84
tv185 = 88
tv195 = 92
v_old_norm_curved$1 = 96
v_old_ref_for_accum_remainder$ = 100
decimal_precision$2 = 104
tv222 = 108
v_new_norm_curved$3 = 112
tv252 = 116
v_cur_norm_curved$4 = 120
tv139 = 128
tv169 = 136
$T5 = 144
data_type$ = 176
v$ = 184
v_speed$ = 192
v_min$ = 200
v_max$ = 208
format$ = 216
power$ = 224
flags$ = 232
??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDMH@Z PROC	; ImGui::DragBehaviorT<float,float,float>, COMDAT

; 2081 : {

$LN50:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 168				; 000000a8H

; 2082 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2083 : 	const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN26@DragBehavi
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN27@DragBehavi
$LN26@DragBehavi:
	mov	DWORD PTR tv66[rsp], 0
$LN27@DragBehavi:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR axis$[rsp], eax

; 2084 : 	const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN28@DragBehavi
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN28@DragBehavi
	mov	BYTE PTR tv69[rsp], 0
	jmp	SHORT $LN29@DragBehavi
$LN28@DragBehavi:
	mov	BYTE PTR tv69[rsp], 1
$LN29@DragBehavi:
	movzx	eax, BYTE PTR tv69[rsp]
	mov	BYTE PTR is_decimal$[rsp], al

; 2085 : 	const bool has_min_max = (v_min != v_max);

	movss	xmm0, DWORD PTR v_min$[rsp]
	ucomiss	xmm0, DWORD PTR v_max$[rsp]
	jp	SHORT $LN49@DragBehavi
	je	SHORT $LN30@DragBehavi
$LN49@DragBehavi:
	mov	BYTE PTR tv71[rsp], 1
	jmp	SHORT $LN31@DragBehavi
$LN30@DragBehavi:
	mov	BYTE PTR tv71[rsp], 0
$LN31@DragBehavi:
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR has_min_max$[rsp], al

; 2086 : 	const bool is_power = (power != 1.0f && is_decimal && has_min_max && (v_max - v_min < FLT_MAX));

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN48@DragBehavi
	je	SHORT $LN32@DragBehavi
$LN48@DragBehavi:
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN32@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN32@DragBehavi
	movss	xmm0, DWORD PTR v_max$[rsp]
	subss	xmm0, DWORD PTR v_min$[rsp]
	movss	xmm1, DWORD PTR __real@7f7fffff
	comiss	xmm1, xmm0
	jbe	SHORT $LN32@DragBehavi
	mov	BYTE PTR tv79[rsp], 1
	jmp	SHORT $LN33@DragBehavi
$LN32@DragBehavi:
	mov	BYTE PTR tv79[rsp], 0
$LN33@DragBehavi:
	movzx	eax, BYTE PTR tv79[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2087 : 
; 2088 : 	// Default tweak speed
; 2089 : 	if (v_speed == 0.0f && has_min_max && (v_max - v_min < FLT_MAX))

	movss	xmm0, DWORD PTR v_speed$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN2@DragBehavi
	jne	SHORT $LN2@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN2@DragBehavi
	movss	xmm0, DWORD PTR v_max$[rsp]
	subss	xmm0, DWORD PTR v_min$[rsp]
	movss	xmm1, DWORD PTR __real@7f7fffff
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@DragBehavi

; 2090 : 		v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	movss	xmm0, DWORD PTR v_max$[rsp]
	subss	xmm0, DWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mulss	xmm0, DWORD PTR [rax+11696]
	movss	DWORD PTR v_speed$[rsp], xmm0
$LN2@DragBehavi:

; 2091 : 
; 2092 : 	// Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
; 2093 : 	float adjust_delta = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2094 : 	if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f * 1.0f)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN3@DragBehavi
	xor	ecx, ecx
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	$LN3@DragBehavi
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+3304]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN3@DragBehavi

; 2095 : 	{
; 2096 : 		adjust_delta = g.IO.MouseDelta[axis];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 968				; 000003c8H
	mov	QWORD PTR tv139[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv139[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2097 : 		if (g.IO.KeyAlt)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+324]
	test	eax, eax
	je	SHORT $LN5@DragBehavi

; 2098 : 			adjust_delta *= 1.0f / 100.0f;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN5@DragBehavi:

; 2099 : 		if (g.IO.KeyShift)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	je	SHORT $LN6@DragBehavi

; 2100 : 			adjust_delta *= 10.0f;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN6@DragBehavi:

; 2101 : 	}

	jmp	$LN4@DragBehavi
$LN3@DragBehavi:

; 2102 : 	else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	$LN7@DragBehavi

; 2103 : 	{
; 2104 : 		int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN34@DragBehavi
	mov	edx, 3
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	DWORD PTR tv157[rsp], eax
	jmp	SHORT $LN35@DragBehavi
$LN34@DragBehavi:
	mov	DWORD PTR tv157[rsp], 0
$LN35@DragBehavi:
	mov	eax, DWORD PTR tv157[rsp]
	mov	DWORD PTR decimal_precision$2[rsp], eax

; 2105 : 		adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3dcccccd
	mov	r8d, 5
	mov	edx, 3
	lea	rcx, QWORD PTR $T5[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
	mov	QWORD PTR tv169[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv169[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2106 : 		v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

	mov	ecx, DWORD PTR decimal_precision$2[rsp]
	call	?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR v_speed$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR v_speed$[rsp], xmm0
$LN7@DragBehavi:
$LN4@DragBehavi:

; 2107 : 	}
; 2108 : 	adjust_delta *= v_speed;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR v_speed$[rsp]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2109 : 
; 2110 : 	// For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 2111 : 	if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN8@DragBehavi

; 2112 : 		adjust_delta = -adjust_delta;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN8@DragBehavi:

; 2113 : 
; 2114 : 	// Clear current value on activation
; 2115 : 	// Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 2116 : 	bool is_just_activated = g.ActiveIdIsJustActivated;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	mov	BYTE PTR is_just_activated$[rsp], al

; 2117 : 	bool is_already_past_limits_and_pushing_outward = has_min_max && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN39@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR v_max$[rsp]
	jb	SHORT $LN36@DragBehavi
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN38@DragBehavi
$LN36@DragBehavi:
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR v_min$[rsp]
	comiss	xmm0, DWORD PTR [rax]
	jb	SHORT $LN37@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN39@DragBehavi
$LN38@DragBehavi:
	mov	DWORD PTR tv185[rsp], 1
	jmp	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
$LN37@DragBehavi:
	mov	DWORD PTR tv185[rsp], 0
$LN40@DragBehavi:
	movzx	eax, BYTE PTR tv185[rsp]
	mov	BYTE PTR is_already_past_limits_and_pushing_outward$[rsp], al

; 2118 : 	bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN44@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN41@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11672]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN43@DragBehavi
$LN41@DragBehavi:
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN42@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+11672]
	jbe	SHORT $LN44@DragBehavi
$LN43@DragBehavi:
	mov	DWORD PTR tv195[rsp], 1
	jmp	SHORT $LN45@DragBehavi
$LN44@DragBehavi:
$LN42@DragBehavi:
	mov	DWORD PTR tv195[rsp], 0
$LN45@DragBehavi:
	movzx	eax, BYTE PTR tv195[rsp]
	mov	BYTE PTR is_drag_direction_change_with_power$[rsp], al

; 2119 : 	if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)

	movzx	eax, BYTE PTR is_just_activated$[rsp]
	test	eax, eax
	jne	SHORT $LN11@DragBehavi
	movzx	eax, BYTE PTR is_already_past_limits_and_pushing_outward$[rsp]
	test	eax, eax
	jne	SHORT $LN11@DragBehavi
	movzx	eax, BYTE PTR is_drag_direction_change_with_power$[rsp]
	test	eax, eax
	je	SHORT $LN9@DragBehavi
$LN11@DragBehavi:

; 2120 : 	{
; 2121 : 		g.DragCurrentAccum = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+11672], xmm0

; 2122 : 		g.DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 2123 : 	}

	jmp	SHORT $LN10@DragBehavi
$LN9@DragBehavi:

; 2124 : 	else if (adjust_delta != 0.0f)

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN47@DragBehavi
	je	SHORT $LN12@DragBehavi
$LN47@DragBehavi:

; 2125 : 	{
; 2126 : 		g.DragCurrentAccum += adjust_delta;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11672]
	addss	xmm0, DWORD PTR adjust_delta$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0

; 2127 : 		g.DragCurrentAccumDirty = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 1
$LN12@DragBehavi:
$LN10@DragBehavi:

; 2128 : 	}
; 2129 : 
; 2130 : 	if (!g.DragCurrentAccumDirty)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+11668]
	test	eax, eax
	jne	SHORT $LN13@DragBehavi

; 2131 : 		return false;

	xor	al, al
	jmp	$LN1@DragBehavi
$LN13@DragBehavi:

; 2132 : 
; 2133 : 	TYPE v_cur = *v;

	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR v_cur$[rsp], xmm0

; 2134 : 	FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR v_old_ref_for_accum_remainder$[rsp], xmm0

; 2135 : 
; 2136 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN14@DragBehavi

; 2137 : 	{
; 2138 : 		// Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
; 2139 : 		FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movss	xmm1, DWORD PTR v_cur$[rsp]
	subss	xmm1, DWORD PTR v_min$[rsp]
	movss	xmm2, DWORD PTR v_max$[rsp]
	subss	xmm2, DWORD PTR v_min$[rsp]
	divss	xmm1, xmm2
	movss	DWORD PTR tv222[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv222[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR v_old_norm_curved$1[rsp], xmm0

; 2140 : 		FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));

	movss	xmm0, DWORD PTR v_max$[rsp]
	subss	xmm0, DWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR v_old_norm_curved$1[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR v_new_norm_curved$3[rsp], xmm0

; 2141 : 		v_cur = v_min + (TYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);

	movss	xmm0, DWORD PTR v_new_norm_curved$3[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	xmm1, DWORD PTR power$[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	xmm1, DWORD PTR v_max$[rsp]
	subss	xmm1, DWORD PTR v_min$[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR v_min$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR v_cur$[rsp], xmm0

; 2142 : 		v_old_ref_for_accum_remainder = v_old_norm_curved;

	movss	xmm0, DWORD PTR v_old_norm_curved$1[rsp]
	movss	DWORD PTR v_old_ref_for_accum_remainder$[rsp], xmm0

; 2143 : 	}

	jmp	SHORT $LN15@DragBehavi
$LN14@DragBehavi:

; 2144 : 	else
; 2145 : 	{
; 2146 : 		v_cur += (TYPE)g.DragCurrentAccum;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR v_cur$[rsp]
	addss	xmm0, DWORD PTR [rax+11672]
	movss	DWORD PTR v_cur$[rsp], xmm0
$LN15@DragBehavi:

; 2147 : 	}
; 2148 : 
; 2149 : 	// Round to user desired precision based on format string
; 2150 : 	v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

	movss	xmm2, DWORD PTR v_cur$[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	??$RoundScalarWithFormatT@MM@ImGui@@YAMPEBDHM@Z ; ImGui::RoundScalarWithFormatT<float,float>
	movss	DWORD PTR v_cur$[rsp], xmm0

; 2151 : 
; 2152 : 	// Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 2153 : 	g.DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 2154 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN16@DragBehavi

; 2155 : 	{
; 2156 : 		FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	movss	xmm1, DWORD PTR v_cur$[rsp]
	subss	xmm1, DWORD PTR v_min$[rsp]
	movss	xmm2, DWORD PTR v_max$[rsp]
	subss	xmm2, DWORD PTR v_min$[rsp]
	divss	xmm1, xmm2
	movss	DWORD PTR tv252[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv252[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR v_cur_norm_curved$4[rsp], xmm0

; 2157 : 		g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);

	movss	xmm0, DWORD PTR v_cur_norm_curved$4[rsp]
	subss	xmm0, DWORD PTR v_old_ref_for_accum_remainder$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0

; 2158 : 	}

	jmp	SHORT $LN17@DragBehavi
$LN16@DragBehavi:

; 2159 : 	else
; 2160 : 	{
; 2161 : 		g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR v_cur$[rsp]
	subss	xmm0, DWORD PTR [rax]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0
$LN17@DragBehavi:

; 2162 : 	}
; 2163 : 
; 2164 : 	// Lose zero sign for float/double
; 2165 : 	if (v_cur == (TYPE)-0)

	movss	xmm0, DWORD PTR v_cur$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN18@DragBehavi
	jne	SHORT $LN18@DragBehavi

; 2166 : 		v_cur = (TYPE)0;

	xorps	xmm0, xmm0
	movss	DWORD PTR v_cur$[rsp], xmm0
$LN18@DragBehavi:

; 2167 : 
; 2168 : 	// Clamp values (+ handle overflow/wrap-around for integer types)
; 2169 : 	if (*v != v_cur && has_min_max)

	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	ucomiss	xmm0, DWORD PTR v_cur$[rsp]
	jp	SHORT $LN46@DragBehavi
	je	$LN19@DragBehavi
$LN46@DragBehavi:
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	$LN19@DragBehavi

; 2170 : 	{
; 2171 : 		if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))

	movss	xmm0, DWORD PTR v_min$[rsp]
	comiss	xmm0, DWORD PTR v_cur$[rsp]
	ja	SHORT $LN21@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR v_cur$[rsp]
	comiss	xmm0, DWORD PTR [rax]
	jbe	SHORT $LN20@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN20@DragBehavi
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN20@DragBehavi
$LN21@DragBehavi:

; 2172 : 			v_cur = v_min;

	movss	xmm0, DWORD PTR v_min$[rsp]
	movss	DWORD PTR v_cur$[rsp], xmm0
$LN20@DragBehavi:

; 2173 : 		if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))

	movss	xmm0, DWORD PTR v_cur$[rsp]
	comiss	xmm0, DWORD PTR v_max$[rsp]
	ja	SHORT $LN23@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR v_cur$[rsp]
	jbe	SHORT $LN22@DragBehavi
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN22@DragBehavi
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN22@DragBehavi
$LN23@DragBehavi:

; 2174 : 			v_cur = v_max;

	movss	xmm0, DWORD PTR v_max$[rsp]
	movss	DWORD PTR v_cur$[rsp], xmm0
$LN22@DragBehavi:
$LN19@DragBehavi:

; 2175 : 	}
; 2176 : 
; 2177 : 	// Apply result
; 2178 : 	if (*v == v_cur)

	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	ucomiss	xmm0, DWORD PTR v_cur$[rsp]
	jp	SHORT $LN24@DragBehavi
	jne	SHORT $LN24@DragBehavi

; 2179 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@DragBehavi
$LN24@DragBehavi:

; 2180 : 	*v = v_cur;

	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR v_cur$[rsp]
	movss	DWORD PTR [rax], xmm0

; 2181 : 	return true;

	mov	al, 1
$LN1@DragBehavi:

; 2182 : }

	add	rsp, 168				; 000000a8H
	ret	0
??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDMH@Z ENDP	; ImGui::DragBehaviorT<float,float,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDMH@Z
_TEXT	SEGMENT
has_min_max$ = 48
is_decimal$ = 49
adjust_delta$ = 52
is_power$ = 56
tv69 = 57
tv71 = 58
tv80 = 59
g$ = 64
v_cur$ = 72
is_just_activated$ = 80
is_already_past_limits_and_pushing_outward$ = 81
is_drag_direction_change_with_power$ = 82
axis$ = 84
tv66 = 88
tv160 = 92
tv188 = 96
tv198 = 100
decimal_precision$1 = 104
v_old_norm_curved$2 = 112
v_old_ref_for_accum_remainder$ = 120
tv142 = 128
tv172 = 136
tv226 = 144
v_new_norm_curved$3 = 152
tv262 = 160
v_cur_norm_curved$4 = 168
$T5 = 176
data_type$ = 208
v$ = 216
v_speed$ = 224
v_min$ = 232
v_max$ = 240
format$ = 248
power$ = 256
flags$ = 264
??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDMH@Z PROC ; ImGui::DragBehaviorT<unsigned __int64,__int64,double>, COMDAT

; 2081 : {

$LN66:
	mov	QWORD PTR [rsp+32], r9
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 200				; 000000c8H

; 2082 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2083 : 	const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN26@DragBehavi
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN27@DragBehavi
$LN26@DragBehavi:
	mov	DWORD PTR tv66[rsp], 0
$LN27@DragBehavi:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR axis$[rsp], eax

; 2084 : 	const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN28@DragBehavi
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN28@DragBehavi
	mov	BYTE PTR tv69[rsp], 0
	jmp	SHORT $LN29@DragBehavi
$LN28@DragBehavi:
	mov	BYTE PTR tv69[rsp], 1
$LN29@DragBehavi:
	movzx	eax, BYTE PTR tv69[rsp]
	mov	BYTE PTR is_decimal$[rsp], al

; 2085 : 	const bool has_min_max = (v_min != v_max);

	mov	rax, QWORD PTR v_max$[rsp]
	cmp	QWORD PTR v_min$[rsp], rax
	je	SHORT $LN30@DragBehavi
	mov	BYTE PTR tv71[rsp], 1
	jmp	SHORT $LN31@DragBehavi
$LN30@DragBehavi:
	mov	BYTE PTR tv71[rsp], 0
$LN31@DragBehavi:
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR has_min_max$[rsp], al

; 2086 : 	const bool is_power = (power != 1.0f && is_decimal && has_min_max && (v_max - v_min < FLT_MAX));

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN65@DragBehavi
	je	SHORT $LN32@DragBehavi
$LN65@DragBehavi:
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN32@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN32@DragBehavi
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jl	SHORT $LN63@DragBehavi
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN64@DragBehavi
$LN63@DragBehavi:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN64@DragBehavi:
	movss	xmm1, DWORD PTR __real@7f7fffff
	comiss	xmm1, xmm0
	jbe	SHORT $LN32@DragBehavi
	mov	BYTE PTR tv80[rsp], 1
	jmp	SHORT $LN33@DragBehavi
$LN32@DragBehavi:
	mov	BYTE PTR tv80[rsp], 0
$LN33@DragBehavi:
	movzx	eax, BYTE PTR tv80[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2087 : 
; 2088 : 	// Default tweak speed
; 2089 : 	if (v_speed == 0.0f && has_min_max && (v_max - v_min < FLT_MAX))

	movss	xmm0, DWORD PTR v_speed$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	$LN2@DragBehavi
	jne	$LN2@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	$LN2@DragBehavi
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jl	SHORT $LN61@DragBehavi
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN62@DragBehavi
$LN61@DragBehavi:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN62@DragBehavi:
	movss	xmm1, DWORD PTR __real@7f7fffff
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@DragBehavi

; 2090 : 		v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jl	SHORT $LN59@DragBehavi
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN60@DragBehavi
$LN59@DragBehavi:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN60@DragBehavi:
	mov	rax, QWORD PTR g$[rsp]
	mulss	xmm0, DWORD PTR [rax+11696]
	movss	DWORD PTR v_speed$[rsp], xmm0
$LN2@DragBehavi:

; 2091 : 
; 2092 : 	// Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
; 2093 : 	float adjust_delta = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2094 : 	if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f * 1.0f)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN3@DragBehavi
	xor	ecx, ecx
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	$LN3@DragBehavi
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+3304]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN3@DragBehavi

; 2095 : 	{
; 2096 : 		adjust_delta = g.IO.MouseDelta[axis];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 968				; 000003c8H
	mov	QWORD PTR tv142[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv142[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2097 : 		if (g.IO.KeyAlt)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+324]
	test	eax, eax
	je	SHORT $LN5@DragBehavi

; 2098 : 			adjust_delta *= 1.0f / 100.0f;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN5@DragBehavi:

; 2099 : 		if (g.IO.KeyShift)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	je	SHORT $LN6@DragBehavi

; 2100 : 			adjust_delta *= 10.0f;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN6@DragBehavi:

; 2101 : 	}

	jmp	$LN4@DragBehavi
$LN3@DragBehavi:

; 2102 : 	else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	$LN7@DragBehavi

; 2103 : 	{
; 2104 : 		int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN34@DragBehavi
	mov	edx, 3
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	DWORD PTR tv160[rsp], eax
	jmp	SHORT $LN35@DragBehavi
$LN34@DragBehavi:
	mov	DWORD PTR tv160[rsp], 0
$LN35@DragBehavi:
	mov	eax, DWORD PTR tv160[rsp]
	mov	DWORD PTR decimal_precision$1[rsp], eax

; 2105 : 		adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3dcccccd
	mov	r8d, 5
	mov	edx, 3
	lea	rcx, QWORD PTR $T5[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
	mov	QWORD PTR tv172[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv172[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2106 : 		v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

	mov	ecx, DWORD PTR decimal_precision$1[rsp]
	call	?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR v_speed$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR v_speed$[rsp], xmm0
$LN7@DragBehavi:
$LN4@DragBehavi:

; 2107 : 	}
; 2108 : 	adjust_delta *= v_speed;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR v_speed$[rsp]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2109 : 
; 2110 : 	// For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 2111 : 	if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN8@DragBehavi

; 2112 : 		adjust_delta = -adjust_delta;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN8@DragBehavi:

; 2113 : 
; 2114 : 	// Clear current value on activation
; 2115 : 	// Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 2116 : 	bool is_just_activated = g.ActiveIdIsJustActivated;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	mov	BYTE PTR is_just_activated$[rsp], al

; 2117 : 	bool is_already_past_limits_and_pushing_outward = has_min_max && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN39@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	cmp	QWORD PTR [rax], rcx
	jb	SHORT $LN36@DragBehavi
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN38@DragBehavi
$LN36@DragBehavi:
	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_min$[rsp]
	cmp	QWORD PTR [rax], rcx
	ja	SHORT $LN37@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN39@DragBehavi
$LN38@DragBehavi:
	mov	DWORD PTR tv188[rsp], 1
	jmp	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
$LN37@DragBehavi:
	mov	DWORD PTR tv188[rsp], 0
$LN40@DragBehavi:
	movzx	eax, BYTE PTR tv188[rsp]
	mov	BYTE PTR is_already_past_limits_and_pushing_outward$[rsp], al

; 2118 : 	bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN44@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN41@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11672]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN43@DragBehavi
$LN41@DragBehavi:
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN42@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+11672]
	jbe	SHORT $LN44@DragBehavi
$LN43@DragBehavi:
	mov	DWORD PTR tv198[rsp], 1
	jmp	SHORT $LN45@DragBehavi
$LN44@DragBehavi:
$LN42@DragBehavi:
	mov	DWORD PTR tv198[rsp], 0
$LN45@DragBehavi:
	movzx	eax, BYTE PTR tv198[rsp]
	mov	BYTE PTR is_drag_direction_change_with_power$[rsp], al

; 2119 : 	if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)

	movzx	eax, BYTE PTR is_just_activated$[rsp]
	test	eax, eax
	jne	SHORT $LN11@DragBehavi
	movzx	eax, BYTE PTR is_already_past_limits_and_pushing_outward$[rsp]
	test	eax, eax
	jne	SHORT $LN11@DragBehavi
	movzx	eax, BYTE PTR is_drag_direction_change_with_power$[rsp]
	test	eax, eax
	je	SHORT $LN9@DragBehavi
$LN11@DragBehavi:

; 2120 : 	{
; 2121 : 		g.DragCurrentAccum = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+11672], xmm0

; 2122 : 		g.DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 2123 : 	}

	jmp	SHORT $LN10@DragBehavi
$LN9@DragBehavi:

; 2124 : 	else if (adjust_delta != 0.0f)

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN58@DragBehavi
	je	SHORT $LN12@DragBehavi
$LN58@DragBehavi:

; 2125 : 	{
; 2126 : 		g.DragCurrentAccum += adjust_delta;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11672]
	addss	xmm0, DWORD PTR adjust_delta$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0

; 2127 : 		g.DragCurrentAccumDirty = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 1
$LN12@DragBehavi:
$LN10@DragBehavi:

; 2128 : 	}
; 2129 : 
; 2130 : 	if (!g.DragCurrentAccumDirty)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+11668]
	test	eax, eax
	jne	SHORT $LN13@DragBehavi

; 2131 : 		return false;

	xor	al, al
	jmp	$LN1@DragBehavi
$LN13@DragBehavi:

; 2132 : 
; 2133 : 	TYPE v_cur = *v;

	mov	rax, QWORD PTR v$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR v_cur$[rsp], rax

; 2134 : 	FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

	xorps	xmm0, xmm0
	movsd	QWORD PTR v_old_ref_for_accum_remainder$[rsp], xmm0

; 2135 : 
; 2136 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN14@DragBehavi

; 2137 : 	{
; 2138 : 		// Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
; 2139 : 		FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

	cvtss2sd xmm0, DWORD PTR power$[rsp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_cur$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jl	SHORT $LN56@DragBehavi
	cvtsi2sd xmm1, rax
	jmp	SHORT $LN57@DragBehavi
$LN56@DragBehavi:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm2, rcx
	addsd	xmm2, xmm2
	movaps	xmm1, xmm2
$LN57@DragBehavi:
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jl	SHORT $LN54@DragBehavi
	cvtsi2sd xmm2, rax
	jmp	SHORT $LN55@DragBehavi
$LN54@DragBehavi:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm3, rcx
	addsd	xmm3, xmm3
	movaps	xmm2, xmm3
$LN55@DragBehavi:
	divsd	xmm1, xmm2
	movsd	QWORD PTR tv226[rsp], xmm1
	movaps	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv226[rsp]
	call	?ImPow@@YANNN@Z				; ImPow
	movsd	QWORD PTR v_old_norm_curved$2[rsp], xmm0

; 2140 : 		FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));

	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jl	SHORT $LN52@DragBehavi
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN53@DragBehavi
$LN52@DragBehavi:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN53@DragBehavi:
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	movsd	xmm1, QWORD PTR v_old_norm_curved$2[rsp]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR v_new_norm_curved$3[rsp], xmm0

; 2141 : 		v_cur = v_min + (TYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);

	cvtsd2ss xmm0, QWORD PTR v_new_norm_curved$3[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	xmm1, DWORD PTR power$[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	xor	eax, eax
	comiss	xmm0, DWORD PTR __real@5f000000
	jb	SHORT $LN51@DragBehavi
	subss	xmm0, DWORD PTR __real@5f000000
	comiss	xmm0, DWORD PTR __real@5f000000
	jae	SHORT $LN51@DragBehavi
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN51@DragBehavi:
	cvttss2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR v_min$[rsp]
	mov	rdx, QWORD PTR v_max$[rsp]
	sub	rdx, rcx
	mov	rcx, rdx
	imul	rax, rcx
	mov	rcx, QWORD PTR v_min$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_cur$[rsp], rax

; 2142 : 		v_old_ref_for_accum_remainder = v_old_norm_curved;

	movsd	xmm0, QWORD PTR v_old_norm_curved$2[rsp]
	movsd	QWORD PTR v_old_ref_for_accum_remainder$[rsp], xmm0

; 2143 : 	}

	jmp	SHORT $LN15@DragBehavi
$LN14@DragBehavi:

; 2144 : 	else
; 2145 : 	{
; 2146 : 		v_cur += (TYPE)g.DragCurrentAccum;

	xor	eax, eax
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+11672]
	comiss	xmm0, DWORD PTR __real@5f000000
	jb	SHORT $LN50@DragBehavi
	subss	xmm0, DWORD PTR __real@5f000000
	comiss	xmm0, DWORD PTR __real@5f000000
	jae	SHORT $LN50@DragBehavi
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN50@DragBehavi:
	cvttss2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR v_cur$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_cur$[rsp], rax
$LN15@DragBehavi:

; 2147 : 	}
; 2148 : 
; 2149 : 	// Round to user desired precision based on format string
; 2150 : 	v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

	mov	r8, QWORD PTR v_cur$[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPEBDH_K@Z ; ImGui::RoundScalarWithFormatT<unsigned __int64,__int64>
	mov	QWORD PTR v_cur$[rsp], rax

; 2151 : 
; 2152 : 	// Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 2153 : 	g.DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 2154 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN16@DragBehavi

; 2155 : 	{
; 2156 : 		FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

	cvtss2sd xmm0, DWORD PTR power$[rsp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_cur$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jl	SHORT $LN48@DragBehavi
	cvtsi2sd xmm1, rax
	jmp	SHORT $LN49@DragBehavi
$LN48@DragBehavi:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm2, rcx
	addsd	xmm2, xmm2
	movaps	xmm1, xmm2
$LN49@DragBehavi:
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jl	SHORT $LN46@DragBehavi
	cvtsi2sd xmm2, rax
	jmp	SHORT $LN47@DragBehavi
$LN46@DragBehavi:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm3, rcx
	addsd	xmm3, xmm3
	movaps	xmm2, xmm3
$LN47@DragBehavi:
	divsd	xmm1, xmm2
	movsd	QWORD PTR tv262[rsp], xmm1
	movaps	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv262[rsp]
	call	?ImPow@@YANNN@Z				; ImPow
	movsd	QWORD PTR v_cur_norm_curved$4[rsp], xmm0

; 2157 : 		g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);

	movsd	xmm0, QWORD PTR v_cur_norm_curved$4[rsp]
	subsd	xmm0, QWORD PTR v_old_ref_for_accum_remainder$[rsp]
	cvtsd2ss xmm0, xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0

; 2158 : 	}

	jmp	SHORT $LN17@DragBehavi
$LN16@DragBehavi:

; 2159 : 	else
; 2160 : 	{
; 2161 : 		g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

	mov	rax, QWORD PTR v$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR v_cur$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2ss xmm0, rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0
$LN17@DragBehavi:

; 2162 : 	}
; 2163 : 
; 2164 : 	// Lose zero sign for float/double
; 2165 : 	if (v_cur == (TYPE)-0)

	cmp	QWORD PTR v_cur$[rsp], 0
	jne	SHORT $LN18@DragBehavi

; 2166 : 		v_cur = (TYPE)0;

	mov	QWORD PTR v_cur$[rsp], 0
$LN18@DragBehavi:

; 2167 : 
; 2168 : 	// Clamp values (+ handle overflow/wrap-around for integer types)
; 2169 : 	if (*v != v_cur && has_min_max)

	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_cur$[rsp]
	cmp	QWORD PTR [rax], rcx
	je	$LN19@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	$LN19@DragBehavi

; 2170 : 	{
; 2171 : 		if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))

	mov	rax, QWORD PTR v_min$[rsp]
	cmp	QWORD PTR v_cur$[rsp], rax
	jb	SHORT $LN21@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR v_cur$[rsp], rax
	jbe	SHORT $LN20@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN20@DragBehavi
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN20@DragBehavi
$LN21@DragBehavi:

; 2172 : 			v_cur = v_min;

	mov	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR v_cur$[rsp], rax
$LN20@DragBehavi:

; 2173 : 		if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))

	mov	rax, QWORD PTR v_max$[rsp]
	cmp	QWORD PTR v_cur$[rsp], rax
	ja	SHORT $LN23@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR v_cur$[rsp], rax
	jae	SHORT $LN22@DragBehavi
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN22@DragBehavi
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN22@DragBehavi
$LN23@DragBehavi:

; 2174 : 			v_cur = v_max;

	mov	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR v_cur$[rsp], rax
$LN22@DragBehavi:
$LN19@DragBehavi:

; 2175 : 	}
; 2176 : 
; 2177 : 	// Apply result
; 2178 : 	if (*v == v_cur)

	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_cur$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN24@DragBehavi

; 2179 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@DragBehavi
$LN24@DragBehavi:

; 2180 : 	*v = v_cur;

	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_cur$[rsp]
	mov	QWORD PTR [rax], rcx

; 2181 : 	return true;

	mov	al, 1
$LN1@DragBehavi:

; 2182 : }

	add	rsp, 200				; 000000c8H
	ret	0
??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDMH@Z ENDP ; ImGui::DragBehaviorT<unsigned __int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDMH@Z
_TEXT	SEGMENT
has_min_max$ = 48
is_decimal$ = 49
adjust_delta$ = 52
is_power$ = 56
tv69 = 57
tv71 = 58
tv80 = 59
g$ = 64
v_cur$ = 72
is_just_activated$ = 80
is_already_past_limits_and_pushing_outward$ = 81
is_drag_direction_change_with_power$ = 82
axis$ = 84
tv66 = 88
tv160 = 92
tv188 = 96
tv198 = 100
decimal_precision$1 = 104
v_old_norm_curved$2 = 112
v_old_ref_for_accum_remainder$ = 120
tv142 = 128
tv172 = 136
tv226 = 144
v_new_norm_curved$3 = 152
tv262 = 160
v_cur_norm_curved$4 = 168
$T5 = 176
data_type$ = 208
v$ = 216
v_speed$ = 224
v_min$ = 232
v_max$ = 240
format$ = 248
power$ = 256
flags$ = 264
??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDMH@Z PROC ; ImGui::DragBehaviorT<__int64,__int64,double>, COMDAT

; 2081 : {

$LN48:
	mov	QWORD PTR [rsp+32], r9
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 200				; 000000c8H

; 2082 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2083 : 	const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN26@DragBehavi
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN27@DragBehavi
$LN26@DragBehavi:
	mov	DWORD PTR tv66[rsp], 0
$LN27@DragBehavi:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR axis$[rsp], eax

; 2084 : 	const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN28@DragBehavi
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN28@DragBehavi
	mov	BYTE PTR tv69[rsp], 0
	jmp	SHORT $LN29@DragBehavi
$LN28@DragBehavi:
	mov	BYTE PTR tv69[rsp], 1
$LN29@DragBehavi:
	movzx	eax, BYTE PTR tv69[rsp]
	mov	BYTE PTR is_decimal$[rsp], al

; 2085 : 	const bool has_min_max = (v_min != v_max);

	mov	rax, QWORD PTR v_max$[rsp]
	cmp	QWORD PTR v_min$[rsp], rax
	je	SHORT $LN30@DragBehavi
	mov	BYTE PTR tv71[rsp], 1
	jmp	SHORT $LN31@DragBehavi
$LN30@DragBehavi:
	mov	BYTE PTR tv71[rsp], 0
$LN31@DragBehavi:
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR has_min_max$[rsp], al

; 2086 : 	const bool is_power = (power != 1.0f && is_decimal && has_min_max && (v_max - v_min < FLT_MAX));

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN47@DragBehavi
	je	SHORT $LN32@DragBehavi
$LN47@DragBehavi:
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN32@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN32@DragBehavi
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR __real@7f7fffff
	comiss	xmm1, xmm0
	jbe	SHORT $LN32@DragBehavi
	mov	BYTE PTR tv80[rsp], 1
	jmp	SHORT $LN33@DragBehavi
$LN32@DragBehavi:
	mov	BYTE PTR tv80[rsp], 0
$LN33@DragBehavi:
	movzx	eax, BYTE PTR tv80[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2087 : 
; 2088 : 	// Default tweak speed
; 2089 : 	if (v_speed == 0.0f && has_min_max && (v_max - v_min < FLT_MAX))

	movss	xmm0, DWORD PTR v_speed$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN2@DragBehavi
	jne	SHORT $LN2@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN2@DragBehavi
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR __real@7f7fffff
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@DragBehavi

; 2090 : 		v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2ss xmm0, rax
	mov	rax, QWORD PTR g$[rsp]
	mulss	xmm0, DWORD PTR [rax+11696]
	movss	DWORD PTR v_speed$[rsp], xmm0
$LN2@DragBehavi:

; 2091 : 
; 2092 : 	// Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
; 2093 : 	float adjust_delta = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2094 : 	if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f * 1.0f)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN3@DragBehavi
	xor	ecx, ecx
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	$LN3@DragBehavi
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+3304]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN3@DragBehavi

; 2095 : 	{
; 2096 : 		adjust_delta = g.IO.MouseDelta[axis];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 968				; 000003c8H
	mov	QWORD PTR tv142[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv142[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2097 : 		if (g.IO.KeyAlt)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+324]
	test	eax, eax
	je	SHORT $LN5@DragBehavi

; 2098 : 			adjust_delta *= 1.0f / 100.0f;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN5@DragBehavi:

; 2099 : 		if (g.IO.KeyShift)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	je	SHORT $LN6@DragBehavi

; 2100 : 			adjust_delta *= 10.0f;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN6@DragBehavi:

; 2101 : 	}

	jmp	$LN4@DragBehavi
$LN3@DragBehavi:

; 2102 : 	else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	$LN7@DragBehavi

; 2103 : 	{
; 2104 : 		int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN34@DragBehavi
	mov	edx, 3
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	DWORD PTR tv160[rsp], eax
	jmp	SHORT $LN35@DragBehavi
$LN34@DragBehavi:
	mov	DWORD PTR tv160[rsp], 0
$LN35@DragBehavi:
	mov	eax, DWORD PTR tv160[rsp]
	mov	DWORD PTR decimal_precision$1[rsp], eax

; 2105 : 		adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3dcccccd
	mov	r8d, 5
	mov	edx, 3
	lea	rcx, QWORD PTR $T5[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
	mov	QWORD PTR tv172[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv172[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2106 : 		v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

	mov	ecx, DWORD PTR decimal_precision$1[rsp]
	call	?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR v_speed$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR v_speed$[rsp], xmm0
$LN7@DragBehavi:
$LN4@DragBehavi:

; 2107 : 	}
; 2108 : 	adjust_delta *= v_speed;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR v_speed$[rsp]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2109 : 
; 2110 : 	// For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 2111 : 	if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN8@DragBehavi

; 2112 : 		adjust_delta = -adjust_delta;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN8@DragBehavi:

; 2113 : 
; 2114 : 	// Clear current value on activation
; 2115 : 	// Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 2116 : 	bool is_just_activated = g.ActiveIdIsJustActivated;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	mov	BYTE PTR is_just_activated$[rsp], al

; 2117 : 	bool is_already_past_limits_and_pushing_outward = has_min_max && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN39@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	cmp	QWORD PTR [rax], rcx
	jl	SHORT $LN36@DragBehavi
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN38@DragBehavi
$LN36@DragBehavi:
	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_min$[rsp]
	cmp	QWORD PTR [rax], rcx
	jg	SHORT $LN37@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN39@DragBehavi
$LN38@DragBehavi:
	mov	DWORD PTR tv188[rsp], 1
	jmp	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
$LN37@DragBehavi:
	mov	DWORD PTR tv188[rsp], 0
$LN40@DragBehavi:
	movzx	eax, BYTE PTR tv188[rsp]
	mov	BYTE PTR is_already_past_limits_and_pushing_outward$[rsp], al

; 2118 : 	bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN44@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN41@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11672]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN43@DragBehavi
$LN41@DragBehavi:
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN42@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+11672]
	jbe	SHORT $LN44@DragBehavi
$LN43@DragBehavi:
	mov	DWORD PTR tv198[rsp], 1
	jmp	SHORT $LN45@DragBehavi
$LN44@DragBehavi:
$LN42@DragBehavi:
	mov	DWORD PTR tv198[rsp], 0
$LN45@DragBehavi:
	movzx	eax, BYTE PTR tv198[rsp]
	mov	BYTE PTR is_drag_direction_change_with_power$[rsp], al

; 2119 : 	if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)

	movzx	eax, BYTE PTR is_just_activated$[rsp]
	test	eax, eax
	jne	SHORT $LN11@DragBehavi
	movzx	eax, BYTE PTR is_already_past_limits_and_pushing_outward$[rsp]
	test	eax, eax
	jne	SHORT $LN11@DragBehavi
	movzx	eax, BYTE PTR is_drag_direction_change_with_power$[rsp]
	test	eax, eax
	je	SHORT $LN9@DragBehavi
$LN11@DragBehavi:

; 2120 : 	{
; 2121 : 		g.DragCurrentAccum = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+11672], xmm0

; 2122 : 		g.DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 2123 : 	}

	jmp	SHORT $LN10@DragBehavi
$LN9@DragBehavi:

; 2124 : 	else if (adjust_delta != 0.0f)

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN46@DragBehavi
	je	SHORT $LN12@DragBehavi
$LN46@DragBehavi:

; 2125 : 	{
; 2126 : 		g.DragCurrentAccum += adjust_delta;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11672]
	addss	xmm0, DWORD PTR adjust_delta$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0

; 2127 : 		g.DragCurrentAccumDirty = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 1
$LN12@DragBehavi:
$LN10@DragBehavi:

; 2128 : 	}
; 2129 : 
; 2130 : 	if (!g.DragCurrentAccumDirty)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+11668]
	test	eax, eax
	jne	SHORT $LN13@DragBehavi

; 2131 : 		return false;

	xor	al, al
	jmp	$LN1@DragBehavi
$LN13@DragBehavi:

; 2132 : 
; 2133 : 	TYPE v_cur = *v;

	mov	rax, QWORD PTR v$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR v_cur$[rsp], rax

; 2134 : 	FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

	xorps	xmm0, xmm0
	movsd	QWORD PTR v_old_ref_for_accum_remainder$[rsp], xmm0

; 2135 : 
; 2136 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN14@DragBehavi

; 2137 : 	{
; 2138 : 		// Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
; 2139 : 		FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

	cvtss2sd xmm0, DWORD PTR power$[rsp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_cur$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2sd xmm1, rax
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2sd xmm2, rax
	divsd	xmm1, xmm2
	movsd	QWORD PTR tv226[rsp], xmm1
	movaps	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv226[rsp]
	call	?ImPow@@YANNN@Z				; ImPow
	movsd	QWORD PTR v_old_norm_curved$2[rsp], xmm0

; 2140 : 		FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));

	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2ss xmm0, rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	movsd	xmm1, QWORD PTR v_old_norm_curved$2[rsp]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR v_new_norm_curved$3[rsp], xmm0

; 2141 : 		v_cur = v_min + (TYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);

	cvtsd2ss xmm0, QWORD PTR v_new_norm_curved$3[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	xmm1, DWORD PTR power$[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	cvttss2si rax, xmm0
	mov	rcx, QWORD PTR v_min$[rsp]
	mov	rdx, QWORD PTR v_max$[rsp]
	sub	rdx, rcx
	mov	rcx, rdx
	imul	rax, rcx
	mov	rcx, QWORD PTR v_min$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_cur$[rsp], rax

; 2142 : 		v_old_ref_for_accum_remainder = v_old_norm_curved;

	movsd	xmm0, QWORD PTR v_old_norm_curved$2[rsp]
	movsd	QWORD PTR v_old_ref_for_accum_remainder$[rsp], xmm0

; 2143 : 	}

	jmp	SHORT $LN15@DragBehavi
$LN14@DragBehavi:

; 2144 : 	else
; 2145 : 	{
; 2146 : 		v_cur += (TYPE)g.DragCurrentAccum;

	mov	rax, QWORD PTR g$[rsp]
	cvttss2si rax, DWORD PTR [rax+11672]
	mov	rcx, QWORD PTR v_cur$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_cur$[rsp], rax
$LN15@DragBehavi:

; 2147 : 	}
; 2148 : 
; 2149 : 	// Round to user desired precision based on format string
; 2150 : 	v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

	mov	r8, QWORD PTR v_cur$[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPEBDH_J@Z ; ImGui::RoundScalarWithFormatT<__int64,__int64>
	mov	QWORD PTR v_cur$[rsp], rax

; 2151 : 
; 2152 : 	// Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 2153 : 	g.DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 2154 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN16@DragBehavi

; 2155 : 	{
; 2156 : 		FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

	cvtss2sd xmm0, DWORD PTR power$[rsp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_cur$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2sd xmm1, rax
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rcx, QWORD PTR v_max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2sd xmm2, rax
	divsd	xmm1, xmm2
	movsd	QWORD PTR tv262[rsp], xmm1
	movaps	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv262[rsp]
	call	?ImPow@@YANNN@Z				; ImPow
	movsd	QWORD PTR v_cur_norm_curved$4[rsp], xmm0

; 2157 : 		g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);

	movsd	xmm0, QWORD PTR v_cur_norm_curved$4[rsp]
	subsd	xmm0, QWORD PTR v_old_ref_for_accum_remainder$[rsp]
	cvtsd2ss xmm0, xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0

; 2158 : 	}

	jmp	SHORT $LN17@DragBehavi
$LN16@DragBehavi:

; 2159 : 	else
; 2160 : 	{
; 2161 : 		g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

	mov	rax, QWORD PTR v$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR v_cur$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cvtsi2ss xmm0, rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0
$LN17@DragBehavi:

; 2162 : 	}
; 2163 : 
; 2164 : 	// Lose zero sign for float/double
; 2165 : 	if (v_cur == (TYPE)-0)

	cmp	QWORD PTR v_cur$[rsp], 0
	jne	SHORT $LN18@DragBehavi

; 2166 : 		v_cur = (TYPE)0;

	mov	QWORD PTR v_cur$[rsp], 0
$LN18@DragBehavi:

; 2167 : 
; 2168 : 	// Clamp values (+ handle overflow/wrap-around for integer types)
; 2169 : 	if (*v != v_cur && has_min_max)

	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_cur$[rsp]
	cmp	QWORD PTR [rax], rcx
	je	$LN19@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	$LN19@DragBehavi

; 2170 : 	{
; 2171 : 		if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))

	mov	rax, QWORD PTR v_min$[rsp]
	cmp	QWORD PTR v_cur$[rsp], rax
	jl	SHORT $LN21@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR v_cur$[rsp], rax
	jle	SHORT $LN20@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN20@DragBehavi
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN20@DragBehavi
$LN21@DragBehavi:

; 2172 : 			v_cur = v_min;

	mov	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR v_cur$[rsp], rax
$LN20@DragBehavi:

; 2173 : 		if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))

	mov	rax, QWORD PTR v_max$[rsp]
	cmp	QWORD PTR v_cur$[rsp], rax
	jg	SHORT $LN23@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR v_cur$[rsp], rax
	jge	SHORT $LN22@DragBehavi
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN22@DragBehavi
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN22@DragBehavi
$LN23@DragBehavi:

; 2174 : 			v_cur = v_max;

	mov	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR v_cur$[rsp], rax
$LN22@DragBehavi:
$LN19@DragBehavi:

; 2175 : 	}
; 2176 : 
; 2177 : 	// Apply result
; 2178 : 	if (*v == v_cur)

	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_cur$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN24@DragBehavi

; 2179 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@DragBehavi
$LN24@DragBehavi:

; 2180 : 	*v = v_cur;

	mov	rax, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR v_cur$[rsp]
	mov	QWORD PTR [rax], rcx

; 2181 : 	return true;

	mov	al, 1
$LN1@DragBehavi:

; 2182 : }

	add	rsp, 200				; 000000c8H
	ret	0
??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDMH@Z ENDP ; ImGui::DragBehaviorT<__int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDMH@Z
_TEXT	SEGMENT
has_min_max$ = 48
is_decimal$ = 49
v_cur$ = 52
adjust_delta$ = 56
is_power$ = 60
tv69 = 61
tv71 = 62
tv80 = 63
g$ = 64
is_just_activated$ = 72
is_already_past_limits_and_pushing_outward$ = 73
is_drag_direction_change_with_power$ = 74
axis$ = 76
tv66 = 80
tv160 = 84
tv188 = 88
tv198 = 92
v_old_norm_curved$1 = 96
v_old_ref_for_accum_remainder$ = 100
decimal_precision$2 = 104
tv225 = 108
v_new_norm_curved$3 = 112
tv258 = 116
v_cur_norm_curved$4 = 120
tv142 = 128
tv172 = 136
$T5 = 144
data_type$ = 176
v$ = 184
v_speed$ = 192
v_min$ = 200
v_max$ = 208
format$ = 216
power$ = 224
flags$ = 232
??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDMH@Z PROC	; ImGui::DragBehaviorT<unsigned int,int,float>, COMDAT

; 2081 : {

$LN48:
	mov	DWORD PTR [rsp+32], r9d
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 168				; 000000a8H

; 2082 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2083 : 	const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN26@DragBehavi
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN27@DragBehavi
$LN26@DragBehavi:
	mov	DWORD PTR tv66[rsp], 0
$LN27@DragBehavi:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR axis$[rsp], eax

; 2084 : 	const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN28@DragBehavi
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN28@DragBehavi
	mov	BYTE PTR tv69[rsp], 0
	jmp	SHORT $LN29@DragBehavi
$LN28@DragBehavi:
	mov	BYTE PTR tv69[rsp], 1
$LN29@DragBehavi:
	movzx	eax, BYTE PTR tv69[rsp]
	mov	BYTE PTR is_decimal$[rsp], al

; 2085 : 	const bool has_min_max = (v_min != v_max);

	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_min$[rsp], eax
	je	SHORT $LN30@DragBehavi
	mov	BYTE PTR tv71[rsp], 1
	jmp	SHORT $LN31@DragBehavi
$LN30@DragBehavi:
	mov	BYTE PTR tv71[rsp], 0
$LN31@DragBehavi:
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR has_min_max$[rsp], al

; 2086 : 	const bool is_power = (power != 1.0f && is_decimal && has_min_max && (v_max - v_min < FLT_MAX));

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN47@DragBehavi
	je	SHORT $LN32@DragBehavi
$LN47@DragBehavi:
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN32@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN32@DragBehavi
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR __real@7f7fffff
	comiss	xmm1, xmm0
	jbe	SHORT $LN32@DragBehavi
	mov	BYTE PTR tv80[rsp], 1
	jmp	SHORT $LN33@DragBehavi
$LN32@DragBehavi:
	mov	BYTE PTR tv80[rsp], 0
$LN33@DragBehavi:
	movzx	eax, BYTE PTR tv80[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2087 : 
; 2088 : 	// Default tweak speed
; 2089 : 	if (v_speed == 0.0f && has_min_max && (v_max - v_min < FLT_MAX))

	movss	xmm0, DWORD PTR v_speed$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN2@DragBehavi
	jne	SHORT $LN2@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN2@DragBehavi
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR __real@7f7fffff
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@DragBehavi

; 2090 : 		v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	cvtsi2ss xmm0, rax
	mov	rax, QWORD PTR g$[rsp]
	mulss	xmm0, DWORD PTR [rax+11696]
	movss	DWORD PTR v_speed$[rsp], xmm0
$LN2@DragBehavi:

; 2091 : 
; 2092 : 	// Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
; 2093 : 	float adjust_delta = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2094 : 	if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f * 1.0f)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN3@DragBehavi
	xor	ecx, ecx
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	$LN3@DragBehavi
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+3304]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN3@DragBehavi

; 2095 : 	{
; 2096 : 		adjust_delta = g.IO.MouseDelta[axis];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 968				; 000003c8H
	mov	QWORD PTR tv142[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv142[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2097 : 		if (g.IO.KeyAlt)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+324]
	test	eax, eax
	je	SHORT $LN5@DragBehavi

; 2098 : 			adjust_delta *= 1.0f / 100.0f;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN5@DragBehavi:

; 2099 : 		if (g.IO.KeyShift)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	je	SHORT $LN6@DragBehavi

; 2100 : 			adjust_delta *= 10.0f;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN6@DragBehavi:

; 2101 : 	}

	jmp	$LN4@DragBehavi
$LN3@DragBehavi:

; 2102 : 	else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	$LN7@DragBehavi

; 2103 : 	{
; 2104 : 		int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN34@DragBehavi
	mov	edx, 3
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	DWORD PTR tv160[rsp], eax
	jmp	SHORT $LN35@DragBehavi
$LN34@DragBehavi:
	mov	DWORD PTR tv160[rsp], 0
$LN35@DragBehavi:
	mov	eax, DWORD PTR tv160[rsp]
	mov	DWORD PTR decimal_precision$2[rsp], eax

; 2105 : 		adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3dcccccd
	mov	r8d, 5
	mov	edx, 3
	lea	rcx, QWORD PTR $T5[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
	mov	QWORD PTR tv172[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv172[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2106 : 		v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

	mov	ecx, DWORD PTR decimal_precision$2[rsp]
	call	?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR v_speed$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR v_speed$[rsp], xmm0
$LN7@DragBehavi:
$LN4@DragBehavi:

; 2107 : 	}
; 2108 : 	adjust_delta *= v_speed;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR v_speed$[rsp]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2109 : 
; 2110 : 	// For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 2111 : 	if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN8@DragBehavi

; 2112 : 		adjust_delta = -adjust_delta;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN8@DragBehavi:

; 2113 : 
; 2114 : 	// Clear current value on activation
; 2115 : 	// Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 2116 : 	bool is_just_activated = g.ActiveIdIsJustActivated;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	mov	BYTE PTR is_just_activated$[rsp], al

; 2117 : 	bool is_already_past_limits_and_pushing_outward = has_min_max && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN39@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR [rax], ecx
	jb	SHORT $LN36@DragBehavi
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN38@DragBehavi
$LN36@DragBehavi:
	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_min$[rsp]
	cmp	DWORD PTR [rax], ecx
	ja	SHORT $LN37@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN39@DragBehavi
$LN38@DragBehavi:
	mov	DWORD PTR tv188[rsp], 1
	jmp	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
$LN37@DragBehavi:
	mov	DWORD PTR tv188[rsp], 0
$LN40@DragBehavi:
	movzx	eax, BYTE PTR tv188[rsp]
	mov	BYTE PTR is_already_past_limits_and_pushing_outward$[rsp], al

; 2118 : 	bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN44@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN41@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11672]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN43@DragBehavi
$LN41@DragBehavi:
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN42@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+11672]
	jbe	SHORT $LN44@DragBehavi
$LN43@DragBehavi:
	mov	DWORD PTR tv198[rsp], 1
	jmp	SHORT $LN45@DragBehavi
$LN44@DragBehavi:
$LN42@DragBehavi:
	mov	DWORD PTR tv198[rsp], 0
$LN45@DragBehavi:
	movzx	eax, BYTE PTR tv198[rsp]
	mov	BYTE PTR is_drag_direction_change_with_power$[rsp], al

; 2119 : 	if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)

	movzx	eax, BYTE PTR is_just_activated$[rsp]
	test	eax, eax
	jne	SHORT $LN11@DragBehavi
	movzx	eax, BYTE PTR is_already_past_limits_and_pushing_outward$[rsp]
	test	eax, eax
	jne	SHORT $LN11@DragBehavi
	movzx	eax, BYTE PTR is_drag_direction_change_with_power$[rsp]
	test	eax, eax
	je	SHORT $LN9@DragBehavi
$LN11@DragBehavi:

; 2120 : 	{
; 2121 : 		g.DragCurrentAccum = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+11672], xmm0

; 2122 : 		g.DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 2123 : 	}

	jmp	SHORT $LN10@DragBehavi
$LN9@DragBehavi:

; 2124 : 	else if (adjust_delta != 0.0f)

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN46@DragBehavi
	je	SHORT $LN12@DragBehavi
$LN46@DragBehavi:

; 2125 : 	{
; 2126 : 		g.DragCurrentAccum += adjust_delta;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11672]
	addss	xmm0, DWORD PTR adjust_delta$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0

; 2127 : 		g.DragCurrentAccumDirty = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 1
$LN12@DragBehavi:
$LN10@DragBehavi:

; 2128 : 	}
; 2129 : 
; 2130 : 	if (!g.DragCurrentAccumDirty)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+11668]
	test	eax, eax
	jne	SHORT $LN13@DragBehavi

; 2131 : 		return false;

	xor	al, al
	jmp	$LN1@DragBehavi
$LN13@DragBehavi:

; 2132 : 
; 2133 : 	TYPE v_cur = *v;

	mov	rax, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR v_cur$[rsp], eax

; 2134 : 	FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR v_old_ref_for_accum_remainder$[rsp], xmm0

; 2135 : 
; 2136 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN14@DragBehavi

; 2137 : 	{
; 2138 : 		// Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
; 2139 : 		FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_cur$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	cvtsi2ss xmm1, rax
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	cvtsi2ss xmm2, rax
	divss	xmm1, xmm2
	movss	DWORD PTR tv225[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv225[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR v_old_norm_curved$1[rsp], xmm0

; 2140 : 		FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));

	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	cvtsi2ss xmm0, rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR v_old_norm_curved$1[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR v_new_norm_curved$3[rsp], xmm0

; 2141 : 		v_cur = v_min + (TYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);

	movss	xmm0, DWORD PTR v_new_norm_curved$3[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	xmm1, DWORD PTR power$[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	cvttss2si rax, xmm0
	mov	ecx, DWORD PTR v_min$[rsp]
	mov	edx, DWORD PTR v_max$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	imul	eax, ecx
	mov	ecx, DWORD PTR v_min$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v_cur$[rsp], eax

; 2142 : 		v_old_ref_for_accum_remainder = v_old_norm_curved;

	movss	xmm0, DWORD PTR v_old_norm_curved$1[rsp]
	movss	DWORD PTR v_old_ref_for_accum_remainder$[rsp], xmm0

; 2143 : 	}

	jmp	SHORT $LN15@DragBehavi
$LN14@DragBehavi:

; 2144 : 	else
; 2145 : 	{
; 2146 : 		v_cur += (TYPE)g.DragCurrentAccum;

	mov	rax, QWORD PTR g$[rsp]
	cvttss2si rax, DWORD PTR [rax+11672]
	mov	ecx, DWORD PTR v_cur$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v_cur$[rsp], eax
$LN15@DragBehavi:

; 2147 : 	}
; 2148 : 
; 2149 : 	// Round to user desired precision based on format string
; 2150 : 	v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

	mov	r8d, DWORD PTR v_cur$[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	??$RoundScalarWithFormatT@IH@ImGui@@YAIPEBDHI@Z ; ImGui::RoundScalarWithFormatT<unsigned int,int>
	mov	DWORD PTR v_cur$[rsp], eax

; 2151 : 
; 2152 : 	// Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 2153 : 	g.DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 2154 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN16@DragBehavi

; 2155 : 	{
; 2156 : 		FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_cur$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	cvtsi2ss xmm1, rax
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	cvtsi2ss xmm2, rax
	divss	xmm1, xmm2
	movss	DWORD PTR tv258[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv258[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR v_cur_norm_curved$4[rsp], xmm0

; 2157 : 		g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);

	movss	xmm0, DWORD PTR v_cur_norm_curved$4[rsp]
	subss	xmm0, DWORD PTR v_old_ref_for_accum_remainder$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0

; 2158 : 	}

	jmp	SHORT $LN17@DragBehavi
$LN16@DragBehavi:

; 2159 : 	else
; 2160 : 	{
; 2161 : 		g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

	mov	rax, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	ecx, DWORD PTR v_cur$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0
$LN17@DragBehavi:

; 2162 : 	}
; 2163 : 
; 2164 : 	// Lose zero sign for float/double
; 2165 : 	if (v_cur == (TYPE)-0)

	cmp	DWORD PTR v_cur$[rsp], 0
	jne	SHORT $LN18@DragBehavi

; 2166 : 		v_cur = (TYPE)0;

	mov	DWORD PTR v_cur$[rsp], 0
$LN18@DragBehavi:

; 2167 : 
; 2168 : 	// Clamp values (+ handle overflow/wrap-around for integer types)
; 2169 : 	if (*v != v_cur && has_min_max)

	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_cur$[rsp]
	cmp	DWORD PTR [rax], ecx
	je	$LN19@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN19@DragBehavi

; 2170 : 	{
; 2171 : 		if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))

	mov	eax, DWORD PTR v_min$[rsp]
	cmp	DWORD PTR v_cur$[rsp], eax
	jb	SHORT $LN21@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR v_cur$[rsp], eax
	jbe	SHORT $LN20@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN20@DragBehavi
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN20@DragBehavi
$LN21@DragBehavi:

; 2172 : 			v_cur = v_min;

	mov	eax, DWORD PTR v_min$[rsp]
	mov	DWORD PTR v_cur$[rsp], eax
$LN20@DragBehavi:

; 2173 : 		if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))

	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_cur$[rsp], eax
	ja	SHORT $LN23@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR v_cur$[rsp], eax
	jae	SHORT $LN22@DragBehavi
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN22@DragBehavi
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN22@DragBehavi
$LN23@DragBehavi:

; 2174 : 			v_cur = v_max;

	mov	eax, DWORD PTR v_max$[rsp]
	mov	DWORD PTR v_cur$[rsp], eax
$LN22@DragBehavi:
$LN19@DragBehavi:

; 2175 : 	}
; 2176 : 
; 2177 : 	// Apply result
; 2178 : 	if (*v == v_cur)

	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_cur$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN24@DragBehavi

; 2179 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@DragBehavi
$LN24@DragBehavi:

; 2180 : 	*v = v_cur;

	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_cur$[rsp]
	mov	DWORD PTR [rax], ecx

; 2181 : 	return true;

	mov	al, 1
$LN1@DragBehavi:

; 2182 : }

	add	rsp, 168				; 000000a8H
	ret	0
??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDMH@Z ENDP	; ImGui::DragBehaviorT<unsigned int,int,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDMH@Z
_TEXT	SEGMENT
has_min_max$ = 48
is_decimal$ = 49
v_cur$ = 52
adjust_delta$ = 56
is_power$ = 60
tv69 = 61
tv71 = 62
tv80 = 63
g$ = 64
is_just_activated$ = 72
is_already_past_limits_and_pushing_outward$ = 73
is_drag_direction_change_with_power$ = 74
axis$ = 76
tv66 = 80
tv160 = 84
tv188 = 88
tv198 = 92
v_old_norm_curved$1 = 96
v_old_ref_for_accum_remainder$ = 100
decimal_precision$2 = 104
tv225 = 108
v_new_norm_curved$3 = 112
tv258 = 116
v_cur_norm_curved$4 = 120
tv142 = 128
tv172 = 136
$T5 = 144
data_type$ = 176
v$ = 184
v_speed$ = 192
v_min$ = 200
v_max$ = 208
format$ = 216
power$ = 224
flags$ = 232
??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDMH@Z PROC	; ImGui::DragBehaviorT<int,int,float>, COMDAT

; 2081 : {

$LN48:
	mov	DWORD PTR [rsp+32], r9d
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 168				; 000000a8H

; 2082 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2083 : 	const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN26@DragBehavi
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN27@DragBehavi
$LN26@DragBehavi:
	mov	DWORD PTR tv66[rsp], 0
$LN27@DragBehavi:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR axis$[rsp], eax

; 2084 : 	const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN28@DragBehavi
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN28@DragBehavi
	mov	BYTE PTR tv69[rsp], 0
	jmp	SHORT $LN29@DragBehavi
$LN28@DragBehavi:
	mov	BYTE PTR tv69[rsp], 1
$LN29@DragBehavi:
	movzx	eax, BYTE PTR tv69[rsp]
	mov	BYTE PTR is_decimal$[rsp], al

; 2085 : 	const bool has_min_max = (v_min != v_max);

	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_min$[rsp], eax
	je	SHORT $LN30@DragBehavi
	mov	BYTE PTR tv71[rsp], 1
	jmp	SHORT $LN31@DragBehavi
$LN30@DragBehavi:
	mov	BYTE PTR tv71[rsp], 0
$LN31@DragBehavi:
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR has_min_max$[rsp], al

; 2086 : 	const bool is_power = (power != 1.0f && is_decimal && has_min_max && (v_max - v_min < FLT_MAX));

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN47@DragBehavi
	je	SHORT $LN32@DragBehavi
$LN47@DragBehavi:
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN32@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN32@DragBehavi
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR __real@7f7fffff
	comiss	xmm1, xmm0
	jbe	SHORT $LN32@DragBehavi
	mov	BYTE PTR tv80[rsp], 1
	jmp	SHORT $LN33@DragBehavi
$LN32@DragBehavi:
	mov	BYTE PTR tv80[rsp], 0
$LN33@DragBehavi:
	movzx	eax, BYTE PTR tv80[rsp]
	mov	BYTE PTR is_power$[rsp], al

; 2087 : 
; 2088 : 	// Default tweak speed
; 2089 : 	if (v_speed == 0.0f && has_min_max && (v_max - v_min < FLT_MAX))

	movss	xmm0, DWORD PTR v_speed$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN2@DragBehavi
	jne	SHORT $LN2@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN2@DragBehavi
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR __real@7f7fffff
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@DragBehavi

; 2090 : 		v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR g$[rsp]
	mulss	xmm0, DWORD PTR [rax+11696]
	movss	DWORD PTR v_speed$[rsp], xmm0
$LN2@DragBehavi:

; 2091 : 
; 2092 : 	// Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
; 2093 : 	float adjust_delta = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2094 : 	if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f * 1.0f)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN3@DragBehavi
	xor	ecx, ecx
	call	?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z ; ImGui::IsMousePosValid
	movzx	eax, al
	test	eax, eax
	je	$LN3@DragBehavi
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+3304]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN3@DragBehavi

; 2095 : 	{
; 2096 : 		adjust_delta = g.IO.MouseDelta[axis];

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 968				; 000003c8H
	mov	QWORD PTR tv142[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv142[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2097 : 		if (g.IO.KeyAlt)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+324]
	test	eax, eax
	je	SHORT $LN5@DragBehavi

; 2098 : 			adjust_delta *= 1.0f / 100.0f;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN5@DragBehavi:

; 2099 : 		if (g.IO.KeyShift)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	je	SHORT $LN6@DragBehavi

; 2100 : 			adjust_delta *= 10.0f;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN6@DragBehavi:

; 2101 : 	}

	jmp	$LN4@DragBehavi
$LN3@DragBehavi:

; 2102 : 	else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	$LN7@DragBehavi

; 2103 : 	{
; 2104 : 		int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	je	SHORT $LN34@DragBehavi
	mov	edx, 3
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	DWORD PTR tv160[rsp], eax
	jmp	SHORT $LN35@DragBehavi
$LN34@DragBehavi:
	mov	DWORD PTR tv160[rsp], 0
$LN35@DragBehavi:
	mov	eax, DWORD PTR tv160[rsp]
	mov	DWORD PTR decimal_precision$2[rsp], eax

; 2105 : 		adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3dcccccd
	mov	r8d, 5
	mov	edx, 3
	lea	rcx, QWORD PTR $T5[rsp]
	call	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
	mov	QWORD PTR tv172[rsp], rax
	movsxd	rax, DWORD PTR axis$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv172[rsp]
	call	??AImVec2@@QEAAAEAM_K@Z			; ImVec2::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2106 : 		v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

	mov	ecx, DWORD PTR decimal_precision$2[rsp]
	call	?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR v_speed$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR v_speed$[rsp], xmm0
$LN7@DragBehavi:
$LN4@DragBehavi:

; 2107 : 	}
; 2108 : 	adjust_delta *= v_speed;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	mulss	xmm0, DWORD PTR v_speed$[rsp]
	movss	DWORD PTR adjust_delta$[rsp], xmm0

; 2109 : 
; 2110 : 	// For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 2111 : 	if (axis == ImGuiAxis_Y)

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN8@DragBehavi

; 2112 : 		adjust_delta = -adjust_delta;

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR adjust_delta$[rsp], xmm0
$LN8@DragBehavi:

; 2113 : 
; 2114 : 	// Clear current value on activation
; 2115 : 	// Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 2116 : 	bool is_just_activated = g.ActiveIdIsJustActivated;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	mov	BYTE PTR is_just_activated$[rsp], al

; 2117 : 	bool is_already_past_limits_and_pushing_outward = has_min_max && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN39@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR [rax], ecx
	jl	SHORT $LN36@DragBehavi
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN38@DragBehavi
$LN36@DragBehavi:
	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_min$[rsp]
	cmp	DWORD PTR [rax], ecx
	jg	SHORT $LN37@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN39@DragBehavi
$LN38@DragBehavi:
	mov	DWORD PTR tv188[rsp], 1
	jmp	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
$LN37@DragBehavi:
	mov	DWORD PTR tv188[rsp], 0
$LN40@DragBehavi:
	movzx	eax, BYTE PTR tv188[rsp]
	mov	BYTE PTR is_already_past_limits_and_pushing_outward$[rsp], al

; 2118 : 	bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	SHORT $LN44@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN41@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11672]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN43@DragBehavi
$LN41@DragBehavi:
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN42@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+11672]
	jbe	SHORT $LN44@DragBehavi
$LN43@DragBehavi:
	mov	DWORD PTR tv198[rsp], 1
	jmp	SHORT $LN45@DragBehavi
$LN44@DragBehavi:
$LN42@DragBehavi:
	mov	DWORD PTR tv198[rsp], 0
$LN45@DragBehavi:
	movzx	eax, BYTE PTR tv198[rsp]
	mov	BYTE PTR is_drag_direction_change_with_power$[rsp], al

; 2119 : 	if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)

	movzx	eax, BYTE PTR is_just_activated$[rsp]
	test	eax, eax
	jne	SHORT $LN11@DragBehavi
	movzx	eax, BYTE PTR is_already_past_limits_and_pushing_outward$[rsp]
	test	eax, eax
	jne	SHORT $LN11@DragBehavi
	movzx	eax, BYTE PTR is_drag_direction_change_with_power$[rsp]
	test	eax, eax
	je	SHORT $LN9@DragBehavi
$LN11@DragBehavi:

; 2120 : 	{
; 2121 : 		g.DragCurrentAccum = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+11672], xmm0

; 2122 : 		g.DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 2123 : 	}

	jmp	SHORT $LN10@DragBehavi
$LN9@DragBehavi:

; 2124 : 	else if (adjust_delta != 0.0f)

	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN46@DragBehavi
	je	SHORT $LN12@DragBehavi
$LN46@DragBehavi:

; 2125 : 	{
; 2126 : 		g.DragCurrentAccum += adjust_delta;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+11672]
	addss	xmm0, DWORD PTR adjust_delta$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0

; 2127 : 		g.DragCurrentAccumDirty = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 1
$LN12@DragBehavi:
$LN10@DragBehavi:

; 2128 : 	}
; 2129 : 
; 2130 : 	if (!g.DragCurrentAccumDirty)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+11668]
	test	eax, eax
	jne	SHORT $LN13@DragBehavi

; 2131 : 		return false;

	xor	al, al
	jmp	$LN1@DragBehavi
$LN13@DragBehavi:

; 2132 : 
; 2133 : 	TYPE v_cur = *v;

	mov	rax, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR v_cur$[rsp], eax

; 2134 : 	FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR v_old_ref_for_accum_remainder$[rsp], xmm0

; 2135 : 
; 2136 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN14@DragBehavi

; 2137 : 	{
; 2138 : 		// Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
; 2139 : 		FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_cur$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm1, eax
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm2, eax
	divss	xmm1, xmm2
	movss	DWORD PTR tv225[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv225[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR v_old_norm_curved$1[rsp], xmm0

; 2140 : 		FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));

	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR v_old_norm_curved$1[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR v_new_norm_curved$3[rsp], xmm0

; 2141 : 		v_cur = v_min + (TYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);

	movss	xmm0, DWORD PTR v_new_norm_curved$3[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	xmm1, DWORD PTR power$[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR v_min$[rsp]
	mov	edx, DWORD PTR v_max$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	imul	eax, ecx
	mov	ecx, DWORD PTR v_min$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v_cur$[rsp], eax

; 2142 : 		v_old_ref_for_accum_remainder = v_old_norm_curved;

	movss	xmm0, DWORD PTR v_old_norm_curved$1[rsp]
	movss	DWORD PTR v_old_ref_for_accum_remainder$[rsp], xmm0

; 2143 : 	}

	jmp	SHORT $LN15@DragBehavi
$LN14@DragBehavi:

; 2144 : 	else
; 2145 : 	{
; 2146 : 		v_cur += (TYPE)g.DragCurrentAccum;

	mov	rax, QWORD PTR g$[rsp]
	cvttss2si eax, DWORD PTR [rax+11672]
	mov	ecx, DWORD PTR v_cur$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR v_cur$[rsp], eax
$LN15@DragBehavi:

; 2147 : 	}
; 2148 : 
; 2149 : 	// Round to user desired precision based on format string
; 2150 : 	v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

	mov	r8d, DWORD PTR v_cur$[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	??$RoundScalarWithFormatT@HH@ImGui@@YAHPEBDHH@Z ; ImGui::RoundScalarWithFormatT<int,int>
	mov	DWORD PTR v_cur$[rsp], eax

; 2151 : 
; 2152 : 	// Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 2153 : 	g.DragCurrentAccumDirty = false;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+11668], 0

; 2154 : 	if (is_power)

	movzx	eax, BYTE PTR is_power$[rsp]
	test	eax, eax
	je	$LN16@DragBehavi

; 2155 : 	{
; 2156 : 		FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR power$[rsp]
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_cur$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm1, eax
	mov	eax, DWORD PTR v_min$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm2, eax
	divss	xmm1, xmm2
	movss	DWORD PTR tv258[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv258[rsp]
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR v_cur_norm_curved$4[rsp], xmm0

; 2157 : 		g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);

	movss	xmm0, DWORD PTR v_cur_norm_curved$4[rsp]
	subss	xmm0, DWORD PTR v_old_ref_for_accum_remainder$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0

; 2158 : 	}

	jmp	SHORT $LN17@DragBehavi
$LN16@DragBehavi:

; 2159 : 	else
; 2160 : 	{
; 2161 : 		g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

	mov	rax, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	ecx, DWORD PTR v_cur$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+11672]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+11672], xmm0
$LN17@DragBehavi:

; 2162 : 	}
; 2163 : 
; 2164 : 	// Lose zero sign for float/double
; 2165 : 	if (v_cur == (TYPE)-0)

	cmp	DWORD PTR v_cur$[rsp], 0
	jne	SHORT $LN18@DragBehavi

; 2166 : 		v_cur = (TYPE)0;

	mov	DWORD PTR v_cur$[rsp], 0
$LN18@DragBehavi:

; 2167 : 
; 2168 : 	// Clamp values (+ handle overflow/wrap-around for integer types)
; 2169 : 	if (*v != v_cur && has_min_max)

	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_cur$[rsp]
	cmp	DWORD PTR [rax], ecx
	je	$LN19@DragBehavi
	movzx	eax, BYTE PTR has_min_max$[rsp]
	test	eax, eax
	je	SHORT $LN19@DragBehavi

; 2170 : 	{
; 2171 : 		if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))

	mov	eax, DWORD PTR v_min$[rsp]
	cmp	DWORD PTR v_cur$[rsp], eax
	jl	SHORT $LN21@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR v_cur$[rsp], eax
	jle	SHORT $LN20@DragBehavi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR adjust_delta$[rsp]
	jbe	SHORT $LN20@DragBehavi
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN20@DragBehavi
$LN21@DragBehavi:

; 2172 : 			v_cur = v_min;

	mov	eax, DWORD PTR v_min$[rsp]
	mov	DWORD PTR v_cur$[rsp], eax
$LN20@DragBehavi:

; 2173 : 		if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))

	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_cur$[rsp], eax
	jg	SHORT $LN23@DragBehavi
	mov	rax, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR v_cur$[rsp], eax
	jge	SHORT $LN22@DragBehavi
	movss	xmm0, DWORD PTR adjust_delta$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN22@DragBehavi
	movzx	eax, BYTE PTR is_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN22@DragBehavi
$LN23@DragBehavi:

; 2174 : 			v_cur = v_max;

	mov	eax, DWORD PTR v_max$[rsp]
	mov	DWORD PTR v_cur$[rsp], eax
$LN22@DragBehavi:
$LN19@DragBehavi:

; 2175 : 	}
; 2176 : 
; 2177 : 	// Apply result
; 2178 : 	if (*v == v_cur)

	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_cur$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN24@DragBehavi

; 2179 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@DragBehavi
$LN24@DragBehavi:

; 2180 : 	*v = v_cur;

	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_cur$[rsp]
	mov	DWORD PTR [rax], ecx

; 2181 : 	return true;

	mov	al, 1
$LN1@DragBehavi:

; 2182 : }

	add	rsp, 168				; 000000a8H
	ret	0
??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDMH@Z ENDP	; ImGui::DragBehaviorT<int,int,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv74 = 32
decimal_precision$ = 64
?GetMinimumStepAtDecimalPrecision@@YAMH@Z PROC		; GetMinimumStepAtDecimalPrecision

; 2021 : {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 2022 : 	static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };
; 2023 : 	if (decimal_precision < 0)

	cmp	DWORD PTR decimal_precision$[rsp], 0
	jge	SHORT $LN2@GetMinimum

; 2024 : 		return FLT_MIN;

	movss	xmm0, DWORD PTR __real@00800000
	jmp	SHORT $LN1@GetMinimum
$LN2@GetMinimum:

; 2025 : 	return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	cmp	DWORD PTR decimal_precision$[rsp], 10
	jge	SHORT $LN4@GetMinimum
	movsxd	rax, DWORD PTR decimal_precision$[rsp]
	lea	rcx, OFFSET FLAT:?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB
	movss	xmm0, DWORD PTR [rcx+rax*4]
	movss	DWORD PTR tv74[rsp], xmm0
	jmp	SHORT $LN5@GetMinimum
$LN4@GetMinimum:
	mov	eax, DWORD PTR decimal_precision$[rsp]
	neg	eax
	cvtsi2ss xmm0, eax
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@41200000
	call	?ImPow@@YAMMM@Z				; ImPow
	movss	DWORD PTR tv74[rsp], xmm0
$LN5@GetMinimum:
	movss	xmm0, DWORD PTR tv74[rsp]
$LN1@GetMinimum:

; 2026 : }

	add	rsp, 56					; 00000038H
	ret	0
?GetMinimumStepAtDecimalPrecision@@YAMH@Z ENDP		; GetMinimumStepAtDecimalPrecision
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
fmt_start$ = 48
fmt_end$ = 56
g$1 = 64
fmt$ = 96
?PatchFormatStringFloatToInt@@YAPEBDPEBD@Z PROC		; PatchFormatStringFloatToInt

; 1867 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1868 : 	if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '0' && fmt[3] == 'f' && fmt[4] == 0) // Fast legacy path for "%.0f" which is expected to be the most common case.

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN2@PatchForma
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN2@PatchForma
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN2@PatchForma
	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 102				; 00000066H
	jne	SHORT $LN2@PatchForma
	mov	eax, 1
	imul	rax, rax, 4
	mov	rcx, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN2@PatchForma

; 1869 : 		return ("%d");

	lea	rax, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	jmp	$LN1@PatchForma
$LN2@PatchForma:

; 1870 : 	const char* fmt_start = ImParseFormatFindStart(fmt);    // Find % (if any, and ignore %%)

	mov	rcx, QWORD PTR fmt$[rsp]
	call	?ImParseFormatFindStart@@YAPEBDPEBD@Z	; ImParseFormatFindStart
	mov	QWORD PTR fmt_start$[rsp], rax

; 1871 : 	const char* fmt_end = ImParseFormatFindEnd(fmt_start);  // Find end of format specifier, which itself is an exercise of confidence/recklessness (because snprintf is dependent on libc or user).

	mov	rcx, QWORD PTR fmt_start$[rsp]
	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd
	mov	QWORD PTR fmt_end$[rsp], rax

; 1872 : 	if (fmt_end > fmt_start && fmt_end[-1] == 'f')

	mov	rax, QWORD PTR fmt_start$[rsp]
	cmp	QWORD PTR fmt_end$[rsp], rax
	jbe	$LN3@PatchForma
	mov	eax, 1
	imul	rax, rax, -1
	mov	rcx, QWORD PTR fmt_end$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 102				; 00000066H
	jne	$LN3@PatchForma

; 1873 : 	{
; 1874 : #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
; 1875 : 		if (fmt_start == fmt && fmt_end[0] == 0)

	mov	rax, QWORD PTR fmt$[rsp]
	cmp	QWORD PTR fmt_start$[rsp], rax
	jne	SHORT $LN4@PatchForma
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt_end$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN4@PatchForma

; 1876 : 			return "%d";

	lea	rax, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	jmp	SHORT $LN1@PatchForma
$LN4@PatchForma:

; 1877 : 		ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$1[rsp], rax

; 1878 : 		ImFormatString(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), ("%.*s%%d%s"), (int)(fmt_start - fmt), fmt, fmt_end); // Honor leading and trailing decorations, but lose alignment/precision.

	mov	rax, QWORD PTR fmt$[rsp]
	mov	rcx, QWORD PTR fmt_start$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR g$1[rsp]
	add	rcx, 12240				; 00002fd0H
	mov	rdx, QWORD PTR fmt_end$[rsp]
	mov	QWORD PTR [rsp+40], rdx
	mov	rdx, QWORD PTR fmt$[rsp]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9d, eax
	lea	r8, OFFSET FLAT:??_C@_09JKJEEIJP@?$CF?4?$CKs?$CF?$CFd?$CFs@
	mov	edx, 3073				; 00000c01H
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 1879 : 		return g.TempBuffer;

	mov	rax, QWORD PTR g$1[rsp]
	add	rax, 12240				; 00002fd0H
	jmp	SHORT $LN1@PatchForma
$LN3@PatchForma:

; 1880 : #else
; 1881 : 		IM_ASSERT(0 && "DragInt(): Invalid format string!"); // Old versions used a default parameter of "%.0f", please replace with e.g. "%d"
; 1882 : #endif
; 1883 : 	}
; 1884 : 	return fmt;

	mov	rax, QWORD PTR fmt$[rsp]
$LN1@PatchForma:

; 1885 : }

	add	rsp, 88					; 00000058H
	ret	0
?PatchFormatStringFloatToInt@@YAPEBDPEBD@Z ENDP		; PatchFormatStringFloatToInt
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FGDataTypeInfo@@YAXXZ
text$yd	SEGMENT
??__FGDataTypeInfo@@YAXXZ PROC				; `dynamic atexit destructor for 'GDataTypeInfo'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	r9, OFFSET FLAT:??1ImGuiDataTypeInfo@@QEAA@XZ
	mov	r8d, 6
	mov	edx, 72					; 00000048H
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__FGDataTypeInfo@@YAXXZ ENDP				; `dynamic atexit destructor for 'GDataTypeInfo''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
;	COMDAT ??__EGDataTypeInfo@@YAXXZ
text$di	SEGMENT
??__EGDataTypeInfo@@YAXXZ PROC				; `dynamic initializer for 'GDataTypeInfo'', COMDAT

; 1860 : };

	sub	rsp, 40					; 00000028H

; 1848 : {
; 1849 : 	{ sizeof(int),          ("%d"),  ("%d")    },

	mov	QWORD PTR ?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B, 4
	lea	rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+8
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+40
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1850 : 	{ sizeof(unsigned int), ("%u"),   ("%u")    },

	mov	QWORD PTR ?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+72, 4
	lea	rdx, OFFSET FLAT:??_C@_02GMHACPFF@?$CFu@
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+80
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_02GMHACPFF@?$CFu@
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+112
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1851 : #ifdef _MSC_VER
; 1852 : 	{ sizeof(ImS64),        ("%I64d"),("%I64d") },

	mov	QWORD PTR ?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+144, 8
	lea	rdx, OFFSET FLAT:??_C@_05LLAMLEHD@?$CFI64d@
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+152
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_05LLAMLEHD@?$CFI64d@
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+184
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1853 : 	{ sizeof(ImU64),        ("%I64u"),("%I64u") },

	mov	QWORD PTR ?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+216, 8
	lea	rdx, OFFSET FLAT:??_C@_05OINFJHGD@?$CFI64u@
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+224
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_05OINFJHGD@?$CFI64u@
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+256
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1854 : #else
; 1855 : 	{ sizeof(ImS64),        ("%lld"), ("%lld")  },
; 1856 : 	{ sizeof(ImU64),        ("%llu"), ("%llu")  },
; 1857 : #endif
; 1858 : 	{ sizeof(float),        ("%f"),   ("%f")    },  // float are promoted to double in va_arg

	mov	QWORD PTR ?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+288, 4
	lea	rdx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+296
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+328
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1859 : 	{ sizeof(double),       ("%f"),   ("%lf")   },

	mov	QWORD PTR ?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+360, 8
	lea	rdx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+368
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_03DLDNIBIK@?$CFlf@
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+400
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1847 : static const ImGuiDataTypeInfo GDataTypeInfo[] =

	lea	rcx, OFFSET FLAT:??__FGDataTypeInfo@@YAXXZ ; `dynamic atexit destructor for 'GDataTypeInfo''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__EGDataTypeInfo@@YAXXZ ENDP				; `dynamic initializer for 'GDataTypeInfo''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__EGDataTypeInfo@@YAXXZ@4HA PROC		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???__EGDataTypeInfo@@YAXXZ@4HA ENDP		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$2@?0???__EGDataTypeInfo@@YAXXZ@4HA PROC		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	call	??1ImGuiDataTypeInfo@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???__EGDataTypeInfo@@YAXXZ@4HA ENDP		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$3@?0???__EGDataTypeInfo@@YAXXZ@4HA PROC		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+80
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???__EGDataTypeInfo@@YAXXZ@4HA ENDP		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$5@?0???__EGDataTypeInfo@@YAXXZ@4HA PROC		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	add	rcx, 72					; 00000048H
	call	??1ImGuiDataTypeInfo@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0???__EGDataTypeInfo@@YAXXZ@4HA ENDP		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$6@?0???__EGDataTypeInfo@@YAXXZ@4HA PROC		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+152
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0???__EGDataTypeInfo@@YAXXZ@4HA ENDP		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$8@?0???__EGDataTypeInfo@@YAXXZ@4HA PROC		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$8
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	add	rcx, 144				; 00000090H
	call	??1ImGuiDataTypeInfo@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$8@?0???__EGDataTypeInfo@@YAXXZ@4HA ENDP		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$9@?0???__EGDataTypeInfo@@YAXXZ@4HA PROC		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$9
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+224
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$9@?0???__EGDataTypeInfo@@YAXXZ@4HA ENDP		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$11@?0???__EGDataTypeInfo@@YAXXZ@4HA PROC		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$11
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	add	rcx, 216				; 000000d8H
	call	??1ImGuiDataTypeInfo@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$11@?0???__EGDataTypeInfo@@YAXXZ@4HA ENDP		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$12@?0???__EGDataTypeInfo@@YAXXZ@4HA PROC		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$12
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+296
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$12@?0???__EGDataTypeInfo@@YAXXZ@4HA ENDP		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$14@?0???__EGDataTypeInfo@@YAXXZ@4HA PROC		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$14
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	add	rcx, 288				; 00000120H
	call	??1ImGuiDataTypeInfo@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$14@?0???__EGDataTypeInfo@@YAXXZ@4HA ENDP		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$15@?0???__EGDataTypeInfo@@YAXXZ@4HA PROC		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$15
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B+368
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$15@?0???__EGDataTypeInfo@@YAXXZ@4HA ENDP		; ``dynamic initializer for 'GDataTypeInfo'''::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImGuiDataTypeInfo@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImGuiDataTypeInfo@@QEAA@XZ PROC			; ImGuiDataTypeInfo::~ImGuiDataTypeInfo, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImGuiDataTypeInfo@@QEAA@XZ ENDP			; ImGuiDataTypeInfo::~ImGuiDataTypeInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA PROC	; `ImGuiDataTypeInfo::~ImGuiDataTypeInfo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA ENDP	; `ImGuiDataTypeInfo::~ImGuiDataTypeInfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA PROC	; `ImGuiDataTypeInfo::~ImGuiDataTypeInfo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 40					; 00000028H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1ImGuiDataTypeInfo@@QEAA@XZ@4HA ENDP	; `ImGuiDataTypeInfo::~ImGuiDataTypeInfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
items_count$ = 32
p$ = 40
items_separated_by_zeros$ = 48
data$ = 80
idx$ = 88
out_text$ = 96
?Items_SingleStringGetter@@YA_NPEAXHPEAPEBD@Z PROC	; Items_SingleStringGetter

; 1712 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1713 : 	// FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.
; 1714 : 	const char* items_separated_by_zeros = (const char*)data;

	mov	rax, QWORD PTR data$[rsp]
	mov	QWORD PTR items_separated_by_zeros$[rsp], rax

; 1715 : 	int items_count = 0;

	mov	DWORD PTR items_count$[rsp], 0

; 1716 : 	const char* p = items_separated_by_zeros;

	mov	rax, QWORD PTR items_separated_by_zeros$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@Items_Sing:

; 1717 : 	while (*p)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@Items_Sing

; 1718 : 	{
; 1719 : 		if (idx == items_count)

	mov	eax, DWORD PTR items_count$[rsp]
	cmp	DWORD PTR idx$[rsp], eax
	jne	SHORT $LN4@Items_Sing

; 1720 : 			break;

	jmp	SHORT $LN3@Items_Sing
$LN4@Items_Sing:

; 1721 : 		p += strlen(p) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax

; 1722 : 		items_count++;

	mov	eax, DWORD PTR items_count$[rsp]
	inc	eax
	mov	DWORD PTR items_count$[rsp], eax

; 1723 : 	}

	jmp	SHORT $LN2@Items_Sing
$LN3@Items_Sing:

; 1724 : 	if (!*p)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN5@Items_Sing

; 1725 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@Items_Sing
$LN5@Items_Sing:

; 1726 : 	if (out_text)

	cmp	QWORD PTR out_text$[rsp], 0
	je	SHORT $LN6@Items_Sing

; 1727 : 		*out_text = p;

	mov	rax, QWORD PTR out_text$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax], rcx
$LN6@Items_Sing:

; 1728 : 	return true;

	mov	al, 1
$LN1@Items_Sing:

; 1729 : }

	add	rsp, 72					; 00000048H
	ret	0
?Items_SingleStringGetter@@YA_NPEAXHPEAPEBD@Z ENDP	; Items_SingleStringGetter
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
items$ = 0
data$ = 32
idx$ = 40
out_text$ = 48
?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z PROC		; Items_ArrayGetter

; 1703 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1704 : 	const char* const* items = (const char* const*)data;

	mov	rax, QWORD PTR data$[rsp]
	mov	QWORD PTR items$[rsp], rax

; 1705 : 	if (out_text)

	cmp	QWORD PTR out_text$[rsp], 0
	je	SHORT $LN2@Items_Arra

; 1706 : 		*out_text = items[idx];

	movsxd	rax, DWORD PTR idx$[rsp]
	mov	rcx, QWORD PTR out_text$[rsp]
	mov	rdx, QWORD PTR items$[rsp]
	mov	rax, QWORD PTR [rdx+rax*8]
	mov	QWORD PTR [rcx], rax
$LN2@Items_Arra:

; 1707 : 	return true;

	mov	al, 1

; 1708 : }

	add	rsp, 24
	ret	0
?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z ENDP		; Items_ArrayGetter
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 0
items_count$ = 32
?CalcMaxPopupHeightFromItemCount@@YAMH@Z PROC		; CalcMaxPopupHeightFromItemCount

; 1584 : {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 1585 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1586 : 	if (items_count <= 0)

	cmp	DWORD PTR items_count$[rsp], 0
	jg	SHORT $LN2@CalcMaxPop

; 1587 : 		return FLT_MAX;

	movss	xmm0, DWORD PTR __real@7f7fffff
	jmp	SHORT $LN1@CalcMaxPop
$LN2@CalcMaxPop:

; 1588 : 	return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	addss	xmm0, DWORD PTR [rcx+5544]
	cvtsi2ss xmm1, DWORD PTR items_count$[rsp]
	mulss	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	subss	xmm0, DWORD PTR [rax+5544]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5480]
	mulss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
$LN1@CalcMaxPop:

; 1589 : }

	add	rsp, 24
	ret	0
?CalcMaxPopupHeightFromItemCount@@YAMH@Z ENDP		; CalcMaxPopupHeightFromItemCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@M@@YAMMMM@Z PROC				; ImLerp<float>

; 230  : template<typename T> static inline T ImLerp(T a, T b, float t) { return (T)(a + (b - a) * t); }

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	movss	xmm0, DWORD PTR b$[rsp]
	subss	xmm0, DWORD PTR a$[rsp]
	mulss	xmm0, DWORD PTR t$[rsp]
	movss	xmm1, DWORD PTR a$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	ret	0
??$ImLerp@M@@YAMMMM@Z ENDP				; ImLerp<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv66 = 0
tv67 = 4
v$ = 32
mn$ = 40
mx$ = 48
??$ImClamp@M@@YAMMMM@Z PROC				; ImClamp<float>

; 229  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	movss	xmm0, DWORD PTR mn$[rsp]
	comiss	xmm0, DWORD PTR v$[rsp]
	jbe	SHORT $LN5@ImClamp
	movss	xmm0, DWORD PTR mn$[rsp]
	movss	DWORD PTR tv67[rsp], xmm0
	jmp	SHORT $LN6@ImClamp
$LN5@ImClamp:
	movss	xmm0, DWORD PTR v$[rsp]
	comiss	xmm0, DWORD PTR mx$[rsp]
	jbe	SHORT $LN3@ImClamp
	movss	xmm0, DWORD PTR mx$[rsp]
	movss	DWORD PTR tv66[rsp], xmm0
	jmp	SHORT $LN4@ImClamp
$LN3@ImClamp:
	movss	xmm0, DWORD PTR v$[rsp]
	movss	DWORD PTR tv66[rsp], xmm0
$LN4@ImClamp:
	movss	xmm0, DWORD PTR tv66[rsp]
	movss	DWORD PTR tv67[rsp], xmm0
$LN6@ImClamp:
	movss	xmm0, DWORD PTR tv67[rsp]
	add	rsp, 24
	ret	0
??$ImClamp@M@@YAMMMM@Z ENDP				; ImClamp<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
line_width$ = 32
text_size$ = 40
line_height$ = 48
c$1 = 52
s$ = 56
tv75 = 64
scale$ = 68
char_width$2 = 72
g$ = 80
font$ = 88
$T3 = 96
__$ReturnUdt$ = 128
text_begin$ = 136
text_end$ = 144
remaining$ = 152
out_offset$ = 160
stop_on_new_line$ = 168
?InputTextCalcTextSizeW@@YA?AUImVec2@@PEBG0PEAPEBGPEAU1@_N@Z PROC ; InputTextCalcTextSizeW

; 3302 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 3303 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3304 : 	ImFont* font = g.Font;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR font$[rsp], rax

; 3305 : 	const float line_height = g.FontSize;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR line_height$[rsp], xmm0

; 3306 : 	const float scale = line_height / font->FontSize;

	mov	rax, QWORD PTR font$[rsp]
	movss	xmm0, DWORD PTR line_height$[rsp]
	divss	xmm0, DWORD PTR [rax+20]
	movss	DWORD PTR scale$[rsp], xmm0

; 3307 : 
; 3308 : 	ImVec2 text_size = ImVec2(0, 0);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR text_size$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 3309 : 	float line_width = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR line_width$[rsp], xmm0

; 3310 : 
; 3311 : 	const ImWchar* s = text_begin;

	mov	rax, QWORD PTR text_begin$[rsp]
	mov	QWORD PTR s$[rsp], rax
$LN14@InputTextC:
$LN13@InputTextC:
$LN2@InputTextC:

; 3312 : 	while (s < text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR s$[rsp], rax
	jae	$LN3@InputTextC

; 3313 : 	{
; 3314 : 		unsigned int c = (unsigned int)(*s++);

	mov	rax, QWORD PTR s$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR tv75[rsp], eax
	mov	rax, QWORD PTR s$[rsp]
	add	rax, 2
	mov	QWORD PTR s$[rsp], rax
	mov	eax, DWORD PTR tv75[rsp]
	mov	DWORD PTR c$1[rsp], eax

; 3315 : 		if (c == '\n')

	cmp	DWORD PTR c$1[rsp], 10
	jne	SHORT $LN4@InputTextC

; 3316 : 		{
; 3317 : 			text_size.x = ImMax(text_size.x, line_width);

	movss	xmm1, DWORD PTR line_width$[rsp]
	movss	xmm0, DWORD PTR text_size$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR text_size$[rsp], xmm0

; 3318 : 			text_size.y += line_height;

	movss	xmm0, DWORD PTR text_size$[rsp+4]
	addss	xmm0, DWORD PTR line_height$[rsp]
	movss	DWORD PTR text_size$[rsp+4], xmm0

; 3319 : 			line_width = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR line_width$[rsp], xmm0

; 3320 : 			if (stop_on_new_line)

	movzx	eax, BYTE PTR stop_on_new_line$[rsp]
	test	eax, eax
	je	SHORT $LN5@InputTextC

; 3321 : 				break;

	jmp	SHORT $LN3@InputTextC
$LN5@InputTextC:

; 3322 : 			continue;

	jmp	SHORT $LN2@InputTextC
$LN4@InputTextC:

; 3323 : 		}
; 3324 : 		if (c == '\r')

	cmp	DWORD PTR c$1[rsp], 13
	jne	SHORT $LN6@InputTextC

; 3325 : 			continue;

	jmp	$LN13@InputTextC
$LN6@InputTextC:

; 3326 : 
; 3327 : 		const float char_width = font->GetCharAdvance((ImWchar)c) * scale;

	movzx	edx, WORD PTR c$1[rsp]
	mov	rcx, QWORD PTR font$[rsp]
	call	?GetCharAdvance@ImFont@@QEBAMG@Z	; ImFont::GetCharAdvance
	mulss	xmm0, DWORD PTR scale$[rsp]
	movss	DWORD PTR char_width$2[rsp], xmm0

; 3328 : 		line_width += char_width;

	movss	xmm0, DWORD PTR line_width$[rsp]
	addss	xmm0, DWORD PTR char_width$2[rsp]
	movss	DWORD PTR line_width$[rsp], xmm0

; 3329 : 	}

	jmp	$LN14@InputTextC
$LN3@InputTextC:

; 3330 : 
; 3331 : 	if (text_size.x < line_width)

	movss	xmm0, DWORD PTR line_width$[rsp]
	comiss	xmm0, DWORD PTR text_size$[rsp]
	jbe	SHORT $LN7@InputTextC

; 3332 : 		text_size.x = line_width;

	movss	xmm0, DWORD PTR line_width$[rsp]
	movss	DWORD PTR text_size$[rsp], xmm0
$LN7@InputTextC:

; 3333 : 
; 3334 : 	if (out_offset)

	cmp	QWORD PTR out_offset$[rsp], 0
	je	SHORT $LN8@InputTextC

; 3335 : 		*out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n

	movss	xmm0, DWORD PTR text_size$[rsp+4]
	addss	xmm0, DWORD PTR line_height$[rsp]
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR line_width$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR out_offset$[rsp]
	mov	QWORD PTR [rcx], rax
$LN8@InputTextC:

; 3336 : 
; 3337 : 	if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n

	movss	xmm0, DWORD PTR line_width$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN10@InputTextC
	movss	xmm0, DWORD PTR text_size$[rsp+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN9@InputTextC
	jne	SHORT $LN9@InputTextC
$LN10@InputTextC:

; 3338 : 		text_size.y += line_height;

	movss	xmm0, DWORD PTR text_size$[rsp+4]
	addss	xmm0, DWORD PTR line_height$[rsp]
	movss	DWORD PTR text_size$[rsp+4], xmm0
$LN9@InputTextC:

; 3339 : 
; 3340 : 	if (remaining)

	cmp	QWORD PTR remaining$[rsp], 0
	je	SHORT $LN11@InputTextC

; 3341 : 		*remaining = s;

	mov	rax, QWORD PTR remaining$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	QWORD PTR [rax], rcx
$LN11@InputTextC:

; 3342 : 
; 3343 : 	return text_size;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR text_size$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3344 : }

	add	rsp, 120				; 00000078H
	ret	0
?InputTextCalcTextSizeW@@YA?AUImVec2@@PEBG0PEAPEBGPEAU1@_N@Z ENDP ; InputTextCalcTextSizeW
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
c$1 = 0
tv66 = 1
line_count$ = 4
s$ = 8
text_begin$ = 32
out_text_end$ = 40
?InputTextCalcTextLenAndLineCount@@YAHPEBDPEAPEBD@Z PROC ; InputTextCalcTextLenAndLineCount

; 3288 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 3289 : 	int line_count = 0;

	mov	DWORD PTR line_count$[rsp], 0

; 3290 : 	const char* s = text_begin;

	mov	rax, QWORD PTR text_begin$[rsp]
	mov	QWORD PTR s$[rsp], rax
$LN2@InputTextC:

; 3291 : 	while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding

	mov	rax, QWORD PTR s$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv66[rsp], al
	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax
	movzx	eax, BYTE PTR tv66[rsp]
	mov	BYTE PTR c$1[rsp], al
	movsx	eax, BYTE PTR c$1[rsp]
	test	eax, eax
	je	SHORT $LN3@InputTextC

; 3292 : 		if (c == '\n')

	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 10
	jne	SHORT $LN4@InputTextC

; 3293 : 			line_count++;

	mov	eax, DWORD PTR line_count$[rsp]
	inc	eax
	mov	DWORD PTR line_count$[rsp], eax
$LN4@InputTextC:
	jmp	SHORT $LN2@InputTextC
$LN3@InputTextC:

; 3294 : 	s--;

	mov	rax, QWORD PTR s$[rsp]
	dec	rax
	mov	QWORD PTR s$[rsp], rax

; 3295 : 	if (s[0] != '\n' && s[0] != '\r')

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 10
	je	SHORT $LN5@InputTextC
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	je	SHORT $LN5@InputTextC

; 3296 : 		line_count++;

	mov	eax, DWORD PTR line_count$[rsp]
	inc	eax
	mov	DWORD PTR line_count$[rsp], eax
$LN5@InputTextC:

; 3297 : 	*out_text_end = s;

	mov	rax, QWORD PTR out_text_end$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	QWORD PTR [rax], rcx

; 3298 : 	return line_count;

	mov	eax, DWORD PTR line_count$[rsp]

; 3299 : }

	add	rsp, 24
	ret	0
?InputTextCalcTextLenAndLineCount@@YAHPEBDPEAPEBD@Z ENDP ; InputTextCalcTextLenAndLineCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
c$ = 32
pass$1 = 36
tv74 = 40
tv83 = 44
tv76 = 48
tv85 = 52
tv176 = 56
callback_data$2 = 64
p_char$ = 144
flags$ = 152
callback$ = 160
user_data$ = 168
?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z PROC ; InputTextFilterCharacter

; 3515 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 3516 : 	unsigned int c = *p_char;

	mov	rax, QWORD PTR p_char$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR c$[rsp], eax

; 3517 : 
; 3518 : 	if (c < 128 && c != ' ' && !isprint((int)(c & 0xFF)))

	cmp	DWORD PTR c$[rsp], 128			; 00000080H
	jae	$LN2@InputTextF
	cmp	DWORD PTR c$[rsp], 32			; 00000020H
	je	$LN2@InputTextF
	mov	eax, DWORD PTR c$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, eax
	call	isprint
	test	eax, eax
	jne	$LN2@InputTextF

; 3519 : 	{
; 3520 : 		bool pass = false;

	mov	BYTE PTR pass$1[rsp], 0

; 3521 : 		pass |= (c == '\n' && (flags & ImGuiInputTextFlags_Multiline));

	movzx	eax, BYTE PTR pass$1[rsp]
	mov	DWORD PTR tv76[rsp], eax
	cmp	DWORD PTR c$[rsp], 10
	jne	SHORT $LN26@InputTextF
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	je	SHORT $LN26@InputTextF
	mov	DWORD PTR tv74[rsp], 1
	jmp	SHORT $LN27@InputTextF
$LN26@InputTextF:
	mov	DWORD PTR tv74[rsp], 0
$LN27@InputTextF:
	mov	eax, DWORD PTR tv74[rsp]
	mov	ecx, DWORD PTR tv76[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR pass$1[rsp], al

; 3522 : 		pass |= (c == '\t' && (flags & ImGuiInputTextFlags_AllowTabInput));

	movzx	eax, BYTE PTR pass$1[rsp]
	mov	DWORD PTR tv85[rsp], eax
	cmp	DWORD PTR c$[rsp], 9
	jne	SHORT $LN28@InputTextF
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $LN28@InputTextF
	mov	DWORD PTR tv83[rsp], 1
	jmp	SHORT $LN29@InputTextF
$LN28@InputTextF:
	mov	DWORD PTR tv83[rsp], 0
$LN29@InputTextF:
	mov	eax, DWORD PTR tv83[rsp]
	mov	ecx, DWORD PTR tv85[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR pass$1[rsp], al

; 3523 : 		if (!pass)

	movzx	eax, BYTE PTR pass$1[rsp]
	test	eax, eax
	jne	SHORT $LN3@InputTextF

; 3524 : 			return false;

	xor	al, al
	jmp	$LN1@InputTextF
$LN3@InputTextF:
$LN2@InputTextF:

; 3525 : 	}
; 3526 : 
; 3527 : 	if (c >= 0xE000 && c <= 0xF8FF) // Filter private Unicode range. I don't imagine anybody would want to input them. GLFW on OSX seems to send private characters for special keys like arrow keys.

	cmp	DWORD PTR c$[rsp], 57344		; 0000e000H
	jb	SHORT $LN4@InputTextF
	cmp	DWORD PTR c$[rsp], 63743		; 0000f8ffH
	ja	SHORT $LN4@InputTextF

; 3528 : 		return false;

	xor	al, al
	jmp	$LN1@InputTextF
$LN4@InputTextF:

; 3529 : 
; 3530 : 	if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 131087				; 0002000fH
	test	eax, eax
	je	$LN5@InputTextF

; 3531 : 	{
; 3532 : 		if (flags & ImGuiInputTextFlags_CharsDecimal)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@InputTextF

; 3533 : 			if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/'))

	cmp	DWORD PTR c$[rsp], 48			; 00000030H
	jb	SHORT $LN8@InputTextF
	cmp	DWORD PTR c$[rsp], 57			; 00000039H
	jbe	SHORT $LN7@InputTextF
$LN8@InputTextF:
	cmp	DWORD PTR c$[rsp], 46			; 0000002eH
	je	SHORT $LN7@InputTextF
	cmp	DWORD PTR c$[rsp], 45			; 0000002dH
	je	SHORT $LN7@InputTextF
	cmp	DWORD PTR c$[rsp], 43			; 0000002bH
	je	SHORT $LN7@InputTextF
	cmp	DWORD PTR c$[rsp], 42			; 0000002aH
	je	SHORT $LN7@InputTextF
	cmp	DWORD PTR c$[rsp], 47			; 0000002fH
	je	SHORT $LN7@InputTextF

; 3534 : 				return false;

	xor	al, al
	jmp	$LN1@InputTextF
$LN7@InputTextF:
$LN6@InputTextF:

; 3535 : 
; 3536 : 		if (flags & ImGuiInputTextFlags_CharsScientific)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $LN9@InputTextF

; 3537 : 			if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))

	cmp	DWORD PTR c$[rsp], 48			; 00000030H
	jb	SHORT $LN11@InputTextF
	cmp	DWORD PTR c$[rsp], 57			; 00000039H
	jbe	SHORT $LN10@InputTextF
$LN11@InputTextF:
	cmp	DWORD PTR c$[rsp], 46			; 0000002eH
	je	SHORT $LN10@InputTextF
	cmp	DWORD PTR c$[rsp], 45			; 0000002dH
	je	SHORT $LN10@InputTextF
	cmp	DWORD PTR c$[rsp], 43			; 0000002bH
	je	SHORT $LN10@InputTextF
	cmp	DWORD PTR c$[rsp], 42			; 0000002aH
	je	SHORT $LN10@InputTextF
	cmp	DWORD PTR c$[rsp], 47			; 0000002fH
	je	SHORT $LN10@InputTextF
	cmp	DWORD PTR c$[rsp], 101			; 00000065H
	je	SHORT $LN10@InputTextF
	cmp	DWORD PTR c$[rsp], 69			; 00000045H
	je	SHORT $LN10@InputTextF

; 3538 : 				return false;

	xor	al, al
	jmp	$LN1@InputTextF
$LN10@InputTextF:
$LN9@InputTextF:

; 3539 : 
; 3540 : 		if (flags & ImGuiInputTextFlags_CharsHexadecimal)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN12@InputTextF

; 3541 : 			if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z'))

	cmp	DWORD PTR c$[rsp], 48			; 00000030H
	jb	SHORT $LN14@InputTextF
	cmp	DWORD PTR c$[rsp], 57			; 00000039H
	jbe	SHORT $LN13@InputTextF
$LN14@InputTextF:
	cmp	DWORD PTR c$[rsp], 97			; 00000061H
	jb	SHORT $LN15@InputTextF
	cmp	DWORD PTR c$[rsp], 122			; 0000007aH
	jbe	SHORT $LN13@InputTextF
$LN15@InputTextF:
	cmp	DWORD PTR c$[rsp], 65			; 00000041H
	jb	SHORT $LN16@InputTextF
	cmp	DWORD PTR c$[rsp], 90			; 0000005aH
	jbe	SHORT $LN13@InputTextF
$LN16@InputTextF:

; 3542 : 				if (c != '-' && c != '_')

	cmp	DWORD PTR c$[rsp], 45			; 0000002dH
	je	SHORT $LN17@InputTextF
	cmp	DWORD PTR c$[rsp], 95			; 0000005fH
	je	SHORT $LN17@InputTextF

; 3543 : 					return false;

	xor	al, al
	jmp	$LN1@InputTextF
$LN17@InputTextF:
$LN13@InputTextF:
$LN12@InputTextF:

; 3544 : 
; 3545 : 		if (flags & ImGuiInputTextFlags_CharsUppercase)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN18@InputTextF

; 3546 : 			if (c >= 'a' && c <= 'z')

	cmp	DWORD PTR c$[rsp], 97			; 00000061H
	jb	SHORT $LN19@InputTextF
	cmp	DWORD PTR c$[rsp], 122			; 0000007aH
	ja	SHORT $LN19@InputTextF

; 3547 : 				*p_char = (c += (unsigned int)('A' - 'a'));

	mov	eax, DWORD PTR c$[rsp]
	add	eax, -32				; ffffffe0H
	mov	DWORD PTR c$[rsp], eax
	mov	rax, QWORD PTR p_char$[rsp]
	mov	ecx, DWORD PTR c$[rsp]
	mov	DWORD PTR [rax], ecx
$LN19@InputTextF:
$LN18@InputTextF:

; 3548 : 
; 3549 : 		if (flags & ImGuiInputTextFlags_CharsNoBlank)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN20@InputTextF

; 3550 : 			if (ImCharIsBlankW(c))

	mov	ecx, DWORD PTR c$[rsp]
	call	?ImCharIsBlankW@@YA_NI@Z		; ImCharIsBlankW
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@InputTextF

; 3551 : 				return false;

	xor	al, al
	jmp	$LN1@InputTextF
$LN21@InputTextF:
$LN20@InputTextF:
$LN5@InputTextF:

; 3552 : 	}
; 3553 : 
; 3554 : 	if (flags & ImGuiInputTextFlags_CallbackCharFilter)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	$LN22@InputTextF

; 3555 : 	{
; 3556 : 		ImGuiInputTextCallbackData callback_data;

	lea	rcx, QWORD PTR callback_data$2[rsp]
	call	??0ImGuiInputTextCallbackData@@QEAA@XZ	; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData

; 3557 : 		memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));

	mov	r8d, 56					; 00000038H
	xor	edx, edx
	lea	rcx, QWORD PTR callback_data$2[rsp]
	call	memset

; 3558 : 		callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;

	mov	DWORD PTR callback_data$2[rsp+4], 512	; 00000200H

; 3559 : 		callback_data.EventChar = (ImWchar)c;

	movzx	eax, WORD PTR c$[rsp]
	mov	WORD PTR callback_data$2[rsp+20], ax

; 3560 : 		callback_data.Flags = flags;

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR callback_data$2[rsp], eax

; 3561 : 		callback_data.UserData = user_data;

	mov	rax, QWORD PTR user_data$[rsp]
	mov	QWORD PTR callback_data$2[rsp+8], rax

; 3562 : 		if (callback(&callback_data) != 0)

	mov	rax, QWORD PTR callback$[rsp]
	mov	QWORD PTR tv176[rsp], rax
	lea	rcx, QWORD PTR callback_data$2[rsp]
	call	QWORD PTR tv176[rsp]
	test	eax, eax
	je	SHORT $LN23@InputTextF

; 3563 : 			return false;

	xor	al, al
	jmp	SHORT $LN1@InputTextF
$LN23@InputTextF:

; 3564 : 		*p_char = callback_data.EventChar;

	movzx	eax, WORD PTR callback_data$2[rsp+20]
	mov	rcx, QWORD PTR p_char$[rsp]
	mov	DWORD PTR [rcx], eax

; 3565 : 		if (!callback_data.EventChar)

	movzx	eax, WORD PTR callback_data$2[rsp+20]
	test	eax, eax
	jne	SHORT $LN24@InputTextF

; 3566 : 			return false;

	xor	al, al
	jmp	SHORT $LN1@InputTextF
$LN24@InputTextF:
$LN22@InputTextF:

; 3567 : 	}
; 3568 : 
; 3569 : 	return true;

	mov	al, 1
$LN1@InputTextF:

; 3570 : }

	add	rsp, 136				; 00000088H
	ret	0
?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ENDP ; InputTextFilterCharacter
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
op$ = 32
arg1f$1 = 36
arg1f$2 = 40
arg0i$3 = 44
arg1i$ = 48
arg0f$4 = 52
arg1f$5 = 56
tv238 = 64
v$6 = 72
v$7 = 80
v$8 = 88
arg0f$9 = 96
data_backup$ = 104
buf$ = 128
initial_value_buf$ = 136
data_type$ = 144
data_ptr$ = 152
format$ = 160
?DataTypeApplyOpFromText@@YA_NPEBD0HPEAX0@Z PROC	; DataTypeApplyOpFromText

; 1939 : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
$LN2@DataTypeAp:

; 1940 : 	while (ImCharIsBlankA(*buf))

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR [rax]
	call	?ImCharIsBlankA@@YA_ND@Z		; ImCharIsBlankA
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@DataTypeAp

; 1941 : 		buf++;

	mov	rax, QWORD PTR buf$[rsp]
	inc	rax
	mov	QWORD PTR buf$[rsp], rax
	jmp	SHORT $LN2@DataTypeAp
$LN3@DataTypeAp:

; 1942 : 
; 1943 : 	// We don't support '-' op because it would conflict with inputing negative value.
; 1944 : 	// Instead you can use +-100 to subtract from an existing value
; 1945 : 	char op = buf[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR buf$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR op$[rsp], al

; 1946 : 	if (op == '+' || op == '*' || op == '/')

	movsx	eax, BYTE PTR op$[rsp]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN8@DataTypeAp
	movsx	eax, BYTE PTR op$[rsp]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN8@DataTypeAp
	movsx	eax, BYTE PTR op$[rsp]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN6@DataTypeAp
$LN8@DataTypeAp:

; 1947 : 	{
; 1948 : 		buf++;

	mov	rax, QWORD PTR buf$[rsp]
	inc	rax
	mov	QWORD PTR buf$[rsp], rax
$LN4@DataTypeAp:

; 1949 : 		while (ImCharIsBlankA(*buf))

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR [rax]
	call	?ImCharIsBlankA@@YA_ND@Z		; ImCharIsBlankA
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@DataTypeAp

; 1950 : 			buf++;

	mov	rax, QWORD PTR buf$[rsp]
	inc	rax
	mov	QWORD PTR buf$[rsp], rax
	jmp	SHORT $LN4@DataTypeAp
$LN5@DataTypeAp:

; 1951 : 	}

	jmp	SHORT $LN7@DataTypeAp
$LN6@DataTypeAp:

; 1952 : 	else
; 1953 : 	{
; 1954 : 		op = 0;

	mov	BYTE PTR op$[rsp], 0
$LN7@DataTypeAp:

; 1955 : 	}
; 1956 : 	if (!buf[0])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR buf$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN9@DataTypeAp

; 1957 : 		return false;

	xor	al, al
	jmp	$LN1@DataTypeAp
$LN9@DataTypeAp:

; 1958 : 
; 1959 : 	// Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
; 1960 : 	IM_ASSERT(data_type < ImGuiDataType_COUNT);
; 1961 : 	int data_backup[2];
; 1962 : 	IM_ASSERT(GDataTypeInfo[data_type].Size <= sizeof(data_backup));
; 1963 : 	memcpy(data_backup, data_ptr, GDataTypeInfo[data_type].Size);

	movsxd	rax, DWORD PTR data_type$[rsp]
	imul	rax, rax, 72				; 00000048H
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	mov	r8, QWORD PTR [rcx+rax]
	mov	rdx, QWORD PTR data_ptr$[rsp]
	lea	rcx, QWORD PTR data_backup$[rsp]
	call	memcpy
	npad	1

; 1964 : 
; 1965 : 	if (format == NULL)

	cmp	QWORD PTR format$[rsp], 0
	jne	SHORT $LN10@DataTypeAp

; 1966 : 		format = GDataTypeInfo[data_type].ScanFmt.c_str();

	movsxd	rax, DWORD PTR data_type$[rsp]
	imul	rax, rax, 72				; 00000048H
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	lea	rax, QWORD PTR [rcx+rax+40]
	mov	rcx, rax
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR format$[rsp], rax
$LN10@DataTypeAp:

; 1967 : 
; 1968 : 	int arg1i = 0;

	mov	DWORD PTR arg1i$[rsp], 0

; 1969 : 	if (data_type == ImGuiDataType_S32)

	cmp	DWORD PTR data_type$[rsp], 0
	jne	$LN11@DataTypeAp

; 1970 : 	{
; 1971 : 		int* v = (int*)data_ptr;

	mov	rax, QWORD PTR data_ptr$[rsp]
	mov	QWORD PTR v$6[rsp], rax

; 1972 : 		int arg0i = *v;

	mov	rax, QWORD PTR v$6[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR arg0i$3[rsp], eax

; 1973 : 		float arg1f = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR arg1f$2[rsp], xmm0

; 1974 : 		if (op && sscanf(initial_value_buf, format, &arg0i) < 1)

	movsx	eax, BYTE PTR op$[rsp]
	test	eax, eax
	je	SHORT $LN13@DataTypeAp
	lea	r8, QWORD PTR arg0i$3[rsp]
	mov	rdx, QWORD PTR format$[rsp]
	mov	rcx, QWORD PTR initial_value_buf$[rsp]
	call	sscanf
	cmp	eax, 1
	jge	SHORT $LN13@DataTypeAp

; 1975 : 			return false;

	xor	al, al
	jmp	$LN1@DataTypeAp
$LN13@DataTypeAp:

; 1976 : 		// Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision
; 1977 : 		if (op == '+') { if (sscanf(buf, ("%d"), &arg1i)) *v = (int)(arg0i + arg1i); }                   // Add (use "+-" to subtract)

	movsx	eax, BYTE PTR op$[rsp]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN14@DataTypeAp
	lea	r8, QWORD PTR arg1i$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	mov	rcx, QWORD PTR buf$[rsp]
	call	sscanf
	test	eax, eax
	je	SHORT $LN16@DataTypeAp
	mov	eax, DWORD PTR arg1i$[rsp]
	mov	ecx, DWORD PTR arg0i$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR v$6[rsp]
	mov	DWORD PTR [rcx], eax
$LN16@DataTypeAp:
	jmp	$LN15@DataTypeAp
$LN14@DataTypeAp:

; 1978 : 		else if (op == '*') { if (sscanf(buf, ("%f"), &arg1f)) *v = (int)(arg0i * arg1f); }                   // Multiply

	movsx	eax, BYTE PTR op$[rsp]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN17@DataTypeAp
	lea	r8, QWORD PTR arg1f$2[rsp]
	lea	rdx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	mov	rcx, QWORD PTR buf$[rsp]
	call	sscanf
	test	eax, eax
	je	SHORT $LN19@DataTypeAp
	cvtsi2ss xmm0, DWORD PTR arg0i$3[rsp]
	mulss	xmm0, DWORD PTR arg1f$2[rsp]
	cvttss2si eax, xmm0
	mov	rcx, QWORD PTR v$6[rsp]
	mov	DWORD PTR [rcx], eax
$LN19@DataTypeAp:
	jmp	SHORT $LN18@DataTypeAp
$LN17@DataTypeAp:

; 1979 : 		else if (op == '/') { if (sscanf(buf, ("%f"), &arg1f) && arg1f != 0.0f) *v = (int)(arg0i / arg1f); }  // Divide

	movsx	eax, BYTE PTR op$[rsp]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN20@DataTypeAp
	lea	r8, QWORD PTR arg1f$2[rsp]
	lea	rdx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	mov	rcx, QWORD PTR buf$[rsp]
	call	sscanf
	test	eax, eax
	je	SHORT $LN22@DataTypeAp
	movss	xmm0, DWORD PTR arg1f$2[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN53@DataTypeAp
	je	SHORT $LN22@DataTypeAp
$LN53@DataTypeAp:
	cvtsi2ss xmm0, DWORD PTR arg0i$3[rsp]
	divss	xmm0, DWORD PTR arg1f$2[rsp]
	cvttss2si eax, xmm0
	mov	rcx, QWORD PTR v$6[rsp]
	mov	DWORD PTR [rcx], eax
$LN22@DataTypeAp:
	jmp	SHORT $LN21@DataTypeAp
$LN20@DataTypeAp:

; 1980 : 		else { if (sscanf(buf, format, &arg1i) == 1) *v = arg1i; }                           // Assign constant

	lea	r8, QWORD PTR arg1i$[rsp]
	mov	rdx, QWORD PTR format$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	sscanf
	cmp	eax, 1
	jne	SHORT $LN23@DataTypeAp
	mov	rax, QWORD PTR v$6[rsp]
	mov	ecx, DWORD PTR arg1i$[rsp]
	mov	DWORD PTR [rax], ecx
$LN23@DataTypeAp:
$LN21@DataTypeAp:
$LN18@DataTypeAp:
$LN15@DataTypeAp:

; 1981 : 	}

	jmp	$LN12@DataTypeAp
$LN11@DataTypeAp:

; 1982 : 	else if (data_type == ImGuiDataType_U32 || data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)

	cmp	DWORD PTR data_type$[rsp], 1
	je	SHORT $LN26@DataTypeAp
	cmp	DWORD PTR data_type$[rsp], 2
	je	SHORT $LN26@DataTypeAp
	cmp	DWORD PTR data_type$[rsp], 3
	jne	SHORT $LN24@DataTypeAp
$LN26@DataTypeAp:

; 1983 : 	{
; 1984 : 		// Assign constant
; 1985 : 		// FIXME: We don't bother handling support for legacy operators since they are a little too crappy. Instead we may implement a proper expression evaluator in the future.
; 1986 : 		sscanf(buf, format, data_ptr);

	mov	r8, QWORD PTR data_ptr$[rsp]
	mov	rdx, QWORD PTR format$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	sscanf
	npad	1

; 1987 : 	}

	jmp	$LN25@DataTypeAp
$LN24@DataTypeAp:

; 1988 : 	else if (data_type == ImGuiDataType_Float)

	cmp	DWORD PTR data_type$[rsp], 4
	jne	$LN27@DataTypeAp

; 1989 : 	{
; 1990 : 		// For floats we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in
; 1991 : 		format = ("%f");

	lea	rax, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	mov	QWORD PTR format$[rsp], rax

; 1992 : 		float* v = (float*)data_ptr;

	mov	rax, QWORD PTR data_ptr$[rsp]
	mov	QWORD PTR v$7[rsp], rax

; 1993 : 		float arg0f = *v, arg1f = 0.0f;

	mov	rax, QWORD PTR v$7[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR arg0f$4[rsp], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR arg1f$1[rsp], xmm0

; 1994 : 		if (op && sscanf(initial_value_buf, format, &arg0f) < 1)

	movsx	eax, BYTE PTR op$[rsp]
	test	eax, eax
	je	SHORT $LN29@DataTypeAp
	lea	r8, QWORD PTR arg0f$4[rsp]
	mov	rdx, QWORD PTR format$[rsp]
	mov	rcx, QWORD PTR initial_value_buf$[rsp]
	call	sscanf
	cmp	eax, 1
	jge	SHORT $LN29@DataTypeAp

; 1995 : 			return false;

	xor	al, al
	jmp	$LN1@DataTypeAp
$LN29@DataTypeAp:

; 1996 : 		if (sscanf(buf, format, &arg1f) < 1)

	lea	r8, QWORD PTR arg1f$1[rsp]
	mov	rdx, QWORD PTR format$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	sscanf
	cmp	eax, 1
	jge	SHORT $LN30@DataTypeAp

; 1997 : 			return false;

	xor	al, al
	jmp	$LN1@DataTypeAp
$LN30@DataTypeAp:

; 1998 : 		if (op == '+') { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)

	movsx	eax, BYTE PTR op$[rsp]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN31@DataTypeAp
	movss	xmm0, DWORD PTR arg0f$4[rsp]
	addss	xmm0, DWORD PTR arg1f$1[rsp]
	mov	rax, QWORD PTR v$7[rsp]
	movss	DWORD PTR [rax], xmm0
	jmp	SHORT $LN32@DataTypeAp
$LN31@DataTypeAp:

; 1999 : 		else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply

	movsx	eax, BYTE PTR op$[rsp]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN33@DataTypeAp
	movss	xmm0, DWORD PTR arg0f$4[rsp]
	mulss	xmm0, DWORD PTR arg1f$1[rsp]
	mov	rax, QWORD PTR v$7[rsp]
	movss	DWORD PTR [rax], xmm0
	jmp	SHORT $LN34@DataTypeAp
$LN33@DataTypeAp:

; 2000 : 		else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide

	movsx	eax, BYTE PTR op$[rsp]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN35@DataTypeAp
	movss	xmm0, DWORD PTR arg1f$1[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN52@DataTypeAp
	je	SHORT $LN37@DataTypeAp
$LN52@DataTypeAp:
	movss	xmm0, DWORD PTR arg0f$4[rsp]
	divss	xmm0, DWORD PTR arg1f$1[rsp]
	mov	rax, QWORD PTR v$7[rsp]
	movss	DWORD PTR [rax], xmm0
$LN37@DataTypeAp:
	jmp	SHORT $LN36@DataTypeAp
$LN35@DataTypeAp:

; 2001 : 		else { *v = arg1f; }                            // Assign constant

	mov	rax, QWORD PTR v$7[rsp]
	movss	xmm0, DWORD PTR arg1f$1[rsp]
	movss	DWORD PTR [rax], xmm0
$LN36@DataTypeAp:
$LN34@DataTypeAp:
$LN32@DataTypeAp:

; 2002 : 	}

	jmp	$LN28@DataTypeAp
$LN27@DataTypeAp:

; 2003 : 	else if (data_type == ImGuiDataType_Double)

	cmp	DWORD PTR data_type$[rsp], 5
	jne	$LN38@DataTypeAp

; 2004 : 	{
; 2005 : 		format = "%lf"; // scanf differentiate float/double unlike printf which forces everything to double because of ellipsis

	lea	rax, OFFSET FLAT:??_C@_03DLDNIBIK@?$CFlf@
	mov	QWORD PTR format$[rsp], rax

; 2006 : 		double* v = (double*)data_ptr;

	mov	rax, QWORD PTR data_ptr$[rsp]
	mov	QWORD PTR v$8[rsp], rax

; 2007 : 		double arg0f = *v, arg1f = 0.0;

	mov	rax, QWORD PTR v$8[rsp]
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR arg0f$9[rsp], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR arg1f$5[rsp], xmm0

; 2008 : 		if (op && sscanf(initial_value_buf, format, &arg0f) < 1)

	movsx	eax, BYTE PTR op$[rsp]
	test	eax, eax
	je	SHORT $LN39@DataTypeAp
	lea	r8, QWORD PTR arg0f$9[rsp]
	mov	rdx, QWORD PTR format$[rsp]
	mov	rcx, QWORD PTR initial_value_buf$[rsp]
	call	sscanf
	cmp	eax, 1
	jge	SHORT $LN39@DataTypeAp

; 2009 : 			return false;

	xor	al, al
	jmp	$LN1@DataTypeAp
$LN39@DataTypeAp:

; 2010 : 		if (sscanf(buf, format, &arg1f) < 1)

	lea	r8, QWORD PTR arg1f$5[rsp]
	mov	rdx, QWORD PTR format$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	sscanf
	cmp	eax, 1
	jge	SHORT $LN40@DataTypeAp

; 2011 : 			return false;

	xor	al, al
	jmp	$LN1@DataTypeAp
$LN40@DataTypeAp:

; 2012 : 		if (op == '+') { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)

	movsx	eax, BYTE PTR op$[rsp]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN41@DataTypeAp
	movsd	xmm0, QWORD PTR arg0f$9[rsp]
	addsd	xmm0, QWORD PTR arg1f$5[rsp]
	mov	rax, QWORD PTR v$8[rsp]
	movsd	QWORD PTR [rax], xmm0
	jmp	SHORT $LN42@DataTypeAp
$LN41@DataTypeAp:

; 2013 : 		else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply

	movsx	eax, BYTE PTR op$[rsp]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN43@DataTypeAp
	movsd	xmm0, QWORD PTR arg0f$9[rsp]
	mulsd	xmm0, QWORD PTR arg1f$5[rsp]
	mov	rax, QWORD PTR v$8[rsp]
	movsd	QWORD PTR [rax], xmm0
	jmp	SHORT $LN44@DataTypeAp
$LN43@DataTypeAp:

; 2014 : 		else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide

	movsx	eax, BYTE PTR op$[rsp]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN45@DataTypeAp
	movsd	xmm0, QWORD PTR arg1f$5[rsp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	jp	SHORT $LN51@DataTypeAp
	je	SHORT $LN47@DataTypeAp
$LN51@DataTypeAp:
	movsd	xmm0, QWORD PTR arg0f$9[rsp]
	divsd	xmm0, QWORD PTR arg1f$5[rsp]
	mov	rax, QWORD PTR v$8[rsp]
	movsd	QWORD PTR [rax], xmm0
$LN47@DataTypeAp:
	jmp	SHORT $LN46@DataTypeAp
$LN45@DataTypeAp:

; 2015 : 		else { *v = arg1f; }                            // Assign constant

	mov	rax, QWORD PTR v$8[rsp]
	movsd	xmm0, QWORD PTR arg1f$5[rsp]
	movsd	QWORD PTR [rax], xmm0
$LN46@DataTypeAp:
$LN44@DataTypeAp:
$LN42@DataTypeAp:
$LN38@DataTypeAp:
$LN28@DataTypeAp:
$LN25@DataTypeAp:
$LN12@DataTypeAp:

; 2016 : 	}
; 2017 : 	return memcmp(data_backup, data_ptr, GDataTypeInfo[data_type].Size) != 0;

	movsxd	rax, DWORD PTR data_type$[rsp]
	imul	rax, rax, 72				; 00000048H
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	mov	r8, QWORD PTR [rcx+rax]
	mov	rdx, QWORD PTR data_ptr$[rsp]
	lea	rcx, QWORD PTR data_backup$[rsp]
	call	memcmp
	test	eax, eax
	je	SHORT $LN49@DataTypeAp
	mov	DWORD PTR tv238[rsp], 1
	jmp	SHORT $LN50@DataTypeAp
$LN49@DataTypeAp:
	mov	DWORD PTR tv238[rsp], 0
$LN50@DataTypeAp:
	movzx	eax, BYTE PTR tv238[rsp]
$LN1@DataTypeAp:

; 2018 : }

	add	rsp, 120				; 00000078H
	ret	0
?DataTypeApplyOpFromText@@YA_NPEBD0HPEAX0@Z ENDP	; DataTypeApplyOpFromText
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv64 = 0
data_type$ = 32
op$ = 40
output$ = 48
arg1$ = 56
arg2$ = 64
?DataTypeApplyOp@@YAXHHPEAX0PEBX@Z PROC			; DataTypeApplyOp

; 1903 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 1904 : 	IM_ASSERT(op == '+' || op == '-');
; 1905 : 	switch (data_type)

	mov	eax, DWORD PTR data_type$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 5
	ja	$LN2@DataTypeAp
	movsxd	rax, DWORD PTR tv64[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN30@DataTypeAp[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@DataTypeAp:

; 1906 : 	{
; 1907 : 	case ImGuiDataType_S32:
; 1908 : 		if (op == '+')      *(int*)output = *(const int*)arg1 + *(const int*)arg2;

	cmp	DWORD PTR op$[rsp], 43			; 0000002bH
	jne	SHORT $LN5@DataTypeAp
	mov	rax, QWORD PTR arg1$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR arg2$[rsp]
	add	eax, DWORD PTR [rcx]
	mov	rcx, QWORD PTR output$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN6@DataTypeAp
$LN5@DataTypeAp:

; 1909 : 		else if (op == '-') *(int*)output = *(const int*)arg1 - *(const int*)arg2;

	cmp	DWORD PTR op$[rsp], 45			; 0000002dH
	jne	SHORT $LN7@DataTypeAp
	mov	rax, QWORD PTR arg1$[rsp]
	mov	rcx, QWORD PTR arg2$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	eax, DWORD PTR [rax]
	sub	eax, ecx
	mov	rcx, QWORD PTR output$[rsp]
	mov	DWORD PTR [rcx], eax
$LN7@DataTypeAp:
$LN6@DataTypeAp:

; 1910 : 		return;

	jmp	$LN1@DataTypeAp
$LN8@DataTypeAp:

; 1911 : 	case ImGuiDataType_U32:
; 1912 : 		if (op == '+')      *(unsigned int*)output = *(const unsigned int*)arg1 + *(const ImU32*)arg2;

	cmp	DWORD PTR op$[rsp], 43			; 0000002bH
	jne	SHORT $LN9@DataTypeAp
	mov	rax, QWORD PTR arg1$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR arg2$[rsp]
	add	eax, DWORD PTR [rcx]
	mov	rcx, QWORD PTR output$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN10@DataTypeAp
$LN9@DataTypeAp:

; 1913 : 		else if (op == '-') *(unsigned int*)output = *(const unsigned int*)arg1 - *(const ImU32*)arg2;

	cmp	DWORD PTR op$[rsp], 45			; 0000002dH
	jne	SHORT $LN11@DataTypeAp
	mov	rax, QWORD PTR arg1$[rsp]
	mov	rcx, QWORD PTR arg2$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	eax, DWORD PTR [rax]
	sub	eax, ecx
	mov	rcx, QWORD PTR output$[rsp]
	mov	DWORD PTR [rcx], eax
$LN11@DataTypeAp:
$LN10@DataTypeAp:

; 1914 : 		return;

	jmp	$LN1@DataTypeAp
$LN12@DataTypeAp:

; 1915 : 	case ImGuiDataType_S64:
; 1916 : 		if (op == '+')      *(ImS64*)output = *(const ImS64*)arg1 + *(const ImS64*)arg2;

	cmp	DWORD PTR op$[rsp], 43			; 0000002bH
	jne	SHORT $LN13@DataTypeAp
	mov	rax, QWORD PTR arg1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR arg2$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR output$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN14@DataTypeAp
$LN13@DataTypeAp:

; 1917 : 		else if (op == '-') *(ImS64*)output = *(const ImS64*)arg1 - *(const ImS64*)arg2;

	cmp	DWORD PTR op$[rsp], 45			; 0000002dH
	jne	SHORT $LN15@DataTypeAp
	mov	rax, QWORD PTR arg1$[rsp]
	mov	rcx, QWORD PTR arg2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	rcx, QWORD PTR output$[rsp]
	mov	QWORD PTR [rcx], rax
$LN15@DataTypeAp:
$LN14@DataTypeAp:

; 1918 : 		return;

	jmp	$LN1@DataTypeAp
$LN16@DataTypeAp:

; 1919 : 	case ImGuiDataType_U64:
; 1920 : 		if (op == '+')      *(ImU64*)output = *(const ImU64*)arg1 + *(const ImU64*)arg2;

	cmp	DWORD PTR op$[rsp], 43			; 0000002bH
	jne	SHORT $LN17@DataTypeAp
	mov	rax, QWORD PTR arg1$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR arg2$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR output$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN18@DataTypeAp
$LN17@DataTypeAp:

; 1921 : 		else if (op == '-') *(ImU64*)output = *(const ImU64*)arg1 - *(const ImU64*)arg2;

	cmp	DWORD PTR op$[rsp], 45			; 0000002dH
	jne	SHORT $LN19@DataTypeAp
	mov	rax, QWORD PTR arg1$[rsp]
	mov	rcx, QWORD PTR arg2$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	rcx, QWORD PTR output$[rsp]
	mov	QWORD PTR [rcx], rax
$LN19@DataTypeAp:
$LN18@DataTypeAp:

; 1922 : 		return;

	jmp	$LN1@DataTypeAp
$LN20@DataTypeAp:

; 1923 : 	case ImGuiDataType_Float:
; 1924 : 		if (op == '+')      *(float*)output = *(const float*)arg1 + *(const float*)arg2;

	cmp	DWORD PTR op$[rsp], 43			; 0000002bH
	jne	SHORT $LN21@DataTypeAp
	mov	rax, QWORD PTR arg1$[rsp]
	mov	rcx, QWORD PTR arg2$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR output$[rsp]
	movss	DWORD PTR [rax], xmm0
	jmp	SHORT $LN22@DataTypeAp
$LN21@DataTypeAp:

; 1925 : 		else if (op == '-') *(float*)output = *(const float*)arg1 - *(const float*)arg2;

	cmp	DWORD PTR op$[rsp], 45			; 0000002dH
	jne	SHORT $LN23@DataTypeAp
	mov	rax, QWORD PTR arg1$[rsp]
	mov	rcx, QWORD PTR arg2$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR output$[rsp]
	movss	DWORD PTR [rax], xmm0
$LN23@DataTypeAp:
$LN22@DataTypeAp:

; 1926 : 		return;

	jmp	SHORT $LN1@DataTypeAp
$LN24@DataTypeAp:

; 1927 : 	case ImGuiDataType_Double:
; 1928 : 		if (op == '+')      *(double*)output = *(const double*)arg1 + *(const double*)arg2;

	cmp	DWORD PTR op$[rsp], 43			; 0000002bH
	jne	SHORT $LN25@DataTypeAp
	mov	rax, QWORD PTR arg1$[rsp]
	mov	rcx, QWORD PTR arg2$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	addsd	xmm0, QWORD PTR [rcx]
	mov	rax, QWORD PTR output$[rsp]
	movsd	QWORD PTR [rax], xmm0
	jmp	SHORT $LN26@DataTypeAp
$LN25@DataTypeAp:

; 1929 : 		else if (op == '-') *(double*)output = *(const double*)arg1 - *(const double*)arg2;

	cmp	DWORD PTR op$[rsp], 45			; 0000002dH
	jne	SHORT $LN27@DataTypeAp
	mov	rax, QWORD PTR arg1$[rsp]
	mov	rcx, QWORD PTR arg2$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	subsd	xmm0, QWORD PTR [rcx]
	mov	rax, QWORD PTR output$[rsp]
	movsd	QWORD PTR [rax], xmm0
$LN27@DataTypeAp:
$LN26@DataTypeAp:
$LN2@DataTypeAp:
$LN1@DataTypeAp:

; 1930 : 		return;
; 1931 : 	case ImGuiDataType_COUNT: break;
; 1932 : 	}
; 1933 : 	IM_ASSERT(0);
; 1934 : }

	add	rsp, 24
	ret	0
	npad	1
$LN30@DataTypeAp:
	DD	$LN4@DataTypeAp
	DD	$LN8@DataTypeAp
	DD	$LN12@DataTypeAp
	DD	$LN16@DataTypeAp
	DD	$LN20@DataTypeAp
	DD	$LN24@DataTypeAp
?DataTypeApplyOp@@YAXHHPEAX0PEBX@Z ENDP			; DataTypeApplyOp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
buf$ = 48
buf_size$ = 56
data_type$ = 64
data_ptr$ = 72
format$ = 80
?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z PROC		; DataTypeFormatString

; 1888 : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1889 : 	if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)   // Signedness doesn't matter when pushing the argument

	cmp	DWORD PTR data_type$[rsp], 0
	je	SHORT $LN3@DataTypeFo
	cmp	DWORD PTR data_type$[rsp], 1
	jne	SHORT $LN2@DataTypeFo
$LN3@DataTypeFo:

; 1890 : 		return ImFormatString(buf, buf_size, format, *(const ImU32*)data_ptr);

	movsxd	rax, DWORD PTR buf_size$[rsp]
	mov	rcx, QWORD PTR data_ptr$[rsp]
	mov	r9d, DWORD PTR [rcx]
	mov	r8, QWORD PTR format$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR buf$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	jmp	$LN1@DataTypeFo
$LN2@DataTypeFo:

; 1891 : 	if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)   // Signedness doesn't matter when pushing the argument

	cmp	DWORD PTR data_type$[rsp], 2
	je	SHORT $LN5@DataTypeFo
	cmp	DWORD PTR data_type$[rsp], 3
	jne	SHORT $LN4@DataTypeFo
$LN5@DataTypeFo:

; 1892 : 		return ImFormatString(buf, buf_size, format, *(const ImU64*)data_ptr);

	movsxd	rax, DWORD PTR buf_size$[rsp]
	mov	rcx, QWORD PTR data_ptr$[rsp]
	mov	r9, QWORD PTR [rcx]
	mov	r8, QWORD PTR format$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR buf$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	jmp	SHORT $LN1@DataTypeFo
$LN4@DataTypeFo:

; 1893 : 	if (data_type == ImGuiDataType_Float)

	cmp	DWORD PTR data_type$[rsp], 4
	jne	SHORT $LN6@DataTypeFo

; 1894 : 		return ImFormatString(buf, buf_size, format, *(const float*)data_ptr);

	mov	rax, QWORD PTR data_ptr$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax]
	movsxd	rax, DWORD PTR buf_size$[rsp]
	movaps	xmm3, xmm0
	movq	r9, xmm3
	mov	r8, QWORD PTR format$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR buf$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	jmp	SHORT $LN1@DataTypeFo
$LN6@DataTypeFo:

; 1895 : 	if (data_type == ImGuiDataType_Double)

	cmp	DWORD PTR data_type$[rsp], 5
	jne	SHORT $LN7@DataTypeFo

; 1896 : 		return ImFormatString(buf, buf_size, format, *(const double*)data_ptr);

	movsxd	rax, DWORD PTR buf_size$[rsp]
	mov	rcx, QWORD PTR data_ptr$[rsp]
	movsd	xmm3, QWORD PTR [rcx]
	movq	r9, xmm3
	mov	r8, QWORD PTR format$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR buf$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	jmp	SHORT $LN1@DataTypeFo
$LN7@DataTypeFo:

; 1897 : 	IM_ASSERT(0);
; 1898 : 	return 0;

	xor	eax, eax
$LN1@DataTypeFo:

; 1899 : }

	add	rsp, 40					; 00000028H
	ret	0
?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z ENDP		; DataTypeFormatString
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
hovered$ = 64
v_idx$1 = 68
i$2 = 72
t0$3 = 76
style$ = 80
v_min$4 = 88
v_max$5 = 92
n$6 = 96
inv_scale$7 = 100
v1_idx$8 = 104
v_hovered$9 = 108
window$ = 112
frame_bb$ = 120
tv245 = 136
v0$10 = 140
tv304 = 144
tv324 = 148
tv325 = 152
tv329 = 156
tv334 = 160
res_w$11 = 164
item_count$12 = 168
tv379 = 172
col_hovered$13 = 176
col_base$14 = 180
tv426 = 184
t1$15 = 188
tv155 = 192
v$16 = 196
pos1$17 = 200
tv242 = 208
label_size$ = 216
inner_bb$ = 224
t_step$18 = 240
v1$19 = 244
histogram_zero_line_t$20 = 248
id$ = 252
tv235 = 256
tv233 = 260
t$21 = 264
g$ = 272
pos0$22 = 280
tp1$23 = 288
v1$24 = 296
v0$25 = 300
tv370 = 304
tp0$26 = 312
tv145 = 320
tv143 = 328
tv182 = 336
tv276 = 344
tv284 = 352
tv310 = 360
tv351 = 368
$T27 = 376
$T28 = 384
tv416 = 392
tv431 = 400
tv454 = 408
tv452 = 416
total_bb$ = 424
$T29 = 440
$T30 = 448
$T31 = 456
$T32 = 464
$T33 = 472
$T34 = 480
$T35 = 488
$T36 = 496
$T37 = 504
plot_type$ = 528
label$ = 536
values_getter$ = 544
data$ = 552
values_count$ = 560
values_offset$ = 568
overlay_text$ = 576
scale_min$ = 584
scale_max$ = 592
frame_size$ = 600
?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PEBDP6AMPEAXH@Z2HH1MMUImVec2@@@Z PROC ; ImGui::PlotEx

; 5836 : {

$LN51:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 520				; 00000208H

; 5837 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5838 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN8@PlotEx

; 5839 : 		return;

	jmp	$LN1@PlotEx
$LN8@PlotEx:

; 5840 : 
; 5841 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5842 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 5843 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 5844 : 
; 5845 : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	npad	1

; 5846 : 	if (frame_size.x == 0.0f)

	movss	xmm0, DWORD PTR frame_size$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN9@PlotEx
	jne	SHORT $LN9@PlotEx

; 5847 : 		frame_size.x = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movss	DWORD PTR frame_size$[rsp], xmm0
$LN9@PlotEx:

; 5848 : 	if (frame_size.y == 0.0f)

	movss	xmm0, DWORD PTR frame_size$[rsp+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN10@PlotEx
	jne	SHORT $LN10@PlotEx

; 5849 : 		frame_size.y = label_size.y + (style.FramePadding.y * 2);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR frame_size$[rsp+4], xmm0
$LN10@PlotEx:

; 5850 : 
; 5851 : 	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	lea	r8, QWORD PTR frame_size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T29[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 5852 : 	const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);

	mov	rax, QWORD PTR style$[rsp]
	add	rax, 52					; 00000034H
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	lea	rcx, QWORD PTR $T30[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv145[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	add	rax, 52					; 00000034H
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR $T31[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv143[rsp], rax
	mov	r8, QWORD PTR tv145[rsp]
	mov	rdx, QWORD PTR tv143[rsp]
	lea	rcx, QWORD PTR inner_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 5853 : 	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN28@PlotEx
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	addss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR tv155[rsp], xmm0
	jmp	SHORT $LN29@PlotEx
$LN28@PlotEx:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv155[rsp], xmm0
$LN29@PlotEx:
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR tv155[rsp]
	lea	rcx, QWORD PTR $T37[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	lea	rcx, QWORD PTR $T32[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 5854 : 	ItemSize(total_bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 5855 : 	if (!ItemAdd(total_bb, 0, &frame_bb))

	lea	r8, QWORD PTR frame_bb$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@PlotEx

; 5856 : 		return;

	jmp	$LN1@PlotEx
$LN11@PlotEx:

; 5857 : 	const bool hovered = ItemHoverable(frame_bb, id);

	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z ; ImGui::ItemHoverable
	mov	BYTE PTR hovered$[rsp], al

; 5858 : 
; 5859 : 	// Determine scale from values if not specified
; 5860 : 	if (scale_min == FLT_MAX || scale_max == FLT_MAX)

	movss	xmm0, DWORD PTR scale_min$[rsp]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	jp	SHORT $LN50@PlotEx
	je	SHORT $LN13@PlotEx
$LN50@PlotEx:
	movss	xmm0, DWORD PTR scale_max$[rsp]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	jp	$LN12@PlotEx
	jne	$LN12@PlotEx
$LN13@PlotEx:

; 5861 : 	{
; 5862 : 		float v_min = FLT_MAX;

	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR v_min$4[rsp], xmm0

; 5863 : 		float v_max = -FLT_MAX;

	movss	xmm0, DWORD PTR __real@ff7fffff
	movss	DWORD PTR v_max$5[rsp], xmm0

; 5864 : 		for (int i = 0; i < values_count; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN4@PlotEx
$LN2@PlotEx:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN4@PlotEx:
	mov	eax, DWORD PTR values_count$[rsp]
	cmp	DWORD PTR i$2[rsp], eax
	jge	SHORT $LN3@PlotEx

; 5865 : 		{
; 5866 : 			const float v = values_getter(data, i);

	mov	rax, QWORD PTR values_getter$[rsp]
	mov	QWORD PTR tv182[rsp], rax
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	QWORD PTR tv182[rsp]
	movss	DWORD PTR v$16[rsp], xmm0

; 5867 : 			v_min = ImMin(v_min, v);

	movss	xmm1, DWORD PTR v$16[rsp]
	movss	xmm0, DWORD PTR v_min$4[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR v_min$4[rsp], xmm0

; 5868 : 			v_max = ImMax(v_max, v);

	movss	xmm1, DWORD PTR v$16[rsp]
	movss	xmm0, DWORD PTR v_max$5[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR v_max$5[rsp], xmm0

; 5869 : 		}

	jmp	SHORT $LN2@PlotEx
$LN3@PlotEx:

; 5870 : 		if (scale_min == FLT_MAX)

	movss	xmm0, DWORD PTR scale_min$[rsp]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	jp	SHORT $LN14@PlotEx
	jne	SHORT $LN14@PlotEx

; 5871 : 			scale_min = v_min;

	movss	xmm0, DWORD PTR v_min$4[rsp]
	movss	DWORD PTR scale_min$[rsp], xmm0
$LN14@PlotEx:

; 5872 : 		if (scale_max == FLT_MAX)

	movss	xmm0, DWORD PTR scale_max$[rsp]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	jp	SHORT $LN15@PlotEx
	jne	SHORT $LN15@PlotEx

; 5873 : 			scale_max = v_max;

	movss	xmm0, DWORD PTR v_max$5[rsp]
	movss	DWORD PTR scale_max$[rsp], xmm0
$LN15@PlotEx:
$LN12@PlotEx:

; 5874 : 	}
; 5875 : 
; 5876 : 	RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	movss	DWORD PTR tv235[rsp], xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 7
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv233[rsp], eax
	movss	xmm0, DWORD PTR tv235[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	r8d, DWORD PTR tv233[rsp]
	mov	rdx, QWORD PTR frame_bb$[rsp+8]
	mov	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	npad	1

; 5877 : 
; 5878 : 	if (values_count > 0)

	cmp	DWORD PTR values_count$[rsp], 0
	jle	$LN16@PlotEx

; 5879 : 	{
; 5880 : 		int res_w = ImMin((int)frame_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

	cmp	DWORD PTR plot_type$[rsp], 0
	jne	SHORT $LN30@PlotEx
	mov	DWORD PTR tv242[rsp], -1
	jmp	SHORT $LN31@PlotEx
$LN30@PlotEx:
	mov	DWORD PTR tv242[rsp], 0
$LN31@PlotEx:
	cvttss2si eax, DWORD PTR frame_size$[rsp]
	mov	edx, DWORD PTR values_count$[rsp]
	mov	ecx, eax
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	add	eax, DWORD PTR tv242[rsp]
	mov	DWORD PTR res_w$11[rsp], eax

; 5881 : 		int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

	cmp	DWORD PTR plot_type$[rsp], 0
	jne	SHORT $LN32@PlotEx
	mov	DWORD PTR tv245[rsp], -1
	jmp	SHORT $LN33@PlotEx
$LN32@PlotEx:
	mov	DWORD PTR tv245[rsp], 0
$LN33@PlotEx:
	mov	eax, DWORD PTR tv245[rsp]
	mov	ecx, DWORD PTR values_count$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR item_count$12[rsp], eax

; 5882 : 
; 5883 : 		// Tooltip on hover
; 5884 : 		int v_hovered = -1;

	mov	DWORD PTR v_hovered$9[rsp], -1

; 5885 : 		if (hovered && inner_bb.Contains(g.IO.MousePos))

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	$LN17@PlotEx
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	rdx, rax
	lea	rcx, QWORD PTR inner_bb$[rsp]
	call	?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z	; ImRect::Contains
	movzx	eax, al
	test	eax, eax
	je	$LN17@PlotEx

; 5886 : 		{
; 5887 : 			const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+316]
	subss	xmm0, DWORD PTR inner_bb$[rsp]
	movss	xmm1, DWORD PTR inner_bb$[rsp+8]
	subss	xmm1, DWORD PTR inner_bb$[rsp]
	divss	xmm0, xmm1
	movss	xmm2, DWORD PTR __real@3f7ff972
	xorps	xmm1, xmm1
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR t$21[rsp], xmm0

; 5888 : 			const int v_idx = (int)(t * item_count);

	cvtsi2ss xmm0, DWORD PTR item_count$12[rsp]
	movss	xmm1, DWORD PTR t$21[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR v_idx$1[rsp], eax

; 5889 : 			IM_ASSERT(v_idx >= 0 && v_idx < values_count);
; 5890 : 
; 5891 : 			const float v0 = values_getter(data, (v_idx + values_offset) % values_count);

	mov	rax, QWORD PTR values_getter$[rsp]
	mov	QWORD PTR tv276[rsp], rax
	mov	eax, DWORD PTR values_offset$[rsp]
	mov	ecx, DWORD PTR v_idx$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdq
	idiv	DWORD PTR values_count$[rsp]
	mov	eax, edx
	mov	edx, eax
	mov	rcx, QWORD PTR data$[rsp]
	call	QWORD PTR tv276[rsp]
	movss	DWORD PTR v0$10[rsp], xmm0

; 5892 : 			const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);

	mov	rax, QWORD PTR values_getter$[rsp]
	mov	QWORD PTR tv284[rsp], rax
	mov	eax, DWORD PTR v_idx$1[rsp]
	mov	ecx, DWORD PTR values_offset$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	cdq
	idiv	DWORD PTR values_count$[rsp]
	mov	eax, edx
	mov	edx, eax
	mov	rcx, QWORD PTR data$[rsp]
	call	QWORD PTR tv284[rsp]
	movss	DWORD PTR v1$24[rsp], xmm0

; 5893 : 			if (plot_type == ImGuiPlotType_Lines)

	cmp	DWORD PTR plot_type$[rsp], 0
	jne	SHORT $LN18@PlotEx

; 5894 : 				SetTooltip(("%d: %8.4g\n%d: %8.4g"), v_idx, v0, v_idx + 1, v1);

	cvtss2sd xmm0, DWORD PTR v1$24[rsp]
	mov	eax, DWORD PTR v_idx$1[rsp]
	inc	eax
	cvtss2sd xmm1, DWORD PTR v0$10[rsp]
	movsd	QWORD PTR [rsp+32], xmm0
	mov	r9d, eax
	movaps	xmm2, xmm1
	movq	r8, xmm2
	mov	edx, DWORD PTR v_idx$1[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BE@OBCBLNMM@?$CFd?3?5?$CF8?44g?6?$CFd?3?5?$CF8?44g@
	call	?SetTooltip@ImGui@@YAXPEBDZZ		; ImGui::SetTooltip
	npad	1
	jmp	SHORT $LN19@PlotEx
$LN18@PlotEx:

; 5895 : 			else if (plot_type == ImGuiPlotType_Histogram)

	cmp	DWORD PTR plot_type$[rsp], 1
	jne	SHORT $LN20@PlotEx

; 5896 : 				SetTooltip(("%d: %8.4g"), v_idx, v0);

	cvtss2sd xmm0, DWORD PTR v0$10[rsp]
	movaps	xmm2, xmm0
	movq	r8, xmm2
	mov	edx, DWORD PTR v_idx$1[rsp]
	lea	rcx, OFFSET FLAT:??_C@_09OADNPGHP@?$CFd?3?5?$CF8?44g@
	call	?SetTooltip@ImGui@@YAXPEBDZZ		; ImGui::SetTooltip
	npad	1
$LN20@PlotEx:
$LN19@PlotEx:

; 5897 : 			v_hovered = v_idx;

	mov	eax, DWORD PTR v_idx$1[rsp]
	mov	DWORD PTR v_hovered$9[rsp], eax
$LN17@PlotEx:

; 5898 : 		}
; 5899 : 
; 5900 : 		const float t_step = 1.0f / (float)res_w;

	cvtsi2ss xmm0, DWORD PTR res_w$11[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR t_step$18[rsp], xmm0

; 5901 : 		const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));

	movss	xmm0, DWORD PTR scale_min$[rsp]
	ucomiss	xmm0, DWORD PTR scale_max$[rsp]
	jp	SHORT $LN34@PlotEx
	jne	SHORT $LN34@PlotEx
	xorps	xmm0, xmm0
	movss	DWORD PTR tv304[rsp], xmm0
	jmp	SHORT $LN35@PlotEx
$LN34@PlotEx:
	movss	xmm0, DWORD PTR scale_max$[rsp]
	subss	xmm0, DWORD PTR scale_min$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv304[rsp], xmm0
$LN35@PlotEx:
	movss	xmm0, DWORD PTR tv304[rsp]
	movss	DWORD PTR inv_scale$7[rsp], xmm0

; 5902 : 
; 5903 : 		float v0 = values_getter(data, (0 + values_offset) % values_count);

	mov	rax, QWORD PTR values_getter$[rsp]
	mov	QWORD PTR tv310[rsp], rax
	mov	eax, DWORD PTR values_offset$[rsp]
	cdq
	idiv	DWORD PTR values_count$[rsp]
	mov	eax, edx
	mov	edx, eax
	mov	rcx, QWORD PTR data$[rsp]
	call	QWORD PTR tv310[rsp]
	movss	DWORD PTR v0$25[rsp], xmm0

; 5904 : 		float t0 = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR t0$3[rsp], xmm0

; 5905 : 		ImVec2 tp0 = ImVec2(t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale));                       // Point in the normalized space of our target rectangle

	movss	xmm0, DWORD PTR v0$25[rsp]
	subss	xmm0, DWORD PTR scale_min$[rsp]
	mulss	xmm0, DWORD PTR inv_scale$7[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR t0$3[rsp]
	lea	rcx, QWORD PTR tp0$26[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 5906 : 		float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (-scale_min * inv_scale) : (scale_min < 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands

	movss	xmm0, DWORD PTR scale_min$[rsp]
	mulss	xmm0, DWORD PTR scale_max$[rsp]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN38@PlotEx
	movss	xmm0, DWORD PTR scale_min$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR inv_scale$7[rsp]
	movss	DWORD PTR tv325[rsp], xmm0
	jmp	SHORT $LN39@PlotEx
$LN38@PlotEx:
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR scale_min$[rsp]
	jbe	SHORT $LN36@PlotEx
	xorps	xmm0, xmm0
	movss	DWORD PTR tv324[rsp], xmm0
	jmp	SHORT $LN37@PlotEx
$LN36@PlotEx:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv324[rsp], xmm0
$LN37@PlotEx:
	movss	xmm0, DWORD PTR tv324[rsp]
	movss	DWORD PTR tv325[rsp], xmm0
$LN39@PlotEx:
	movss	xmm0, DWORD PTR tv325[rsp]
	movss	DWORD PTR histogram_zero_line_t$20[rsp], xmm0

; 5907 : 
; 5908 : 		const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);

	cmp	DWORD PTR plot_type$[rsp], 0
	jne	SHORT $LN40@PlotEx
	mov	DWORD PTR tv329[rsp], 38		; 00000026H
	jmp	SHORT $LN41@PlotEx
$LN40@PlotEx:
	mov	DWORD PTR tv329[rsp], 40		; 00000028H
$LN41@PlotEx:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv329[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR col_base$14[rsp], eax

; 5909 : 		const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);

	cmp	DWORD PTR plot_type$[rsp], 0
	jne	SHORT $LN42@PlotEx
	mov	DWORD PTR tv334[rsp], 39		; 00000027H
	jmp	SHORT $LN43@PlotEx
$LN42@PlotEx:
	mov	DWORD PTR tv334[rsp], 41		; 00000029H
$LN43@PlotEx:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv334[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR col_hovered$13[rsp], eax

; 5910 : 
; 5911 : 		for (int n = 0; n < res_w; n++)

	mov	DWORD PTR n$6[rsp], 0
	jmp	SHORT $LN7@PlotEx
$LN5@PlotEx:
	mov	eax, DWORD PTR n$6[rsp]
	inc	eax
	mov	DWORD PTR n$6[rsp], eax
$LN7@PlotEx:
	mov	eax, DWORD PTR res_w$11[rsp]
	cmp	DWORD PTR n$6[rsp], eax
	jge	$LN6@PlotEx

; 5912 : 		{
; 5913 : 			const float t1 = t0 + t_step;

	movss	xmm0, DWORD PTR t0$3[rsp]
	addss	xmm0, DWORD PTR t_step$18[rsp]
	movss	DWORD PTR t1$15[rsp], xmm0

; 5914 : 			const int v1_idx = (int)(t0 * item_count + 0.5f);

	cvtsi2ss xmm0, DWORD PTR item_count$12[rsp]
	movss	xmm1, DWORD PTR t0$3[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR v1_idx$8[rsp], eax

; 5915 : 			IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);
; 5916 : 			const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);

	mov	rax, QWORD PTR values_getter$[rsp]
	mov	QWORD PTR tv351[rsp], rax
	mov	eax, DWORD PTR v1_idx$8[rsp]
	mov	ecx, DWORD PTR values_offset$[rsp]
	lea	eax, DWORD PTR [rax+rcx+1]
	cdq
	idiv	DWORD PTR values_count$[rsp]
	mov	eax, edx
	mov	edx, eax
	mov	rcx, QWORD PTR data$[rsp]
	call	QWORD PTR tv351[rsp]
	movss	DWORD PTR v1$19[rsp], xmm0

; 5917 : 			const ImVec2 tp1 = ImVec2(t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale));

	movss	xmm0, DWORD PTR v1$19[rsp]
	subss	xmm0, DWORD PTR scale_min$[rsp]
	mulss	xmm0, DWORD PTR inv_scale$7[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR t1$15[rsp]
	lea	rcx, QWORD PTR tp1$23[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 5918 : 
; 5919 : 			// NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.
; 5920 : 			ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);

	lea	r9, QWORD PTR tp0$26[rsp]
	lea	r8, QWORD PTR inner_bb$[rsp+8]
	lea	rdx, QWORD PTR inner_bb$[rsp]
	lea	rcx, QWORD PTR pos0$22[rsp]
	call	?ImLerp@@YA?AUImVec2@@AEBU1@00@Z	; ImLerp
	npad	1

; 5921 : 			ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));

	cmp	DWORD PTR plot_type$[rsp], 0
	jne	SHORT $LN44@PlotEx
	mov	rax, QWORD PTR tp1$23[rsp]
	mov	QWORD PTR $T27[rsp], rax
	lea	rax, QWORD PTR $T27[rsp]
	mov	QWORD PTR tv370[rsp], rax
	jmp	SHORT $LN45@PlotEx
$LN44@PlotEx:
	movss	xmm2, DWORD PTR histogram_zero_line_t$20[rsp]
	movss	xmm1, DWORD PTR tp1$23[rsp]
	lea	rcx, QWORD PTR $T33[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv370[rsp], rax
$LN45@PlotEx:
	mov	rax, QWORD PTR tv370[rsp]
	mov	QWORD PTR $T28[rsp], rax
	mov	r9, QWORD PTR $T28[rsp]
	lea	r8, QWORD PTR inner_bb$[rsp+8]
	lea	rdx, QWORD PTR inner_bb$[rsp]
	lea	rcx, QWORD PTR pos1$17[rsp]
	call	?ImLerp@@YA?AUImVec2@@AEBU1@00@Z	; ImLerp
	npad	1

; 5922 : 			if (plot_type == ImGuiPlotType_Lines)

	cmp	DWORD PTR plot_type$[rsp], 0
	jne	SHORT $LN21@PlotEx

; 5923 : 			{
; 5924 : 				window->DrawList->AddLine(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv416[rsp], rax
	mov	eax, DWORD PTR v1_idx$8[rsp]
	cmp	DWORD PTR v_hovered$9[rsp], eax
	jne	SHORT $LN46@PlotEx
	mov	eax, DWORD PTR col_hovered$13[rsp]
	mov	DWORD PTR tv379[rsp], eax
	jmp	SHORT $LN47@PlotEx
$LN46@PlotEx:
	mov	eax, DWORD PTR col_base$14[rsp]
	mov	DWORD PTR tv379[rsp], eax
$LN47@PlotEx:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv379[rsp]
	lea	r8, QWORD PTR pos1$17[rsp]
	lea	rdx, QWORD PTR pos0$22[rsp]
	mov	rcx, QWORD PTR tv416[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 5925 : 			}

	jmp	$LN22@PlotEx
$LN21@PlotEx:

; 5926 : 			else if (plot_type == ImGuiPlotType_Histogram)

	cmp	DWORD PTR plot_type$[rsp], 1
	jne	$LN23@PlotEx

; 5927 : 			{
; 5928 : 				if (pos1.x >= pos0.x + 2.0f)

	movss	xmm0, DWORD PTR pos0$22[rsp]
	addss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR pos1$17[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN24@PlotEx

; 5929 : 					pos1.x -= 1.0f;

	movss	xmm0, DWORD PTR pos1$17[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR pos1$17[rsp], xmm0
$LN24@PlotEx:

; 5930 : 				window->DrawList->AddRectFilled(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv431[rsp], rax
	mov	eax, DWORD PTR v1_idx$8[rsp]
	cmp	DWORD PTR v_hovered$9[rsp], eax
	jne	SHORT $LN48@PlotEx
	mov	eax, DWORD PTR col_hovered$13[rsp]
	mov	DWORD PTR tv426[rsp], eax
	jmp	SHORT $LN49@PlotEx
$LN48@PlotEx:
	mov	eax, DWORD PTR col_base$14[rsp]
	mov	DWORD PTR tv426[rsp], eax
$LN49@PlotEx:
	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv426[rsp]
	lea	r8, QWORD PTR pos1$17[rsp]
	lea	rdx, QWORD PTR pos0$22[rsp]
	mov	rcx, QWORD PTR tv431[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1
$LN23@PlotEx:
$LN22@PlotEx:

; 5931 : 			}
; 5932 : 
; 5933 : 			t0 = t1;

	movss	xmm0, DWORD PTR t1$15[rsp]
	movss	DWORD PTR t0$3[rsp], xmm0

; 5934 : 			tp0 = tp1;

	mov	rax, QWORD PTR tp1$23[rsp]
	mov	QWORD PTR tp0$26[rsp], rax

; 5935 : 		}

	jmp	$LN5@PlotEx
$LN6@PlotEx:
$LN16@PlotEx:

; 5936 : 	}
; 5937 : 
; 5938 : 	// Text overlay
; 5939 : 	if (overlay_text)

	cmp	QWORD PTR overlay_text$[rsp], 0
	je	$LN25@PlotEx

; 5940 : 		RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f, 0.0f));

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T34[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv454[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR frame_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR $T35[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv452[rsp], rax
	mov	QWORD PTR [rsp+48], 0
	mov	rax, QWORD PTR tv454[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR overlay_text$[rsp]
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	mov	rcx, QWORD PTR tv452[rsp]
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
	npad	1
$LN25@PlotEx:

; 5941 : 
; 5942 : 	if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN26@PlotEx

; 5943 : 		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR frame_bb$[rsp+8]
	addss	xmm0, DWORD PTR [rax+76]
	movss	xmm2, DWORD PTR inner_bb$[rsp+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T36[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN26@PlotEx:
$LN1@PlotEx:

; 5944 : }

	add	rsp, 520				; 00000208H
	ret	0
?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PEBDP6AMPEAXH@Z2HH1MMUImVec2@@@Z ENDP ; ImGui::PlotEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
allow_opt_picker$ = 32
allow_opt_alpha_bar$ = 33
picker_type$1 = 36
picker_flags$2 = 40
g$ = 48
tv66 = 56
tv72 = 60
tv166 = 64
tv90 = 68
tv137 = 72
tv135 = 76
picker_size$3 = 80
backup_pos$4 = 88
dummy_ref_col$5 = 96
ref_col$ = 128
flags$ = 136
?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z PROC		; ImGui::ColorPickerOptionsPopup

; 5160 : {

$LN22:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 5161 : 	bool allow_opt_picker = !(flags & ImGuiColorEditFlags__PickerMask);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 100663296				; 06000000H
	test	eax, eax
	jne	SHORT $LN16@ColorPicke
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN17@ColorPicke
$LN16@ColorPicke:
	mov	DWORD PTR tv66[rsp], 0
$LN17@ColorPicke:
	movzx	eax, BYTE PTR tv66[rsp]
	mov	BYTE PTR allow_opt_picker$[rsp], al

; 5162 : 	bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN18@ColorPicke
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 65536				; 00010000H
	test	eax, eax
	jne	SHORT $LN18@ColorPicke
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN19@ColorPicke
$LN18@ColorPicke:
	mov	DWORD PTR tv72[rsp], 0
$LN19@ColorPicke:
	movzx	eax, BYTE PTR tv72[rsp]
	mov	BYTE PTR allow_opt_alpha_bar$[rsp], al

; 5163 : 	if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup(("context")))

	movzx	eax, BYTE PTR allow_opt_picker$[rsp]
	test	eax, eax
	jne	SHORT $LN7@ColorPicke
	movzx	eax, BYTE PTR allow_opt_alpha_bar$[rsp]
	test	eax, eax
	je	SHORT $LN6@ColorPicke
$LN7@ColorPicke:
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	call	?BeginPopup@ImGui@@YA_NPEBDH@Z		; ImGui::BeginPopup
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@ColorPicke
$LN6@ColorPicke:

; 5164 : 		return;

	jmp	$LN1@ColorPicke
$LN5@ColorPicke:

; 5165 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5166 : 	if (allow_opt_picker)

	movzx	eax, BYTE PTR allow_opt_picker$[rsp]
	test	eax, eax
	je	$LN8@ColorPicke

; 5167 : 	{
; 5168 : 		ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR tv90[rsp], xmm0
	call	?GetFrameHeight@ImGui@@YAMXZ		; ImGui::GetFrameHeight
	mov	rax, QWORD PTR g$[rsp]
	addss	xmm0, DWORD PTR [rax+5548]
	movss	xmm1, DWORD PTR tv90[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR tv137[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR tv135[rsp], xmm0
	movss	xmm2, DWORD PTR tv137[rsp]
	movss	xmm1, DWORD PTR tv135[rsp]
	lea	rcx, QWORD PTR picker_size$3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 5169 : 		PushItemWidth(picker_size.x);

	movss	xmm0, DWORD PTR picker_size$3[rsp]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	npad	1

; 5170 : 		for (int picker_type = 0; picker_type < 2; picker_type++)

	mov	DWORD PTR picker_type$1[rsp], 0
	jmp	SHORT $LN4@ColorPicke
$LN2@ColorPicke:
	mov	eax, DWORD PTR picker_type$1[rsp]
	inc	eax
	mov	DWORD PTR picker_type$1[rsp], eax
$LN4@ColorPicke:
	cmp	DWORD PTR picker_type$1[rsp], 2
	jge	$LN3@ColorPicke

; 5171 : 		{
; 5172 : 			// Draw small/thumbnail version of each picker type (over an invisible button for selection)
; 5173 : 			if (picker_type > 0) Separator();

	cmp	DWORD PTR picker_type$1[rsp], 0
	jle	SHORT $LN9@ColorPicke
	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator
	npad	1
$LN9@ColorPicke:

; 5174 : 			PushID(picker_type);

	mov	ecx, DWORD PTR picker_type$1[rsp]
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 5175 : 			ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_NoSidePreview | (flags & ImGuiColorEditFlags_NoAlpha);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	or	eax, 424				; 000001a8H
	mov	DWORD PTR picker_flags$2[rsp], eax

; 5176 : 			if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;

	cmp	DWORD PTR picker_type$1[rsp], 0
	jne	SHORT $LN10@ColorPicke
	mov	eax, DWORD PTR picker_flags$2[rsp]
	bts	eax, 25
	mov	DWORD PTR picker_flags$2[rsp], eax
$LN10@ColorPicke:

; 5177 : 			if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;

	cmp	DWORD PTR picker_type$1[rsp], 1
	jne	SHORT $LN11@ColorPicke
	mov	eax, DWORD PTR picker_flags$2[rsp]
	bts	eax, 26
	mov	DWORD PTR picker_flags$2[rsp], eax
$LN11@ColorPicke:

; 5178 : 			ImVec2 backup_pos = GetCursorScreenPos();

	lea	rcx, QWORD PTR backup_pos$4[rsp]
	call	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetCursorScreenPos
	npad	1

; 5179 : 			if (Selectable(("##+-selectable"), false, 0, picker_size)) // By default, Selectable() is closing popup

	lea	r9, QWORD PTR picker_size$3[rsp]
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_0P@OGDNCJGJ@?$CD?$CD?$CL?9selectable@
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@ColorPicke

; 5180 : 				g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags__PickerMask) | (picker_flags & ImGuiColorEditFlags__PickerMask);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+11676]
	and	eax, -100663297				; fffffffff9ffffffH
	mov	ecx, DWORD PTR picker_flags$2[rsp]
	and	ecx, 100663296				; 06000000H
	or	eax, ecx
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+11676], eax
$LN12@ColorPicke:

; 5181 : 			SetCursorScreenPos(backup_pos);

	lea	rcx, QWORD PTR backup_pos$4[rsp]
	call	?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z ; ImGui::SetCursorScreenPos

; 5182 : 			ImVec4 dummy_ref_col;

	lea	rcx, QWORD PTR dummy_ref_col$5[rsp]
	call	??0ImVec4@@QEAA@XZ			; ImVec4::ImVec4

; 5183 : 			memcpy(&dummy_ref_col, ref_col, sizeof(float) * ((picker_flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4));

	mov	eax, DWORD PTR picker_flags$2[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN20@ColorPicke
	mov	DWORD PTR tv166[rsp], 3
	jmp	SHORT $LN21@ColorPicke
$LN20@ColorPicke:
	mov	DWORD PTR tv166[rsp], 4
$LN21@ColorPicke:
	movsxd	rax, DWORD PTR tv166[rsp]
	shl	rax, 2
	mov	r8, rax
	mov	rdx, QWORD PTR ref_col$[rsp]
	lea	rcx, QWORD PTR dummy_ref_col$5[rsp]
	call	memcpy

; 5184 : 			ColorPicker4(("##+-dummypicker"), &dummy_ref_col.x, picker_flags);

	xor	r9d, r9d
	mov	r8d, DWORD PTR picker_flags$2[rsp]
	lea	rdx, QWORD PTR dummy_ref_col$5[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BA@PODNGMKL@?$CD?$CD?$CL?9dummypicker@
	call	?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z ; ImGui::ColorPicker4

; 5185 : 			PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	npad	1

; 5186 : 		}

	jmp	$LN2@ColorPicke
$LN3@ColorPicke:

; 5187 : 		PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	npad	1
$LN8@ColorPicke:

; 5188 : 	}
; 5189 : 	if (allow_opt_alpha_bar)

	movzx	eax, BYTE PTR allow_opt_alpha_bar$[rsp]
	test	eax, eax
	je	SHORT $LN13@ColorPicke

; 5190 : 	{
; 5191 : 		if (allow_opt_picker) Separator();

	movzx	eax, BYTE PTR allow_opt_picker$[rsp]
	test	eax, eax
	je	SHORT $LN14@ColorPicke
	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator
	npad	1
$LN14@ColorPicke:

; 5192 : 		CheckboxFlags(("Alpha Bar"), (unsigned int*)&g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 11676				; 00002d9cH
	mov	r8d, 65536				; 00010000H
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_09KEDLMDJL@Alpha?5Bar@
	call	?CheckboxFlags@ImGui@@YA_NPEBDPEAII@Z	; ImGui::CheckboxFlags
	npad	1
$LN13@ColorPicke:

; 5193 : 	}
; 5194 : 	EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	npad	1
$LN1@ColorPicke:

; 5195 : }

	add	rsp, 120				; 00000078H
	ret	0
?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z ENDP		; ImGui::ColorPickerOptionsPopup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
allow_opt_inputs$ = 64
opts$ = 68
allow_opt_datatype$ = 72
tv87 = 73
tv129 = 74
tv139 = 75
tv153 = 76
tv163 = 77
cb$1 = 80
cg$2 = 84
cr$3 = 88
tv66 = 92
tv70 = 96
tv223 = 100
tv229 = 104
ca$4 = 108
g$ = 112
$T5 = 120
$T6 = 128
$T7 = 136
$T8 = 144
buf$9 = 160
__$ArrayPad$ = 224
col$ = 256
flags$ = 264
?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z PROC		; ImGui::ColorEditOptionsPopup

; 5112 : {

$LN41:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 248				; 000000f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5113 : 	bool allow_opt_inputs = !(flags & ImGuiColorEditFlags__InputsMask);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 7340032				; 00700000H
	test	eax, eax
	jne	SHORT $LN23@ColorEditO
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN24@ColorEditO
$LN23@ColorEditO:
	mov	DWORD PTR tv66[rsp], 0
$LN24@ColorEditO:
	movzx	eax, BYTE PTR tv66[rsp]
	mov	BYTE PTR allow_opt_inputs$[rsp], al

; 5114 : 	bool allow_opt_datatype = !(flags & ImGuiColorEditFlags__DataTypeMask);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 25165824				; 01800000H
	test	eax, eax
	jne	SHORT $LN25@ColorEditO
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN26@ColorEditO
$LN25@ColorEditO:
	mov	DWORD PTR tv70[rsp], 0
$LN26@ColorEditO:
	movzx	eax, BYTE PTR tv70[rsp]
	mov	BYTE PTR allow_opt_datatype$[rsp], al

; 5115 : 	if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context"))

	movzx	eax, BYTE PTR allow_opt_inputs$[rsp]
	test	eax, eax
	jne	SHORT $LN4@ColorEditO
	movzx	eax, BYTE PTR allow_opt_datatype$[rsp]
	test	eax, eax
	je	SHORT $LN3@ColorEditO
$LN4@ColorEditO:
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	call	?BeginPopup@ImGui@@YA_NPEBDH@Z		; ImGui::BeginPopup
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@ColorEditO
$LN3@ColorEditO:

; 5116 : 		return;

	jmp	$LN1@ColorEditO
$LN2@ColorEditO:

; 5117 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5118 : 	ImGuiColorEditFlags opts = g.ColorEditOptions;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+11676]
	mov	DWORD PTR opts$[rsp], eax

; 5119 : 	if (allow_opt_inputs)

	movzx	eax, BYTE PTR allow_opt_inputs$[rsp]
	test	eax, eax
	je	$LN5@ColorEditO

; 5120 : 	{
; 5121 : 		if (RadioButton(("RGB"), (opts & ImGuiColorEditFlags_RGB) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_RGB;

	mov	eax, DWORD PTR opts$[rsp]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	je	SHORT $LN27@ColorEditO
	mov	BYTE PTR tv87[rsp], 1
	jmp	SHORT $LN28@ColorEditO
$LN27@ColorEditO:
	mov	BYTE PTR tv87[rsp], 0
$LN28@ColorEditO:
	movzx	edx, BYTE PTR tv87[rsp]
	lea	rcx, OFFSET FLAT:??_C@_03ICFFBAI@RGB@
	call	?RadioButton@ImGui@@YA_NPEBD_N@Z	; ImGui::RadioButton
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@ColorEditO
	mov	eax, DWORD PTR opts$[rsp]
	and	eax, -7340033				; ffffffffff8fffffH
	bts	eax, 20
	mov	DWORD PTR opts$[rsp], eax
$LN6@ColorEditO:

; 5122 : 		if (RadioButton(("HSV"), (opts & ImGuiColorEditFlags_HSV) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HSV;

	mov	eax, DWORD PTR opts$[rsp]
	and	eax, 2097152				; 00200000H
	test	eax, eax
	je	SHORT $LN29@ColorEditO
	mov	BYTE PTR tv129[rsp], 1
	jmp	SHORT $LN30@ColorEditO
$LN29@ColorEditO:
	mov	BYTE PTR tv129[rsp], 0
$LN30@ColorEditO:
	movzx	edx, BYTE PTR tv129[rsp]
	lea	rcx, OFFSET FLAT:??_C@_03CAADKAK@HSV@
	call	?RadioButton@ImGui@@YA_NPEBD_N@Z	; ImGui::RadioButton
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@ColorEditO
	mov	eax, DWORD PTR opts$[rsp]
	and	eax, -7340033				; ffffffffff8fffffH
	bts	eax, 21
	mov	DWORD PTR opts$[rsp], eax
$LN7@ColorEditO:

; 5123 : 		if (RadioButton(("HEX"), (opts & ImGuiColorEditFlags_HEX) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HEX;

	mov	eax, DWORD PTR opts$[rsp]
	and	eax, 4194304				; 00400000H
	test	eax, eax
	je	SHORT $LN31@ColorEditO
	mov	BYTE PTR tv139[rsp], 1
	jmp	SHORT $LN32@ColorEditO
$LN31@ColorEditO:
	mov	BYTE PTR tv139[rsp], 0
$LN32@ColorEditO:
	movzx	edx, BYTE PTR tv139[rsp]
	lea	rcx, OFFSET FLAT:??_C@_03IECIMIEG@HEX@
	call	?RadioButton@ImGui@@YA_NPEBD_N@Z	; ImGui::RadioButton
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@ColorEditO
	mov	eax, DWORD PTR opts$[rsp]
	and	eax, -7340033				; ffffffffff8fffffH
	bts	eax, 22
	mov	DWORD PTR opts$[rsp], eax
$LN8@ColorEditO:
$LN5@ColorEditO:

; 5124 : 	}
; 5125 : 	if (allow_opt_datatype)

	movzx	eax, BYTE PTR allow_opt_datatype$[rsp]
	test	eax, eax
	je	$LN9@ColorEditO

; 5126 : 	{
; 5127 : 		if (allow_opt_inputs) Separator();

	movzx	eax, BYTE PTR allow_opt_inputs$[rsp]
	test	eax, eax
	je	SHORT $LN10@ColorEditO
	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator
	npad	1
$LN10@ColorEditO:

; 5128 : 		if (RadioButton(("0..255"), (opts & ImGuiColorEditFlags_Uint8) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Uint8;

	mov	eax, DWORD PTR opts$[rsp]
	and	eax, 8388608				; 00800000H
	test	eax, eax
	je	SHORT $LN33@ColorEditO
	mov	BYTE PTR tv153[rsp], 1
	jmp	SHORT $LN34@ColorEditO
$LN33@ColorEditO:
	mov	BYTE PTR tv153[rsp], 0
$LN34@ColorEditO:
	movzx	edx, BYTE PTR tv153[rsp]
	lea	rcx, OFFSET FLAT:??_C@_06FDBEKFBH@0?4?4255@
	call	?RadioButton@ImGui@@YA_NPEBD_N@Z	; ImGui::RadioButton
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@ColorEditO
	mov	eax, DWORD PTR opts$[rsp]
	and	eax, -25165825				; fffffffffe7fffffH
	bts	eax, 23
	mov	DWORD PTR opts$[rsp], eax
$LN11@ColorEditO:

; 5129 : 		if (RadioButton(("0.00..1.00"), (opts & ImGuiColorEditFlags_Float) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Float;

	mov	eax, DWORD PTR opts$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN35@ColorEditO
	mov	BYTE PTR tv163[rsp], 1
	jmp	SHORT $LN36@ColorEditO
$LN35@ColorEditO:
	mov	BYTE PTR tv163[rsp], 0
$LN36@ColorEditO:
	movzx	edx, BYTE PTR tv163[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0L@MDNPBJBM@0?400?4?41?400@
	call	?RadioButton@ImGui@@YA_NPEBD_N@Z	; ImGui::RadioButton
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@ColorEditO
	mov	eax, DWORD PTR opts$[rsp]
	and	eax, -25165825				; fffffffffe7fffffH
	bts	eax, 24
	mov	DWORD PTR opts$[rsp], eax
$LN12@ColorEditO:
$LN9@ColorEditO:

; 5130 : 	}
; 5131 : 
; 5132 : 	if (allow_opt_inputs || allow_opt_datatype)

	movzx	eax, BYTE PTR allow_opt_inputs$[rsp]
	test	eax, eax
	jne	SHORT $LN14@ColorEditO
	movzx	eax, BYTE PTR allow_opt_datatype$[rsp]
	test	eax, eax
	je	SHORT $LN13@ColorEditO
$LN14@ColorEditO:

; 5133 : 		Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator
	npad	1
$LN13@ColorEditO:

; 5134 : 	if (Button(("Copy as.."), ImVec2(-1, 0)))

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@bf800000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_09NMCCFHEI@Copy?5as?4?4@
	call	?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z	; ImGui::Button
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@ColorEditO

; 5135 : 		OpenPopup(("Copy"));

	lea	rcx, OFFSET FLAT:??_C@_04OPMHGHMB@Copy@
	call	?OpenPopup@ImGui@@YAXPEBD@Z		; ImGui::OpenPopup
	npad	1
$LN15@ColorEditO:

; 5136 : 	if (BeginPopup(("Copy")))

	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_04OPMHGHMB@Copy@
	call	?BeginPopup@ImGui@@YA_NPEBDH@Z		; ImGui::BeginPopup
	movzx	eax, al
	test	eax, eax
	je	$LN16@ColorEditO

; 5137 : 	{
; 5138 : 		int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR cr$3[rsp], eax
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR cg$2[rsp], eax
	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR cb$1[rsp], eax
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN37@ColorEditO
	mov	DWORD PTR tv223[rsp], 255		; 000000ffH
	jmp	SHORT $LN38@ColorEditO
$LN37@ColorEditO:
	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR tv223[rsp], eax
$LN38@ColorEditO:
	mov	eax, DWORD PTR tv223[rsp]
	mov	DWORD PTR ca$4[rsp], eax

; 5139 : 		char buf[64];
; 5140 : 		ImFormatString(buf, IM_ARRAYSIZE(buf), ("(%.3ff, %.3ff, %.3ff, %.3ff)"), col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN39@ColorEditO
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv229[rsp], xmm0
	jmp	SHORT $LN40@ColorEditO
$LN39@ColorEditO:
	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR tv229[rsp], xmm0
$LN40@ColorEditO:
	cvtss2sd xmm0, DWORD PTR tv229[rsp]
	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR col$[rsp]
	cvtss2sd xmm1, DWORD PTR [rcx+rax]
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR col$[rsp]
	cvtss2sd xmm2, DWORD PTR [rcx+rax]
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR col$[rsp]
	cvtss2sd xmm3, DWORD PTR [rcx+rax]
	movsd	QWORD PTR [rsp+48], xmm0
	movsd	QWORD PTR [rsp+40], xmm1
	movsd	QWORD PTR [rsp+32], xmm2
	movq	r9, xmm3
	lea	r8, OFFSET FLAT:??_C@_0BN@GKCJMPCH@?$CI?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?$CJ@
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR buf$9[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1

; 5141 : 		if (Selectable(buf))

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9, rax
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR buf$9[rsp]
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@ColorEditO

; 5142 : 			SetClipboardText(buf);

	lea	rcx, QWORD PTR buf$9[rsp]
	call	?SetClipboardText@ImGui@@YAXPEBD@Z	; ImGui::SetClipboardText
	npad	1
$LN17@ColorEditO:

; 5143 : 		ImFormatString(buf, IM_ARRAYSIZE(buf), ("(%d,%d,%d,%d)"), cr, cg, cb, ca);

	mov	eax, DWORD PTR ca$4[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR cb$1[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR cg$2[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR cr$3[rsp]
	lea	r8, OFFSET FLAT:??_C@_0O@EJHNAHBL@?$CI?$CFd?0?$CFd?0?$CFd?0?$CFd?$CJ@
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR buf$9[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1

; 5144 : 		if (Selectable(buf))

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9, rax
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR buf$9[rsp]
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@ColorEditO

; 5145 : 			SetClipboardText(buf);

	lea	rcx, QWORD PTR buf$9[rsp]
	call	?SetClipboardText@ImGui@@YAXPEBD@Z	; ImGui::SetClipboardText
	npad	1
$LN18@ColorEditO:

; 5146 : 		if (flags & ImGuiColorEditFlags_NoAlpha)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN19@ColorEditO

; 5147 : 			ImFormatString(buf, IM_ARRAYSIZE(buf), ("0x%02X%02X%02X"), cr, cg, cb);

	mov	eax, DWORD PTR cb$1[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR cg$2[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR cr$3[rsp]
	lea	r8, OFFSET FLAT:??_C@_0P@GDANBODO@0x?$CF02X?$CF02X?$CF02X@
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR buf$9[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
	jmp	SHORT $LN20@ColorEditO
$LN19@ColorEditO:

; 5148 : 		else
; 5149 : 			ImFormatString(buf, IM_ARRAYSIZE(buf), ("0x%02X%02X%02X%02X"), cr, cg, cb, ca);

	mov	eax, DWORD PTR ca$4[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR cb$1[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR cg$2[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR cr$3[rsp]
	lea	r8, OFFSET FLAT:??_C@_0BD@MLNOPBDA@0x?$CF02X?$CF02X?$CF02X?$CF02X@
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR buf$9[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
$LN20@ColorEditO:

; 5150 : 		if (Selectable(buf))

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9, rax
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR buf$9[rsp]
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@ColorEditO

; 5151 : 			SetClipboardText(buf);

	lea	rcx, QWORD PTR buf$9[rsp]
	call	?SetClipboardText@ImGui@@YAXPEBD@Z	; ImGui::SetClipboardText
	npad	1
$LN21@ColorEditO:

; 5152 : 		EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	npad	1
$LN16@ColorEditO:

; 5153 : 	}
; 5154 : 
; 5155 : 	g.ColorEditOptions = opts;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR opts$[rsp]
	mov	DWORD PTR [rax+11676], ecx

; 5156 : 	EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	npad	1
$LN1@ColorEditO:

; 5157 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 248				; 000000f8H
	ret	0
?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z ENDP		; ImGui::ColorEditOptionsPopup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
cb$ = 112
cg$ = 116
cr$ = 120
tv130 = 124
ca$ = 128
g$ = 136
tv137 = 144
text_end$ = 152
sz$ = 160
$T1 = 168
tv180 = 176
$T2 = 184
text$ = 224
col$ = 232
flags$ = 240
?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z PROC		; ImGui::ColorTooltip

; 5088 : {

$LN10:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H

; 5089 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5090 : 
; 5091 : 	int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR cr$[rsp], eax
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR cg$[rsp], eax
	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR cb$[rsp], eax
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN6@ColorToolt
	mov	DWORD PTR tv130[rsp], 255		; 000000ffH
	jmp	SHORT $LN7@ColorToolt
$LN6@ColorToolt:
	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR tv130[rsp], eax
$LN7@ColorToolt:
	mov	eax, DWORD PTR tv130[rsp]
	mov	DWORD PTR ca$[rsp], eax

; 5092 : 	BeginTooltipEx(0, true);

	mov	dl, 1
	xor	ecx, ecx
	call	?BeginTooltipEx@ImGui@@YAXH_N@Z		; ImGui::BeginTooltipEx

; 5093 : 
; 5094 : 	const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;

	cmp	QWORD PTR text$[rsp], 0
	je	SHORT $LN8@ColorToolt
	xor	edx, edx
	mov	rcx, QWORD PTR text$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	QWORD PTR tv137[rsp], rax
	jmp	SHORT $LN9@ColorToolt
$LN8@ColorToolt:
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR tv137[rsp], rax
$LN9@ColorToolt:
	mov	rax, QWORD PTR tv137[rsp]
	mov	QWORD PTR text_end$[rsp], rax

; 5095 : 	if (text_end > text)

	mov	rax, QWORD PTR text$[rsp]
	cmp	QWORD PTR text_end$[rsp], rax
	jbe	SHORT $LN2@ColorToolt

; 5096 : 	{
; 5097 : 		TextUnformatted(text, text_end);

	mov	rdx, QWORD PTR text_end$[rsp]
	mov	rcx, QWORD PTR text$[rsp]
	call	?TextUnformatted@ImGui@@YAXPEBD0@Z	; ImGui::TextUnformatted

; 5098 : 		Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator
	npad	1
$LN2@ColorToolt:

; 5099 : 	}
; 5100 : 
; 5101 : 	ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@40400000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5528]
	mulss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	mulss	xmm1, DWORD PTR __real@40400000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR [rax+5528]
	mulss	xmm2, DWORD PTR __real@40000000
	addss	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR sz$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 5102 : 	ColorButton(("##+-preview"), ImVec4(col[0], col[1], col[2], col[3]), (flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);

	mov	rax, QWORD PTR sz$[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	eax, 4
	imul	rax, rax, 3
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 4
	imul	rdx, rdx, 1
	mov	r8d, 4
	imul	r8, r8, 0
	mov	r9, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [r9+rax]
	movss	DWORD PTR [rsp+32], xmm0
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm3, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm2, DWORD PTR [rax+rdx]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm1, DWORD PTR [rax+r8]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	QWORD PTR tv180[rsp], rax
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 393218				; 00060002H
	or	eax, 64					; 00000040H
	mov	r9, QWORD PTR $T1[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR tv180[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0M@KBLIMBPK@?$CD?$CD?$CL?9preview@
	call	?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z ; ImGui::ColorButton
	npad	1

; 5103 : 	SameLine(100);

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@bf800000
	movss	xmm0, DWORD PTR __real@42c80000
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1

; 5104 : 	if (flags & ImGuiColorEditFlags_NoAlpha)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	$LN3@ColorToolt

; 5105 : 		Text(("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)"), cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR col$[rsp]
	cvtss2sd xmm0, DWORD PTR [rcx+rax]
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR col$[rsp]
	cvtss2sd xmm1, DWORD PTR [rcx+rax]
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR col$[rsp]
	cvtss2sd xmm2, DWORD PTR [rcx+rax]
	movsd	QWORD PTR [rsp+72], xmm0
	movsd	QWORD PTR [rsp+64], xmm1
	movsd	QWORD PTR [rsp+56], xmm2
	mov	eax, DWORD PTR cb$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR cg$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR cr$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR cb$[rsp]
	mov	r8d, DWORD PTR cg$[rsp]
	mov	edx, DWORD PTR cr$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0DF@FAPNKOHO@?$CD?$CF02X?$CF02X?$CF02X?6R?3?5?$CFd?0?5G?3?5?$CFd?0?5B?3?5@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1
	jmp	$LN4@ColorToolt
$LN3@ColorToolt:

; 5106 : 	else
; 5107 : 		Text(("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)"), cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR col$[rsp]
	cvtss2sd xmm0, DWORD PTR [rcx+rax]
	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR col$[rsp]
	cvtss2sd xmm1, DWORD PTR [rcx+rax]
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR col$[rsp]
	cvtss2sd xmm2, DWORD PTR [rcx+rax]
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR col$[rsp]
	cvtss2sd xmm3, DWORD PTR [rcx+rax]
	movsd	QWORD PTR [rsp+96], xmm0
	movsd	QWORD PTR [rsp+88], xmm1
	movsd	QWORD PTR [rsp+80], xmm2
	movsd	QWORD PTR [rsp+72], xmm3
	mov	eax, DWORD PTR ca$[rsp]
	mov	DWORD PTR [rsp+64], eax
	mov	eax, DWORD PTR cb$[rsp]
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR cg$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR cr$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR ca$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR cb$[rsp]
	mov	r8d, DWORD PTR cg$[rsp]
	mov	edx, DWORD PTR cr$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0EC@EBPMGCGK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X?6R?3?$CFd?0?5G?3?$CFd?0?5B@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1
$LN4@ColorToolt:

; 5108 : 	EndTooltip();

	call	?EndTooltip@ImGui@@YAXXZ		; ImGui::EndTooltip
	npad	1

; 5109 : }

	add	rsp, 216				; 000000d8H
	ret	0
?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z ENDP		; ImGui::ColorTooltip
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 64
tv78 = 68
g$ = 72
flags$ = 80
$T1 = 84
data_buf$ = 96
fmt_buf$ = 128
__$ArrayPad$ = 160
bb$ = 192
id$ = 200
label$ = 208
data_type$ = 216
data_ptr$ = 224
format$ = 232
?InputScalarAsWidgetReplacement@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1@Z PROC ; ImGui::InputScalarAsWidgetReplacement

; 3018 : {

$LN8:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3019 : 	IM_UNUSED(id);
; 3020 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3021 : 
; 3022 : 	// On the first frame, g.ScalarAsInputTextId == 0, then on subsequent frames it becomes == id.
; 3023 : 	// We clear ActiveID on the first frame to allow the InputText() taking it back.
; 3024 : 	if (g.ScalarAsInputTextId == 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+11664], 0
	jne	SHORT $LN2@InputScala

; 3025 : 		ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
$LN2@InputScala:

; 3026 : 
; 3027 : 	char fmt_buf[32];
; 3028 : 	char data_buf[32];
; 3029 : 	format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));

	mov	r8d, 32					; 00000020H
	lea	rdx, QWORD PTR fmt_buf$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z ; ImParseFormatTrimDecorations
	mov	QWORD PTR format$[rsp], rax

; 3030 : 	DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, data_ptr, format);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR data_ptr$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, 32					; 00000020H
	lea	rcx, QWORD PTR data_buf$[rsp]
	call	?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z ; DataTypeFormatString

; 3031 : 	ImStrTrimBlanks(data_buf);

	lea	rcx, QWORD PTR data_buf$[rsp]
	call	?ImStrTrimBlanks@@YAXPEAD@Z		; ImStrTrimBlanks

; 3032 : 	ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | ((data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double) ? ImGuiInputTextFlags_CharsScientific : ImGuiInputTextFlags_CharsDecimal);

	cmp	DWORD PTR data_type$[rsp], 4
	je	SHORT $LN6@InputScala
	cmp	DWORD PTR data_type$[rsp], 5
	je	SHORT $LN6@InputScala
	mov	DWORD PTR tv78[rsp], 1
	jmp	SHORT $LN7@InputScala
$LN6@InputScala:
	mov	DWORD PTR tv78[rsp], 131072		; 00020000H
$LN7@InputScala:
	mov	eax, DWORD PTR tv78[rsp]
	or	eax, 16
	mov	DWORD PTR flags$[rsp], eax

; 3033 : 	bool value_changed = InputTextEx(label, data_buf, IM_ARRAYSIZE(data_buf), bb.GetSize(), flags);

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR bb$[rsp]
	call	?GetSize@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetSize
	mov	QWORD PTR [rsp+48], 0
	mov	QWORD PTR [rsp+40], 0
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, rax
	mov	r8d, 32					; 00000020H
	lea	rdx, QWORD PTR data_buf$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputTextEx@ImGui@@YA_NPEBDPEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextEx
	mov	BYTE PTR value_changed$[rsp], al

; 3034 : 	if (g.ScalarAsInputTextId == 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+11664], 0
	jne	SHORT $LN3@InputScala

; 3035 : 	{
; 3036 : 		// First frame we started displaying the InputText widget, we expect it to take the active id.
; 3037 : 		IM_ASSERT(g.ActiveId == id);
; 3038 : 		g.ScalarAsInputTextId = g.ActiveId;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6704]
	mov	DWORD PTR [rax+11664], ecx
$LN3@InputScala:

; 3039 : 	}
; 3040 : 	if (value_changed)

	movzx	eax, BYTE PTR value_changed$[rsp]
	test	eax, eax
	je	SHORT $LN4@InputScala

; 3041 : 		return DataTypeApplyOpFromText(data_buf, g.InputTextState.InitialText.Data, data_type, data_ptr, NULL);

	mov	QWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR data_ptr$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR [rax+7984]
	lea	rcx, QWORD PTR data_buf$[rsp]
	call	?DataTypeApplyOpFromText@@YA_NPEBD0HPEAX0@Z ; DataTypeApplyOpFromText
	jmp	SHORT $LN1@InputScala
$LN4@InputScala:

; 3042 : 	return false;

	xor	al, al
$LN1@InputScala:

; 3043 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 184				; 000000b8H
	ret	0
?InputScalarAsWidgetReplacement@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1@Z ENDP ; ImGui::InputScalarAsWidgetReplacement
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
is_multiline$ = 80
edit_state$ = 88
is_editable$ = 96
io$ = 104
g$ = 112
is_shortcut_key$1 = 120
clear_active_id$ = 121
id$ = 124
hovered$ = 128
is_osx$2 = 129
is_startend_key_down$3 = 130
cancel_edit$ = 131
is_password$ = 132
enter_pressed$ = 133
focus_requested$ = 134
select_all$ = 135
is_osx$4 = 136
user_nav_input_start$ = 137
is_wordmove_key_down$5 = 138
is_resizable$ = 139
value_changed$ = 140
tv84 = 141
tv293 = 142
tv302 = 143
tv307 = 144
tv315 = 145
tv324 = 146
tv336 = 147
tv346 = 148
tv407 = 149
focus_requested_by_code$ = 150
user_clicked$ = 151
tv704 = 152
tv719 = 153
tv724 = 154
tv736 = 155
tv749 = 156
tv762 = 157
tv787 = 158
tv810 = 159
is_shift_key_only$6 = 160
tv827 = 161
tv839 = 162
is_undoable$ = 163
tv858 = 164
ctrl_enter_for_new_line$7 = 165
is_undo$8 = 166
is_cut$9 = 167
tv72 = 168
draw_window$ = 176
tv75 = 184
tv78 = 185
tv81 = 186
k_mask$10 = 188
searches_remaining$11 = 192
line_count$12 = 196
is_osx_shift_shortcut$13 = 200
is_redo$14 = 201
is_copy$15 = 202
is_paste$16 = 203
apply_edit_back_to_user_buffer$17 = 204
user_scroll_active$ = 205
cursor_is_visible$18 = 206
user_scroll_finish$ = 207
apply_new_text_length$19 = 208
ignore_inputs$20 = 212
focus_requested_by_tab$ = 213
recycle_state$21 = 214
is_ctrl_key_only$22 = 215
clipboard_filtered_len$23 = 216
event_flag$24 = 220
scroll_y$25 = 224
searches_result_line_number$26 = 232
size$ = 240
window$ = 248
cursor_offset$27 = 256
style$ = 264
backup_current_text_length$ = 272
event_key$28 = 276
c$29 = 280
n$30 = 284
password_font$31 = 288
frame_bb$ = 296
rect_pos$32 = 312
text_begin$33 = 320
p$34 = 328
buf_display$ = 336
text$35 = 344
s$36 = 352
cursor_screen_pos$37 = 360
render_pos$ = 368
tv660 = 376
tv664 = 380
tv870 = 384
tv881 = 388
tv884 = 392
tv909 = 396
tv939 = 400
tv953 = 404
tv966 = 408
tv1016 = 412
c$38 = 416
c$39 = 420
tv1080 = 424
tv1109 = 428
tv1122 = 432
ie$40 = 436
ib$41 = 440
tv1230 = 444
tv1566 = 448
scroll_increment_x$42 = 452
tv1785 = 456
tv1788 = 460
buf_display_len$43 = 464
tv1957 = 468
tv867 = 472
tv135 = 476
tv171 = 480
tv355 = 484
init_buf_len$44 = 488
tv415 = 492
tv491 = 496
tv515 = 500
mouse_y$45 = 504
mouse_x$46 = 508
tv603 = 512
c$47 = 516
tv646 = 520
tv661 = 524
buf_end$48 = 528
apply_new_text$49 = 536
clipboard_filtered$50 = 544
s$51 = 552
render_scroll$52 = 560
label_size$ = 568
callback_data$53 = 576
searches_input_ptr$54 = 632
tv150 = 648
utf8_cursor_pos$55 = 652
utf8_selection_start$56 = 656
utf8_selection_end$57 = 660
tv1500 = 664
tv1498 = 668
tv2057 = 672
bg_offy_dn$58 = 676
clipboard_len$59 = 680
bg_offy_up$60 = 684
tv1939 = 688
tv1941 = 692
tv2000 = 696
bg_color$61 = 700
tv931 = 704
tv1808 = 708
tv933 = 712
clipboard$62 = 720
select_start_offset$63 = 728
text_selected_end$64 = 736
rect_size$65 = 744
text_size$ = 752
prev_len_w$66 = 760
tv2055 = 764
tv147 = 768
clip_rect$ = 776
tv1482 = 792
tv1518 = 800
tv1882 = 808
glyph$67 = 816
tv2038 = 824
buf_end$68 = 832
buf_end$69 = 840
total_bb$ = 848
rect$70 = 864
tv464 = 880
tv620 = 888
tv635 = 896
tv1130 = 904
tv1244 = 912
tv1350 = 920
tv1388 = 928
tv1425 = 936
$T71 = 944
$T72 = 952
tv1622 = 960
tv1620 = 968
tv1649 = 976
tv1647 = 984
text_selected_begin$73 = 992
tv1821 = 1000
tv1851 = 1008
tv1849 = 1016
tv1870 = 1024
tv1937 = 1032
tv1935 = 1040
tv1943 = 1048
tv1998 = 1056
tv2002 = 1064
tv2059 = 1072
tv2053 = 1080
tv2061 = 1088
buf_display_max_length$ = 1096
$T74 = 1104
$T75 = 1112
tv264 = 1120
tv376 = 1128
cursor_screen_rect$76 = 1136
tv382 = 1152
callback_data$77 = 1160
$T78 = 1216
$T79 = 1224
$T80 = 1232
$T81 = 1240
$T82 = 1248
$T83 = 1256
$T84 = 1264
$T85 = 1272
$T86 = 1280
$T87 = 1288
$T88 = 1296
$T89 = 1304
$T90 = 1312
$T91 = 1320
$T92 = 1328
$T93 = 1336
$T94 = 1344
$T95 = 1352
$T96 = 1360
$T97 = 1368
$T98 = 1384
$T99 = 1400
$T100 = 1416
$T101 = 1424
label$ = 1456
buf$ = 1464
buf_size$ = 1472
size_arg$ = 1480
flags$ = 1488
callback$ = 1496
callback_user_data$ = 1504
?InputTextEx@ImGui@@YA_NPEBDPEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z PROC ; ImGui::InputTextEx

; 3580 : {

$LN310:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1448				; 000005a8H

; 3581 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 3582 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN19@InputTextE

; 3583 : 		return false;

	xor	al, al
	jmp	$LN1@InputTextE
$LN19@InputTextE:

; 3584 : 
; 3585 : 	IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline)));        // Can't use both together (they both use up/down keys)
; 3586 : 	IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)
; 3587 : 
; 3588 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3589 : 	ImGuiIO& io = g.IO;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 16
	mov	QWORD PTR io$[rsp], rax

; 3590 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 3591 : 
; 3592 : 	const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	je	SHORT $LN181@InputTextE
	mov	BYTE PTR tv72[rsp], 1
	jmp	SHORT $LN182@InputTextE
$LN181@InputTextE:
	mov	BYTE PTR tv72[rsp], 0
$LN182@InputTextE:
	movzx	eax, BYTE PTR tv72[rsp]
	mov	BYTE PTR is_multiline$[rsp], al

; 3593 : 	const bool is_editable = (flags & ImGuiInputTextFlags_ReadOnly) == 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16384				; 00004000H
	test	eax, eax
	jne	SHORT $LN183@InputTextE
	mov	BYTE PTR tv75[rsp], 1
	jmp	SHORT $LN184@InputTextE
$LN183@InputTextE:
	mov	BYTE PTR tv75[rsp], 0
$LN184@InputTextE:
	movzx	eax, BYTE PTR tv75[rsp]
	mov	BYTE PTR is_editable$[rsp], al

; 3594 : 	const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32768				; 00008000H
	test	eax, eax
	je	SHORT $LN185@InputTextE
	mov	BYTE PTR tv78[rsp], 1
	jmp	SHORT $LN186@InputTextE
$LN185@InputTextE:
	mov	BYTE PTR tv78[rsp], 0
$LN186@InputTextE:
	movzx	eax, BYTE PTR tv78[rsp]
	mov	BYTE PTR is_password$[rsp], al

; 3595 : 	const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 65536				; 00010000H
	test	eax, eax
	jne	SHORT $LN187@InputTextE
	mov	BYTE PTR tv81[rsp], 1
	jmp	SHORT $LN188@InputTextE
$LN187@InputTextE:
	mov	BYTE PTR tv81[rsp], 0
$LN188@InputTextE:
	movzx	eax, BYTE PTR tv81[rsp]
	mov	BYTE PTR is_undoable$[rsp], al

; 3596 : 	const bool is_resizable = (flags & ImGuiInputTextFlags_CallbackResize) != 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN189@InputTextE
	mov	BYTE PTR tv84[rsp], 1
	jmp	SHORT $LN190@InputTextE
$LN189@InputTextE:
	mov	BYTE PTR tv84[rsp], 0
$LN190@InputTextE:
	movzx	eax, BYTE PTR tv84[rsp]
	mov	BYTE PTR is_resizable$[rsp], al

; 3597 : 	if (is_resizable)

	movzx	eax, BYTE PTR is_resizable$[rsp]

; 3598 : 		IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!
; 3599 : 
; 3600 : 	if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope,

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN21@InputTextE

; 3601 : 		BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup
	npad	1
$LN21@InputTextE:

; 3602 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 3603 : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	npad	1

; 3604 : 	ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? GetTextLineHeight() * 8.0f : label_size.y) + style.FramePadding.y * 2.0f); // Arbitrary default of 8 lines high for multi-line

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN191@InputTextE
	call	?GetTextLineHeight@ImGui@@YAMXZ		; ImGui::GetTextLineHeight
	mulss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR tv135[rsp], xmm0
	jmp	SHORT $LN192@InputTextE
$LN191@InputTextE:
	movss	xmm0, DWORD PTR label_size$[rsp+4]
	movss	DWORD PTR tv135[rsp], xmm0
$LN192@InputTextE:
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv135[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv150[rsp], xmm0
	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movss	DWORD PTR tv147[rsp], xmm0
	mov	rax, QWORD PTR size_arg$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T74[rsp], rax
	mov	rax, QWORD PTR $T74[rsp]
	mov	QWORD PTR $T75[rsp], rax
	movss	xmm3, DWORD PTR tv150[rsp]
	movss	xmm2, DWORD PTR tv147[rsp]
	mov	rdx, QWORD PTR $T75[rsp]
	lea	rcx, QWORD PTR size$[rsp]
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
	npad	1

; 3605 : 	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	lea	r8, QWORD PTR size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T92[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 3606 : 	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? (style.ItemInnerSpacing.x + label_size.x) : 0.0f, 0.0f));

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN193@InputTextE
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	addss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR tv171[rsp], xmm0
	jmp	SHORT $LN194@InputTextE
$LN193@InputTextE:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv171[rsp], xmm0
$LN194@InputTextE:
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR tv171[rsp]
	lea	rcx, QWORD PTR $T93[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	lea	rcx, QWORD PTR $T94[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 3607 : 
; 3608 : 	ImGuiWindow* draw_window = window;

	mov	rax, QWORD PTR window$[rsp]
	mov	QWORD PTR draw_window$[rsp], rax

; 3609 : 	if (is_multiline)

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	$LN22@InputTextE

; 3610 : 	{
; 3611 : 		if (!ItemAdd(total_bb, id, &frame_bb))

	lea	r8, QWORD PTR frame_bb$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN24@InputTextE

; 3612 : 		{
; 3613 : 			ItemSize(total_bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize

; 3614 : 			EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 3615 : 			return false;

	xor	al, al
	jmp	$LN1@InputTextE
$LN24@InputTextE:

; 3616 : 		}
; 3617 : 		if (!BeginChildFrame(id, frame_bb.GetSize()))

	lea	rdx, QWORD PTR $T101[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?GetSize@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetSize
	xor	r8d, r8d
	mov	rdx, rax
	mov	ecx, DWORD PTR id$[rsp]
	call	?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z ; ImGui::BeginChildFrame
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@InputTextE

; 3618 : 		{
; 3619 : 			EndChildFrame();

	call	?EndChildFrame@ImGui@@YAXXZ		; ImGui::EndChildFrame

; 3620 : 			EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 3621 : 			return false;

	xor	al, al
	jmp	$LN1@InputTextE
$LN25@InputTextE:

; 3622 : 		}
; 3623 : 		draw_window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR draw_window$[rsp], rax

; 3624 : 		draw_window->DC.NavLayerActiveMaskNext |= draw_window->DC.NavLayerCurrentMask; // This is to ensure that EndChild() will display a navigation highlight

	mov	rax, QWORD PTR draw_window$[rsp]
	mov	rcx, QWORD PTR draw_window$[rsp]
	mov	ecx, DWORD PTR [rcx+404]
	mov	eax, DWORD PTR [rax+424]
	or	eax, ecx
	mov	rcx, QWORD PTR draw_window$[rsp]
	mov	DWORD PTR [rcx+424], eax

; 3625 : 		size.x -= draw_window->ScrollbarSizes.x;

	mov	rax, QWORD PTR draw_window$[rsp]
	movss	xmm0, DWORD PTR size$[rsp]
	subss	xmm0, DWORD PTR [rax+124]
	movss	DWORD PTR size$[rsp], xmm0

; 3626 : 	}

	jmp	SHORT $LN23@InputTextE
$LN22@InputTextE:

; 3627 : 	else
; 3628 : 	{
; 3629 : 		ItemSize(total_bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 3630 : 		if (!ItemAdd(total_bb, id, &frame_bb))

	lea	r8, QWORD PTR frame_bb$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN26@InputTextE

; 3631 : 			return false;

	xor	al, al
	jmp	$LN1@InputTextE
$LN26@InputTextE:
$LN23@InputTextE:

; 3632 : 	}
; 3633 : 	const bool hovered = ItemHoverable(frame_bb, id);

	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z ; ImGui::ItemHoverable
	mov	BYTE PTR hovered$[rsp], al

; 3634 : 	if (hovered)

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN27@InputTextE

; 3635 : 		g.MouseCursor = ImGuiMouseCursor_TextInput;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7504], 1
$LN27@InputTextE:

; 3636 : 
; 3637 : 	// Password pushes a temporary font with only a fallback glyph
; 3638 : 	if (is_password)

	movzx	eax, BYTE PTR is_password$[rsp]
	test	eax, eax
	je	$LN28@InputTextE

; 3639 : 	{
; 3640 : 		const ImFontGlyph* glyph = g.Font->FindGlyph('*');

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv264[rsp], rax
	mov	dx, 42					; 0000002aH
	mov	rcx, QWORD PTR tv264[rsp]
	call	?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z ; ImFont::FindGlyph
	mov	QWORD PTR glyph$67[rsp], rax

; 3641 : 		ImFont* password_font = &g.InputTextPasswordFont;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7816				; 00001e88H
	mov	QWORD PTR password_font$31[rsp], rax

; 3642 : 		password_font->FontSize = g.Font->FontSize;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR password_font$31[rsp]
	movss	xmm0, DWORD PTR [rax+20]
	movss	DWORD PTR [rcx+20], xmm0

; 3643 : 		password_font->Scale = g.Font->Scale;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR password_font$31[rsp]
	movss	xmm0, DWORD PTR [rax+80]
	movss	DWORD PTR [rcx+80], xmm0

; 3644 : 		password_font->DisplayOffset = g.Font->DisplayOffset;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR password_font$31[rsp]
	mov	QWORD PTR [rcx+64], rax

; 3645 : 		password_font->Ascent = g.Font->Ascent;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR password_font$31[rsp]
	movss	xmm0, DWORD PTR [rax+84]
	movss	DWORD PTR [rcx+84], xmm0

; 3646 : 		password_font->Descent = g.Font->Descent;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR password_font$31[rsp]
	movss	xmm0, DWORD PTR [rax+88]
	movss	DWORD PTR [rcx+88], xmm0

; 3647 : 		password_font->ContainerAtlas = g.Font->ContainerAtlas;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR password_font$31[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR [rcx+72], rax

; 3648 : 		password_font->FallbackGlyph = glyph;

	mov	rax, QWORD PTR password_font$31[rsp]
	mov	rcx, QWORD PTR glyph$67[rsp]
	mov	QWORD PTR [rax+40], rcx

; 3649 : 		password_font->FallbackAdvanceX = glyph->AdvanceX;

	mov	rax, QWORD PTR password_font$31[rsp]
	mov	rcx, QWORD PTR glyph$67[rsp]
	movss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [rax+16], xmm0

; 3650 : 		IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());
; 3651 : 		PushFont(password_font);

	mov	rcx, QWORD PTR password_font$31[rsp]
	call	?PushFont@ImGui@@YAXPEAUImFont@@@Z	; ImGui::PushFont
	npad	1
$LN28@InputTextE:

; 3652 : 	}
; 3653 : 
; 3654 : 	// NB: we are only allowed to access 'edit_state' if we are the active widget.
; 3655 : 	ImGuiInputTextState& edit_state = g.InputTextState;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7936				; 00001f00H
	mov	QWORD PTR edit_state$[rsp], rax

; 3656 : 
; 3657 : 	const bool focus_requested = FocusableItemRegister(window, id, (flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_AllowTabInput)) == 0);    // Using completion callback disable keyboard tabbing

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1088				; 00000440H
	test	eax, eax
	jne	SHORT $LN195@InputTextE
	mov	BYTE PTR tv293[rsp], 1
	jmp	SHORT $LN196@InputTextE
$LN195@InputTextE:
	mov	BYTE PTR tv293[rsp], 0
$LN196@InputTextE:
	movzx	r8d, BYTE PTR tv293[rsp]
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusableItemRegister@ImGui@@YA_NPEAUImGuiWindow@@I_N@Z ; ImGui::FocusableItemRegister
	mov	BYTE PTR focus_requested$[rsp], al

; 3658 : 	const bool focus_requested_by_code = focus_requested && (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent);

	movzx	eax, BYTE PTR focus_requested$[rsp]
	test	eax, eax
	je	SHORT $LN197@InputTextE
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+948]
	cmp	DWORD PTR [rax+944], ecx
	jne	SHORT $LN197@InputTextE
	mov	BYTE PTR tv302[rsp], 1
	jmp	SHORT $LN198@InputTextE
$LN197@InputTextE:
	mov	BYTE PTR tv302[rsp], 0
$LN198@InputTextE:
	movzx	eax, BYTE PTR tv302[rsp]
	mov	BYTE PTR focus_requested_by_code$[rsp], al

; 3659 : 	const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;

	movzx	eax, BYTE PTR focus_requested$[rsp]
	test	eax, eax
	je	SHORT $LN199@InputTextE
	movzx	eax, BYTE PTR focus_requested_by_code$[rsp]
	test	eax, eax
	jne	SHORT $LN199@InputTextE
	mov	BYTE PTR tv307[rsp], 1
	jmp	SHORT $LN200@InputTextE
$LN199@InputTextE:
	mov	BYTE PTR tv307[rsp], 0
$LN200@InputTextE:
	movzx	eax, BYTE PTR tv307[rsp]
	mov	BYTE PTR focus_requested_by_tab$[rsp], al

; 3660 : 
; 3661 : 	const bool user_clicked = hovered && io.MouseClicked[0];

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN201@InputTextE
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1000]
	test	eax, eax
	je	SHORT $LN201@InputTextE
	mov	BYTE PTR tv315[rsp], 1
	jmp	SHORT $LN202@InputTextE
$LN201@InputTextE:
	mov	BYTE PTR tv315[rsp], 0
$LN202@InputTextE:
	movzx	eax, BYTE PTR tv315[rsp]
	mov	BYTE PTR user_clicked$[rsp], al

; 3662 : 	const bool user_nav_input_start = (g.ActiveId != id) && ((g.NavInputId == id) || (g.NavActivateId == id && g.NavInputSource == ImGuiInputSource_NavKeyboard));

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN205@InputTextE
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7048], ecx
	je	SHORT $LN204@InputTextE
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7044], ecx
	jne	SHORT $LN203@InputTextE
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7060], 3
	jne	SHORT $LN205@InputTextE
$LN204@InputTextE:
	mov	BYTE PTR tv324[rsp], 1
	jmp	SHORT $LN206@InputTextE
$LN205@InputTextE:
$LN203@InputTextE:
	mov	BYTE PTR tv324[rsp], 0
$LN206@InputTextE:
	movzx	eax, BYTE PTR tv324[rsp]
	mov	BYTE PTR user_nav_input_start$[rsp], al

; 3663 : 	const bool user_scroll_finish = is_multiline && edit_state.ID == id && g.ActiveId == 0 && g.ActiveIdPreviousFrame == GetScrollbarID(draw_window, ImGuiAxis_Y);

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN207@InputTextE
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN207@InputTextE
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	jne	SHORT $LN207@InputTextE
	mov	edx, 1
	mov	rcx, QWORD PTR draw_window$[rsp]
	call	?GetScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z ; ImGui::GetScrollbarID
	mov	rcx, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rcx+6708], eax
	jne	SHORT $LN207@InputTextE
	mov	BYTE PTR tv336[rsp], 1
	jmp	SHORT $LN208@InputTextE
$LN207@InputTextE:
	mov	BYTE PTR tv336[rsp], 0
$LN208@InputTextE:
	movzx	eax, BYTE PTR tv336[rsp]
	mov	BYTE PTR user_scroll_finish$[rsp], al

; 3664 : 	const bool user_scroll_active = is_multiline && edit_state.ID == id && g.ActiveId == GetScrollbarID(draw_window, ImGuiAxis_Y);

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN209@InputTextE
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN209@InputTextE
	mov	edx, 1
	mov	rcx, QWORD PTR draw_window$[rsp]
	call	?GetScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z ; ImGui::GetScrollbarID
	mov	rcx, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rcx+6704], eax
	jne	SHORT $LN209@InputTextE
	mov	BYTE PTR tv346[rsp], 1
	jmp	SHORT $LN210@InputTextE
$LN209@InputTextE:
	mov	BYTE PTR tv346[rsp], 0
$LN210@InputTextE:
	movzx	eax, BYTE PTR tv346[rsp]
	mov	BYTE PTR user_scroll_active$[rsp], al

; 3665 : 
; 3666 : 	bool clear_active_id = false;

	mov	BYTE PTR clear_active_id$[rsp], 0

; 3667 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 3668 : 	bool enter_pressed = false;

	mov	BYTE PTR enter_pressed$[rsp], 0

; 3669 : 	bool select_all = (g.ActiveId != id) && ((flags & ImGuiInputTextFlags_AutoSelectAll) != 0 || user_nav_input_start) && (!is_multiline);

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN212@InputTextE
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16
	test	eax, eax
	jne	SHORT $LN211@InputTextE
	movzx	eax, BYTE PTR user_nav_input_start$[rsp]
	test	eax, eax
	je	SHORT $LN212@InputTextE
$LN211@InputTextE:
	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	jne	SHORT $LN212@InputTextE
	mov	DWORD PTR tv355[rsp], 1
	jmp	SHORT $LN213@InputTextE
$LN212@InputTextE:
	mov	DWORD PTR tv355[rsp], 0
$LN213@InputTextE:
	movzx	eax, BYTE PTR tv355[rsp]
	mov	BYTE PTR select_all$[rsp], al

; 3670 : 	if (focus_requested || user_clicked || user_scroll_finish || user_nav_input_start)

	movzx	eax, BYTE PTR focus_requested$[rsp]
	test	eax, eax
	jne	SHORT $LN31@InputTextE
	movzx	eax, BYTE PTR user_clicked$[rsp]
	test	eax, eax
	jne	SHORT $LN31@InputTextE
	movzx	eax, BYTE PTR user_scroll_finish$[rsp]
	test	eax, eax
	jne	SHORT $LN31@InputTextE
	movzx	eax, BYTE PTR user_nav_input_start$[rsp]
	test	eax, eax
	je	$LN29@InputTextE
$LN31@InputTextE:

; 3671 : 	{
; 3672 : 		if (g.ActiveId != id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	je	$LN32@InputTextE

; 3673 : 		{
; 3674 : 			// Start edition
; 3675 : 			// Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)
; 3676 : 			// From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)
; 3677 : 			const int prev_len_w = edit_state.CurLenW;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR prev_len_w$66[rsp], eax

; 3678 : 			const int init_buf_len = (int)strlen(buf);

	mov	rcx, QWORD PTR buf$[rsp]
	call	strlen
	mov	DWORD PTR init_buf_len$44[rsp], eax

; 3679 : 			edit_state.TextW.resize(buf_size + 1);             // wchar count <= UTF-8 count. we use +1 to make sure that .Data isn't NULL so it doesn't crash.

	mov	rax, QWORD PTR edit_state$[rsp]
	add	rax, 8
	mov	QWORD PTR tv376[rsp], rax
	mov	eax, DWORD PTR buf_size$[rsp]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv376[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize

; 3680 : 			edit_state.InitialText.resize(init_buf_len + 1); // UTF-8. we use +1 to make sure that .Data isn't NULL so it doesn't crash.

	mov	rax, QWORD PTR edit_state$[rsp]
	add	rax, 40					; 00000028H
	mov	QWORD PTR tv382[rsp], rax
	mov	eax, DWORD PTR init_buf_len$44[rsp]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv382[rsp]
	call	?resize@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::resize

; 3681 : 			memcpy(edit_state.InitialText.Data, buf, init_buf_len + 1);

	mov	eax, DWORD PTR init_buf_len$44[rsp]
	inc	eax
	cdqe
	mov	r8, rax
	mov	rdx, QWORD PTR buf$[rsp]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR [rax+48]
	call	memcpy

; 3682 : 			const char* buf_end = NULL;

	mov	QWORD PTR buf_end$69[rsp], 0

; 3683 : 			edit_state.CurLenW = ImTextStrFromUtf8(edit_state.TextW.Data, buf_size, buf, NULL, &buf_end);

	lea	rax, QWORD PTR buf_end$69[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR buf$[rsp]
	mov	edx, DWORD PTR buf_size$[rsp]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z ; ImTextStrFromUtf8
	mov	rcx, QWORD PTR edit_state$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 3684 : 			edit_state.CurLenA = (int)(buf_end - buf); // We can't get the result from ImStrncpy() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.

	mov	rax, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR buf_end$69[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR edit_state$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 3685 : 			edit_state.CursorAnimReset();

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ ; ImGuiInputTextState::CursorAnimReset

; 3686 : 
; 3687 : 			// Preserve cursor position and undo/redo stack if we come back to same widget
; 3688 : 			// FIXME: We should probably compare the whole buffer to be on the safety side. Comparing buf (utf8) and edit_state.Text (wchar).
; 3689 : 			const bool recycle_state = (edit_state.ID == id) && (prev_len_w == edit_state.CurLenW);

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN214@InputTextE
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	eax, DWORD PTR [rax+32]
	cmp	DWORD PTR prev_len_w$66[rsp], eax
	jne	SHORT $LN214@InputTextE
	mov	BYTE PTR tv407[rsp], 1
	jmp	SHORT $LN215@InputTextE
$LN214@InputTextE:
	mov	BYTE PTR tv407[rsp], 0
$LN215@InputTextE:
	movzx	eax, BYTE PTR tv407[rsp]
	mov	BYTE PTR recycle_state$21[rsp], al

; 3690 : 			if (recycle_state)

	movzx	eax, BYTE PTR recycle_state$21[rsp]
	test	eax, eax
	je	SHORT $LN33@InputTextE

; 3691 : 			{
; 3692 : 				// Recycle existing cursor/selection/undo stack but clamp position
; 3693 : 				// Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
; 3694 : 				edit_state.CursorClamp();

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?CursorClamp@ImGuiInputTextState@@QEAAXXZ ; ImGuiInputTextState::CursorClamp
	npad	1

; 3695 : 			}

	jmp	SHORT $LN34@InputTextE
$LN33@InputTextE:

; 3696 : 			else
; 3697 : 			{
; 3698 : 				edit_state.ID = id;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax], ecx

; 3699 : 				edit_state.ScrollX = 0.0f;

	mov	rax, QWORD PTR edit_state$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+72], xmm0

; 3700 : 				stb_textedit_initialize_state(&edit_state.StbState, !is_multiline);

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	jne	SHORT $LN216@InputTextE
	mov	DWORD PTR tv415[rsp], 1
	jmp	SHORT $LN217@InputTextE
$LN216@InputTextE:
	mov	DWORD PTR tv415[rsp], 0
$LN217@InputTextE:
	mov	rax, QWORD PTR edit_state$[rsp]
	add	rax, 80					; 00000050H
	mov	edx, DWORD PTR tv415[rsp]
	mov	rcx, rax
	call	?stb_textedit_initialize_state@ImGuiStb@@YAXPEAUSTB_TexteditState@1@H@Z ; ImGuiStb::stb_textedit_initialize_state
	npad	1

; 3701 : 				if (!is_multiline && focus_requested_by_code)

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	jne	SHORT $LN35@InputTextE
	movzx	eax, BYTE PTR focus_requested_by_code$[rsp]
	test	eax, eax
	je	SHORT $LN35@InputTextE

; 3702 : 					select_all = true;

	mov	BYTE PTR select_all$[rsp], 1
$LN35@InputTextE:
$LN34@InputTextE:

; 3703 : 			}
; 3704 : 			if (flags & ImGuiInputTextFlags_AlwaysInsertMode)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8192				; 00002000H
	test	eax, eax
	je	SHORT $LN36@InputTextE

; 3705 : 				edit_state.StbState.insert_mode = 1;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	BYTE PTR [rax+92], 1
$LN36@InputTextE:

; 3706 : 			if (!is_multiline && (focus_requested_by_tab || (user_clicked && io.KeyCtrl)))

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	jne	SHORT $LN37@InputTextE
	movzx	eax, BYTE PTR focus_requested_by_tab$[rsp]
	test	eax, eax
	jne	SHORT $LN38@InputTextE
	movzx	eax, BYTE PTR user_clicked$[rsp]
	test	eax, eax
	je	SHORT $LN37@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	je	SHORT $LN37@InputTextE
$LN38@InputTextE:

; 3707 : 				select_all = true;

	mov	BYTE PTR select_all$[rsp], 1
$LN37@InputTextE:
$LN32@InputTextE:

; 3708 : 		}
; 3709 : 		SetActiveID(id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 3710 : 		SetFocusID(id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetFocusID

; 3711 : 		FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 3712 : 		g.ActiveIdBlockNavInputFlags = (1 << ImGuiNavInput_Cancel);

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6808], 2

; 3713 : 		if (!is_multiline && !(flags & ImGuiInputTextFlags_CallbackHistory))

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	jne	SHORT $LN39@InputTextE
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN39@InputTextE

; 3714 : 			g.ActiveIdAllowNavDirFlags = ((1 << ImGuiDir_Up) | (1 << ImGuiDir_Down));

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6804], 12
$LN39@InputTextE:

; 3715 : 	}

	jmp	SHORT $LN30@InputTextE
$LN29@InputTextE:

; 3716 : 	else if (io.MouseClicked[0])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1000]
	test	eax, eax
	je	SHORT $LN40@InputTextE

; 3717 : 	{
; 3718 : 		// Release focus when we click outside
; 3719 : 		clear_active_id = true;

	mov	BYTE PTR clear_active_id$[rsp], 1

; 3720 : 		enter_pressed = true;

	mov	BYTE PTR enter_pressed$[rsp], 1
$LN40@InputTextE:
$LN30@InputTextE:

; 3721 : 	}
; 3722 : 
; 3723 : 
; 3724 : 	int backup_current_text_length = 0;

	mov	DWORD PTR backup_current_text_length$[rsp], 0

; 3725 : 
; 3726 : 	if (g.ActiveId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	$LN41@InputTextE

; 3727 : 	{
; 3728 : 		if (!is_editable && !g.ActiveIdIsJustActivated)

	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	jne	$LN42@InputTextE
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	test	eax, eax
	jne	$LN42@InputTextE

; 3729 : 		{
; 3730 : 			// When read-only we always use the live data passed to the function
; 3731 : 			edit_state.TextW.resize(buf_size + 1);

	mov	rax, QWORD PTR edit_state$[rsp]
	add	rax, 8
	mov	QWORD PTR tv464[rsp], rax
	mov	eax, DWORD PTR buf_size$[rsp]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv464[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize

; 3732 : 			const char* buf_end = NULL;

	mov	QWORD PTR buf_end$68[rsp], 0

; 3733 : 			edit_state.CurLenW = ImTextStrFromUtf8(edit_state.TextW.Data, edit_state.TextW.Size, buf, NULL, &buf_end);

	lea	rax, QWORD PTR buf_end$68[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR buf$[rsp]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	edx, DWORD PTR [rax+8]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z ; ImTextStrFromUtf8
	mov	rcx, QWORD PTR edit_state$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 3734 : 			edit_state.CurLenA = (int)(buf_end - buf);

	mov	rax, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR buf_end$68[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR edit_state$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 3735 : 			edit_state.CursorClamp();

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?CursorClamp@ImGuiInputTextState@@QEAAXXZ ; ImGuiInputTextState::CursorClamp
	npad	1
$LN42@InputTextE:

; 3736 : 		}
; 3737 : 
; 3738 : 		backup_current_text_length = edit_state.CurLenA;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR backup_current_text_length$[rsp], eax

; 3739 : 		edit_state.BufCapacityA = buf_size;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR buf_size$[rsp]
	mov	DWORD PTR [rax+76], ecx

; 3740 : 		edit_state.UserFlags = flags;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rax+3704], ecx

; 3741 : 		edit_state.UserCallback = callback;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR callback$[rsp]
	mov	QWORD PTR [rax+3712], rcx

; 3742 : 		edit_state.UserCallbackData = callback_user_data;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR callback_user_data$[rsp]
	mov	QWORD PTR [rax+3720], rcx

; 3743 : 
; 3744 : 		// Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
; 3745 : 		// Down the line we should have a cleaner library-wide concept of Selected vs Active.
; 3746 : 		g.ActiveIdAllowOverlap = !io.MouseDown[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+289]
	test	eax, eax
	jne	SHORT $LN218@InputTextE
	mov	DWORD PTR tv491[rsp], 1
	jmp	SHORT $LN219@InputTextE
$LN218@InputTextE:
	mov	DWORD PTR tv491[rsp], 0
$LN219@InputTextE:
	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR tv491[rsp]
	mov	BYTE PTR [rax+6753], cl

; 3747 : 		g.WantTextInputNextFrame = 1;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+12236], 1

; 3748 : 
; 3749 : 		// Edit in progress
; 3750 : 		const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + edit_state.ScrollX;

	mov	rax, QWORD PTR io$[rsp]
	movss	xmm0, DWORD PTR [rax+300]
	subss	xmm0, DWORD PTR frame_bb$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	subss	xmm0, DWORD PTR [rax+52]
	mov	rax, QWORD PTR edit_state$[rsp]
	addss	xmm0, DWORD PTR [rax+72]
	movss	DWORD PTR mouse_x$46[rsp], xmm0

; 3751 : 		const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y - style.FramePadding.y) : (g.FontSize * 0.5f));

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN220@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	mov	rcx, QWORD PTR draw_window$[rsp]
	movss	xmm0, DWORD PTR [rax+304]
	subss	xmm0, DWORD PTR [rcx+344]
	mov	rax, QWORD PTR style$[rsp]
	subss	xmm0, DWORD PTR [rax+56]
	movss	DWORD PTR tv515[rsp], xmm0
	jmp	SHORT $LN221@InputTextE
$LN220@InputTextE:
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv515[rsp], xmm0
$LN221@InputTextE:
	movss	xmm0, DWORD PTR tv515[rsp]
	movss	DWORD PTR mouse_y$45[rsp], xmm0

; 3752 : 
; 3753 : 		const bool is_osx = io.ConfigMacOSXBehaviors;

	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+192]
	mov	BYTE PTR is_osx$4[rsp], al

; 3754 : 		if (select_all || (hovered && !is_osx && io.MouseDoubleClicked[0]))

	movzx	eax, BYTE PTR select_all$[rsp]
	test	eax, eax
	jne	SHORT $LN45@InputTextE
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN43@InputTextE
	movzx	eax, BYTE PTR is_osx$4[rsp]
	test	eax, eax
	jne	SHORT $LN43@InputTextE
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1005]
	test	eax, eax
	je	SHORT $LN43@InputTextE
$LN45@InputTextE:

; 3755 : 		{
; 3756 : 			edit_state.SelectAll();

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?SelectAll@ImGuiInputTextState@@QEAAXXZ	; ImGuiInputTextState::SelectAll

; 3757 : 			edit_state.SelectedAllMouseLock = true;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	BYTE PTR [rax+3701], 1

; 3758 : 		}

	jmp	$LN44@InputTextE
$LN43@InputTextE:

; 3759 : 		else if (hovered && is_osx && io.MouseDoubleClicked[0])

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN46@InputTextE
	movzx	eax, BYTE PTR is_osx$4[rsp]
	test	eax, eax
	je	SHORT $LN46@InputTextE
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1005]
	test	eax, eax
	je	SHORT $LN46@InputTextE

; 3760 : 		{
; 3761 : 			// Double-click select a word only, OS X style (by simulating keystrokes)
; 3762 : 			edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);

	mov	edx, 65548				; 0001000cH
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed

; 3763 : 			edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);

	mov	edx, 196621				; 0003000dH
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1

; 3764 : 		}

	jmp	$LN47@InputTextE
$LN46@InputTextE:

; 3765 : 		else if (io.MouseClicked[0] && !edit_state.SelectedAllMouseLock)

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1000]
	test	eax, eax
	je	SHORT $LN48@InputTextE
	mov	rax, QWORD PTR edit_state$[rsp]
	movzx	eax, BYTE PTR [rax+3701]
	test	eax, eax
	jne	SHORT $LN48@InputTextE

; 3766 : 		{
; 3767 : 			if (hovered)

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN50@InputTextE

; 3768 : 			{
; 3769 : 				stb_textedit_click(&edit_state, &edit_state.StbState, mouse_x, mouse_y);

	mov	rax, QWORD PTR edit_state$[rsp]
	add	rax, 80					; 00000050H
	movss	xmm3, DWORD PTR mouse_y$45[rsp]
	movss	xmm2, DWORD PTR mouse_x$46[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?stb_textedit_click@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z ; ImGuiStb::stb_textedit_click

; 3770 : 				edit_state.CursorAnimReset();

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ ; ImGuiInputTextState::CursorAnimReset
	npad	1
$LN50@InputTextE:

; 3771 : 			}
; 3772 : 		}

	jmp	$LN49@InputTextE
$LN48@InputTextE:

; 3773 : 		else if (io.MouseDown[0] && !edit_state.SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+289]
	test	eax, eax
	je	SHORT $LN51@InputTextE
	mov	rax, QWORD PTR edit_state$[rsp]
	movzx	eax, BYTE PTR [rax+3701]
	test	eax, eax
	jne	SHORT $LN51@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movss	xmm0, DWORD PTR [rax+952]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN52@InputTextE
	jne	SHORT $LN52@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movss	xmm0, DWORD PTR [rax+956]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN309@InputTextE
	je	SHORT $LN51@InputTextE
$LN309@InputTextE:
$LN52@InputTextE:

; 3774 : 		{
; 3775 : 			stb_textedit_drag(&edit_state, &edit_state.StbState, mouse_x, mouse_y);

	mov	rax, QWORD PTR edit_state$[rsp]
	add	rax, 80					; 00000050H
	movss	xmm3, DWORD PTR mouse_y$45[rsp]
	movss	xmm2, DWORD PTR mouse_x$46[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?stb_textedit_drag@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z ; ImGuiStb::stb_textedit_drag

; 3776 : 			edit_state.CursorAnimReset();

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ ; ImGuiInputTextState::CursorAnimReset

; 3777 : 			edit_state.CursorFollow = true;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	BYTE PTR [rax+3700], 1
$LN51@InputTextE:
$LN49@InputTextE:
$LN47@InputTextE:
$LN44@InputTextE:

; 3778 : 		}
; 3779 : 		if (edit_state.SelectedAllMouseLock && !io.MouseDown[0])

	mov	rax, QWORD PTR edit_state$[rsp]
	movzx	eax, BYTE PTR [rax+3701]
	test	eax, eax
	je	SHORT $LN53@InputTextE
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+289]
	test	eax, eax
	jne	SHORT $LN53@InputTextE

; 3780 : 			edit_state.SelectedAllMouseLock = false;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	BYTE PTR [rax+3701], 0
$LN53@InputTextE:

; 3781 : 
; 3782 : 		if (io.InputQueueCharacters.Size > 0)

	mov	rax, QWORD PTR io$[rsp]
	cmp	DWORD PTR [rax+5440], 0
	jle	$LN54@InputTextE

; 3783 : 		{
; 3784 : 			// Process text input (before we check for Return because using some IME will effectively send a Return?)
; 3785 : 			// We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
; 3786 : 			bool ignore_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeySuper);

	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	je	SHORT $LN222@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+308]
	test	eax, eax
	je	SHORT $LN224@InputTextE
$LN222@InputTextE:
	movzx	eax, BYTE PTR is_osx$4[rsp]
	test	eax, eax
	je	SHORT $LN223@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+316]
	test	eax, eax
	jne	SHORT $LN224@InputTextE
$LN223@InputTextE:
	mov	DWORD PTR tv603[rsp], 0
	jmp	SHORT $LN225@InputTextE
$LN224@InputTextE:
	mov	DWORD PTR tv603[rsp], 1
$LN225@InputTextE:
	movzx	eax, BYTE PTR tv603[rsp]
	mov	BYTE PTR ignore_inputs$20[rsp], al

; 3787 : 			if (!ignore_inputs && is_editable && !user_nav_input_start)

	movzx	eax, BYTE PTR ignore_inputs$20[rsp]
	test	eax, eax
	jne	$LN55@InputTextE
	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	$LN55@InputTextE
	movzx	eax, BYTE PTR user_nav_input_start$[rsp]
	test	eax, eax
	jne	$LN55@InputTextE

; 3788 : 				for (int n = 0; n < io.InputQueueCharacters.Size; n++)

	mov	DWORD PTR n$30[rsp], 0
	jmp	SHORT $LN4@InputTextE
$LN2@InputTextE:
	mov	eax, DWORD PTR n$30[rsp]
	inc	eax
	mov	DWORD PTR n$30[rsp], eax
$LN4@InputTextE:
	mov	rax, QWORD PTR io$[rsp]
	mov	eax, DWORD PTR [rax+5440]
	cmp	DWORD PTR n$30[rsp], eax
	jge	SHORT $LN3@InputTextE

; 3789 : 				{
; 3790 : 					// Insert character if they pass filtering
; 3791 : 					unsigned int c = (unsigned int)io.InputQueueCharacters[n];

	mov	rax, QWORD PTR io$[rsp]
	add	rax, 5440				; 00001540H
	mov	QWORD PTR tv620[rsp], rax
	mov	edx, DWORD PTR n$30[rsp]
	mov	rcx, QWORD PTR tv620[rsp]
	call	??A?$ImVector@G@@QEAAAEAGH@Z		; ImVector<unsigned short>::operator[]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR c$47[rsp], eax

; 3792 : 					if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))

	mov	r9, QWORD PTR callback_user_data$[rsp]
	mov	r8, QWORD PTR callback$[rsp]
	mov	edx, DWORD PTR flags$[rsp]
	lea	rcx, QWORD PTR c$47[rsp]
	call	?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; InputTextFilterCharacter
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN56@InputTextE

; 3793 : 						edit_state.OnKeyPressed((int)c);

	mov	edx, DWORD PTR c$47[rsp]
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1
$LN56@InputTextE:

; 3794 : 				}

	jmp	$LN2@InputTextE
$LN3@InputTextE:
$LN55@InputTextE:

; 3795 : 
; 3796 : 			// Consume characters
; 3797 : 			io.InputQueueCharacters.resize(0);

	mov	rax, QWORD PTR io$[rsp]
	add	rax, 5440				; 00001540H
	mov	QWORD PTR tv635[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv635[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize
	npad	1
$LN54@InputTextE:
$LN41@InputTextE:

; 3798 : 		}
; 3799 : 	}
; 3800 : 
; 3801 : 	bool cancel_edit = false;

	mov	BYTE PTR cancel_edit$[rsp], 0

; 3802 : 	if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	$LN57@InputTextE
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	test	eax, eax
	jne	$LN57@InputTextE
	movzx	eax, BYTE PTR clear_active_id$[rsp]
	test	eax, eax
	jne	$LN57@InputTextE

; 3803 : 	{
; 3804 : 		// Handle key-presses
; 3805 : 		const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);

	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+288]
	test	eax, eax
	je	SHORT $LN226@InputTextE
	mov	DWORD PTR tv646[rsp], 131072		; 00020000H
	jmp	SHORT $LN227@InputTextE
$LN226@InputTextE:
	mov	DWORD PTR tv646[rsp], 0
$LN227@InputTextE:
	mov	eax, DWORD PTR tv646[rsp]
	mov	DWORD PTR k_mask$10[rsp], eax

; 3806 : 		const bool is_osx = io.ConfigMacOSXBehaviors;

	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+192]
	mov	BYTE PTR is_osx$2[rsp], al

; 3807 : 		const bool is_shortcut_key = (is_osx ? (io.KeySuper && !io.KeyCtrl) : (io.KeyCtrl && !io.KeySuper)) && !io.KeyAlt && !io.KeyShift; // OS X style: Shortcuts using Cmd/Super instead of Ctrl

	movzx	eax, BYTE PTR is_osx$2[rsp]
	test	eax, eax
	je	SHORT $LN232@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+316]
	test	eax, eax
	je	SHORT $LN228@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	jne	SHORT $LN228@InputTextE
	mov	DWORD PTR tv661[rsp], 1
	jmp	SHORT $LN231@InputTextE
$LN228@InputTextE:
	mov	DWORD PTR tv661[rsp], 0
$LN231@InputTextE:
	mov	eax, DWORD PTR tv661[rsp]
	mov	DWORD PTR tv664[rsp], eax
	jmp	SHORT $LN233@InputTextE
$LN232@InputTextE:
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	je	SHORT $LN229@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+316]
	test	eax, eax
	jne	SHORT $LN229@InputTextE
	mov	DWORD PTR tv660[rsp], 1
	jmp	SHORT $LN230@InputTextE
$LN229@InputTextE:
	mov	DWORD PTR tv660[rsp], 0
$LN230@InputTextE:
	mov	eax, DWORD PTR tv660[rsp]
	mov	DWORD PTR tv664[rsp], eax
$LN233@InputTextE:
	cmp	DWORD PTR tv664[rsp], 0
	je	SHORT $LN234@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+308]
	test	eax, eax
	jne	SHORT $LN234@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+288]
	test	eax, eax
	jne	SHORT $LN234@InputTextE
	mov	BYTE PTR tv704[rsp], 1
	jmp	SHORT $LN235@InputTextE
$LN234@InputTextE:
	mov	BYTE PTR tv704[rsp], 0
$LN235@InputTextE:
	movzx	eax, BYTE PTR tv704[rsp]
	mov	BYTE PTR is_shortcut_key$1[rsp], al

; 3808 : 		const bool is_osx_shift_shortcut = is_osx && io.KeySuper && io.KeyShift && !io.KeyCtrl && !io.KeyAlt;

	movzx	eax, BYTE PTR is_osx$2[rsp]
	test	eax, eax
	je	SHORT $LN236@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+316]
	test	eax, eax
	je	SHORT $LN236@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+288]
	test	eax, eax
	je	SHORT $LN236@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	jne	SHORT $LN236@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+308]
	test	eax, eax
	jne	SHORT $LN236@InputTextE
	mov	BYTE PTR tv719[rsp], 1
	jmp	SHORT $LN237@InputTextE
$LN236@InputTextE:
	mov	BYTE PTR tv719[rsp], 0
$LN237@InputTextE:
	movzx	eax, BYTE PTR tv719[rsp]
	mov	BYTE PTR is_osx_shift_shortcut$13[rsp], al

; 3809 : 		const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl

	movzx	eax, BYTE PTR is_osx$2[rsp]
	test	eax, eax
	je	SHORT $LN238@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+308]
	mov	BYTE PTR tv724[rsp], al
	jmp	SHORT $LN239@InputTextE
$LN238@InputTextE:
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	mov	BYTE PTR tv724[rsp], al
$LN239@InputTextE:
	movzx	eax, BYTE PTR tv724[rsp]
	mov	BYTE PTR is_wordmove_key_down$5[rsp], al

; 3810 : 		const bool is_startend_key_down = is_osx && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End

	movzx	eax, BYTE PTR is_osx$2[rsp]
	test	eax, eax
	je	SHORT $LN240@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+316]
	test	eax, eax
	je	SHORT $LN240@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	jne	SHORT $LN240@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+308]
	test	eax, eax
	jne	SHORT $LN240@InputTextE
	mov	BYTE PTR tv736[rsp], 1
	jmp	SHORT $LN241@InputTextE
$LN240@InputTextE:
	mov	BYTE PTR tv736[rsp], 0
$LN241@InputTextE:
	movzx	eax, BYTE PTR tv736[rsp]
	mov	BYTE PTR is_startend_key_down$3[rsp], al

; 3811 : 		const bool is_ctrl_key_only = io.KeyCtrl && !io.KeyShift && !io.KeyAlt && !io.KeySuper;

	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	je	SHORT $LN242@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+288]
	test	eax, eax
	jne	SHORT $LN242@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+308]
	test	eax, eax
	jne	SHORT $LN242@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+316]
	test	eax, eax
	jne	SHORT $LN242@InputTextE
	mov	BYTE PTR tv749[rsp], 1
	jmp	SHORT $LN243@InputTextE
$LN242@InputTextE:
	mov	BYTE PTR tv749[rsp], 0
$LN243@InputTextE:
	movzx	eax, BYTE PTR tv749[rsp]
	mov	BYTE PTR is_ctrl_key_only$22[rsp], al

; 3812 : 		const bool is_shift_key_only = io.KeyShift && !io.KeyCtrl && !io.KeyAlt && !io.KeySuper;

	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+288]
	test	eax, eax
	je	SHORT $LN244@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	jne	SHORT $LN244@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+308]
	test	eax, eax
	jne	SHORT $LN244@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+316]
	test	eax, eax
	jne	SHORT $LN244@InputTextE
	mov	BYTE PTR tv762[rsp], 1
	jmp	SHORT $LN245@InputTextE
$LN244@InputTextE:
	mov	BYTE PTR tv762[rsp], 0
$LN245@InputTextE:
	movzx	eax, BYTE PTR tv762[rsp]
	mov	BYTE PTR is_shift_key_only$6[rsp], al

; 3813 : 
; 3814 : 		const bool is_cut = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_X)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Delete))) && is_editable && !is_password && (!is_multiline || edit_state.HasSelection());

	movzx	eax, BYTE PTR is_shortcut_key$1[rsp]
	test	eax, eax
	je	SHORT $LN246@InputTextE
	mov	dl, 1
	mov	ecx, 18
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN248@InputTextE
$LN246@InputTextE:
	movzx	eax, BYTE PTR is_shift_key_only$6[rsp]
	test	eax, eax
	je	SHORT $LN247@InputTextE
	mov	dl, 1
	mov	ecx, 10
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN247@InputTextE
$LN248@InputTextE:
	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	SHORT $LN247@InputTextE
	movzx	eax, BYTE PTR is_password$[rsp]
	test	eax, eax
	jne	SHORT $LN247@InputTextE
	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN249@InputTextE
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?HasSelection@ImGuiInputTextState@@QEBA_NXZ ; ImGuiInputTextState::HasSelection
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN247@InputTextE
$LN249@InputTextE:
	mov	BYTE PTR tv787[rsp], 1
	jmp	SHORT $LN250@InputTextE
$LN247@InputTextE:
	mov	BYTE PTR tv787[rsp], 0
$LN250@InputTextE:
	movzx	eax, BYTE PTR tv787[rsp]
	mov	BYTE PTR is_cut$9[rsp], al

; 3815 : 		const bool is_copy = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_C)) || (is_ctrl_key_only && IsKeyPressedMap(ImGuiKey_Insert))) && !is_password && (!is_multiline || edit_state.HasSelection());

	movzx	eax, BYTE PTR is_shortcut_key$1[rsp]
	test	eax, eax
	je	SHORT $LN251@InputTextE
	mov	dl, 1
	mov	ecx, 16
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN253@InputTextE
$LN251@InputTextE:
	movzx	eax, BYTE PTR is_ctrl_key_only$22[rsp]
	test	eax, eax
	je	SHORT $LN252@InputTextE
	mov	dl, 1
	mov	ecx, 9
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN252@InputTextE
$LN253@InputTextE:
	movzx	eax, BYTE PTR is_password$[rsp]
	test	eax, eax
	jne	SHORT $LN252@InputTextE
	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN254@InputTextE
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?HasSelection@ImGuiInputTextState@@QEBA_NXZ ; ImGuiInputTextState::HasSelection
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN252@InputTextE
$LN254@InputTextE:
	mov	BYTE PTR tv810[rsp], 1
	jmp	SHORT $LN255@InputTextE
$LN252@InputTextE:
	mov	BYTE PTR tv810[rsp], 0
$LN255@InputTextE:
	movzx	eax, BYTE PTR tv810[rsp]
	mov	BYTE PTR is_copy$15[rsp], al

; 3816 : 		const bool is_paste = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_V)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Insert))) && is_editable;

	movzx	eax, BYTE PTR is_shortcut_key$1[rsp]
	test	eax, eax
	je	SHORT $LN256@InputTextE
	mov	dl, 1
	mov	ecx, 17
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN258@InputTextE
$LN256@InputTextE:
	movzx	eax, BYTE PTR is_shift_key_only$6[rsp]
	test	eax, eax
	je	SHORT $LN257@InputTextE
	mov	dl, 1
	mov	ecx, 9
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN257@InputTextE
$LN258@InputTextE:
	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	SHORT $LN257@InputTextE
	mov	BYTE PTR tv827[rsp], 1
	jmp	SHORT $LN259@InputTextE
$LN257@InputTextE:
	mov	BYTE PTR tv827[rsp], 0
$LN259@InputTextE:
	movzx	eax, BYTE PTR tv827[rsp]
	mov	BYTE PTR is_paste$16[rsp], al

; 3817 : 		const bool is_undo = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Z)) && is_editable && is_undoable);

	movzx	eax, BYTE PTR is_shortcut_key$1[rsp]
	test	eax, eax
	je	SHORT $LN260@InputTextE
	mov	dl, 1
	mov	ecx, 20
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN260@InputTextE
	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	SHORT $LN260@InputTextE
	movzx	eax, BYTE PTR is_undoable$[rsp]
	test	eax, eax
	je	SHORT $LN260@InputTextE
	mov	BYTE PTR tv839[rsp], 1
	jmp	SHORT $LN261@InputTextE
$LN260@InputTextE:
	mov	BYTE PTR tv839[rsp], 0
$LN261@InputTextE:
	movzx	eax, BYTE PTR tv839[rsp]
	mov	BYTE PTR is_undo$8[rsp], al

; 3818 : 		const bool is_redo = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Y)) || (is_osx_shift_shortcut && IsKeyPressedMap(ImGuiKey_Z))) && is_editable && is_undoable;

	movzx	eax, BYTE PTR is_shortcut_key$1[rsp]
	test	eax, eax
	je	SHORT $LN262@InputTextE
	mov	dl, 1
	mov	ecx, 19
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN264@InputTextE
$LN262@InputTextE:
	movzx	eax, BYTE PTR is_osx_shift_shortcut$13[rsp]
	test	eax, eax
	je	SHORT $LN263@InputTextE
	mov	dl, 1
	mov	ecx, 20
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN263@InputTextE
$LN264@InputTextE:
	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	SHORT $LN263@InputTextE
	movzx	eax, BYTE PTR is_undoable$[rsp]
	test	eax, eax
	je	SHORT $LN263@InputTextE
	mov	BYTE PTR tv858[rsp], 1
	jmp	SHORT $LN265@InputTextE
$LN263@InputTextE:
	mov	BYTE PTR tv858[rsp], 0
$LN265@InputTextE:
	movzx	eax, BYTE PTR tv858[rsp]
	mov	BYTE PTR is_redo$14[rsp], al

; 3819 : 
; 3820 : 		if (IsKeyPressedMap(ImGuiKey_LeftArrow)) { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }

	mov	dl, 1
	mov	ecx, 1
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN58@InputTextE
	movzx	eax, BYTE PTR is_startend_key_down$3[rsp]
	test	eax, eax
	je	SHORT $LN268@InputTextE
	mov	DWORD PTR tv870[rsp], 65540		; 00010004H
	jmp	SHORT $LN269@InputTextE
$LN268@InputTextE:
	movzx	eax, BYTE PTR is_wordmove_key_down$5[rsp]
	test	eax, eax
	je	SHORT $LN266@InputTextE
	mov	DWORD PTR tv867[rsp], 65548		; 0001000cH
	jmp	SHORT $LN267@InputTextE
$LN266@InputTextE:
	mov	DWORD PTR tv867[rsp], 65536		; 00010000H
$LN267@InputTextE:
	mov	eax, DWORD PTR tv867[rsp]
	mov	DWORD PTR tv870[rsp], eax
$LN269@InputTextE:
	mov	eax, DWORD PTR k_mask$10[rsp]
	mov	ecx, DWORD PTR tv870[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1
	jmp	$LN59@InputTextE
$LN58@InputTextE:

; 3821 : 		else if (IsKeyPressedMap(ImGuiKey_RightArrow)) { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }

	mov	dl, 1
	mov	ecx, 2
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN60@InputTextE
	movzx	eax, BYTE PTR is_startend_key_down$3[rsp]
	test	eax, eax
	je	SHORT $LN272@InputTextE
	mov	DWORD PTR tv884[rsp], 65541		; 00010005H
	jmp	SHORT $LN273@InputTextE
$LN272@InputTextE:
	movzx	eax, BYTE PTR is_wordmove_key_down$5[rsp]
	test	eax, eax
	je	SHORT $LN270@InputTextE
	mov	DWORD PTR tv881[rsp], 65549		; 0001000dH
	jmp	SHORT $LN271@InputTextE
$LN270@InputTextE:
	mov	DWORD PTR tv881[rsp], 65537		; 00010001H
$LN271@InputTextE:
	mov	eax, DWORD PTR tv881[rsp]
	mov	DWORD PTR tv884[rsp], eax
$LN273@InputTextE:
	mov	eax, DWORD PTR k_mask$10[rsp]
	mov	ecx, DWORD PTR tv884[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1
	jmp	$LN61@InputTextE
$LN60@InputTextE:

; 3822 : 		else if (IsKeyPressedMap(ImGuiKey_UpArrow) && is_multiline) { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }

	mov	dl, 1
	mov	ecx, 3
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	$LN62@InputTextE
	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	$LN62@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	je	SHORT $LN64@InputTextE
	mov	rax, QWORD PTR draw_window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+96]
	subss	xmm0, DWORD PTR [rcx+6408]
	xorps	xmm1, xmm1
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR draw_window$[rsp]
	call	?SetWindowScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z ; ImGui::SetWindowScrollY
	npad	1
	jmp	SHORT $LN65@InputTextE
$LN64@InputTextE:
	movzx	eax, BYTE PTR is_startend_key_down$3[rsp]
	test	eax, eax
	je	SHORT $LN274@InputTextE
	mov	DWORD PTR tv909[rsp], 65542		; 00010006H
	jmp	SHORT $LN275@InputTextE
$LN274@InputTextE:
	mov	DWORD PTR tv909[rsp], 65538		; 00010002H
$LN275@InputTextE:
	mov	eax, DWORD PTR k_mask$10[rsp]
	mov	ecx, DWORD PTR tv909[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1
$LN65@InputTextE:
	jmp	$LN63@InputTextE
$LN62@InputTextE:

; 3823 : 		else if (IsKeyPressedMap(ImGuiKey_DownArrow) && is_multiline) { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }

	mov	dl, 1
	mov	ecx, 4
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	$LN66@InputTextE
	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	$LN66@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	je	SHORT $LN68@InputTextE
	call	?GetScrollMaxY@ImGui@@YAMXZ		; ImGui::GetScrollMaxY
	movss	DWORD PTR tv933[rsp], xmm0
	mov	rax, QWORD PTR draw_window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+96]
	addss	xmm0, DWORD PTR [rcx+6408]
	movss	DWORD PTR tv931[rsp], xmm0
	movss	xmm1, DWORD PTR tv933[rsp]
	movss	xmm0, DWORD PTR tv931[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR draw_window$[rsp]
	call	?SetWindowScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z ; ImGui::SetWindowScrollY
	npad	1
	jmp	SHORT $LN69@InputTextE
$LN68@InputTextE:
	movzx	eax, BYTE PTR is_startend_key_down$3[rsp]
	test	eax, eax
	je	SHORT $LN276@InputTextE
	mov	DWORD PTR tv939[rsp], 65543		; 00010007H
	jmp	SHORT $LN277@InputTextE
$LN276@InputTextE:
	mov	DWORD PTR tv939[rsp], 65539		; 00010003H
$LN277@InputTextE:
	mov	eax, DWORD PTR k_mask$10[rsp]
	mov	ecx, DWORD PTR tv939[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1
$LN69@InputTextE:
	jmp	$LN67@InputTextE
$LN66@InputTextE:

; 3824 : 		else if (IsKeyPressedMap(ImGuiKey_Home)) { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }

	mov	dl, 1
	mov	ecx, 7
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN70@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	je	SHORT $LN278@InputTextE
	mov	eax, DWORD PTR k_mask$10[rsp]
	or	eax, 65542				; 00010006H
	mov	DWORD PTR tv953[rsp], eax
	jmp	SHORT $LN279@InputTextE
$LN278@InputTextE:
	mov	eax, DWORD PTR k_mask$10[rsp]
	or	eax, 65540				; 00010004H
	mov	DWORD PTR tv953[rsp], eax
$LN279@InputTextE:
	mov	edx, DWORD PTR tv953[rsp]
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1
	jmp	$LN71@InputTextE
$LN70@InputTextE:

; 3825 : 		else if (IsKeyPressedMap(ImGuiKey_End)) { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }

	mov	dl, 1
	mov	ecx, 8
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN72@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	je	SHORT $LN280@InputTextE
	mov	eax, DWORD PTR k_mask$10[rsp]
	or	eax, 65543				; 00010007H
	mov	DWORD PTR tv966[rsp], eax
	jmp	SHORT $LN281@InputTextE
$LN280@InputTextE:
	mov	eax, DWORD PTR k_mask$10[rsp]
	or	eax, 65541				; 00010005H
	mov	DWORD PTR tv966[rsp], eax
$LN281@InputTextE:
	mov	edx, DWORD PTR tv966[rsp]
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1
	jmp	$LN73@InputTextE
$LN72@InputTextE:

; 3826 : 		else if (IsKeyPressedMap(ImGuiKey_Delete) && is_editable) { edit_state.OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask); }

	mov	dl, 1
	mov	ecx, 10
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN74@InputTextE
	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	SHORT $LN74@InputTextE
	mov	eax, DWORD PTR k_mask$10[rsp]
	or	eax, 65544				; 00010008H
	mov	edx, eax
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1
	jmp	$LN75@InputTextE
$LN74@InputTextE:

; 3827 : 		else if (IsKeyPressedMap(ImGuiKey_Backspace) && is_editable)

	mov	dl, 1
	mov	ecx, 11
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	$LN76@InputTextE
	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	$LN76@InputTextE

; 3828 : 		{
; 3829 : 			if (!edit_state.HasSelection())

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?HasSelection@ImGuiInputTextState@@QEBA_NXZ ; ImGuiInputTextState::HasSelection
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN78@InputTextE

; 3830 : 			{
; 3831 : 				if (is_wordmove_key_down) edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT);

	movzx	eax, BYTE PTR is_wordmove_key_down$5[rsp]
	test	eax, eax
	je	SHORT $LN79@InputTextE
	mov	edx, 196620				; 0003000cH
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1
	jmp	SHORT $LN80@InputTextE
$LN79@InputTextE:

; 3832 : 				else if (is_osx && io.KeySuper && !io.KeyAlt && !io.KeyCtrl) edit_state.OnKeyPressed(STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT);

	movzx	eax, BYTE PTR is_osx$2[rsp]
	test	eax, eax
	je	SHORT $LN81@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+316]
	test	eax, eax
	je	SHORT $LN81@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+308]
	test	eax, eax
	jne	SHORT $LN81@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	jne	SHORT $LN81@InputTextE
	mov	edx, 196612				; 00030004H
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1
$LN81@InputTextE:
$LN80@InputTextE:
$LN78@InputTextE:

; 3833 : 			}
; 3834 : 			edit_state.OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);

	mov	eax, DWORD PTR k_mask$10[rsp]
	or	eax, 65545				; 00010009H
	mov	edx, eax
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1

; 3835 : 		}

	jmp	$LN77@InputTextE
$LN76@InputTextE:

; 3836 : 		else if (IsKeyPressedMap(ImGuiKey_Enter))

	mov	dl, 1
	mov	ecx, 13
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	$LN82@InputTextE

; 3837 : 		{
; 3838 : 			bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $LN282@InputTextE
	mov	DWORD PTR tv1016[rsp], 1
	jmp	SHORT $LN283@InputTextE
$LN282@InputTextE:
	mov	DWORD PTR tv1016[rsp], 0
$LN283@InputTextE:
	movzx	eax, BYTE PTR tv1016[rsp]
	mov	BYTE PTR ctrl_enter_for_new_line$7[rsp], al

; 3839 : 			if (!is_multiline || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN86@InputTextE
	movzx	eax, BYTE PTR ctrl_enter_for_new_line$7[rsp]
	test	eax, eax
	je	SHORT $LN87@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	je	SHORT $LN86@InputTextE
$LN87@InputTextE:
	movzx	eax, BYTE PTR ctrl_enter_for_new_line$7[rsp]
	test	eax, eax
	jne	SHORT $LN84@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	je	SHORT $LN84@InputTextE
$LN86@InputTextE:

; 3840 : 			{
; 3841 : 				enter_pressed = clear_active_id = true;

	mov	BYTE PTR clear_active_id$[rsp], 1
	movzx	eax, BYTE PTR clear_active_id$[rsp]
	mov	BYTE PTR enter_pressed$[rsp], al

; 3842 : 			}

	jmp	SHORT $LN85@InputTextE
$LN84@InputTextE:

; 3843 : 			else if (is_editable)

	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	SHORT $LN88@InputTextE

; 3844 : 			{
; 3845 : 				unsigned int c = '\n'; // Insert new line

	mov	DWORD PTR c$38[rsp], 10

; 3846 : 				if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))

	mov	r9, QWORD PTR callback_user_data$[rsp]
	mov	r8, QWORD PTR callback$[rsp]
	mov	edx, DWORD PTR flags$[rsp]
	lea	rcx, QWORD PTR c$38[rsp]
	call	?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; InputTextFilterCharacter
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN89@InputTextE

; 3847 : 					edit_state.OnKeyPressed((int)c);

	mov	edx, DWORD PTR c$38[rsp]
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1
$LN89@InputTextE:
$LN88@InputTextE:
$LN85@InputTextE:

; 3848 : 			}
; 3849 : 		}

	jmp	$LN83@InputTextE
$LN82@InputTextE:

; 3850 : 		else if ((flags & ImGuiInputTextFlags_AllowTabInput) && IsKeyPressedMap(ImGuiKey_Tab) && !io.KeyCtrl && !io.KeyShift && !io.KeyAlt && is_editable)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	$LN90@InputTextE
	mov	dl, 1
	xor	ecx, ecx
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	$LN90@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+309]
	test	eax, eax
	jne	SHORT $LN90@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+288]
	test	eax, eax
	jne	SHORT $LN90@InputTextE
	mov	rax, QWORD PTR io$[rsp]
	movzx	eax, BYTE PTR [rax+308]
	test	eax, eax
	jne	SHORT $LN90@InputTextE
	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	SHORT $LN90@InputTextE

; 3851 : 		{
; 3852 : 			unsigned int c = '\t'; // Insert TAB

	mov	DWORD PTR c$39[rsp], 9

; 3853 : 			if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))

	mov	r9, QWORD PTR callback_user_data$[rsp]
	mov	r8, QWORD PTR callback$[rsp]
	mov	edx, DWORD PTR flags$[rsp]
	lea	rcx, QWORD PTR c$39[rsp]
	call	?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; InputTextFilterCharacter
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN92@InputTextE

; 3854 : 				edit_state.OnKeyPressed((int)c);

	mov	edx, DWORD PTR c$39[rsp]
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed
	npad	1
$LN92@InputTextE:

; 3855 : 		}

	jmp	$LN91@InputTextE
$LN90@InputTextE:

; 3856 : 		else if (IsKeyPressedMap(ImGuiKey_Escape))

	mov	dl, 1
	mov	ecx, 14
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN93@InputTextE

; 3857 : 		{
; 3858 : 			clear_active_id = cancel_edit = true;

	mov	BYTE PTR cancel_edit$[rsp], 1
	movzx	eax, BYTE PTR cancel_edit$[rsp]
	mov	BYTE PTR clear_active_id$[rsp], al

; 3859 : 		}

	jmp	$LN94@InputTextE
$LN93@InputTextE:

; 3860 : 		else if (is_undo || is_redo)

	movzx	eax, BYTE PTR is_undo$8[rsp]
	test	eax, eax
	jne	SHORT $LN97@InputTextE
	movzx	eax, BYTE PTR is_redo$14[rsp]
	test	eax, eax
	je	SHORT $LN95@InputTextE
$LN97@InputTextE:

; 3861 : 		{
; 3862 : 			edit_state.OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);

	movzx	eax, BYTE PTR is_undo$8[rsp]
	test	eax, eax
	je	SHORT $LN284@InputTextE
	mov	DWORD PTR tv1080[rsp], 65546		; 0001000aH
	jmp	SHORT $LN285@InputTextE
$LN284@InputTextE:
	mov	DWORD PTR tv1080[rsp], 65547		; 0001000bH
$LN285@InputTextE:
	mov	edx, DWORD PTR tv1080[rsp]
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ; ImGuiInputTextState::OnKeyPressed

; 3863 : 			edit_state.ClearSelection();

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?ClearSelection@ImGuiInputTextState@@QEAAXXZ ; ImGuiInputTextState::ClearSelection
	npad	1

; 3864 : 		}

	jmp	$LN96@InputTextE
$LN95@InputTextE:

; 3865 : 		else if (is_shortcut_key && IsKeyPressedMap(ImGuiKey_A))

	movzx	eax, BYTE PTR is_shortcut_key$1[rsp]
	test	eax, eax
	je	SHORT $LN98@InputTextE
	mov	dl, 1
	mov	ecx, 15
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN98@InputTextE

; 3866 : 		{
; 3867 : 			edit_state.SelectAll();

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?SelectAll@ImGuiInputTextState@@QEAAXXZ	; ImGuiInputTextState::SelectAll

; 3868 : 			edit_state.CursorFollow = true;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	BYTE PTR [rax+3700], 1

; 3869 : 		}

	jmp	$LN99@InputTextE
$LN98@InputTextE:

; 3870 : 		else if (is_cut || is_copy)

	movzx	eax, BYTE PTR is_cut$9[rsp]
	test	eax, eax
	jne	SHORT $LN102@InputTextE
	movzx	eax, BYTE PTR is_copy$15[rsp]
	test	eax, eax
	je	$LN100@InputTextE
$LN102@InputTextE:

; 3871 : 		{
; 3872 : 			// Cut, Copy
; 3873 : 			if (io.SetClipboardTextFn)

	mov	rax, QWORD PTR io$[rsp]
	cmp	QWORD PTR [rax+240], 0
	je	$LN103@InputTextE

; 3874 : 			{
; 3875 : 				const int ib = edit_state.HasSelection() ? ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end) : 0;

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?HasSelection@ImGuiInputTextState@@QEBA_NXZ ; ImGuiInputTextState::HasSelection
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN286@InputTextE
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	edx, DWORD PTR [rax+88]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR [rax+84]
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	mov	DWORD PTR tv1109[rsp], eax
	jmp	SHORT $LN287@InputTextE
$LN286@InputTextE:
	mov	DWORD PTR tv1109[rsp], 0
$LN287@InputTextE:
	mov	eax, DWORD PTR tv1109[rsp]
	mov	DWORD PTR ib$41[rsp], eax

; 3876 : 				const int ie = edit_state.HasSelection() ? ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end) : edit_state.CurLenW;

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?HasSelection@ImGuiInputTextState@@QEBA_NXZ ; ImGuiInputTextState::HasSelection
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN288@InputTextE
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	edx, DWORD PTR [rax+88]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR [rax+84]
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	DWORD PTR tv1122[rsp], eax
	jmp	SHORT $LN289@InputTextE
$LN288@InputTextE:
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv1122[rsp], eax
$LN289@InputTextE:
	mov	eax, DWORD PTR tv1122[rsp]
	mov	DWORD PTR ie$40[rsp], eax

; 3877 : 				edit_state.TempBuffer.resize((ie - ib) * 4 + 1);

	mov	rax, QWORD PTR edit_state$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv1130[rsp], rax
	mov	eax, DWORD PTR ib$41[rsp]
	mov	ecx, DWORD PTR ie$40[rsp]
	sub	ecx, eax
	mov	eax, ecx
	lea	eax, DWORD PTR [rax*4+1]
	mov	edx, eax
	mov	rcx, QWORD PTR tv1130[rsp]
	call	?resize@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::resize

; 3878 : 				ImTextStrToUtf8(edit_state.TempBuffer.Data, edit_state.TempBuffer.Size, edit_state.TextW.Data + ib, edit_state.TextW.Data + ie);

	movsxd	rax, DWORD PTR ie$40[rsp]
	mov	rcx, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [rcx+rax*2]
	movsxd	rcx, DWORD PTR ib$41[rsp]
	mov	rdx, QWORD PTR edit_state$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rdx+rcx*2]
	mov	r9, rax
	mov	r8, rcx
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	edx, DWORD PTR [rax+56]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR [rax+64]
	call	?ImTextStrToUtf8@@YAHPEADHPEBG1@Z	; ImTextStrToUtf8

; 3879 : 				SetClipboardText(edit_state.TempBuffer.Data);

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR [rax+64]
	call	?SetClipboardText@ImGui@@YAXPEBD@Z	; ImGui::SetClipboardText
	npad	1
$LN103@InputTextE:

; 3880 : 			}
; 3881 : 			if (is_cut)

	movzx	eax, BYTE PTR is_cut$9[rsp]
	test	eax, eax
	je	SHORT $LN104@InputTextE

; 3882 : 			{
; 3883 : 				if (!edit_state.HasSelection())

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?HasSelection@ImGuiInputTextState@@QEBA_NXZ ; ImGuiInputTextState::HasSelection
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN105@InputTextE

; 3884 : 					edit_state.SelectAll();

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?SelectAll@ImGuiInputTextState@@QEAAXXZ	; ImGuiInputTextState::SelectAll
	npad	1
$LN105@InputTextE:

; 3885 : 				edit_state.CursorFollow = true;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	BYTE PTR [rax+3700], 1

; 3886 : 				stb_textedit_cut(&edit_state, &edit_state.StbState);

	mov	rax, QWORD PTR edit_state$[rsp]
	add	rax, 80					; 00000050H
	mov	rdx, rax
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?stb_textedit_cut@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_cut
	npad	1
$LN104@InputTextE:

; 3887 : 			}
; 3888 : 		}

	jmp	$LN101@InputTextE
$LN100@InputTextE:

; 3889 : 		else if (is_paste)

	movzx	eax, BYTE PTR is_paste$16[rsp]
	test	eax, eax
	je	$LN106@InputTextE

; 3890 : 		{
; 3891 : 			if (const char* clipboard = GetClipboardText())

	call	?GetClipboardText@ImGui@@YAPEBDXZ	; ImGui::GetClipboardText
	mov	QWORD PTR clipboard$62[rsp], rax
	cmp	QWORD PTR clipboard$62[rsp], 0
	je	$LN107@InputTextE

; 3892 : 			{
; 3893 : 				// Filter pasted buffer
; 3894 : 				const int clipboard_len = (int)strlen(clipboard);

	mov	rcx, QWORD PTR clipboard$62[rsp]
	call	strlen
	mov	DWORD PTR clipboard_len$59[rsp], eax

; 3895 : 				ImWchar* clipboard_filtered = (ImWchar*)MemAlloc((clipboard_len + 1) * sizeof(ImWchar));

	mov	eax, DWORD PTR clipboard_len$59[rsp]
	inc	eax
	cdqe
	shl	rax, 1
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR clipboard_filtered$50[rsp], rax

; 3896 : 				int clipboard_filtered_len = 0;

	mov	DWORD PTR clipboard_filtered_len$23[rsp], 0

; 3897 : 				for (const char* s = clipboard; *s; )

	mov	rax, QWORD PTR clipboard$62[rsp]
	mov	QWORD PTR s$51[rsp], rax
$LN5@InputTextE:
	mov	rax, QWORD PTR s$51[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN6@InputTextE

; 3898 : 				{
; 3899 : 					unsigned int c;
; 3900 : 					s += ImTextCharFromUtf8(&c, s, NULL);

	xor	r8d, r8d
	mov	rdx, QWORD PTR s$51[rsp]
	lea	rcx, QWORD PTR c$29[rsp]
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8
	cdqe
	mov	rcx, QWORD PTR s$51[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR s$51[rsp], rax

; 3901 : 					if (c == 0)

	cmp	DWORD PTR c$29[rsp], 0
	jne	SHORT $LN108@InputTextE

; 3902 : 						break;

	jmp	SHORT $LN6@InputTextE
$LN108@InputTextE:

; 3903 : 					if (c >= 0x10000 || !InputTextFilterCharacter(&c, flags, callback, callback_user_data))

	cmp	DWORD PTR c$29[rsp], 65536		; 00010000H
	jae	SHORT $LN110@InputTextE
	mov	r9, QWORD PTR callback_user_data$[rsp]
	mov	r8, QWORD PTR callback$[rsp]
	mov	edx, DWORD PTR flags$[rsp]
	lea	rcx, QWORD PTR c$29[rsp]
	call	?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; InputTextFilterCharacter
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN109@InputTextE
$LN110@InputTextE:

; 3904 : 						continue;

	jmp	$LN5@InputTextE
$LN109@InputTextE:

; 3905 : 					clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;

	movsxd	rax, DWORD PTR clipboard_filtered_len$23[rsp]
	mov	rcx, QWORD PTR clipboard_filtered$50[rsp]
	movzx	edx, WORD PTR c$29[rsp]
	mov	WORD PTR [rcx+rax*2], dx
	mov	eax, DWORD PTR clipboard_filtered_len$23[rsp]
	inc	eax
	mov	DWORD PTR clipboard_filtered_len$23[rsp], eax

; 3906 : 				}

	jmp	$LN5@InputTextE
$LN6@InputTextE:

; 3907 : 				clipboard_filtered[clipboard_filtered_len] = 0;

	movsxd	rax, DWORD PTR clipboard_filtered_len$23[rsp]
	xor	ecx, ecx
	mov	rdx, QWORD PTR clipboard_filtered$50[rsp]
	mov	WORD PTR [rdx+rax*2], cx

; 3908 : 				if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation

	cmp	DWORD PTR clipboard_filtered_len$23[rsp], 0
	jle	SHORT $LN111@InputTextE

; 3909 : 				{
; 3910 : 					stb_textedit_paste(&edit_state, &edit_state.StbState, clipboard_filtered, clipboard_filtered_len);

	mov	rax, QWORD PTR edit_state$[rsp]
	add	rax, 80					; 00000050H
	mov	r9d, DWORD PTR clipboard_filtered_len$23[rsp]
	mov	r8, QWORD PTR clipboard_filtered$50[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?stb_textedit_paste@ImGuiStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z ; ImGuiStb::stb_textedit_paste

; 3911 : 					edit_state.CursorFollow = true;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	BYTE PTR [rax+3700], 1
$LN111@InputTextE:

; 3912 : 				}
; 3913 : 				MemFree(clipboard_filtered);

	mov	rcx, QWORD PTR clipboard_filtered$50[rsp]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN107@InputTextE:
$LN106@InputTextE:
$LN101@InputTextE:
$LN99@InputTextE:
$LN96@InputTextE:
$LN94@InputTextE:
$LN91@InputTextE:
$LN83@InputTextE:
$LN77@InputTextE:
$LN75@InputTextE:
$LN73@InputTextE:
$LN71@InputTextE:
$LN67@InputTextE:
$LN63@InputTextE:
$LN61@InputTextE:
$LN59@InputTextE:
$LN57@InputTextE:

; 3914 : 			}
; 3915 : 		}
; 3916 : 	}
; 3917 : 
; 3918 : 	if (g.ActiveId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	$LN112@InputTextE

; 3919 : 	{
; 3920 : 		const char* apply_new_text = NULL;

	mov	QWORD PTR apply_new_text$49[rsp], 0

; 3921 : 		int apply_new_text_length = 0;

	mov	DWORD PTR apply_new_text_length$19[rsp], 0

; 3922 : 		if (cancel_edit)

	movzx	eax, BYTE PTR cancel_edit$[rsp]
	test	eax, eax
	je	SHORT $LN113@InputTextE

; 3923 : 		{
; 3924 : 			// Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.
; 3925 : 			if (is_editable && strcmp(buf, edit_state.InitialText.Data) != 0)

	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	SHORT $LN114@InputTextE
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rdx, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR buf$[rsp]
	call	strcmp
	test	eax, eax
	je	SHORT $LN114@InputTextE

; 3926 : 			{
; 3927 : 				apply_new_text = edit_state.InitialText.Data;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR apply_new_text$49[rsp], rax

; 3928 : 				apply_new_text_length = edit_state.InitialText.Size - 1;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	eax, DWORD PTR [rax+40]
	dec	eax
	mov	DWORD PTR apply_new_text_length$19[rsp], eax
$LN114@InputTextE:
$LN113@InputTextE:

; 3929 : 			}
; 3930 : 		}
; 3931 : 
; 3932 : 		// When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
; 3933 : 		// If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail. Also this allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage.
; 3934 : 		bool apply_edit_back_to_user_buffer = !cancel_edit || (enter_pressed && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);

	movzx	eax, BYTE PTR cancel_edit$[rsp]
	test	eax, eax
	je	SHORT $LN291@InputTextE
	movzx	eax, BYTE PTR enter_pressed$[rsp]
	test	eax, eax
	je	SHORT $LN290@InputTextE
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN291@InputTextE
$LN290@InputTextE:
	mov	DWORD PTR tv1230[rsp], 0
	jmp	SHORT $LN292@InputTextE
$LN291@InputTextE:
	mov	DWORD PTR tv1230[rsp], 1
$LN292@InputTextE:
	movzx	eax, BYTE PTR tv1230[rsp]
	mov	BYTE PTR apply_edit_back_to_user_buffer$17[rsp], al

; 3935 : 		if (apply_edit_back_to_user_buffer)

	movzx	eax, BYTE PTR apply_edit_back_to_user_buffer$17[rsp]
	test	eax, eax
	je	$LN115@InputTextE

; 3936 : 		{
; 3937 : 			// Apply new value immediately - copy modified buffer back
; 3938 : 			// Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
; 3939 : 			// FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.
; 3940 : 			// FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.
; 3941 : 			if (is_editable)

	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	SHORT $LN116@InputTextE

; 3942 : 			{
; 3943 : 				edit_state.TempBuffer.resize(edit_state.TextW.Size * 4 + 1);

	mov	rax, QWORD PTR edit_state$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv1244[rsp], rax
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	eax, DWORD PTR [rax+8]
	lea	eax, DWORD PTR [rax*4+1]
	mov	edx, eax
	mov	rcx, QWORD PTR tv1244[rsp]
	call	?resize@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::resize

; 3944 : 				ImTextStrToUtf8(edit_state.TempBuffer.Data, edit_state.TempBuffer.Size, edit_state.TextW.Data, NULL);

	xor	r9d, r9d
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	edx, DWORD PTR [rax+56]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR [rax+64]
	call	?ImTextStrToUtf8@@YAHPEADHPEBG1@Z	; ImTextStrToUtf8
	npad	1
$LN116@InputTextE:

; 3945 : 			}
; 3946 : 
; 3947 : 			// User callback
; 3948 : 			if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackAlways)) != 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 448				; 000001c0H
	test	eax, eax
	je	$LN117@InputTextE

; 3949 : 			{
; 3950 : 				IM_ASSERT(callback != NULL);
; 3951 : 
; 3952 : 				// The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
; 3953 : 				ImGuiInputTextFlags event_flag = 0;

	mov	DWORD PTR event_flag$24[rsp], 0

; 3954 : 				ImGuiKey event_key = ImGuiKey_COUNT;

	mov	DWORD PTR event_key$28[rsp], 21

; 3955 : 				if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && IsKeyPressedMap(ImGuiKey_Tab))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN118@InputTextE
	mov	dl, 1
	xor	ecx, ecx
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN118@InputTextE

; 3956 : 				{
; 3957 : 					event_flag = ImGuiInputTextFlags_CallbackCompletion;

	mov	DWORD PTR event_flag$24[rsp], 64	; 00000040H

; 3958 : 					event_key = ImGuiKey_Tab;

	mov	DWORD PTR event_key$28[rsp], 0

; 3959 : 				}

	jmp	$LN119@InputTextE
$LN118@InputTextE:

; 3960 : 				else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_UpArrow))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN120@InputTextE
	mov	dl, 1
	mov	ecx, 3
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN120@InputTextE

; 3961 : 				{
; 3962 : 					event_flag = ImGuiInputTextFlags_CallbackHistory;

	mov	DWORD PTR event_flag$24[rsp], 128	; 00000080H

; 3963 : 					event_key = ImGuiKey_UpArrow;

	mov	DWORD PTR event_key$28[rsp], 3

; 3964 : 				}

	jmp	SHORT $LN121@InputTextE
$LN120@InputTextE:

; 3965 : 				else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_DownArrow))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN122@InputTextE
	mov	dl, 1
	mov	ecx, 4
	call	?IsKeyPressedMap@ImGui@@YA_NH_N@Z	; ImGui::IsKeyPressedMap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN122@InputTextE

; 3966 : 				{
; 3967 : 					event_flag = ImGuiInputTextFlags_CallbackHistory;

	mov	DWORD PTR event_flag$24[rsp], 128	; 00000080H

; 3968 : 					event_key = ImGuiKey_DownArrow;

	mov	DWORD PTR event_key$28[rsp], 4

; 3969 : 				}

	jmp	SHORT $LN123@InputTextE
$LN122@InputTextE:

; 3970 : 				else if (flags & ImGuiInputTextFlags_CallbackAlways)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN124@InputTextE

; 3971 : 					event_flag = ImGuiInputTextFlags_CallbackAlways;

	mov	DWORD PTR event_flag$24[rsp], 256	; 00000100H
$LN124@InputTextE:
$LN123@InputTextE:
$LN121@InputTextE:
$LN119@InputTextE:

; 3972 : 
; 3973 : 				if (event_flag)

	cmp	DWORD PTR event_flag$24[rsp], 0
	je	$LN125@InputTextE

; 3974 : 				{
; 3975 : 					ImGuiInputTextCallbackData callback_data;

	lea	rcx, QWORD PTR callback_data$53[rsp]
	call	??0ImGuiInputTextCallbackData@@QEAA@XZ	; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData

; 3976 : 					memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));

	mov	r8d, 56					; 00000038H
	xor	edx, edx
	lea	rcx, QWORD PTR callback_data$53[rsp]
	call	memset

; 3977 : 					callback_data.EventFlag = event_flag;

	mov	eax, DWORD PTR event_flag$24[rsp]
	mov	DWORD PTR callback_data$53[rsp+4], eax

; 3978 : 					callback_data.Flags = flags;

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR callback_data$53[rsp], eax

; 3979 : 					callback_data.UserData = callback_user_data;

	mov	rax, QWORD PTR callback_user_data$[rsp]
	mov	QWORD PTR callback_data$53[rsp+8], rax

; 3980 : 
; 3981 : 					callback_data.EventKey = event_key;

	mov	eax, DWORD PTR event_key$28[rsp]
	mov	DWORD PTR callback_data$53[rsp+16], eax

; 3982 : 					callback_data.Buf = edit_state.TempBuffer.Data;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR callback_data$53[rsp+24], rax

; 3983 : 					callback_data.BufTextLen = edit_state.CurLenA;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR callback_data$53[rsp+36], eax

; 3984 : 					callback_data.BufSize = edit_state.BufCapacityA;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	eax, DWORD PTR [rax+76]
	mov	DWORD PTR callback_data$53[rsp+44], eax

; 3985 : 					callback_data.BufDirty = false;

	mov	BYTE PTR callback_data$53[rsp+32], 0

; 3986 : 
; 3987 : 					// We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)
; 3988 : 					ImWchar* text = edit_state.TextW.Data;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR text$35[rsp], rax

; 3989 : 					const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.cursor);

	mov	rax, QWORD PTR edit_state$[rsp]
	movsxd	rax, DWORD PTR [rax+80]
	mov	rcx, QWORD PTR text$35[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rdx, rax
	mov	rcx, QWORD PTR text$35[rsp]
	call	?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z ; ImTextCountUtf8BytesFromStr
	mov	DWORD PTR callback_data$53[rsp+48], eax
	mov	eax, DWORD PTR callback_data$53[rsp+48]
	mov	DWORD PTR utf8_cursor_pos$55[rsp], eax

; 3990 : 					const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_start);

	mov	rax, QWORD PTR edit_state$[rsp]
	movsxd	rax, DWORD PTR [rax+84]
	mov	rcx, QWORD PTR text$35[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rdx, rax
	mov	rcx, QWORD PTR text$35[rsp]
	call	?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z ; ImTextCountUtf8BytesFromStr
	mov	DWORD PTR callback_data$53[rsp+40], eax
	mov	eax, DWORD PTR callback_data$53[rsp+40]
	mov	DWORD PTR utf8_selection_start$56[rsp], eax

; 3991 : 					const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_end);

	mov	rax, QWORD PTR edit_state$[rsp]
	movsxd	rax, DWORD PTR [rax+88]
	mov	rcx, QWORD PTR text$35[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rdx, rax
	mov	rcx, QWORD PTR text$35[rsp]
	call	?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z ; ImTextCountUtf8BytesFromStr
	mov	DWORD PTR callback_data$53[rsp+52], eax
	mov	eax, DWORD PTR callback_data$53[rsp+52]
	mov	DWORD PTR utf8_selection_end$57[rsp], eax

; 3992 : 
; 3993 : 					// Call user code
; 3994 : 					callback(&callback_data);

	mov	rax, QWORD PTR callback$[rsp]
	mov	QWORD PTR tv1350[rsp], rax
	lea	rcx, QWORD PTR callback_data$53[rsp]
	call	QWORD PTR tv1350[rsp]
	npad	1

; 3995 : 
; 3996 : 					// Read back what user may have modified
; 3997 : 					IM_ASSERT(callback_data.Buf == edit_state.TempBuffer.Data);  // Invalid to modify those fields
; 3998 : 					IM_ASSERT(callback_data.BufSize == edit_state.BufCapacityA);
; 3999 : 					IM_ASSERT(callback_data.Flags == flags);
; 4000 : 					if (callback_data.CursorPos != utf8_cursor_pos) { edit_state.StbState.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos); edit_state.CursorFollow = true; }

	mov	eax, DWORD PTR utf8_cursor_pos$55[rsp]
	cmp	DWORD PTR callback_data$53[rsp+48], eax
	je	SHORT $LN126@InputTextE
	movsxd	rax, DWORD PTR callback_data$53[rsp+48]
	mov	rcx, QWORD PTR callback_data$53[rsp+24]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR callback_data$53[rsp+24]
	call	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z	; ImTextCountCharsFromUtf8
	mov	rcx, QWORD PTR edit_state$[rsp]
	mov	DWORD PTR [rcx+80], eax
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	BYTE PTR [rax+3700], 1
$LN126@InputTextE:

; 4001 : 					if (callback_data.SelectionStart != utf8_selection_start) { edit_state.StbState.select_start = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart); }

	mov	eax, DWORD PTR utf8_selection_start$56[rsp]
	cmp	DWORD PTR callback_data$53[rsp+40], eax
	je	SHORT $LN127@InputTextE
	movsxd	rax, DWORD PTR callback_data$53[rsp+40]
	mov	rcx, QWORD PTR callback_data$53[rsp+24]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR callback_data$53[rsp+24]
	call	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z	; ImTextCountCharsFromUtf8
	mov	rcx, QWORD PTR edit_state$[rsp]
	mov	DWORD PTR [rcx+84], eax
$LN127@InputTextE:

; 4002 : 					if (callback_data.SelectionEnd != utf8_selection_end) { edit_state.StbState.select_end = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd); }

	mov	eax, DWORD PTR utf8_selection_end$57[rsp]
	cmp	DWORD PTR callback_data$53[rsp+52], eax
	je	SHORT $LN128@InputTextE
	movsxd	rax, DWORD PTR callback_data$53[rsp+52]
	mov	rcx, QWORD PTR callback_data$53[rsp+24]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR callback_data$53[rsp+24]
	call	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z	; ImTextCountCharsFromUtf8
	mov	rcx, QWORD PTR edit_state$[rsp]
	mov	DWORD PTR [rcx+88], eax
$LN128@InputTextE:

; 4003 : 					if (callback_data.BufDirty)

	movzx	eax, BYTE PTR callback_data$53[rsp+32]
	test	eax, eax
	je	$LN129@InputTextE

; 4004 : 					{
; 4005 : 						IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!
; 4006 : 						if (callback_data.BufTextLen > backup_current_text_length && is_resizable)

	mov	eax, DWORD PTR backup_current_text_length$[rsp]
	cmp	DWORD PTR callback_data$53[rsp+36], eax
	jle	SHORT $LN130@InputTextE
	movzx	eax, BYTE PTR is_resizable$[rsp]
	test	eax, eax
	je	SHORT $LN130@InputTextE

; 4007 : 							edit_state.TextW.resize(edit_state.TextW.Size + (callback_data.BufTextLen - backup_current_text_length));

	mov	rax, QWORD PTR edit_state$[rsp]
	add	rax, 8
	mov	QWORD PTR tv1388[rsp], rax
	mov	eax, DWORD PTR backup_current_text_length$[rsp]
	mov	ecx, DWORD PTR callback_data$53[rsp+36]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR edit_state$[rsp]
	add	eax, DWORD PTR [rcx+8]
	mov	edx, eax
	mov	rcx, QWORD PTR tv1388[rsp]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize
	npad	1
$LN130@InputTextE:

; 4008 : 						edit_state.CurLenW = ImTextStrFromUtf8(edit_state.TextW.Data, edit_state.TextW.Size, callback_data.Buf, NULL);

	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR callback_data$53[rsp+24]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	edx, DWORD PTR [rax+8]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z ; ImTextStrFromUtf8
	mov	rcx, QWORD PTR edit_state$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 4009 : 						edit_state.CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR callback_data$53[rsp+36]
	mov	DWORD PTR [rax+28], ecx

; 4010 : 						edit_state.CursorAnimReset();

	mov	rcx, QWORD PTR edit_state$[rsp]
	call	?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ ; ImGuiInputTextState::CursorAnimReset
	npad	1
$LN129@InputTextE:
$LN125@InputTextE:
$LN117@InputTextE:

; 4011 : 					}
; 4012 : 
; 4013 : 				}
; 4014 : 			}
; 4015 : 
; 4016 : 			// Will copy result string if modified
; 4017 : 			if (is_editable && strcmp(edit_state.TempBuffer.Data, buf) != 0)

	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	SHORT $LN131@InputTextE
	mov	rdx, QWORD PTR buf$[rsp]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR [rax+64]
	call	strcmp
	test	eax, eax
	je	SHORT $LN131@InputTextE

; 4018 : 			{
; 4019 : 				apply_new_text = edit_state.TempBuffer.Data;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR apply_new_text$49[rsp], rax

; 4020 : 				apply_new_text_length = edit_state.CurLenA;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR apply_new_text_length$19[rsp], eax
$LN131@InputTextE:
$LN115@InputTextE:

; 4021 : 				//printf_s("%s|%d\r\n", apply_new_text, apply_new_text_length);
; 4022 : 			}
; 4023 : 
; 4024 : 		}
; 4025 : 
; 4026 : 		// Copy result to user buffer
; 4027 : 		if (apply_new_text)

	cmp	QWORD PTR apply_new_text$49[rsp], 0
	je	$LN132@InputTextE

; 4028 : 		{
; 4029 : 			IM_ASSERT(apply_new_text_length >= 0);
; 4030 : 			if (backup_current_text_length != apply_new_text_length && is_resizable)

	mov	eax, DWORD PTR apply_new_text_length$19[rsp]
	cmp	DWORD PTR backup_current_text_length$[rsp], eax
	je	$LN133@InputTextE
	movzx	eax, BYTE PTR is_resizable$[rsp]
	test	eax, eax
	je	$LN133@InputTextE

; 4031 : 			{
; 4032 : 				ImGuiInputTextCallbackData callback_data;

	lea	rcx, QWORD PTR callback_data$77[rsp]
	call	??0ImGuiInputTextCallbackData@@QEAA@XZ	; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData

; 4033 : 				callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;

	mov	DWORD PTR callback_data$77[rsp+4], 262144 ; 00040000H

; 4034 : 				callback_data.Flags = flags;

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR callback_data$77[rsp], eax

; 4035 : 				callback_data.Buf = buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR callback_data$77[rsp+24], rax

; 4036 : 				callback_data.BufTextLen = apply_new_text_length;

	mov	eax, DWORD PTR apply_new_text_length$19[rsp]
	mov	DWORD PTR callback_data$77[rsp+36], eax

; 4037 : 				callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);

	mov	eax, DWORD PTR apply_new_text_length$19[rsp]
	inc	eax
	mov	edx, eax
	mov	ecx, DWORD PTR buf_size$[rsp]
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	DWORD PTR callback_data$77[rsp+44], eax

; 4038 : 				callback_data.UserData = callback_user_data;

	mov	rax, QWORD PTR callback_user_data$[rsp]
	mov	QWORD PTR callback_data$77[rsp+8], rax

; 4039 : 				callback(&callback_data);

	mov	rax, QWORD PTR callback$[rsp]
	mov	QWORD PTR tv1425[rsp], rax
	lea	rcx, QWORD PTR callback_data$77[rsp]
	call	QWORD PTR tv1425[rsp]

; 4040 : 				buf = callback_data.Buf;

	mov	rax, QWORD PTR callback_data$77[rsp+24]
	mov	QWORD PTR buf$[rsp], rax

; 4041 : 				buf_size = callback_data.BufSize;

	mov	eax, DWORD PTR callback_data$77[rsp+44]
	mov	DWORD PTR buf_size$[rsp], eax

; 4042 : 				apply_new_text_length = ImMin(callback_data.BufTextLen, buf_size - 1);

	mov	eax, DWORD PTR buf_size$[rsp]
	dec	eax
	mov	edx, eax
	mov	ecx, DWORD PTR callback_data$77[rsp+36]
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	mov	DWORD PTR apply_new_text_length$19[rsp], eax
$LN133@InputTextE:

; 4043 : 				IM_ASSERT(apply_new_text_length <= buf_size);
; 4044 : 			}
; 4045 : 
; 4046 : 			// If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.
; 4047 : 			ImStrncpy(buf, apply_new_text, ImMin(apply_new_text_length + 1, buf_size));

	mov	eax, DWORD PTR apply_new_text_length$19[rsp]
	inc	eax
	mov	edx, DWORD PTR buf_size$[rsp]
	mov	ecx, eax
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	cdqe
	mov	r8, rax
	mov	rdx, QWORD PTR apply_new_text$49[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	?ImStrncpy@@YAXPEADPEBD_K@Z		; ImStrncpy

; 4048 : 			value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN132@InputTextE:

; 4049 : 		}
; 4050 : 
; 4051 : 		// Clear temporary user storage
; 4052 : 		edit_state.UserFlags = 0;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	DWORD PTR [rax+3704], 0

; 4053 : 		edit_state.UserCallback = NULL;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	QWORD PTR [rax+3712], 0

; 4054 : 		edit_state.UserCallbackData = NULL;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	QWORD PTR [rax+3720], 0
$LN112@InputTextE:

; 4055 : 	}
; 4056 : 
; 4057 : 	// Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
; 4058 : 	if (clear_active_id && g.ActiveId == id)

	movzx	eax, BYTE PTR clear_active_id$[rsp]
	test	eax, eax
	je	SHORT $LN134@InputTextE
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN134@InputTextE

; 4059 : 		ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
$LN134@InputTextE:

; 4060 : 
; 4061 : 	// Render
; 4062 : 	// Select which buffer we are going to display. When ImGuiInputTextFlags_NoLiveEdit is set 'buf' might still be the old value. We set buf to NULL to prevent accidental usage from now on.
; 4063 : 	const char* buf_display = (g.ActiveId == id && is_editable) ? edit_state.TempBuffer.Data : buf; buf = NULL;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN293@InputTextE
	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	SHORT $LN293@InputTextE
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR tv1482[rsp], rax
	jmp	SHORT $LN294@InputTextE
$LN293@InputTextE:
	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR tv1482[rsp], rax
$LN294@InputTextE:
	mov	rax, QWORD PTR tv1482[rsp]
	mov	QWORD PTR buf_display$[rsp], rax
	mov	QWORD PTR buf$[rsp], 0

; 4064 : 
; 4065 : 	// Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line
; 4066 : 	// without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.
; 4067 : 	// Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.
; 4068 : 	const int buf_display_max_length = 2 * 1024 * 1024;

	mov	DWORD PTR buf_display_max_length$[rsp], 2097152 ; 00200000H

; 4069 : 
; 4070 : 	if (!is_multiline)

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	jne	SHORT $LN135@InputTextE

; 4071 : 	{
; 4072 : 		RenderNavHighlight(frame_bb, id);

	mov	r8d, 1
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 4073 : 		RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	movss	DWORD PTR tv1500[rsp], xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 7
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv1498[rsp], eax
	movss	xmm0, DWORD PTR tv1500[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	r8d, DWORD PTR tv1498[rsp]
	mov	rdx, QWORD PTR frame_bb$[rsp+8]
	mov	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	npad	1
$LN135@InputTextE:

; 4074 : 	}
; 4075 : 
; 4076 : 	const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size

	movss	xmm0, DWORD PTR frame_bb$[rsp+4]
	addss	xmm0, DWORD PTR size$[rsp+4]
	movss	xmm1, DWORD PTR frame_bb$[rsp]
	addss	xmm1, DWORD PTR size$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm2, DWORD PTR frame_bb$[rsp+4]
	movss	xmm1, DWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR clip_rect$[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	npad	1

; 4077 : 	ImVec2 render_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN295@InputTextE
	mov	rax, QWORD PTR draw_window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR $T71[rsp], rax
	lea	rax, QWORD PTR $T71[rsp]
	mov	QWORD PTR tv1518[rsp], rax
	jmp	SHORT $LN296@InputTextE
$LN295@InputTextE:
	mov	rax, QWORD PTR style$[rsp]
	add	rax, 52					; 00000034H
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR $T95[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv1518[rsp], rax
$LN296@InputTextE:
	mov	rax, QWORD PTR tv1518[rsp]
	mov	QWORD PTR $T72[rsp], rax
	mov	rax, QWORD PTR $T72[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR render_pos$[rsp], rax

; 4078 : 	ImVec2 text_size(0.f, 0.f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR text_size$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 4079 : 	if (g.ActiveId == id || user_scroll_active)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN138@InputTextE
	movzx	eax, BYTE PTR user_scroll_active$[rsp]
	test	eax, eax
	je	$LN136@InputTextE
$LN138@InputTextE:

; 4080 : 	{
; 4081 : 		// Animate cursor
; 4082 : 		edit_state.CursorAnim += io.DeltaTime;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR io$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	addss	xmm0, DWORD PTR [rcx+32]
	mov	rax, QWORD PTR edit_state$[rsp]
	movss	DWORD PTR [rax+24], xmm0

; 4083 : 
; 4084 : 		// This is going to be messy. We need to:
; 4085 : 		// - Display the text (this alone can be more easily clipped)
; 4086 : 		// - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)
; 4087 : 		// - Measure text height (for scrollbar)
; 4088 : 		// We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
; 4089 : 		// FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
; 4090 : 		const ImWchar* text_begin = edit_state.TextW.Data;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR text_begin$33[rsp], rax

; 4091 : 		ImVec2 cursor_offset, select_start_offset;

	lea	rcx, QWORD PTR cursor_offset$27[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	lea	rcx, QWORD PTR select_start_offset$63[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	npad	1

; 4092 : 
; 4093 : 		{
; 4094 : 			// Count lines + find lines numbers straddling 'cursor' and 'select_start' position.
; 4095 : 			const ImWchar* searches_input_ptr[2];
; 4096 : 			searches_input_ptr[0] = text_begin + edit_state.StbState.cursor;

	mov	rax, QWORD PTR edit_state$[rsp]
	movsxd	rax, DWORD PTR [rax+80]
	mov	rcx, QWORD PTR text_begin$33[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR searches_input_ptr$54[rsp+rcx], rax

; 4097 : 			searches_input_ptr[1] = NULL;

	mov	eax, 8
	imul	rax, rax, 1
	mov	QWORD PTR searches_input_ptr$54[rsp+rax], 0

; 4098 : 			int searches_remaining = 1;

	mov	DWORD PTR searches_remaining$11[rsp], 1

; 4099 : 			int searches_result_line_number[2] = { -1, -999 };

	mov	DWORD PTR searches_result_line_number$26[rsp], -1
	mov	DWORD PTR searches_result_line_number$26[rsp+4], -999 ; fffffffffffffc19H

; 4100 : 			if (edit_state.StbState.select_start != edit_state.StbState.select_end)

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR [rcx+88]
	cmp	DWORD PTR [rax+84], ecx
	je	SHORT $LN139@InputTextE

; 4101 : 			{
; 4102 : 				searches_input_ptr[1] = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	edx, DWORD PTR [rax+88]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR [rax+84]
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	cdqe
	mov	rcx, QWORD PTR text_begin$33[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	QWORD PTR searches_input_ptr$54[rsp+rcx], rax

; 4103 : 				searches_result_line_number[1] = -1;

	mov	eax, 4
	imul	rax, rax, 1
	mov	DWORD PTR searches_result_line_number$26[rsp+rax], -1

; 4104 : 				searches_remaining++;

	mov	eax, DWORD PTR searches_remaining$11[rsp]
	inc	eax
	mov	DWORD PTR searches_remaining$11[rsp], eax
$LN139@InputTextE:

; 4105 : 			}
; 4106 : 
; 4107 : 			// Iterate all lines to find our line numbers
; 4108 : 			// In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
; 4109 : 			searches_remaining += is_multiline ? 1 : 0;

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN297@InputTextE
	mov	DWORD PTR tv1566[rsp], 1
	jmp	SHORT $LN298@InputTextE
$LN297@InputTextE:
	mov	DWORD PTR tv1566[rsp], 0
$LN298@InputTextE:
	mov	eax, DWORD PTR tv1566[rsp]
	mov	ecx, DWORD PTR searches_remaining$11[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR searches_remaining$11[rsp], eax

; 4110 : 			int line_count = 0;

	mov	DWORD PTR line_count$12[rsp], 0

; 4111 : 			//for (const ImWchar* s = text_begin; (s = (const ImWchar*)wcschr((const wchar_t*)s, (wchar_t)'\n')) != NULL; s++)  // FIXME-OPT: Could use this when wchar_t are 16-bits
; 4112 : 			for (const ImWchar* s = text_begin; *s != 0; s++)

	mov	rax, QWORD PTR text_begin$33[rsp]
	mov	QWORD PTR s$36[rsp], rax
	jmp	SHORT $LN10@InputTextE
$LN8@InputTextE:
	mov	rax, QWORD PTR s$36[rsp]
	add	rax, 2
	mov	QWORD PTR s$36[rsp], rax
$LN10@InputTextE:
	mov	rax, QWORD PTR s$36[rsp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	$LN9@InputTextE

; 4113 : 				if (*s == '\n')

	mov	rax, QWORD PTR s$36[rsp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 10
	jne	$LN140@InputTextE

; 4114 : 				{
; 4115 : 					line_count++;

	mov	eax, DWORD PTR line_count$12[rsp]
	inc	eax
	mov	DWORD PTR line_count$12[rsp], eax

; 4116 : 					if (searches_result_line_number[0] == -1 && s >= searches_input_ptr[0]) { searches_result_line_number[0] = line_count; if (--searches_remaining <= 0) break; }

	mov	eax, 4
	imul	rax, rax, 0
	cmp	DWORD PTR searches_result_line_number$26[rsp+rax], -1
	jne	SHORT $LN141@InputTextE
	mov	eax, 8
	imul	rax, rax, 0
	mov	rax, QWORD PTR searches_input_ptr$54[rsp+rax]
	cmp	QWORD PTR s$36[rsp], rax
	jb	SHORT $LN141@InputTextE
	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, DWORD PTR line_count$12[rsp]
	mov	DWORD PTR searches_result_line_number$26[rsp+rax], ecx
	mov	eax, DWORD PTR searches_remaining$11[rsp]
	dec	eax
	mov	DWORD PTR searches_remaining$11[rsp], eax
	cmp	DWORD PTR searches_remaining$11[rsp], 0
	jg	SHORT $LN142@InputTextE
	jmp	SHORT $LN9@InputTextE
$LN142@InputTextE:
$LN141@InputTextE:

; 4117 : 					if (searches_result_line_number[1] == -1 && s >= searches_input_ptr[1]) { searches_result_line_number[1] = line_count; if (--searches_remaining <= 0) break; }

	mov	eax, 4
	imul	rax, rax, 1
	cmp	DWORD PTR searches_result_line_number$26[rsp+rax], -1
	jne	SHORT $LN143@InputTextE
	mov	eax, 8
	imul	rax, rax, 1
	mov	rax, QWORD PTR searches_input_ptr$54[rsp+rax]
	cmp	QWORD PTR s$36[rsp], rax
	jb	SHORT $LN143@InputTextE
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, DWORD PTR line_count$12[rsp]
	mov	DWORD PTR searches_result_line_number$26[rsp+rax], ecx
	mov	eax, DWORD PTR searches_remaining$11[rsp]
	dec	eax
	mov	DWORD PTR searches_remaining$11[rsp], eax
	cmp	DWORD PTR searches_remaining$11[rsp], 0
	jg	SHORT $LN144@InputTextE
	jmp	SHORT $LN9@InputTextE
$LN144@InputTextE:
$LN143@InputTextE:
$LN140@InputTextE:

; 4118 : 				}

	jmp	$LN8@InputTextE
$LN9@InputTextE:

; 4119 : 			line_count++;

	mov	eax, DWORD PTR line_count$12[rsp]
	inc	eax
	mov	DWORD PTR line_count$12[rsp], eax

; 4120 : 			if (searches_result_line_number[0] == -1) searches_result_line_number[0] = line_count;

	mov	eax, 4
	imul	rax, rax, 0
	cmp	DWORD PTR searches_result_line_number$26[rsp+rax], -1
	jne	SHORT $LN145@InputTextE
	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, DWORD PTR line_count$12[rsp]
	mov	DWORD PTR searches_result_line_number$26[rsp+rax], ecx
$LN145@InputTextE:

; 4121 : 			if (searches_result_line_number[1] == -1) searches_result_line_number[1] = line_count;

	mov	eax, 4
	imul	rax, rax, 1
	cmp	DWORD PTR searches_result_line_number$26[rsp+rax], -1
	jne	SHORT $LN146@InputTextE
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, DWORD PTR line_count$12[rsp]
	mov	DWORD PTR searches_result_line_number$26[rsp+rax], ecx
$LN146@InputTextE:

; 4122 : 
; 4123 : 			// Calculate 2d position by finding the beginning of the line and measuring distance
; 4124 : 			cursor_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rax, QWORD PTR searches_input_ptr$54[rsp+rax]
	mov	QWORD PTR tv1622[rsp], rax
	mov	eax, 8
	imul	rax, rax, 0
	mov	rdx, QWORD PTR text_begin$33[rsp]
	mov	rcx, QWORD PTR searches_input_ptr$54[rsp+rax]
	call	?ImStrbolW@@YAPEBGPEBG0@Z		; ImStrbolW
	mov	QWORD PTR tv1620[rsp], rax
	mov	BYTE PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR tv1622[rsp]
	mov	rdx, QWORD PTR tv1620[rsp]
	lea	rcx, QWORD PTR $T96[rsp]
	call	?InputTextCalcTextSizeW@@YA?AUImVec2@@PEBG0PEAPEBGPEAU1@_N@Z ; InputTextCalcTextSizeW
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR cursor_offset$27[rsp], xmm0

; 4125 : 			cursor_offset.y = searches_result_line_number[0] * g.FontSize;

	mov	eax, 4
	imul	rax, rax, 0
	cvtsi2ss xmm0, DWORD PTR searches_result_line_number$26[rsp+rax]
	mov	rax, QWORD PTR g$[rsp]
	mulss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR cursor_offset$27[rsp+4], xmm0

; 4126 : 			if (searches_result_line_number[1] >= 0)

	mov	eax, 4
	imul	rax, rax, 1
	cmp	DWORD PTR searches_result_line_number$26[rsp+rax], 0
	jl	$LN147@InputTextE

; 4127 : 			{
; 4128 : 				select_start_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rax, QWORD PTR searches_input_ptr$54[rsp+rax]
	mov	QWORD PTR tv1649[rsp], rax
	mov	eax, 8
	imul	rax, rax, 1
	mov	rdx, QWORD PTR text_begin$33[rsp]
	mov	rcx, QWORD PTR searches_input_ptr$54[rsp+rax]
	call	?ImStrbolW@@YAPEBGPEBG0@Z		; ImStrbolW
	mov	QWORD PTR tv1647[rsp], rax
	mov	BYTE PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR tv1649[rsp]
	mov	rdx, QWORD PTR tv1647[rsp]
	lea	rcx, QWORD PTR $T100[rsp]
	call	?InputTextCalcTextSizeW@@YA?AUImVec2@@PEBG0PEAPEBGPEAU1@_N@Z ; InputTextCalcTextSizeW
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR select_start_offset$63[rsp], xmm0

; 4129 : 				select_start_offset.y = searches_result_line_number[1] * g.FontSize;

	mov	eax, 4
	imul	rax, rax, 1
	cvtsi2ss xmm0, DWORD PTR searches_result_line_number$26[rsp+rax]
	mov	rax, QWORD PTR g$[rsp]
	mulss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR select_start_offset$63[rsp+4], xmm0
$LN147@InputTextE:

; 4130 : 			}
; 4131 : 
; 4132 : 			// Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
; 4133 : 			if (is_multiline)

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN148@InputTextE

; 4134 : 				text_size = ImVec2(size.x, line_count * g.FontSize);

	cvtsi2ss xmm0, DWORD PTR line_count$12[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mulss	xmm0, DWORD PTR [rax+6408]
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR size$[rsp]
	lea	rcx, QWORD PTR $T78[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR text_size$[rsp], rax
$LN148@InputTextE:

; 4135 : 		}
; 4136 : 
; 4137 : 		// Scroll
; 4138 : 		if (edit_state.CursorFollow)

	mov	rax, QWORD PTR edit_state$[rsp]
	movzx	eax, BYTE PTR [rax+3700]
	test	eax, eax
	je	$LN149@InputTextE

; 4139 : 		{
; 4140 : 			// Horizontal scroll in chunks of quarter width
; 4141 : 			if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4096				; 00001000H
	test	eax, eax
	jne	$LN150@InputTextE

; 4142 : 			{
; 4143 : 				const float scroll_increment_x = size.x * 0.25f;

	movss	xmm0, DWORD PTR size$[rsp]
	mulss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR scroll_increment_x$42[rsp], xmm0

; 4144 : 				if (cursor_offset.x < edit_state.ScrollX)

	mov	rax, QWORD PTR edit_state$[rsp]
	movss	xmm0, DWORD PTR [rax+72]
	comiss	xmm0, DWORD PTR cursor_offset$27[rsp]
	jbe	SHORT $LN152@InputTextE

; 4145 : 					edit_state.ScrollX = (float)(int)ImMax(0.0f, cursor_offset.x - scroll_increment_x);

	movss	xmm0, DWORD PTR cursor_offset$27[rsp]
	subss	xmm0, DWORD PTR scroll_increment_x$42[rsp]
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR edit_state$[rsp]
	movss	DWORD PTR [rax+72], xmm0
	jmp	SHORT $LN153@InputTextE
$LN152@InputTextE:

; 4146 : 				else if (cursor_offset.x - size.x >= edit_state.ScrollX)

	movss	xmm0, DWORD PTR cursor_offset$27[rsp]
	subss	xmm0, DWORD PTR size$[rsp]
	mov	rax, QWORD PTR edit_state$[rsp]
	comiss	xmm0, DWORD PTR [rax+72]
	jb	SHORT $LN154@InputTextE

; 4147 : 					edit_state.ScrollX = (float)(int)(cursor_offset.x - size.x + scroll_increment_x);

	movss	xmm0, DWORD PTR cursor_offset$27[rsp]
	subss	xmm0, DWORD PTR size$[rsp]
	addss	xmm0, DWORD PTR scroll_increment_x$42[rsp]
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR edit_state$[rsp]
	movss	DWORD PTR [rax+72], xmm0
$LN154@InputTextE:
$LN153@InputTextE:

; 4148 : 			}

	jmp	SHORT $LN151@InputTextE
$LN150@InputTextE:

; 4149 : 			else
; 4150 : 			{
; 4151 : 				edit_state.ScrollX = 0.0f;

	mov	rax, QWORD PTR edit_state$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+72], xmm0
$LN151@InputTextE:

; 4152 : 			}
; 4153 : 
; 4154 : 			// Vertical scroll
; 4155 : 			if (is_multiline)

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	$LN155@InputTextE

; 4156 : 			{
; 4157 : 				float scroll_y = draw_window->Scroll.y;

	mov	rax, QWORD PTR draw_window$[rsp]
	movss	xmm0, DWORD PTR [rax+96]
	movss	DWORD PTR scroll_y$25[rsp], xmm0

; 4158 : 				if (cursor_offset.y - g.FontSize < scroll_y)

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR cursor_offset$27[rsp+4]
	subss	xmm0, DWORD PTR [rax+6408]
	movss	xmm1, DWORD PTR scroll_y$25[rsp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN156@InputTextE

; 4159 : 					scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR cursor_offset$27[rsp+4]
	subss	xmm0, DWORD PTR [rax+6408]
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR scroll_y$25[rsp], xmm0
	jmp	SHORT $LN157@InputTextE
$LN156@InputTextE:

; 4160 : 				else if (cursor_offset.y - size.y >= scroll_y)

	movss	xmm0, DWORD PTR cursor_offset$27[rsp+4]
	subss	xmm0, DWORD PTR size$[rsp+4]
	comiss	xmm0, DWORD PTR scroll_y$25[rsp]
	jb	SHORT $LN158@InputTextE

; 4161 : 					scroll_y = cursor_offset.y - size.y;

	movss	xmm0, DWORD PTR cursor_offset$27[rsp+4]
	subss	xmm0, DWORD PTR size$[rsp+4]
	movss	DWORD PTR scroll_y$25[rsp], xmm0
$LN158@InputTextE:
$LN157@InputTextE:

; 4162 : 				draw_window->DC.CursorPos.y += (draw_window->Scroll.y - scroll_y);   // Manipulate cursor pos immediately avoid a frame of lag

	mov	rax, QWORD PTR draw_window$[rsp]
	movss	xmm0, DWORD PTR [rax+96]
	subss	xmm0, DWORD PTR scroll_y$25[rsp]
	mov	rax, QWORD PTR draw_window$[rsp]
	movss	xmm1, DWORD PTR [rax+344]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR draw_window$[rsp]
	movss	DWORD PTR [rax+344], xmm0

; 4163 : 				draw_window->Scroll.y = scroll_y;

	mov	rax, QWORD PTR draw_window$[rsp]
	movss	xmm0, DWORD PTR scroll_y$25[rsp]
	movss	DWORD PTR [rax+96], xmm0

; 4164 : 				render_pos.y = draw_window->DC.CursorPos.y;

	mov	rax, QWORD PTR draw_window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	movss	DWORD PTR render_pos$[rsp+4], xmm0
$LN155@InputTextE:
$LN149@InputTextE:

; 4165 : 			}
; 4166 : 		}
; 4167 : 		edit_state.CursorFollow = false;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	BYTE PTR [rax+3700], 0

; 4168 : 		const ImVec2 render_scroll = ImVec2(edit_state.ScrollX, 0.0f);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR edit_state$[rsp]
	movss	xmm1, DWORD PTR [rax+72]
	lea	rcx, QWORD PTR render_scroll$52[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 4169 : 
; 4170 : 		// Draw selection
; 4171 : 		if (edit_state.StbState.select_start != edit_state.StbState.select_end)

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	rcx, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR [rcx+88]
	cmp	DWORD PTR [rax+84], ecx
	je	$LN159@InputTextE

; 4172 : 		{
; 4173 : 			const ImWchar* text_selected_begin = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	edx, DWORD PTR [rax+88]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR [rax+84]
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	cdqe
	mov	rcx, QWORD PTR text_begin$33[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR text_selected_begin$73[rsp], rax

; 4174 : 			const ImWchar* text_selected_end = text_begin + ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end);

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	edx, DWORD PTR [rax+88]
	mov	rax, QWORD PTR edit_state$[rsp]
	mov	ecx, DWORD PTR [rax+84]
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	cdqe
	mov	rcx, QWORD PTR text_begin$33[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR text_selected_end$64[rsp], rax

; 4175 : 
; 4176 : 			float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN299@InputTextE
	xorps	xmm0, xmm0
	movss	DWORD PTR tv1785[rsp], xmm0
	jmp	SHORT $LN300@InputTextE
$LN299@InputTextE:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv1785[rsp], xmm0
$LN300@InputTextE:
	movss	xmm0, DWORD PTR tv1785[rsp]
	movss	DWORD PTR bg_offy_up$60[rsp], xmm0

; 4177 : 			float bg_offy_dn = is_multiline ? 0.0f : 2.0f;

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN301@InputTextE
	xorps	xmm0, xmm0
	movss	DWORD PTR tv1788[rsp], xmm0
	jmp	SHORT $LN302@InputTextE
$LN301@InputTextE:
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv1788[rsp], xmm0
$LN302@InputTextE:
	movss	xmm0, DWORD PTR tv1788[rsp]
	movss	DWORD PTR bg_offy_dn$58[rsp], xmm0

; 4178 : 			ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg);

	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 42					; 0000002aH
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR bg_color$61[rsp], eax

; 4179 : 			ImVec2 rect_pos = render_pos + select_start_offset - render_scroll;

	lea	r8, QWORD PTR select_start_offset$63[rsp]
	lea	rdx, QWORD PTR render_pos$[rsp]
	lea	rcx, QWORD PTR $T79[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	lea	r8, QWORD PTR render_scroll$52[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR rect_pos$32[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	npad	1

; 4180 : 			for (const ImWchar* p = text_selected_begin; p < text_selected_end; )

	mov	rax, QWORD PTR text_selected_begin$73[rsp]
	mov	QWORD PTR p$34[rsp], rax
$LN11@InputTextE:
	mov	rax, QWORD PTR text_selected_end$64[rsp]
	cmp	QWORD PTR p$34[rsp], rax
	jae	$LN12@InputTextE

; 4181 : 			{
; 4182 : 				if (rect_pos.y > clip_rect.w + g.FontSize)

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR clip_rect$[rsp+12]
	addss	xmm0, DWORD PTR [rax+6408]
	movss	xmm1, DWORD PTR rect_pos$32[rsp+4]
	comiss	xmm1, xmm0
	jbe	SHORT $LN160@InputTextE

; 4183 : 					break;

	jmp	$LN12@InputTextE
$LN160@InputTextE:

; 4184 : 				if (rect_pos.y < clip_rect.y)

	movss	xmm0, DWORD PTR clip_rect$[rsp+4]
	comiss	xmm0, DWORD PTR rect_pos$32[rsp+4]
	jbe	SHORT $LN161@InputTextE
$LN14@InputTextE:

; 4185 : 				{
; 4186 : 					//p = (const ImWchar*)wmemchr((const wchar_t*)p, '\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bits
; 4187 : 					//p = p ? p + 1 : text_selected_end;
; 4188 : 					while (p < text_selected_end)

	mov	rax, QWORD PTR text_selected_end$64[rsp]
	cmp	QWORD PTR p$34[rsp], rax
	jae	SHORT $LN15@InputTextE

; 4189 : 						if (*p++ == '\n')

	mov	rax, QWORD PTR p$34[rsp]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR tv1808[rsp], eax
	mov	rax, QWORD PTR p$34[rsp]
	add	rax, 2
	mov	QWORD PTR p$34[rsp], rax
	cmp	DWORD PTR tv1808[rsp], 10
	jne	SHORT $LN163@InputTextE

; 4190 : 							break;

	jmp	SHORT $LN15@InputTextE
$LN163@InputTextE:
	jmp	SHORT $LN14@InputTextE
$LN15@InputTextE:

; 4191 : 				}

	jmp	$LN162@InputTextE
$LN161@InputTextE:

; 4192 : 				else
; 4193 : 				{
; 4194 : 					ImVec2 rect_size = InputTextCalcTextSizeW(p, text_selected_end, &p, NULL, true);

	mov	BYTE PTR [rsp+40], 1
	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR p$34[rsp]
	mov	r8, QWORD PTR text_selected_end$64[rsp]
	mov	rdx, QWORD PTR p$34[rsp]
	lea	rcx, QWORD PTR rect_size$65[rsp]
	call	?InputTextCalcTextSizeW@@YA?AUImVec2@@PEBG0PEAPEBGPEAU1@_N@Z ; InputTextCalcTextSizeW
	npad	1

; 4195 : 					if (rect_size.x <= 0.0f) rect_size.x = (float)(int)(g.Font->GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR rect_size$65[rsp]
	jb	SHORT $LN164@InputTextE
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv1821[rsp], rax
	mov	dx, 32					; 00000020H
	mov	rcx, QWORD PTR tv1821[rsp]
	call	?GetCharAdvance@ImFont@@QEBAMG@Z	; ImFont::GetCharAdvance
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR rect_size$65[rsp], xmm0
$LN164@InputTextE:

; 4196 : 					ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos + ImVec2(rect_size.x, bg_offy_dn));

	movss	xmm2, DWORD PTR bg_offy_dn$58[rsp]
	movss	xmm1, DWORD PTR rect_size$65[rsp]
	lea	rcx, QWORD PTR $T80[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR rect_pos$32[rsp]
	lea	rcx, QWORD PTR $T81[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv1851[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR bg_offy_up$60[rsp]
	subss	xmm0, DWORD PTR [rax+6408]
	movaps	xmm2, xmm0
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T82[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR rect_pos$32[rsp]
	lea	rcx, QWORD PTR $T83[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv1849[rsp], rax
	mov	r8, QWORD PTR tv1851[rsp]
	mov	rdx, QWORD PTR tv1849[rsp]
	lea	rcx, QWORD PTR rect$70[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 4197 : 					rect.ClipWith(clip_rect);

	lea	rdx, QWORD PTR clip_rect$[rsp]
	lea	rcx, QWORD PTR $T97[rsp]
	call	??0ImRect@@QEAA@AEBUImVec4@@@Z		; ImRect::ImRect
	lea	rdx, QWORD PTR $T97[rsp]
	lea	rcx, QWORD PTR rect$70[rsp]
	call	?ClipWith@ImRect@@QEAAXAEBU1@@Z		; ImRect::ClipWith
	npad	1

; 4198 : 					if (rect.Overlaps(clip_rect))

	lea	rdx, QWORD PTR clip_rect$[rsp]
	lea	rcx, QWORD PTR $T98[rsp]
	call	??0ImRect@@QEAA@AEBUImVec4@@@Z		; ImRect::ImRect
	lea	rdx, QWORD PTR $T98[rsp]
	lea	rcx, QWORD PTR rect$70[rsp]
	call	?Overlaps@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Overlaps
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN165@InputTextE

; 4199 : 						draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);

	mov	rax, QWORD PTR draw_window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1870[rsp], rax
	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR bg_color$61[rsp]
	lea	r8, QWORD PTR rect$70[rsp+8]
	lea	rdx, QWORD PTR rect$70[rsp]
	mov	rcx, QWORD PTR tv1870[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1
$LN165@InputTextE:
$LN162@InputTextE:

; 4200 : 				}
; 4201 : 				rect_pos.x = render_pos.x - render_scroll.x;

	movss	xmm0, DWORD PTR render_pos$[rsp]
	subss	xmm0, DWORD PTR render_scroll$52[rsp]
	movss	DWORD PTR rect_pos$32[rsp], xmm0

; 4202 : 				rect_pos.y += g.FontSize;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR rect_pos$32[rsp+4]
	addss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR rect_pos$32[rsp+4], xmm0

; 4203 : 			}

	jmp	$LN11@InputTextE
$LN12@InputTextE:
$LN159@InputTextE:

; 4204 : 		}
; 4205 : 
; 4206 : 		// We test for 'buf_display_max_length' as a way to avoid some pathological cases (e.g. single-line 1 MB string) which would make ImDrawList crash.
; 4207 : 		const int buf_display_len = edit_state.CurLenA;

	mov	rax, QWORD PTR edit_state$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR buf_display_len$43[rsp], eax

; 4208 : 		if (is_multiline || buf_display_len < buf_display_max_length)

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	jne	SHORT $LN167@InputTextE
	cmp	DWORD PTR buf_display_len$43[rsp], 2097152 ; 00200000H
	jge	$LN166@InputTextE
$LN167@InputTextE:

; 4209 : 			draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos - render_scroll, GetColorU32(ImGuiCol_Text), buf_display, buf_display + buf_display_len, 0.0f, is_multiline ? NULL : &clip_rect);

	mov	rax, QWORD PTR draw_window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv1943[rsp], rax
	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN303@InputTextE
	mov	QWORD PTR tv1882[rsp], 0
	jmp	SHORT $LN304@InputTextE
$LN303@InputTextE:
	lea	rax, QWORD PTR clip_rect$[rsp]
	mov	QWORD PTR tv1882[rsp], rax
$LN304@InputTextE:
	movss	xmm1, DWORD PTR __real@3f800000
	xor	ecx, ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv1939[rsp], eax
	lea	r8, QWORD PTR render_scroll$52[rsp]
	lea	rdx, QWORD PTR render_pos$[rsp]
	lea	rcx, QWORD PTR $T84[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv1937[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv1941[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv1935[rsp], rax
	movsxd	rax, DWORD PTR buf_display_len$43[rsp]
	mov	rcx, QWORD PTR buf_display$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR tv1882[rsp]
	mov	QWORD PTR [rsp+64], rcx
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR buf_display$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv1939[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv1937[rsp]
	movss	xmm2, DWORD PTR tv1941[rsp]
	mov	rdx, QWORD PTR tv1935[rsp]
	mov	rcx, QWORD PTR tv1943[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1
$LN166@InputTextE:

; 4210 : 
; 4211 : 		// Draw blinking cursor
; 4212 : 		bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) || (g.InputTextState.CursorAnim <= 0.0f) || ImFmod(g.InputTextState.CursorAnim, 1.20f) <= 0.80f;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+209]
	test	eax, eax
	je	SHORT $LN305@InputTextE
	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+7960]
	jae	SHORT $LN305@InputTextE
	movss	xmm1, DWORD PTR __real@3f99999a
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7960]
	call	?ImFmod@@YAMMM@Z			; ImFmod
	movss	xmm1, DWORD PTR __real@3f4ccccd
	comiss	xmm1, xmm0
	jae	SHORT $LN305@InputTextE
	mov	DWORD PTR tv1957[rsp], 0
	jmp	SHORT $LN306@InputTextE
$LN305@InputTextE:
	mov	DWORD PTR tv1957[rsp], 1
$LN306@InputTextE:
	movzx	eax, BYTE PTR tv1957[rsp]
	mov	BYTE PTR cursor_is_visible$18[rsp], al

; 4213 : 		ImVec2 cursor_screen_pos = render_pos + cursor_offset - render_scroll;

	lea	r8, QWORD PTR cursor_offset$27[rsp]
	lea	rdx, QWORD PTR render_pos$[rsp]
	lea	rcx, QWORD PTR $T85[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	lea	r8, QWORD PTR render_scroll$52[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR cursor_screen_pos$37[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	npad	1

; 4214 : 		ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f, cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f);

	movss	xmm0, DWORD PTR cursor_screen_pos$37[rsp+4]
	subss	xmm0, DWORD PTR __real@3fc00000
	movss	xmm1, DWORD PTR cursor_screen_pos$37[rsp]
	addss	xmm1, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR cursor_screen_pos$37[rsp+4]
	subss	xmm2, DWORD PTR [rax+6408]
	addss	xmm2, DWORD PTR __real@3f000000
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm1, DWORD PTR cursor_screen_pos$37[rsp]
	lea	rcx, QWORD PTR cursor_screen_rect$76[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	npad	1

; 4215 : 		if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))

	movzx	eax, BYTE PTR cursor_is_visible$18[rsp]
	test	eax, eax
	je	$LN168@InputTextE
	lea	rdx, QWORD PTR clip_rect$[rsp]
	lea	rcx, QWORD PTR $T99[rsp]
	call	??0ImRect@@QEAA@AEBUImVec4@@@Z		; ImRect::ImRect
	lea	rdx, QWORD PTR $T99[rsp]
	lea	rcx, QWORD PTR cursor_screen_rect$76[rsp]
	call	?Overlaps@ImRect@@QEBA_NAEBU1@@Z	; ImRect::Overlaps
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN168@InputTextE

; 4216 : 			draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));

	mov	rax, QWORD PTR draw_window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv2002[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	xor	ecx, ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv2000[rsp], eax
	lea	rdx, QWORD PTR $T86[rsp]
	lea	rcx, QWORD PTR cursor_screen_rect$76[rsp]
	call	?GetBL@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetBL
	mov	QWORD PTR tv1998[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv2000[rsp]
	mov	r8, QWORD PTR tv1998[rsp]
	lea	rdx, QWORD PTR cursor_screen_rect$76[rsp]
	mov	rcx, QWORD PTR tv2002[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1
$LN168@InputTextE:

; 4217 : 
; 4218 : 		// Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
; 4219 : 		if (is_editable)

	movzx	eax, BYTE PTR is_editable$[rsp]
	test	eax, eax
	je	SHORT $LN169@InputTextE

; 4220 : 			g.PlatformImePos = ImVec2(cursor_screen_pos.x - 1, cursor_screen_pos.y - g.FontSize);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR cursor_screen_pos$37[rsp+4]
	subss	xmm0, DWORD PTR [rax+6408]
	movss	xmm1, DWORD PTR cursor_screen_pos$37[rsp]
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T87[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+11740], rax
$LN169@InputTextE:

; 4221 : 	}

	jmp	$LN137@InputTextE
$LN136@InputTextE:

; 4222 : 	else
; 4223 : 	{
; 4224 : 		// Render text only
; 4225 : 		const char* buf_end = NULL;

	mov	QWORD PTR buf_end$48[rsp], 0

; 4226 : 		if (is_multiline)

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN170@InputTextE

; 4227 : 			text_size = ImVec2(size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_end) * g.FontSize); // We don't need width

	lea	rdx, QWORD PTR buf_end$48[rsp]
	mov	rcx, QWORD PTR buf_display$[rsp]
	call	?InputTextCalcTextLenAndLineCount@@YAHPEBDPEAPEBD@Z ; InputTextCalcTextLenAndLineCount
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR g$[rsp]
	mulss	xmm0, DWORD PTR [rax+6408]
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR size$[rsp]
	lea	rcx, QWORD PTR $T88[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR text_size$[rsp], rax
	jmp	SHORT $LN171@InputTextE
$LN170@InputTextE:

; 4228 : 		else
; 4229 : 			buf_end = buf_display + strlen(buf_display);

	mov	rcx, QWORD PTR buf_display$[rsp]
	call	strlen
	mov	rcx, QWORD PTR buf_display$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR buf_end$48[rsp], rax
$LN171@InputTextE:

; 4230 : 		if (is_multiline || (buf_end - buf_display) < buf_display_max_length)

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	jne	SHORT $LN173@InputTextE
	mov	rax, QWORD PTR buf_display$[rsp]
	mov	rcx, QWORD PTR buf_end$48[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	rax, 2097152				; 00200000H
	jge	$LN172@InputTextE
$LN173@InputTextE:

; 4231 : 			draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos, GetColorU32(ImGuiCol_Text), buf_display, buf_end, 0.0f, is_multiline ? NULL : &clip_rect);

	mov	rax, QWORD PTR draw_window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv2061[rsp], rax
	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN307@InputTextE
	mov	QWORD PTR tv2038[rsp], 0
	jmp	SHORT $LN308@InputTextE
$LN307@InputTextE:
	lea	rax, QWORD PTR clip_rect$[rsp]
	mov	QWORD PTR tv2038[rsp], rax
$LN308@InputTextE:
	mov	rax, QWORD PTR buf_end$48[rsp]
	mov	QWORD PTR tv2059[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	xor	ecx, ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv2055[rsp], eax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv2057[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv2053[rsp], rax
	mov	rax, QWORD PTR tv2038[rsp]
	mov	QWORD PTR [rsp+64], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR tv2059[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR buf_display$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv2055[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR render_pos$[rsp]
	movss	xmm2, DWORD PTR tv2057[rsp]
	mov	rdx, QWORD PTR tv2053[rsp]
	mov	rcx, QWORD PTR tv2061[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1
$LN172@InputTextE:
$LN137@InputTextE:

; 4232 : 	}
; 4233 : 
; 4234 : 	if (is_multiline)

	movzx	eax, BYTE PTR is_multiline$[rsp]
	test	eax, eax
	je	SHORT $LN174@InputTextE

; 4235 : 	{
; 4236 : 		Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR [rax+6408]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T89[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR text_size$[rsp]
	lea	rcx, QWORD PTR $T90[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, rax
	call	?Dummy@ImGui@@YAXAEBUImVec2@@@Z		; ImGui::Dummy
	npad	1

; 4237 : 		EndChildFrame();

	call	?EndChildFrame@ImGui@@YAXXZ		; ImGui::EndChildFrame

; 4238 : 		EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	npad	1
$LN174@InputTextE:

; 4239 : 	}
; 4240 : 
; 4241 : 	if (is_password)

	movzx	eax, BYTE PTR is_password$[rsp]
	test	eax, eax
	je	SHORT $LN175@InputTextE

; 4242 : 		PopFont();

	call	?PopFont@ImGui@@YAXXZ			; ImGui::PopFont
	npad	1
$LN175@InputTextE:

; 4243 : 
; 4244 : 	// Log as text
; 4245 :    /* if (g.LogEnabled && !is_password)
; 4246 : 		LogRenderedText(&render_pos, buf_display, NULL);*/
; 4247 : 
; 4248 : 	if (label_size.x > 0)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN176@InputTextE

; 4249 : 		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR frame_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR frame_bb$[rsp+8]
	addss	xmm1, DWORD PTR [rax+76]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T91[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN176@InputTextE:

; 4250 : 
; 4251 : 	if (value_changed)

	movzx	eax, BYTE PTR value_changed$[rsp]
	test	eax, eax
	je	SHORT $LN177@InputTextE

; 4252 : 		MarkItemEdited(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN177@InputTextE:
$LN18@InputTextE:

; 4253 : 
; 4254 : 	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);

	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN18@InputTextE

; 4255 : 	if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN178@InputTextE

; 4256 : 		return enter_pressed;

	movzx	eax, BYTE PTR enter_pressed$[rsp]
	jmp	SHORT $LN1@InputTextE
	jmp	SHORT $LN179@InputTextE
$LN178@InputTextE:

; 4257 : 	else
; 4258 : 		return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
$LN179@InputTextE:
$LN1@InputTextE:

; 4259 : }

	add	rsp, 1448				; 000005a8H
	ret	0
?InputTextEx@ImGui@@YA_NPEBDPEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ENDP ; ImGui::InputTextEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 32
tv77 = 40
id$ = 64
?TreePushRawID@ImGui@@YAXI@Z PROC			; ImGui::TreePushRawID

; 5514 : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 5515 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5516 : 	Indent();

	xorps	xmm0, xmm0
	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent

; 5517 : 	window->DC.TreeDepth++;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+364]
	inc	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+364], eax

; 5518 : 	window->IDStack.push_back(id);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 232				; 000000e8H
	mov	QWORD PTR tv77[rsp], rax
	lea	rdx, QWORD PTR id$[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	?push_back@?$ImVector@I@@QEAAXAEBI@Z	; ImVector<unsigned int>::push_back
	npad	1

; 5519 : }

	add	rsp, 56					; 00000038H
	ret	0
?TreePushRawID@ImGui@@YAXI@Z ENDP			; ImGui::TreePushRawID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
is_open$ = 32
stored_value$1 = 36
tv90 = 40
tv129 = 44
tv133 = 48
g$ = 56
storage$ = 64
window$ = 72
id$ = 96
flags$ = 104
?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z PROC		; ImGui::TreeNodeBehaviorIsOpen

; 5299 : {

$LN16:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 5300 : 	if (flags & ImGuiTreeNodeFlags_Leaf)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN2@TreeNodeBe

; 5301 : 		return true;

	mov	al, 1
	jmp	$LN1@TreeNodeBe
$LN2@TreeNodeBe:

; 5302 : 
; 5303 : 	// We only write to the tree storage if the user clicks (or explicitly use SetNextTreeNode*** functions)
; 5304 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5305 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5306 : 	ImGuiStorage* storage = window->DC.StateStorage;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+448]
	mov	QWORD PTR storage$[rsp], rax

; 5307 : 
; 5308 : 	bool is_open;
; 5309 : 	if (g.NextTreeNodeOpenCond != 0)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6908], 0
	je	$LN3@TreeNodeBe

; 5310 : 	{
; 5311 : 		if (g.NextTreeNodeOpenCond & ImGuiCond_Always)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6908]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@TreeNodeBe

; 5312 : 		{
; 5313 : 			is_open = g.NextTreeNodeOpenVal;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6904]
	mov	BYTE PTR is_open$[rsp], al

; 5314 : 			storage->SetInt(id, is_open);

	movzx	eax, BYTE PTR is_open$[rsp]
	mov	r8d, eax
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR storage$[rsp]
	call	?SetInt@ImGuiStorage@@QEAAXIH@Z		; ImGuiStorage::SetInt
	npad	1

; 5315 : 		}

	jmp	SHORT $LN6@TreeNodeBe
$LN5@TreeNodeBe:

; 5316 : 		else
; 5317 : 		{
; 5318 : 			// We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
; 5319 : 			const int stored_value = storage->GetInt(id, -1);

	mov	r8d, -1
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR storage$[rsp]
	call	?GetInt@ImGuiStorage@@QEBAHIH@Z		; ImGuiStorage::GetInt
	mov	DWORD PTR stored_value$1[rsp], eax

; 5320 : 			if (stored_value == -1)

	cmp	DWORD PTR stored_value$1[rsp], -1
	jne	SHORT $LN7@TreeNodeBe

; 5321 : 			{
; 5322 : 				is_open = g.NextTreeNodeOpenVal;

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6904]
	mov	BYTE PTR is_open$[rsp], al

; 5323 : 				storage->SetInt(id, is_open);

	movzx	eax, BYTE PTR is_open$[rsp]
	mov	r8d, eax
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR storage$[rsp]
	call	?SetInt@ImGuiStorage@@QEAAXIH@Z		; ImGuiStorage::SetInt
	npad	1

; 5324 : 			}

	jmp	SHORT $LN8@TreeNodeBe
$LN7@TreeNodeBe:

; 5325 : 			else
; 5326 : 			{
; 5327 : 				is_open = stored_value != 0;

	cmp	DWORD PTR stored_value$1[rsp], 0
	je	SHORT $LN10@TreeNodeBe
	mov	DWORD PTR tv90[rsp], 1
	jmp	SHORT $LN11@TreeNodeBe
$LN10@TreeNodeBe:
	mov	DWORD PTR tv90[rsp], 0
$LN11@TreeNodeBe:
	movzx	eax, BYTE PTR tv90[rsp]
	mov	BYTE PTR is_open$[rsp], al
$LN8@TreeNodeBe:
$LN6@TreeNodeBe:

; 5328 : 			}
; 5329 : 		}
; 5330 : 		g.NextTreeNodeOpenCond = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6908], 0

; 5331 : 	}

	jmp	SHORT $LN4@TreeNodeBe
$LN3@TreeNodeBe:

; 5332 : 	else
; 5333 : 	{
; 5334 : 		is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN12@TreeNodeBe
	mov	DWORD PTR tv129[rsp], 1
	jmp	SHORT $LN13@TreeNodeBe
$LN12@TreeNodeBe:
	mov	DWORD PTR tv129[rsp], 0
$LN13@TreeNodeBe:
	mov	r8d, DWORD PTR tv129[rsp]
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR storage$[rsp]
	call	?GetInt@ImGuiStorage@@QEBAHIH@Z		; ImGuiStorage::GetInt
	test	eax, eax
	je	SHORT $LN14@TreeNodeBe
	mov	DWORD PTR tv133[rsp], 1
	jmp	SHORT $LN15@TreeNodeBe
$LN14@TreeNodeBe:
	mov	DWORD PTR tv133[rsp], 0
$LN15@TreeNodeBe:
	movzx	eax, BYTE PTR tv133[rsp]
	mov	BYTE PTR is_open$[rsp], al
$LN4@TreeNodeBe:

; 5335 : 	}
; 5336 : 
; 5337 : 	// When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
; 5338 : 	// NB- If we are above max depth we still allow manually opened nodes to be logged.
; 5339 :    /* if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && window->DC.TreeDepth < g.LogAutoExpandMaxDepth)
; 5340 : 		is_open = true;
; 5341 : */
; 5342 : 	return is_open;

	movzx	eax, BYTE PTR is_open$[rsp]
$LN1@TreeNodeBe:

; 5343 : }

	add	rsp, 88					; 00000058H
	ret	0
?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z ENDP		; ImGui::TreeNodeBehaviorIsOpen
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
is_open$ = 64
toggled$ = 65
display_frame$ = 66
hovered$ = 67
is_leaf$ = 68
tv71 = 69
g$ = 72
item_add$ = 80
pressed$ = 81
held$ = 82
selected$ = 83
button_flags$ = 84
window$ = 88
text_base_offset_y$ = 96
frame_bb$ = 104
text_offset_x$ = 120
padding$ = 128
tv194 = 136
tv200 = 140
tv305 = 144
tv313 = 148
tv329 = 152
tv348 = 156
tv390 = 160
tv410 = 164
tv411 = 168
tv434 = 172
col$ = 176
nav_highlight_flags$ = 180
tv488 = 184
text_width$ = 188
frame_height$ = 192
style$ = 200
tv260 = 208
label_size$ = 216
tv134 = 224
tv671 = 228
tv350 = 232
tv165 = 236
tv167 = 240
tv84 = 248
tv221 = 256
text_pos$ = 264
interact_bb$ = 272
$T1 = 288
$T2 = 296
$T3 = 304
tv399 = 312
$T4 = 320
$T5 = 328
$T6 = 336
$T7 = 344
$T8 = 352
$T9 = 360
$T10 = 368
$T11 = 376
$T12 = 384
$T13 = 392
$T14 = 400
$T15 = 408
$T16 = 416
$T17 = 424
$T18 = 440
id$ = 496
flags$ = 504
label$ = 512
label_end$ = 520
?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z PROC		; ImGui::TreeNodeBehavior

; 5346 : {

$LN65:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	push	rdi
	sub	rsp, 472				; 000001d8H

; 5347 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5348 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN8@TreeNodeBe

; 5349 : 		return false;

	xor	al, al
	jmp	$LN1@TreeNodeBe
$LN8@TreeNodeBe:

; 5350 : 
; 5351 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5352 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 5353 : 	const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN35@TreeNodeBe
	mov	BYTE PTR tv71[rsp], 1
	jmp	SHORT $LN36@TreeNodeBe
$LN35@TreeNodeBe:
	mov	BYTE PTR tv71[rsp], 0
$LN36@TreeNodeBe:
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR display_frame$[rsp], al

; 5354 : 	const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, 0.0f);

	movzx	eax, BYTE PTR display_frame$[rsp]
	test	eax, eax
	jne	SHORT $LN37@TreeNodeBe
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	jne	SHORT $LN37@TreeNodeBe
	xorps	xmm2, xmm2
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+52]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv84[rsp], rax
	jmp	SHORT $LN38@TreeNodeBe
$LN37@TreeNodeBe:
	mov	rax, QWORD PTR style$[rsp]
	mov	rax, QWORD PTR [rax+52]
	mov	QWORD PTR $T1[rsp], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR tv84[rsp], rax
$LN38@TreeNodeBe:
	mov	rax, QWORD PTR tv84[rsp]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR padding$[rsp], rax

; 5355 : 
; 5356 : 	if (!label_end)

	cmp	QWORD PTR label_end$[rsp], 0
	jne	SHORT $LN9@TreeNodeBe

; 5357 : 		label_end = FindRenderedTextEnd(label);

	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	QWORD PTR label_end$[rsp], rax
$LN9@TreeNodeBe:

; 5358 : 	const ImVec2 label_size = CalcTextSize(label, label_end, false);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	mov	r8, QWORD PTR label_end$[rsp]
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 5359 : 
; 5360 : 	// We vertically grow up to current line height up the typical widget height.
; 5361 : 	const float text_base_offset_y = ImMax(padding.y, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+328]
	movss	xmm0, DWORD PTR padding$[rsp+4]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR text_base_offset_y$[rsp], xmm0

; 5362 : 	const float frame_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + style.FramePadding.y * 2), label_size.y + padding.y * 2);

	movss	xmm0, DWORD PTR padding$[rsp+4]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv134[rsp], xmm0
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	mulss	xmm1, DWORD PTR __real@40000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR [rax+6408]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+324]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	xmm1, DWORD PTR tv134[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR frame_height$[rsp], xmm0

; 5363 : 	ImRect frame_bb = ImRect(window->DC.CursorPos, ImVec2(window->Pos.x + GetContentRegionMax().x, window->DC.CursorPos.y + frame_height));

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	addss	xmm0, DWORD PTR frame_height$[rsp]
	movss	DWORD PTR tv167[rsp], xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+48]
	addss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv165[rsp], xmm0
	movss	xmm2, DWORD PTR tv167[rsp]
	movss	xmm1, DWORD PTR tv165[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 5364 : 	if (display_frame)

	movzx	eax, BYTE PTR display_frame$[rsp]
	test	eax, eax
	je	SHORT $LN10@TreeNodeBe

; 5365 : 	{
; 5366 : 		// Framed header expand a little outside the default padding
; 5367 : 		frame_bb.Min.x -= (float)(int)(window->WindowPadding.x * 0.5f) - 1;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+80]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR frame_bb$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR frame_bb$[rsp], xmm0

; 5368 : 		frame_bb.Max.x += (float)(int)(window->WindowPadding.x * 0.5f) - 1;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+80]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR frame_bb$[rsp+8]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR frame_bb$[rsp+8], xmm0
$LN10@TreeNodeBe:

; 5369 : 	}
; 5370 : 
; 5371 : 	const float text_offset_x = (g.FontSize + (display_frame ? padding.x * 3 : padding.x * 2));   // Collapser arrow width + Spacing

	movzx	eax, BYTE PTR display_frame$[rsp]
	test	eax, eax
	je	SHORT $LN39@TreeNodeBe
	movss	xmm0, DWORD PTR padding$[rsp]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR tv194[rsp], xmm0
	jmp	SHORT $LN40@TreeNodeBe
$LN39@TreeNodeBe:
	movss	xmm0, DWORD PTR padding$[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv194[rsp], xmm0
$LN40@TreeNodeBe:
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	addss	xmm0, DWORD PTR tv194[rsp]
	movss	DWORD PTR text_offset_x$[rsp], xmm0

; 5372 : 	const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x * 2 : 0.0f);   // Include collapser

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN41@TreeNodeBe
	movss	xmm0, DWORD PTR padding$[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv200[rsp], xmm0
	jmp	SHORT $LN42@TreeNodeBe
$LN41@TreeNodeBe:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv200[rsp], xmm0
$LN42@TreeNodeBe:
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	addss	xmm0, DWORD PTR tv200[rsp]
	movss	DWORD PTR text_width$[rsp], xmm0

; 5373 : 	ItemSize(ImVec2(text_width, frame_height), text_base_offset_y);

	movss	xmm2, DWORD PTR frame_height$[rsp]
	movss	xmm1, DWORD PTR text_width$[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm1, DWORD PTR text_base_offset_y$[rsp]
	mov	rcx, rax
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 5374 : 
; 5375 : 	// For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
; 5376 : 	// (Ideally we'd want to add a flag for the user to specify if we want the hit test to be done up to the right side of the content or not)
; 5377 : 	const ImRect interact_bb = display_frame ? frame_bb : ImRect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + text_width + style.ItemSpacing.x * 2, frame_bb.Max.y);

	movzx	eax, BYTE PTR display_frame$[rsp]
	test	eax, eax
	je	SHORT $LN43@TreeNodeBe
	lea	rax, QWORD PTR $T17[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T17[rsp]
	mov	QWORD PTR tv221[rsp], rax
	jmp	SHORT $LN44@TreeNodeBe
$LN43@TreeNodeBe:
	movss	xmm0, DWORD PTR frame_bb$[rsp]
	addss	xmm0, DWORD PTR text_width$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+68]
	mulss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR frame_bb$[rsp+12]
	movss	DWORD PTR [rsp+32], xmm1
	movaps	xmm3, xmm0
	movss	xmm2, DWORD PTR frame_bb$[rsp+4]
	movss	xmm1, DWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	QWORD PTR tv221[rsp], rax
$LN44@TreeNodeBe:
	mov	rax, QWORD PTR tv221[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rax, QWORD PTR interact_bb$[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR $T3[rsp]
	mov	ecx, 16
	rep movsb

; 5378 : 	bool is_open = TreeNodeBehaviorIsOpen(id, flags);

	mov	edx, DWORD PTR flags$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z	; ImGui::TreeNodeBehaviorIsOpen
	mov	BYTE PTR is_open$[rsp], al

; 5379 : 	bool is_leaf = (flags & ImGuiTreeNodeFlags_Leaf) != 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN45@TreeNodeBe
	mov	DWORD PTR tv260[rsp], 1
	jmp	SHORT $LN46@TreeNodeBe
$LN45@TreeNodeBe:
	mov	DWORD PTR tv260[rsp], 0
$LN46@TreeNodeBe:
	movzx	eax, BYTE PTR tv260[rsp]
	mov	BYTE PTR is_leaf$[rsp], al

; 5380 : 
; 5381 : 	// Store a flag for the current depth to tell if we will allow closing this node when navigating one of its child.
; 5382 : 	// For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
; 5383 : 	// This is currently only support 32 level deep and we are fine with (1 << Depth) overflowing into a zero.
; 5384 : 	if (is_open && !g.NavIdIsAlive && (flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))

	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	je	SHORT $LN11@TreeNodeBe
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7141]
	test	eax, eax
	jne	SHORT $LN11@TreeNodeBe
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8192				; 00002000H
	test	eax, eax
	je	SHORT $LN11@TreeNodeBe
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN11@TreeNodeBe

; 5385 : 		window->DC.TreeDepthMayJumpToParentOnPop |= (1 << window->DC.TreeDepth);

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+364]
	mov	ecx, 1
	mov	DWORD PTR tv671[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv671[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+408]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+408], eax
$LN11@TreeNodeBe:

; 5386 : 
; 5387 : 	bool item_add = ItemAdd(interact_bb, id);

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR interact_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	mov	BYTE PTR item_add$[rsp], al

; 5388 : 	window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+416]
	or	eax, 2
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+416], eax

; 5389 : 	window->DC.LastItemDisplayRect = frame_bb;

	mov	rax, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	lea	rdi, QWORD PTR [rax+384]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 5390 : 
; 5391 : 	if (!item_add)

	movzx	eax, BYTE PTR item_add$[rsp]
	test	eax, eax
	jne	SHORT $LN12@TreeNodeBe

; 5392 : 	{
; 5393 : 		if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))

	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	je	SHORT $LN13@TreeNodeBe
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN13@TreeNodeBe

; 5394 : 			TreePushRawID(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?TreePushRawID@ImGui@@YAXI@Z		; ImGui::TreePushRawID
	npad	1
$LN13@TreeNodeBe:
$LN4@TreeNodeBe:

; 5395 : 		IMGUI_TEST_ENGINE_ITEM_INFO(window->DC.LastItemId, label, window->DC.ItemFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));

	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@TreeNodeBe

; 5396 : 		return is_open;

	movzx	eax, BYTE PTR is_open$[rsp]
	jmp	$LN1@TreeNodeBe
$LN12@TreeNodeBe:

; 5397 : 	}
; 5398 : 
; 5399 : 	// Flags that affects opening behavior:
; 5400 : 	// - 0 (default) .................... single-click anywhere to open
; 5401 : 	// - OpenOnDoubleClick .............. double-click anywhere to open
; 5402 : 	// - OpenOnArrow .................... single-click on arrow to open
; 5403 : 	// - OpenOnDoubleClick|OpenOnArrow .. single-click on arrow or double-click anywhere to open
; 5404 : 	ImGuiButtonFlags button_flags = ImGuiButtonFlags_NoKeyModifiers;

	mov	DWORD PTR button_flags$[rsp], 1024	; 00000400H

; 5405 : 	if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN14@TreeNodeBe

; 5406 : 		button_flags |= ImGuiButtonFlags_AllowItemOverlap;

	mov	eax, DWORD PTR button_flags$[rsp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR button_flags$[rsp], eax
$LN14@TreeNodeBe:

; 5407 : 	if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN15@TreeNodeBe

; 5408 : 		button_flags |= ImGuiButtonFlags_PressedOnDoubleClick | ((flags & ImGuiTreeNodeFlags_OpenOnArrow) ? ImGuiButtonFlags_PressedOnClickRelease : 0);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN47@TreeNodeBe
	mov	DWORD PTR tv305[rsp], 2
	jmp	SHORT $LN48@TreeNodeBe
$LN47@TreeNodeBe:
	mov	DWORD PTR tv305[rsp], 0
$LN48@TreeNodeBe:
	mov	eax, DWORD PTR tv305[rsp]
	or	eax, 16
	mov	ecx, DWORD PTR button_flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR button_flags$[rsp], eax
$LN15@TreeNodeBe:

; 5409 : 	if (!is_leaf)

	movzx	eax, BYTE PTR is_leaf$[rsp]
	test	eax, eax
	jne	SHORT $LN16@TreeNodeBe

; 5410 : 		button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;

	mov	eax, DWORD PTR button_flags$[rsp]
	bts	eax, 12
	mov	DWORD PTR button_flags$[rsp], eax
$LN16@TreeNodeBe:

; 5411 : 
; 5412 : 	bool selected = (flags & ImGuiTreeNodeFlags_Selected) != 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN49@TreeNodeBe
	mov	DWORD PTR tv313[rsp], 1
	jmp	SHORT $LN50@TreeNodeBe
$LN49@TreeNodeBe:
	mov	DWORD PTR tv313[rsp], 0
$LN50@TreeNodeBe:
	movzx	eax, BYTE PTR tv313[rsp]
	mov	BYTE PTR selected$[rsp], al

; 5413 : 	bool hovered, held;
; 5414 : 	bool pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);

	mov	eax, DWORD PTR button_flags$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR interact_bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 5415 : 	bool toggled = false;

	mov	BYTE PTR toggled$[rsp], 0

; 5416 : 	if (!is_leaf)

	movzx	eax, BYTE PTR is_leaf$[rsp]
	test	eax, eax
	jne	$LN17@TreeNodeBe

; 5417 : 	{
; 5418 : 		if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	$LN18@TreeNodeBe

; 5419 : 		{
; 5420 : 			toggled = !(flags & (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick)) || (g.NavActivateId == id);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 192				; 000000c0H
	test	eax, eax
	je	SHORT $LN51@TreeNodeBe
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7044], ecx
	je	SHORT $LN51@TreeNodeBe
	mov	DWORD PTR tv329[rsp], 0
	jmp	SHORT $LN52@TreeNodeBe
$LN51@TreeNodeBe:
	mov	DWORD PTR tv329[rsp], 1
$LN52@TreeNodeBe:
	movzx	eax, BYTE PTR tv329[rsp]
	mov	BYTE PTR toggled$[rsp], al

; 5421 : 			if (flags & ImGuiTreeNodeFlags_OpenOnArrow)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN19@TreeNodeBe

; 5422 : 				toggled |= IsMouseHoveringRect(interact_bb.Min, ImVec2(interact_bb.Min.x + text_offset_x, interact_bb.Max.y)) && (!g.NavDisableMouseHover);

	movzx	eax, BYTE PTR toggled$[rsp]
	mov	DWORD PTR tv350[rsp], eax
	movss	xmm0, DWORD PTR interact_bb$[rsp]
	addss	xmm0, DWORD PTR text_offset_x$[rsp]
	movss	xmm2, DWORD PTR interact_bb$[rsp+12]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8b, 1
	mov	rdx, rax
	lea	rcx, QWORD PTR interact_bb$[rsp]
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN53@TreeNodeBe
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7143]
	test	eax, eax
	jne	SHORT $LN53@TreeNodeBe
	mov	DWORD PTR tv348[rsp], 1
	jmp	SHORT $LN54@TreeNodeBe
$LN53@TreeNodeBe:
	mov	DWORD PTR tv348[rsp], 0
$LN54@TreeNodeBe:
	mov	eax, DWORD PTR tv348[rsp]
	mov	ecx, DWORD PTR tv350[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR toggled$[rsp], al
$LN19@TreeNodeBe:

; 5423 : 			if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN20@TreeNodeBe

; 5424 : 				toggled |= g.IO.MouseDoubleClicked[0];

	movzx	eax, BYTE PTR toggled$[rsp]
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx+1021]
	or	eax, ecx
	mov	BYTE PTR toggled$[rsp], al
$LN20@TreeNodeBe:

; 5425 : 			if (g.DragDropActive && is_open) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	je	SHORT $LN21@TreeNodeBe
	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	je	SHORT $LN21@TreeNodeBe

; 5426 : 				toggled = false;

	mov	BYTE PTR toggled$[rsp], 0
$LN21@TreeNodeBe:
$LN18@TreeNodeBe:

; 5427 : 		}
; 5428 : 
; 5429 : 		if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Left && is_open)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7040], ecx
	jne	SHORT $LN22@TreeNodeBe
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	SHORT $LN22@TreeNodeBe
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 0
	jne	SHORT $LN22@TreeNodeBe
	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	je	SHORT $LN22@TreeNodeBe

; 5430 : 		{
; 5431 : 			toggled = true;

	mov	BYTE PTR toggled$[rsp], 1

; 5432 : 			NavMoveRequestCancel();

	call	?NavMoveRequestCancel@ImGui@@YAXXZ	; ImGui::NavMoveRequestCancel
	npad	1
$LN22@TreeNodeBe:

; 5433 : 		}
; 5434 : 		if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7040], ecx
	jne	SHORT $LN23@TreeNodeBe
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	SHORT $LN23@TreeNodeBe
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 1
	jne	SHORT $LN23@TreeNodeBe
	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	jne	SHORT $LN23@TreeNodeBe

; 5435 : 		{
; 5436 : 			toggled = true;

	mov	BYTE PTR toggled$[rsp], 1

; 5437 : 			NavMoveRequestCancel();

	call	?NavMoveRequestCancel@ImGui@@YAXXZ	; ImGui::NavMoveRequestCancel
	npad	1
$LN23@TreeNodeBe:

; 5438 : 		}
; 5439 : 
; 5440 : 		if (toggled)

	movzx	eax, BYTE PTR toggled$[rsp]
	test	eax, eax
	je	SHORT $LN24@TreeNodeBe

; 5441 : 		{
; 5442 : 			is_open = !is_open;

	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	jne	SHORT $LN55@TreeNodeBe
	mov	DWORD PTR tv390[rsp], 1
	jmp	SHORT $LN56@TreeNodeBe
$LN55@TreeNodeBe:
	mov	DWORD PTR tv390[rsp], 0
$LN56@TreeNodeBe:
	movzx	eax, BYTE PTR tv390[rsp]
	mov	BYTE PTR is_open$[rsp], al

; 5443 : 			window->DC.StateStorage->SetInt(id, is_open);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+448]
	mov	QWORD PTR tv399[rsp], rax
	movzx	eax, BYTE PTR is_open$[rsp]
	mov	r8d, eax
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR tv399[rsp]
	call	?SetInt@ImGuiStorage@@QEAAXIH@Z		; ImGuiStorage::SetInt
	npad	1
$LN24@TreeNodeBe:
$LN17@TreeNodeBe:

; 5444 : 		}
; 5445 : 	}
; 5446 : 	if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN25@TreeNodeBe

; 5447 : 		SetItemAllowOverlap();

	call	?SetItemAllowOverlap@ImGui@@YAXXZ	; ImGui::SetItemAllowOverlap
	npad	1
$LN25@TreeNodeBe:

; 5448 : 
; 5449 : 	// Render
; 5450 : 	const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN57@TreeNodeBe
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN57@TreeNodeBe
	mov	DWORD PTR tv411[rsp], 26
	jmp	SHORT $LN60@TreeNodeBe
$LN57@TreeNodeBe:
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN58@TreeNodeBe
	mov	DWORD PTR tv410[rsp], 25
	jmp	SHORT $LN59@TreeNodeBe
$LN58@TreeNodeBe:
	mov	DWORD PTR tv410[rsp], 24
$LN59@TreeNodeBe:
	mov	eax, DWORD PTR tv410[rsp]
	mov	DWORD PTR tv411[rsp], eax
$LN60@TreeNodeBe:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv411[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR col$[rsp], eax

; 5451 : 	const ImVec2 text_pos = frame_bb.Min + ImVec2(text_offset_x, text_base_offset_y);

	movss	xmm2, DWORD PTR text_base_offset_y$[rsp]
	movss	xmm1, DWORD PTR text_offset_x$[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR text_pos$[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1

; 5452 : 	ImGuiNavHighlightFlags nav_highlight_flags = ImGuiNavHighlightFlags_TypeThin;

	mov	DWORD PTR nav_highlight_flags$[rsp], 2

; 5453 : 	if (display_frame)

	movzx	eax, BYTE PTR display_frame$[rsp]
	test	eax, eax
	je	$LN26@TreeNodeBe

; 5454 : 	{
; 5455 : 		// Framed type
; 5456 : 		RenderFrame(frame_bb.Min, frame_bb.Max, col, true, style.FrameRounding);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	r8d, DWORD PTR col$[rsp]
	mov	rdx, QWORD PTR frame_bb$[rsp+8]
	mov	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 5457 : 		RenderNavHighlight(frame_bb, id, nav_highlight_flags);

	mov	r8d, DWORD PTR nav_highlight_flags$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
	npad	1

; 5458 : 		RenderArrow(frame_bb.Min + ImVec2(padding.x, text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 1.0f);

	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	je	SHORT $LN61@TreeNodeBe
	mov	DWORD PTR tv434[rsp], 3
	jmp	SHORT $LN62@TreeNodeBe
$LN61@TreeNodeBe:
	mov	DWORD PTR tv434[rsp], 1
$LN62@TreeNodeBe:
	movss	xmm2, DWORD PTR text_base_offset_y$[rsp]
	movss	xmm1, DWORD PTR padding$[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR $T11[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	movss	xmm2, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR tv434[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderArrow@ImGui@@YAXUImVec2@@HM@Z	; ImGui::RenderArrow
	npad	1

; 5459 : 		//if (g.LogEnabled)
; 5460 : 		//{
; 5461 : 		//    // NB: '##' is normally used to hide text (as a library-wide feature), so we need to specify the text range to make sure the ## aren't stripped out here.
; 5462 : 		//    const char log_prefix[] = "\n##";
; 5463 : 		//    const char log_suffix[] = "##";
; 5464 : 		//    LogRenderedText(&text_pos, log_prefix, log_prefix+3);
; 5465 : 		//    RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
; 5466 : 		//    LogRenderedText(&text_pos, log_suffix+1, log_suffix+3);
; 5467 : 		//}
; 5468 : 		//else
; 5469 : 		{
; 5470 : 			RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR [rsp+48], 0
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR label_size$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR label_end$[rsp]
	mov	r8, QWORD PTR label$[rsp]
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	lea	rcx, QWORD PTR text_pos$[rsp]
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
	npad	1

; 5471 : 		}
; 5472 : 	}

	jmp	$LN27@TreeNodeBe
$LN26@TreeNodeBe:

; 5473 : 	else
; 5474 : 	{
; 5475 : 		// Unframed typed for tree nodes
; 5476 : 		if (hovered || selected)

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	jne	SHORT $LN29@TreeNodeBe
	movzx	eax, BYTE PTR selected$[rsp]
	test	eax, eax
	je	SHORT $LN28@TreeNodeBe
$LN29@TreeNodeBe:

; 5477 : 		{
; 5478 : 			RenderFrame(frame_bb.Min, frame_bb.Max, col, false);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	mov	r8d, DWORD PTR col$[rsp]
	mov	rdx, QWORD PTR frame_bb$[rsp+8]
	mov	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 5479 : 			RenderNavHighlight(frame_bb, id, nav_highlight_flags);

	mov	r8d, DWORD PTR nav_highlight_flags$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
	npad	1
$LN28@TreeNodeBe:

; 5480 : 		}
; 5481 : 
; 5482 : 		if (flags & ImGuiTreeNodeFlags_Bullet)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN30@TreeNodeBe

; 5483 : 			RenderBullet(frame_bb.Min + ImVec2(text_offset_x * 0.5f, g.FontSize * 0.50f + text_base_offset_y));

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR text_base_offset_y$[rsp]
	movss	xmm1, DWORD PTR text_offset_x$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR [rax]
	call	?RenderBullet@ImGui@@YAXUImVec2@@@Z	; ImGui::RenderBullet
	npad	1
	jmp	$LN31@TreeNodeBe
$LN30@TreeNodeBe:

; 5484 : 		else if (!is_leaf)

	movzx	eax, BYTE PTR is_leaf$[rsp]
	test	eax, eax
	jne	$LN32@TreeNodeBe

; 5485 : 			RenderArrow(frame_bb.Min + ImVec2(padding.x, g.FontSize * 0.15f + text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 0.70f);

	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	je	SHORT $LN63@TreeNodeBe
	mov	DWORD PTR tv488[rsp], 3
	jmp	SHORT $LN64@TreeNodeBe
$LN63@TreeNodeBe:
	mov	DWORD PTR tv488[rsp], 1
$LN64@TreeNodeBe:
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3e19999a
	addss	xmm0, DWORD PTR text_base_offset_y$[rsp]
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR padding$[rsp]
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR $T16[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	movss	xmm2, DWORD PTR __real@3f333333
	mov	edx, DWORD PTR tv488[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderArrow@ImGui@@YAXUImVec2@@HM@Z	; ImGui::RenderArrow
	npad	1
$LN32@TreeNodeBe:
$LN31@TreeNodeBe:

; 5486 : 		/*if (g.LogEnabled)
; 5487 : 			LogRenderedText(&text_pos, ">");*/
; 5488 : 		RenderText(text_pos, label, label_end, false);

	xor	r9d, r9d
	mov	r8, QWORD PTR label_end$[rsp]
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR text_pos$[rsp]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN27@TreeNodeBe:

; 5489 : 	}
; 5490 : 
; 5491 : 	if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))

	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	je	SHORT $LN33@TreeNodeBe
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN33@TreeNodeBe

; 5492 : 		TreePushRawID(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?TreePushRawID@ImGui@@YAXI@Z		; ImGui::TreePushRawID
	npad	1
$LN33@TreeNodeBe:
$LN7@TreeNodeBe:

; 5493 : 	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));

	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@TreeNodeBe

; 5494 : 	return is_open;

	movzx	eax, BYTE PTR is_open$[rsp]
$LN1@TreeNodeBe:

; 5495 : }

	add	rsp, 472				; 000001d8H
	pop	rdi
	pop	rsi
	ret	0
?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z ENDP		; ImGui::TreeNodeBehavior
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
held$ = 48
mouse_delta$1 = 52
item_add$ = 56
hovered$ = 57
g$ = 64
tv141 = 72
tv157 = 76
size_1_maximum_delta$2 = 80
size_2_maximum_delta$3 = 84
tv226 = 88
tv229 = 92
window$ = 96
item_flags_backup$ = 104
col$ = 108
tv91 = 112
mouse_delta_2d$4 = 120
tv185 = 128
$T5 = 136
$T6 = 144
tv241 = 152
bb_interact$ = 160
bb_render$ = 176
$T7 = 192
$T8 = 200
$T9 = 208
$T10 = 216
$T11 = 224
bb$ = 272
id$ = 280
axis$ = 288
size1$ = 296
size2$ = 304
min_size1$ = 312
min_size2$ = 320
hover_extend$ = 328
hover_visibility_delay$ = 336
?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMM@Z PROC ; ImGui::SplitterBehavior

; 1519 : {

$LN26:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 248				; 000000f8H

; 1520 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1521 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 1522 : 
; 1523 : 	const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+476]
	mov	DWORD PTR item_flags_backup$[rsp], eax

; 1524 : 	window->DC.ItemFlags |= ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+476]
	or	eax, 24
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+476], eax

; 1525 : 	bool item_add = ItemAdd(bb, id);

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	mov	BYTE PTR item_add$[rsp], al

; 1526 : 	window->DC.ItemFlags = item_flags_backup;

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR item_flags_backup$[rsp]
	mov	DWORD PTR [rax+476], ecx

; 1527 : 	if (!item_add)

	movzx	eax, BYTE PTR item_add$[rsp]
	test	eax, eax
	jne	SHORT $LN2@SplitterBe

; 1528 : 		return false;

	xor	al, al
	jmp	$LN1@SplitterBe
$LN2@SplitterBe:

; 1529 : 
; 1530 : 	bool hovered, held;
; 1531 : 	ImRect bb_interact = bb;

	lea	rax, QWORD PTR bb_interact$[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR bb$[rsp]
	mov	ecx, 16
	rep movsb

; 1532 : 	bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN13@SplitterBe
	movss	xmm2, DWORD PTR hover_extend$[rsp]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv91[rsp], rax
	jmp	SHORT $LN14@SplitterBe
$LN13@SplitterBe:
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR hover_extend$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv91[rsp], rax
$LN14@SplitterBe:
	mov	rax, QWORD PTR tv91[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rdx, QWORD PTR $T5[rsp]
	lea	rcx, QWORD PTR bb_interact$[rsp]
	call	?Expand@ImRect@@QEAAXAEBUImVec2@@@Z	; ImRect::Expand
	npad	1

; 1533 : 	ButtonBehavior(bb_interact, id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap);

	mov	DWORD PTR [rsp+32], 96			; 00000060H
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb_interact$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	npad	1

; 1534 : 	if (g.ActiveId != id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN3@SplitterBe

; 1535 : 		SetItemAllowOverlap();

	call	?SetItemAllowOverlap@ImGui@@YAXXZ	; ImGui::SetItemAllowOverlap
	npad	1
$LN3@SplitterBe:

; 1536 : 
; 1537 : 	if (held || (g.HoveredId == id && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay))

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	jne	SHORT $LN5@SplitterBe
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6696], ecx
	jne	SHORT $LN4@SplitterBe
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6724], ecx
	jne	SHORT $LN4@SplitterBe
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6728]
	comiss	xmm0, DWORD PTR hover_visibility_delay$[rsp]
	jb	SHORT $LN4@SplitterBe
$LN5@SplitterBe:

; 1538 : 		SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN15@SplitterBe
	mov	DWORD PTR tv141[rsp], 3
	jmp	SHORT $LN16@SplitterBe
$LN15@SplitterBe:
	mov	DWORD PTR tv141[rsp], 4
$LN16@SplitterBe:
	mov	ecx, DWORD PTR tv141[rsp]
	call	?SetMouseCursor@ImGui@@YAXH@Z		; ImGui::SetMouseCursor
	npad	1
$LN4@SplitterBe:

; 1539 : 
; 1540 : 	ImRect bb_render = bb;

	lea	rax, QWORD PTR bb_render$[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR bb$[rsp]
	mov	ecx, 16
	rep movsb

; 1541 : 	if (held)

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	$LN6@SplitterBe

; 1542 : 	{
; 1543 : 		ImVec2 mouse_delta_2d = g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6812				; 00001a9cH
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 316				; 0000013cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T9[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	lea	r8, QWORD PTR bb_interact$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR mouse_delta_2d$4[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	npad	1

; 1544 : 		float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;

	cmp	DWORD PTR axis$[rsp], 1
	jne	SHORT $LN17@SplitterBe
	movss	xmm0, DWORD PTR mouse_delta_2d$4[rsp+4]
	movss	DWORD PTR tv157[rsp], xmm0
	jmp	SHORT $LN18@SplitterBe
$LN17@SplitterBe:
	movss	xmm0, DWORD PTR mouse_delta_2d$4[rsp]
	movss	DWORD PTR tv157[rsp], xmm0
$LN18@SplitterBe:
	movss	xmm0, DWORD PTR tv157[rsp]
	movss	DWORD PTR mouse_delta$1[rsp], xmm0

; 1545 : 
; 1546 : 		// Minimum pane size
; 1547 : 		float size_1_maximum_delta = ImMax(0.0f, *size1 - min_size1);

	mov	rax, QWORD PTR size1$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR min_size1$[rsp]
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR size_1_maximum_delta$2[rsp], xmm0

; 1548 : 		float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);

	mov	rax, QWORD PTR size2$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR min_size2$[rsp]
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR size_2_maximum_delta$3[rsp], xmm0

; 1549 : 		if (mouse_delta < -size_1_maximum_delta)

	movss	xmm0, DWORD PTR size_1_maximum_delta$2[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR mouse_delta$1[rsp]
	jbe	SHORT $LN7@SplitterBe

; 1550 : 			mouse_delta = -size_1_maximum_delta;

	movss	xmm0, DWORD PTR size_1_maximum_delta$2[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR mouse_delta$1[rsp], xmm0
$LN7@SplitterBe:

; 1551 : 		if (mouse_delta > size_2_maximum_delta)

	movss	xmm0, DWORD PTR mouse_delta$1[rsp]
	comiss	xmm0, DWORD PTR size_2_maximum_delta$3[rsp]
	jbe	SHORT $LN8@SplitterBe

; 1552 : 			mouse_delta = size_2_maximum_delta;

	movss	xmm0, DWORD PTR size_2_maximum_delta$3[rsp]
	movss	DWORD PTR mouse_delta$1[rsp], xmm0
$LN8@SplitterBe:

; 1553 : 
; 1554 : 		// Apply resize
; 1555 : 		if (mouse_delta != 0.0f)

	movss	xmm0, DWORD PTR mouse_delta$1[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN25@SplitterBe
	je	$LN9@SplitterBe
$LN25@SplitterBe:

; 1556 : 		{
; 1557 : 			if (mouse_delta < 0.0f)

	xorps	xmm0, xmm0

; 1558 : 				IM_ASSERT(*size1 + mouse_delta >= min_size1);
; 1559 : 			if (mouse_delta > 0.0f)

	movss	xmm0, DWORD PTR mouse_delta$1[rsp]

; 1560 : 				IM_ASSERT(*size2 - mouse_delta >= min_size2);
; 1561 : 			*size1 += mouse_delta;

	mov	rax, QWORD PTR size1$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR mouse_delta$1[rsp]
	mov	rax, QWORD PTR size1$[rsp]
	movss	DWORD PTR [rax], xmm0

; 1562 : 			*size2 -= mouse_delta;

	mov	rax, QWORD PTR size2$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR mouse_delta$1[rsp]
	mov	rax, QWORD PTR size2$[rsp]
	movss	DWORD PTR [rax], xmm0

; 1563 : 			bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));

	cmp	DWORD PTR axis$[rsp], 0
	jne	SHORT $LN19@SplitterBe
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR mouse_delta$1[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv185[rsp], rax
	jmp	SHORT $LN20@SplitterBe
$LN19@SplitterBe:
	movss	xmm2, DWORD PTR mouse_delta$1[rsp]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv185[rsp], rax
$LN20@SplitterBe:
	mov	rax, QWORD PTR tv185[rsp]
	mov	QWORD PTR $T6[rsp], rax
	mov	rdx, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR bb_render$[rsp]
	call	?Translate@ImRect@@QEAAXAEBUImVec2@@@Z	; ImRect::Translate
	npad	1

; 1564 : 			MarkItemEdited(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN9@SplitterBe:
$LN6@SplitterBe:

; 1565 : 		}
; 1566 : 	}
; 1567 : 
; 1568 : 	// Render
; 1569 : 	const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN23@SplitterBe
	mov	DWORD PTR tv229[rsp], 29
	jmp	SHORT $LN24@SplitterBe
$LN23@SplitterBe:
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN21@SplitterBe
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6728]
	comiss	xmm0, DWORD PTR hover_visibility_delay$[rsp]
	jb	SHORT $LN21@SplitterBe
	mov	DWORD PTR tv226[rsp], 28
	jmp	SHORT $LN22@SplitterBe
$LN21@SplitterBe:
	mov	DWORD PTR tv226[rsp], 27
$LN22@SplitterBe:
	mov	eax, DWORD PTR tv226[rsp]
	mov	DWORD PTR tv229[rsp], eax
$LN24@SplitterBe:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv229[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR col$[rsp], eax

; 1570 : 	window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, g.Style.FrameRounding);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv241[rsp], rax
	mov	DWORD PTR [rsp+40], 15
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5532]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR col$[rsp]
	lea	r8, QWORD PTR bb_render$[rsp+8]
	lea	rdx, QWORD PTR bb_render$[rsp]
	mov	rcx, QWORD PTR tv241[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1571 : 
; 1572 : 	return held;

	movzx	eax, BYTE PTR held$[rsp]
$LN1@SplitterBe:

; 1573 : }

	add	rsp, 248				; 000000f8H
	pop	rdi
	pop	rsi
	ret	0
?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMM@Z ENDP ; ImGui::SplitterBehavior
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv64 = 80
bb$ = 112
id$ = 120
data_type$ = 128
v$ = 136
v_min$ = 144
v_max$ = 152
format$ = 160
power$ = 168
flags$ = 176
out_grab_bb$ = 184
?SliderBehavior@ImGui@@YA_NAEBUImRect@@IHPEAXPEBX2PEBDMHPEAU2@@Z PROC ; ImGui::SliderBehavior

; 2620 : {

$LN13:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2621 : 	switch (data_type)

	mov	eax, DWORD PTR data_type$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 5
	ja	$LN2@SliderBeha
	movsxd	rax, DWORD PTR tv64[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN12@SliderBeha[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@SliderBeha:

; 2622 : 	{
; 2623 : 	case ImGuiDataType_S32:
; 2624 : 		IM_ASSERT(*(const ImS32*)v_min >= IM_S32_MIN / 2 && *(const ImS32*)v_max <= IM_S32_MAX / 2);
; 2625 : 		return SliderBehaviorT<ImS32, ImS32, float >(bb, id, data_type, (ImS32*)v, *(const ImS32*)v_min, *(const ImS32*)v_max, format, power, flags, out_grab_bb);

	mov	rax, QWORD PTR out_grab_bb$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+64], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR v_max$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR v_min$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR v$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR bb$[rsp]
	call	??$SliderBehaviorT@HHM@ImGui@@YA_NAEBUImRect@@IHPEAHHHPEBDMHPEAU1@@Z ; ImGui::SliderBehaviorT<int,int,float>
	jmp	$LN1@SliderBeha
$LN5@SliderBeha:

; 2626 : 	case ImGuiDataType_U32:
; 2627 : 		IM_ASSERT(*(const ImU32*)v_min <= IM_U32_MAX / 2);
; 2628 : 		return SliderBehaviorT<ImU32, ImS32, float >(bb, id, data_type, (ImU32*)v, *(const ImU32*)v_min, *(const ImU32*)v_max, format, power, flags, out_grab_bb);

	mov	rax, QWORD PTR out_grab_bb$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+64], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR v_max$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR v_min$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR v$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR bb$[rsp]
	call	??$SliderBehaviorT@IHM@ImGui@@YA_NAEBUImRect@@IHPEAIIIPEBDMHPEAU1@@Z ; ImGui::SliderBehaviorT<unsigned int,int,float>
	jmp	$LN1@SliderBeha
$LN6@SliderBeha:

; 2629 : 	case ImGuiDataType_S64:
; 2630 : 		IM_ASSERT(*(const ImS64*)v_min >= IM_S64_MIN / 2 && *(const ImS64*)v_max <= IM_S64_MAX / 2);
; 2631 : 		return SliderBehaviorT<ImS64, ImS64, double>(bb, id, data_type, (ImS64*)v, *(const ImS64*)v_min, *(const ImS64*)v_max, format, power, flags, out_grab_bb);

	mov	rax, QWORD PTR out_grab_bb$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+64], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR v_max$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR bb$[rsp]
	call	??$SliderBehaviorT@_J_JN@ImGui@@YA_NAEBUImRect@@IHPEA_J_J2PEBDMHPEAU1@@Z ; ImGui::SliderBehaviorT<__int64,__int64,double>
	jmp	$LN1@SliderBeha
$LN7@SliderBeha:

; 2632 : 	case ImGuiDataType_U64:
; 2633 : 		IM_ASSERT(*(const ImU64*)v_min <= IM_U64_MAX / 2);
; 2634 : 		return SliderBehaviorT<ImU64, ImS64, double>(bb, id, data_type, (ImU64*)v, *(const ImU64*)v_min, *(const ImU64*)v_max, format, power, flags, out_grab_bb);

	mov	rax, QWORD PTR out_grab_bb$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+64], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR v_max$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR bb$[rsp]
	call	??$SliderBehaviorT@_K_JN@ImGui@@YA_NAEBUImRect@@IHPEA_K_K2PEBDMHPEAU1@@Z ; ImGui::SliderBehaviorT<unsigned __int64,__int64,double>
	jmp	$LN1@SliderBeha
$LN8@SliderBeha:

; 2635 : 	case ImGuiDataType_Float:
; 2636 : 		IM_ASSERT(*(const float*)v_min >= -FLT_MAX / 2.0f && *(const float*)v_max <= FLT_MAX / 2.0f);
; 2637 : 		return SliderBehaviorT<float, float, float >(bb, id, data_type, (float*)v, *(const float*)v_min, *(const float*)v_max, format, power, flags, out_grab_bb);

	mov	rax, QWORD PTR out_grab_bb$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+64], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR v_max$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rsp+40], xmm0
	mov	rax, QWORD PTR v_min$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9, QWORD PTR v$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR bb$[rsp]
	call	??$SliderBehaviorT@MMM@ImGui@@YA_NAEBUImRect@@IHPEAMMMPEBDMHPEAU1@@Z ; ImGui::SliderBehaviorT<float,float,float>
	jmp	SHORT $LN1@SliderBeha
$LN9@SliderBeha:

; 2638 : 	case ImGuiDataType_Double:
; 2639 : 		IM_ASSERT(*(const double*)v_min >= -DBL_MAX / 2.0f && *(const double*)v_max <= DBL_MAX / 2.0f);
; 2640 : 		return SliderBehaviorT<double, double, double>(bb, id, data_type, (double*)v, *(const double*)v_min, *(const double*)v_max, format, power, flags, out_grab_bb);

	mov	rax, QWORD PTR out_grab_bb$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+64], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR v_max$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR [rsp+40], xmm0
	mov	rax, QWORD PTR v_min$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR [rsp+32], xmm0
	mov	r9, QWORD PTR v$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR bb$[rsp]
	call	??$SliderBehaviorT@NNN@ImGui@@YA_NAEBUImRect@@IHPEANNNPEBDMHPEAU1@@Z ; ImGui::SliderBehaviorT<double,double,double>
	jmp	SHORT $LN1@SliderBeha
$LN2@SliderBeha:

; 2641 : 	case ImGuiDataType_COUNT: break;
; 2642 : 	}
; 2643 : 	IM_ASSERT(0);
; 2644 : 	return false;

	xor	al, al
$LN1@SliderBeha:

; 2645 : }

	add	rsp, 104				; 00000068H
	ret	0
$LN12@SliderBeha:
	DD	$LN4@SliderBeha
	DD	$LN5@SliderBeha
	DD	$LN6@SliderBeha
	DD	$LN7@SliderBeha
	DD	$LN8@SliderBeha
	DD	$LN9@SliderBeha
?SliderBehavior@ImGui@@YA_NAEBUImRect@@IHPEAXPEBX2PEBDMHPEAU2@@Z ENDP ; ImGui::SliderBehavior
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 64
tv83 = 72
tv89 = 76
tv92 = 80
tv136 = 84
tv139 = 88
tv181 = 92
tv184 = 96
tv151 = 104
tv154 = 112
tv166 = 120
tv169 = 128
tv196 = 136
tv199 = 144
tv130 = 152
tv145 = 160
tv160 = 168
tv175 = 176
tv190 = 184
tv205 = 192
id$ = 224
data_type$ = 232
v$ = 240
v_speed$ = 248
v_min$ = 256
v_max$ = 264
format$ = 272
power$ = 280
flags$ = 288
?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDMH@Z PROC	; ImGui::DragBehavior

; 2185 : {

$LN42:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 216				; 000000d8H

; 2186 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2187 : 	if (g.ActiveId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN4@DragBehavi

; 2188 : 	{
; 2189 : 		if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	SHORT $LN5@DragBehavi
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	jne	SHORT $LN5@DragBehavi

; 2190 : 			ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
	jmp	SHORT $LN6@DragBehavi
$LN5@DragBehavi:

; 2191 : 		else if (g.ActiveIdSource == ImGuiInputSource_Nav && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	SHORT $LN7@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7036], ecx
	jne	SHORT $LN7@DragBehavi
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	test	eax, eax
	jne	SHORT $LN7@DragBehavi

; 2192 : 			ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
$LN7@DragBehavi:
$LN6@DragBehavi:
$LN4@DragBehavi:

; 2193 : 	}
; 2194 : 	if (g.ActiveId != id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN8@DragBehavi

; 2195 : 		return false;

	xor	al, al
	jmp	$LN1@DragBehavi
$LN8@DragBehavi:

; 2196 : 
; 2197 : 	switch (data_type)

	mov	eax, DWORD PTR data_type$[rsp]
	mov	DWORD PTR tv83[rsp], eax
	cmp	DWORD PTR tv83[rsp], 5
	ja	$LN2@DragBehavi
	movsxd	rax, DWORD PTR tv83[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN41@DragBehavi[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN9@DragBehavi:

; 2198 : 	{
; 2199 : 	case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >(data_type, (ImS32*)v, v_speed, v_min ? *(const ImS32*)v_min : IM_S32_MIN, v_max ? *(const ImS32*)v_max : IM_S32_MAX, format, power, flags);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv130[rsp], rax
	cmp	QWORD PTR v_max$[rsp], 0
	je	SHORT $LN17@DragBehavi
	mov	rax, QWORD PTR v_max$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv89[rsp], eax
	jmp	SHORT $LN18@DragBehavi
$LN17@DragBehavi:
	mov	DWORD PTR tv89[rsp], 2147483647		; 7fffffffH
$LN18@DragBehavi:
	cmp	QWORD PTR v_min$[rsp], 0
	je	SHORT $LN19@DragBehavi
	mov	rax, QWORD PTR v_min$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv92[rsp], eax
	jmp	SHORT $LN20@DragBehavi
$LN19@DragBehavi:
	mov	DWORD PTR tv92[rsp], -2147483648	; ffffffff80000000H
$LN20@DragBehavi:
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	rax, QWORD PTR tv130[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv89[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR tv92[rsp]
	movss	xmm2, DWORD PTR v_speed$[rsp]
	mov	rdx, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDMH@Z ; ImGui::DragBehaviorT<int,int,float>
	jmp	$LN1@DragBehavi
$LN10@DragBehavi:

; 2200 : 	case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >(data_type, (ImU32*)v, v_speed, v_min ? *(const ImU32*)v_min : IM_U32_MIN, v_max ? *(const ImU32*)v_max : IM_U32_MAX, format, power, flags);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv145[rsp], rax
	cmp	QWORD PTR v_max$[rsp], 0
	je	SHORT $LN21@DragBehavi
	mov	rax, QWORD PTR v_max$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv136[rsp], eax
	jmp	SHORT $LN22@DragBehavi
$LN21@DragBehavi:
	mov	DWORD PTR tv136[rsp], -1		; ffffffffH
$LN22@DragBehavi:
	cmp	QWORD PTR v_min$[rsp], 0
	je	SHORT $LN23@DragBehavi
	mov	rax, QWORD PTR v_min$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv139[rsp], eax
	jmp	SHORT $LN24@DragBehavi
$LN23@DragBehavi:
	mov	DWORD PTR tv139[rsp], 0
$LN24@DragBehavi:
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	rax, QWORD PTR tv145[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv136[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR tv139[rsp]
	movss	xmm2, DWORD PTR v_speed$[rsp]
	mov	rdx, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDMH@Z ; ImGui::DragBehaviorT<unsigned int,int,float>
	jmp	$LN1@DragBehavi
$LN11@DragBehavi:

; 2201 : 	case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64*)v, v_speed, v_min ? *(const ImS64*)v_min : IM_S64_MIN, v_max ? *(const ImS64*)v_max : IM_S64_MAX, format, power, flags);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv160[rsp], rax
	cmp	QWORD PTR v_max$[rsp], 0
	je	SHORT $LN25@DragBehavi
	mov	rax, QWORD PTR v_max$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv151[rsp], rax
	jmp	SHORT $LN26@DragBehavi
$LN25@DragBehavi:
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	mov	QWORD PTR tv151[rsp], rax
$LN26@DragBehavi:
	cmp	QWORD PTR v_min$[rsp], 0
	je	SHORT $LN27@DragBehavi
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv154[rsp], rax
	jmp	SHORT $LN28@DragBehavi
$LN27@DragBehavi:
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	QWORD PTR tv154[rsp], rax
$LN28@DragBehavi:
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	rax, QWORD PTR tv160[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv151[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv154[rsp]
	movss	xmm2, DWORD PTR v_speed$[rsp]
	mov	rdx, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDMH@Z ; ImGui::DragBehaviorT<__int64,__int64,double>
	jmp	$LN1@DragBehavi
$LN12@DragBehavi:

; 2202 : 	case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64*)v, v_speed, v_min ? *(const ImU64*)v_min : IM_U64_MIN, v_max ? *(const ImU64*)v_max : IM_U64_MAX, format, power, flags);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv175[rsp], rax
	cmp	QWORD PTR v_max$[rsp], 0
	je	SHORT $LN29@DragBehavi
	mov	rax, QWORD PTR v_max$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv166[rsp], rax
	jmp	SHORT $LN30@DragBehavi
$LN29@DragBehavi:
	mov	QWORD PTR tv166[rsp], -1
$LN30@DragBehavi:
	cmp	QWORD PTR v_min$[rsp], 0
	je	SHORT $LN31@DragBehavi
	mov	rax, QWORD PTR v_min$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv169[rsp], rax
	jmp	SHORT $LN32@DragBehavi
$LN31@DragBehavi:
	mov	QWORD PTR tv169[rsp], 0
$LN32@DragBehavi:
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	rax, QWORD PTR tv175[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv166[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv169[rsp]
	movss	xmm2, DWORD PTR v_speed$[rsp]
	mov	rdx, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDMH@Z ; ImGui::DragBehaviorT<unsigned __int64,__int64,double>
	jmp	$LN1@DragBehavi
$LN13@DragBehavi:

; 2203 : 	case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >(data_type, (float*)v, v_speed, v_min ? *(const float*)v_min : -FLT_MAX, v_max ? *(const float*)v_max : FLT_MAX, format, power, flags);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv190[rsp], rax
	cmp	QWORD PTR v_max$[rsp], 0
	je	SHORT $LN33@DragBehavi
	mov	rax, QWORD PTR v_max$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv181[rsp], xmm0
	jmp	SHORT $LN34@DragBehavi
$LN33@DragBehavi:
	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR tv181[rsp], xmm0
$LN34@DragBehavi:
	cmp	QWORD PTR v_min$[rsp], 0
	je	SHORT $LN35@DragBehavi
	mov	rax, QWORD PTR v_min$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv184[rsp], xmm0
	jmp	SHORT $LN36@DragBehavi
$LN35@DragBehavi:
	movss	xmm0, DWORD PTR __real@ff7fffff
	movss	DWORD PTR tv184[rsp], xmm0
$LN36@DragBehavi:
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	rax, QWORD PTR tv190[rsp]
	mov	QWORD PTR [rsp+40], rax
	movss	xmm0, DWORD PTR tv181[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR tv184[rsp]
	movss	xmm2, DWORD PTR v_speed$[rsp]
	mov	rdx, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDMH@Z ; ImGui::DragBehaviorT<float,float,float>
	jmp	$LN1@DragBehavi
$LN14@DragBehavi:

; 2204 : 	case ImGuiDataType_Double: return DragBehaviorT<double, double, double>(data_type, (double*)v, v_speed, v_min ? *(const double*)v_min : -DBL_MAX, v_max ? *(const double*)v_max : DBL_MAX, format, power, flags);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv205[rsp], rax
	cmp	QWORD PTR v_max$[rsp], 0
	je	SHORT $LN37@DragBehavi
	mov	rax, QWORD PTR v_max$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR tv196[rsp], xmm0
	jmp	SHORT $LN38@DragBehavi
$LN37@DragBehavi:
	movsd	xmm0, QWORD PTR __real@7fefffffffffffff
	movsd	QWORD PTR tv196[rsp], xmm0
$LN38@DragBehavi:
	cmp	QWORD PTR v_min$[rsp], 0
	je	SHORT $LN39@DragBehavi
	mov	rax, QWORD PTR v_min$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR tv199[rsp], xmm0
	jmp	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
	movsd	xmm0, QWORD PTR __real@ffefffffffffffff
	movsd	QWORD PTR tv199[rsp], xmm0
$LN40@DragBehavi:
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	rax, QWORD PTR tv205[rsp]
	mov	QWORD PTR [rsp+40], rax
	movsd	xmm0, QWORD PTR tv196[rsp]
	movsd	QWORD PTR [rsp+32], xmm0
	movsd	xmm3, QWORD PTR tv199[rsp]
	movss	xmm2, DWORD PTR v_speed$[rsp]
	mov	rdx, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR data_type$[rsp]
	call	??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDMH@Z ; ImGui::DragBehaviorT<double,double,double>
	jmp	SHORT $LN1@DragBehavi
$LN2@DragBehavi:

; 2205 : 	case ImGuiDataType_COUNT:  break;
; 2206 : 	}
; 2207 : 	IM_ASSERT(0);
; 2208 : 	return false;

	xor	al, al
$LN1@DragBehavi:

; 2209 : }

	add	rsp, 216				; 000000d8H
	ret	0
	npad	1
$LN41@DragBehavi:
	DD	$LN9@DragBehavi
	DD	$LN10@DragBehavi
	DD	$LN11@DragBehavi
	DD	$LN12@DragBehavi
	DD	$LN13@DragBehavi
	DD	$LN14@DragBehavi
?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDMH@Z ENDP	; ImGui::DragBehavior
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
hovered$ = 32
pressed$ = 33
g$ = 40
nav_activated_by_code$1 = 48
nav_activated_by_inputs$2 = 49
held$ = 50
window$ = 56
tv271 = 64
tv276 = 68
tv149 = 72
backup_hovered_window$ = 80
$T3 = 88
bb$ = 112
id$ = 120
out_hovered$ = 128
out_held$ = 136
flags$ = 144
?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z PROC	; ImGui::ButtonBehavior

; 497  : {

$LN59:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 498  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 499  : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 500  : 
; 501  : 	if (flags & ImGuiButtonFlags_Disabled)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN2@ButtonBeha

; 502  : 	{
; 503  : 		if (out_hovered) *out_hovered = false;

	cmp	QWORD PTR out_hovered$[rsp], 0
	je	SHORT $LN3@ButtonBeha
	mov	rax, QWORD PTR out_hovered$[rsp]
	mov	BYTE PTR [rax], 0
$LN3@ButtonBeha:

; 504  : 		if (out_held) *out_held = false;

	cmp	QWORD PTR out_held$[rsp], 0
	je	SHORT $LN4@ButtonBeha
	mov	rax, QWORD PTR out_held$[rsp]
	mov	BYTE PTR [rax], 0
$LN4@ButtonBeha:

; 505  : 		if (g.ActiveId == id) ClearActiveID();

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN5@ButtonBeha
	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
$LN5@ButtonBeha:

; 506  : 		return false;

	xor	al, al
	jmp	$LN1@ButtonBeha
$LN2@ButtonBeha:

; 507  : 	}
; 508  : 
; 509  : 	// Default behavior requires click+release on same spot
; 510  : 	if ((flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick)) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 30
	test	eax, eax
	jne	SHORT $LN6@ButtonBeha

; 511  : 		flags |= ImGuiButtonFlags_PressedOnClickRelease;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 2
	mov	DWORD PTR flags$[rsp], eax
$LN6@ButtonBeha:

; 512  : 
; 513  : 	ImGuiWindow* backup_hovered_window = g.HoveredWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6560]
	mov	QWORD PTR backup_hovered_window$[rsp], rax

; 514  : 	if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN7@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+6688], rcx
	jne	SHORT $LN7@ButtonBeha

; 515  : 		g.HoveredWindow = window;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+6560], rcx
$LN7@ButtonBeha:

; 516  : 
; 517  : #ifdef IMGUI_ENABLE_TEST_ENGINE
; 518  : 	if (id != 0 && window->DC.LastItemId != id)
; 519  : 		ImGuiTestEngineHook_ItemAdd(&g, bb, id);
; 520  : #endif
; 521  : 
; 522  : 	bool pressed = false;

	mov	BYTE PTR pressed$[rsp], 0

; 523  : 	bool hovered = ItemHoverable(bb, id);

	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR bb$[rsp]
	call	?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z ; ImGui::ItemHoverable
	mov	BYTE PTR hovered$[rsp], al

; 524  : 
; 525  : 	// Drag source doesn't report as hovered
; 526  : 	if (hovered && g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN8@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	je	SHORT $LN8@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7628], ecx
	jne	SHORT $LN8@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7608]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN8@ButtonBeha

; 527  : 		hovered = false;

	mov	BYTE PTR hovered$[rsp], 0
$LN8@ButtonBeha:

; 528  : 
; 529  : 	// Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
; 530  : 	if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	je	$LN9@ButtonBeha
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	$LN9@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7608]
	and	eax, 4
	test	eax, eax
	jne	$LN9@ButtonBeha

; 531  : 		if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))

	mov	ecx, 32					; 00000020H
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@ButtonBeha

; 532  : 		{
; 533  : 			hovered = true;

	mov	BYTE PTR hovered$[rsp], 1

; 534  : 			SetHoveredID(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID
	npad	1

; 535  : 			if (CalcTypematicPressedRepeatAmount(g.HoveredIdTimer + 0.0001f, g.HoveredIdTimer + 0.0001f - g.IO.DeltaTime, 0.01f, 0.70f)) // FIXME: Our formula for CalcTypematicPressedRepeatAmount() is fishy

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6728]
	addss	xmm0, DWORD PTR __real@38d1b717
	mov	rax, QWORD PTR g$[rsp]
	subss	xmm0, DWORD PTR [rax+48]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6728]
	addss	xmm1, DWORD PTR __real@38d1b717
	movss	DWORD PTR tv149[rsp], xmm1
	movss	xmm3, DWORD PTR __real@3f333333
	movss	xmm2, DWORD PTR __real@3c23d70a
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv149[rsp]
	call	?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicPressedRepeatAmount
	test	eax, eax
	je	SHORT $LN11@ButtonBeha

; 536  : 			{
; 537  : 				pressed = true;

	mov	BYTE PTR pressed$[rsp], 1

; 538  : 				FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1
$LN11@ButtonBeha:
$LN10@ButtonBeha:
$LN9@ButtonBeha:

; 539  : 			}
; 540  : 		}
; 541  : 
; 542  : 	if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN12@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+6688], rcx
	jne	SHORT $LN12@ButtonBeha

; 543  : 		g.HoveredWindow = backup_hovered_window;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR backup_hovered_window$[rsp]
	mov	QWORD PTR [rax+6560], rcx
$LN12@ButtonBeha:

; 544  : 
; 545  : 	// AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
; 546  : 	if (hovered && (flags & ImGuiButtonFlags_AllowItemOverlap) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN13@ButtonBeha
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN13@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6724], ecx
	je	SHORT $LN13@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6724], 0
	je	SHORT $LN13@ButtonBeha

; 547  : 		hovered = false;

	mov	BYTE PTR hovered$[rsp], 0
$LN13@ButtonBeha:

; 548  : 
; 549  : 	// Mouse
; 550  : 	if (hovered)

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	$LN14@ButtonBeha

; 551  : 	{
; 552  : 		if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $LN16@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	jne	$LN15@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+304]
	test	eax, eax
	jne	$LN15@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+324]
	test	eax, eax
	jne	$LN15@ButtonBeha
$LN16@ButtonBeha:

; 553  : 		{
; 554  : 			//                        | CLICKING        | HOLDING with ImGuiButtonFlags_Repeat
; 555  : 			// PressedOnClickRelease  |  <on release>*  |  <on repeat> <on repeat> .. (NOT on release)  <-- MOST COMMON! (*) only if both click/release were over bounds
; 556  : 			// PressedOnClick         |  <on click>     |  <on click> <on repeat> <on repeat> ..
; 557  : 			// PressedOnRelease       |  <on release>   |  <on repeat> <on repeat> .. (NOT on release)
; 558  : 			// PressedOnDoubleClick   |  <on dclick>    |  <on dclick> <on repeat> <on repeat> ..
; 559  : 			// FIXME-NAV: We don't honor those different behaviors.
; 560  : 			if ((flags & ImGuiButtonFlags_PressedOnClickRelease) && g.IO.MouseClicked[0])

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN17@ButtonBeha
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1016]
	test	eax, eax
	je	SHORT $LN17@ButtonBeha

; 561  : 			{
; 562  : 				SetActiveID(id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
	npad	1

; 563  : 				if (!(flags & ImGuiButtonFlags_NoNavFocus))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8192				; 00002000H
	test	eax, eax
	jne	SHORT $LN18@ButtonBeha

; 564  : 					SetFocusID(id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetFocusID
	npad	1
$LN18@ButtonBeha:

; 565  : 				FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1
$LN17@ButtonBeha:

; 566  : 			}
; 567  : 			if (((flags & ImGuiButtonFlags_PressedOnClick) && g.IO.MouseClicked[0]) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDoubleClicked[0]))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN21@ButtonBeha
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1016]
	test	eax, eax
	jne	SHORT $LN20@ButtonBeha
$LN21@ButtonBeha:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN19@ButtonBeha
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1021]
	test	eax, eax
	je	SHORT $LN19@ButtonBeha
$LN20@ButtonBeha:

; 568  : 			{
; 569  : 				pressed = true;

	mov	BYTE PTR pressed$[rsp], 1

; 570  : 				if (flags & ImGuiButtonFlags_NoHoldingActiveID)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $LN22@ButtonBeha

; 571  : 					ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
	jmp	SHORT $LN23@ButtonBeha
$LN22@ButtonBeha:

; 572  : 				else
; 573  : 					SetActiveID(id, window); // Hold on ID

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
	npad	1
$LN23@ButtonBeha:

; 574  : 				FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow
	npad	1
$LN19@ButtonBeha:

; 575  : 			}
; 576  : 			if ((flags & ImGuiButtonFlags_PressedOnRelease) && g.IO.MouseReleased[0])

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN24@ButtonBeha
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1076]
	test	eax, eax
	je	SHORT $LN24@ButtonBeha

; 577  : 			{
; 578  : 				if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN26@ButtonBeha
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+1112]
	comiss	xmm0, DWORD PTR [rdx+152]
	jae	SHORT $LN25@ButtonBeha
$LN26@ButtonBeha:

; 579  : 					pressed = true;

	mov	BYTE PTR pressed$[rsp], 1
$LN25@ButtonBeha:

; 580  : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
$LN24@ButtonBeha:

; 581  : 			}
; 582  : 
; 583  : 			// 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
; 584  : 			// Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
; 585  : 			if ((flags & ImGuiButtonFlags_Repeat) && g.ActiveId == id && g.IO.MouseDownDuration[0] > 0.0f && IsMouseClicked(0, true))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN27@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN27@ButtonBeha
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+1084]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN27@ButtonBeha
	mov	dl, 1
	xor	ecx, ecx
	call	?IsMouseClicked@ImGui@@YA_NH_N@Z	; ImGui::IsMouseClicked
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN27@ButtonBeha

; 586  : 				pressed = true;

	mov	BYTE PTR pressed$[rsp], 1
$LN27@ButtonBeha:
$LN15@ButtonBeha:

; 587  : 		}
; 588  : 
; 589  : 		if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN28@ButtonBeha

; 590  : 			g.NavDisableHighlight = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 1
$LN28@ButtonBeha:
$LN14@ButtonBeha:

; 591  : 	}
; 592  : 
; 593  : 	// Gamepad/Keyboard navigation
; 594  : 	// We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
; 595  : 	if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7040], ecx
	jne	SHORT $LN29@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7140]
	test	eax, eax
	jne	SHORT $LN29@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7143]
	test	eax, eax
	je	SHORT $LN29@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN30@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	je	SHORT $LN30@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+68]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN29@ButtonBeha
$LN30@ButtonBeha:

; 596  : 		hovered = true;

	mov	BYTE PTR hovered$[rsp], 1
$LN29@ButtonBeha:

; 597  : 
; 598  : 	if (g.NavActivateDownId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7032], ecx
	jne	$LN31@ButtonBeha

; 599  : 	{
; 600  : 		bool nav_activated_by_code = (g.NavActivateId == id);

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7044], ecx
	jne	SHORT $LN55@ButtonBeha
	mov	DWORD PTR tv271[rsp], 1
	jmp	SHORT $LN56@ButtonBeha
$LN55@ButtonBeha:
	mov	DWORD PTR tv271[rsp], 0
$LN56@ButtonBeha:
	movzx	eax, BYTE PTR tv271[rsp]
	mov	BYTE PTR nav_activated_by_code$1[rsp], al

; 601  : 		bool nav_activated_by_inputs = IsNavInputPressed(ImGuiNavInput_Activate, (flags & ImGuiButtonFlags_Repeat) ? ImGuiInputReadMode_Repeat : ImGuiInputReadMode_Pressed);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN57@ButtonBeha
	mov	DWORD PTR tv276[rsp], 3
	jmp	SHORT $LN58@ButtonBeha
$LN57@ButtonBeha:
	mov	DWORD PTR tv276[rsp], 1
$LN58@ButtonBeha:
	mov	edx, DWORD PTR tv276[rsp]
	xor	ecx, ecx
	call	?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputPressed
	mov	BYTE PTR nav_activated_by_inputs$2[rsp], al

; 602  : 		if (nav_activated_by_code || nav_activated_by_inputs)

	movzx	eax, BYTE PTR nav_activated_by_code$1[rsp]
	test	eax, eax
	jne	SHORT $LN33@ButtonBeha
	movzx	eax, BYTE PTR nav_activated_by_inputs$2[rsp]
	test	eax, eax
	je	SHORT $LN32@ButtonBeha
$LN33@ButtonBeha:

; 603  : 			pressed = true;

	mov	BYTE PTR pressed$[rsp], 1
$LN32@ButtonBeha:

; 604  : 		if (nav_activated_by_code || nav_activated_by_inputs || g.ActiveId == id)

	movzx	eax, BYTE PTR nav_activated_by_code$1[rsp]
	test	eax, eax
	jne	SHORT $LN35@ButtonBeha
	movzx	eax, BYTE PTR nav_activated_by_inputs$2[rsp]
	test	eax, eax
	jne	SHORT $LN35@ButtonBeha
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN34@ButtonBeha
$LN35@ButtonBeha:

; 605  : 		{
; 606  : 			// Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
; 607  : 			g.NavActivateId = id; // This is so SetActiveId assign a Nav source

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+7044], ecx

; 608  : 			SetActiveID(id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
	npad	1

; 609  : 			if ((nav_activated_by_code || nav_activated_by_inputs) && !(flags & ImGuiButtonFlags_NoNavFocus))

	movzx	eax, BYTE PTR nav_activated_by_code$1[rsp]
	test	eax, eax
	jne	SHORT $LN37@ButtonBeha
	movzx	eax, BYTE PTR nav_activated_by_inputs$2[rsp]
	test	eax, eax
	je	SHORT $LN36@ButtonBeha
$LN37@ButtonBeha:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8192				; 00002000H
	test	eax, eax
	jne	SHORT $LN36@ButtonBeha

; 610  : 				SetFocusID(id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetFocusID
	npad	1
$LN36@ButtonBeha:

; 611  : 			g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right) | (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6804], 15
$LN34@ButtonBeha:
$LN31@ButtonBeha:

; 612  : 		}
; 613  : 	}
; 614  : 
; 615  : 	bool held = false;

	mov	BYTE PTR held$[rsp], 0

; 616  : 	if (g.ActiveId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	$LN38@ButtonBeha

; 617  : 	{
; 618  : 		if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN39@ButtonBeha

; 619  : 			g.ActiveIdHasBeenPressed = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+6716], 1
$LN39@ButtonBeha:

; 620  : 		if (g.ActiveIdSource == ImGuiInputSource_Mouse)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 1
	jne	$LN40@ButtonBeha

; 621  : 		{
; 622  : 			if (g.ActiveIdIsJustActivated)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6752]
	test	eax, eax
	je	SHORT $LN42@ButtonBeha

; 623  : 				g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;

	mov	rax, QWORD PTR bb$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 316				; 0000013cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T3[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+6812], rax
$LN42@ButtonBeha:

; 624  : 			if (g.IO.MouseDown[0])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+305]
	test	eax, eax
	je	SHORT $LN43@ButtonBeha

; 625  : 			{
; 626  : 				held = true;

	mov	BYTE PTR held$[rsp], 1

; 627  : 			}

	jmp	SHORT $LN44@ButtonBeha
$LN43@ButtonBeha:

; 628  : 			else
; 629  : 			{
; 630  : 				if (hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease))

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN45@ButtonBeha
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN45@ButtonBeha

; 631  : 					if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN47@ButtonBeha
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+1112]
	comiss	xmm0, DWORD PTR [rdx+152]
	jae	SHORT $LN46@ButtonBeha
$LN47@ButtonBeha:

; 632  : 						if (!g.DragDropActive)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	jne	SHORT $LN48@ButtonBeha

; 633  : 							pressed = true;

	mov	BYTE PTR pressed$[rsp], 1
$LN48@ButtonBeha:
$LN46@ButtonBeha:
$LN45@ButtonBeha:

; 634  : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
$LN44@ButtonBeha:

; 635  : 			}
; 636  : 			if (!(flags & ImGuiButtonFlags_NoNavFocus))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8192				; 00002000H
	test	eax, eax
	jne	SHORT $LN49@ButtonBeha

; 637  : 				g.NavDisableHighlight = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 1
$LN49@ButtonBeha:

; 638  : 		}

	jmp	SHORT $LN41@ButtonBeha
$LN40@ButtonBeha:

; 639  : 		else if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6820], 2
	jne	SHORT $LN50@ButtonBeha

; 640  : 		{
; 641  : 			if (g.NavActivateDownId != id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7032], ecx
	je	SHORT $LN51@ButtonBeha

; 642  : 				ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	npad	1
$LN51@ButtonBeha:
$LN50@ButtonBeha:
$LN41@ButtonBeha:
$LN38@ButtonBeha:

; 643  : 		}
; 644  : 	}
; 645  : 
; 646  : 	if (out_hovered) *out_hovered = hovered;

	cmp	QWORD PTR out_hovered$[rsp], 0
	je	SHORT $LN52@ButtonBeha
	mov	rax, QWORD PTR out_hovered$[rsp]
	movzx	ecx, BYTE PTR hovered$[rsp]
	mov	BYTE PTR [rax], cl
$LN52@ButtonBeha:

; 647  : 	if (out_held) *out_held = held;

	cmp	QWORD PTR out_held$[rsp], 0
	je	SHORT $LN53@ButtonBeha
	mov	rax, QWORD PTR out_held$[rsp]
	movzx	ecx, BYTE PTR held$[rsp]
	mov	BYTE PTR [rax], cl
$LN53@ButtonBeha:

; 648  : 
; 649  : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@ButtonBeha:

; 650  : }

	add	rsp, 104				; 00000068H
	ret	0
?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ENDP	; ImGui::ButtonBehavior
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 48
y2$ = 56
y1$ = 60
tv168 = 64
bb$ = 72
tv132 = 88
tv130 = 96
tv166 = 104
tv164 = 112
tv170 = 120
g$ = 128
$T1 = 136
$T2 = 144
$T3 = 152
$T4 = 160
$T5 = 168
?VerticalSeparator@ImGui@@YAXXZ PROC			; ImGui::VerticalSeparator

; 1499 : {

$LN5:
	sub	rsp, 184				; 000000b8H

; 1500 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1501 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@VerticalSe

; 1502 : 		return;

	jmp	$LN1@VerticalSe
$LN2@VerticalSe:

; 1503 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1504 : 
; 1505 : 	float y1 = window->DC.CursorPos.y;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	movss	DWORD PTR y1$[rsp], xmm0

; 1506 : 	float y2 = window->DC.CursorPos.y + window->DC.CurrentLineSize.y;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	addss	xmm0, DWORD PTR [rcx+324]
	movss	DWORD PTR y2$[rsp], xmm0

; 1507 : 	const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + 1.0f, y2));

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+340]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR y2$[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv132[rsp], rax
	movss	xmm2, DWORD PTR y1$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+340]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv130[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1508 : 	ItemSize(ImVec2(bb.GetWidth(), 0.0f));

	lea	rcx, QWORD PTR bb$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	xorps	xmm2, xmm2
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm1, xmm1
	mov	rcx, rax
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 1509 : 	if (!ItemAdd(bb, 0))

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@VerticalSe

; 1510 : 		return;

	jmp	$LN1@VerticalSe
$LN3@VerticalSe:

; 1511 : 
; 1512 : 	window->DrawList->AddLine(ImVec2(bb.Min.x, bb.Min.y), ImVec2(bb.Min.x, bb.Max.y), GetColorU32(ImGuiCol_Separator));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv170[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 27
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv168[rsp], eax
	movss	xmm2, DWORD PTR bb$[rsp+12]
	movss	xmm1, DWORD PTR bb$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv166[rsp], rax
	movss	xmm2, DWORD PTR bb$[rsp+4]
	movss	xmm1, DWORD PTR bb$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv164[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv168[rsp]
	mov	r8, QWORD PTR tv166[rsp]
	mov	rdx, QWORD PTR tv164[rsp]
	mov	rcx, QWORD PTR tv170[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1
$LN1@VerticalSe:

; 1513 : 	/* if (g.LogEnabled)
; 1514 : 		 LogText(" |");*/
; 1515 : }

	add	rsp, 184				; 000000b8H
	ret	0
?VerticalSeparator@ImGui@@YAXXZ ENDP			; ImGui::VerticalSeparator
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv68 = 32
window$ = 64
axis$ = 72
?GetScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z PROC ; ImGui::GetScrollbarID

; 822  : {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 823  : 	return window->GetIDNoKeepAlive(axis == ImGuiAxis_X ? ("#SCROLLX") : ("#SCROLLY"));

	cmp	DWORD PTR axis$[rsp], 0
	jne	SHORT $LN3@GetScrollb
	lea	rax, OFFSET FLAT:??_C@_08ENAFOMOP@?$CDSCROLLX@
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN4@GetScrollb
$LN3@GetScrollb:
	lea	rax, OFFSET FLAT:??_C@_08FEBONNKO@?$CDSCROLLY@
	mov	QWORD PTR tv68[rsp], rax
$LN4@GetScrollb:
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv68[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBD0@Z ; ImGuiWindow::GetIDNoKeepAlive

; 824  : }

	add	rsp, 56					; 00000038H
	ret	0
?GetScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z ENDP ; ImGui::GetScrollbarID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
horizontal$ = 48
other_scrollbar$ = 49
held$ = 50
tv66 = 51
tv76 = 52
tv184 = 53
tv328 = 54
seek_absolute$1 = 55
hovered$ = 56
window$ = 64
grab_v_norm$ = 72
scrollbar_size_v$ = 76
allow_interaction$ = 80
previously_held$ = 81
bb$ = 88
border_size$ = 104
grab_h_norm$ = 108
scroll_v$ = 112
clicked_v_norm$2 = 116
grab_h_pixels$ = 120
g$ = 128
id$ = 136
alpha$ = 140
bb_height$ = 144
other_scrollbar_size_w$ = 148
win_size_avail_v$ = 152
scroll_max$ = 156
scroll_ratio$ = 160
tv200 = 164
tv197 = 168
window_rounding_corners$ = 172
tv257 = 176
tv264 = 180
tv271 = 184
tv279 = 188
win_size_contents_v$ = 192
tv351 = 196
tv360 = 200
tv414 = 204
tv417 = 208
tv80 = 212
tv156 = 216
style$ = 224
tv189 = 232
click_delta_to_grab_center_v$3 = 240
window_rect$ = 248
tv249 = 264
tv247 = 268
win_size_v$ = 272
mouse_pos_v$4 = 276
scrollbar_pos_v$5 = 280
scroll_v_norm$6 = 284
tv420 = 288
tv445 = 292
tv443 = 296
tv468 = 300
tv466 = 304
grab_col$ = 308
tv128 = 312
tv142 = 316
tv216 = 320
tv214 = 324
tv146 = 328
tv367 = 336
grab_rect$ = 344
tv218 = 360
tv479 = 368
$T7 = 376
$T8 = 384
$T9 = 392
$T10 = 408
axis$ = 464
?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z PROC		; ImGui::Scrollbar

; 832  : {

$LN57:
	mov	DWORD PTR [rsp+8], ecx
	push	rsi
	push	rdi
	sub	rsp, 440				; 000001b8H

; 833  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 834  : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 835  : 
; 836  : 	const bool horizontal = (axis == ImGuiAxis_X);

	cmp	DWORD PTR axis$[rsp], 0
	jne	SHORT $LN19@Scrollbar
	mov	BYTE PTR tv66[rsp], 1
	jmp	SHORT $LN20@Scrollbar
$LN19@Scrollbar:
	mov	BYTE PTR tv66[rsp], 0
$LN20@Scrollbar:
	movzx	eax, BYTE PTR tv66[rsp]
	mov	BYTE PTR horizontal$[rsp], al

; 837  : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 838  : 	const ImGuiID id = GetScrollbarID(window, axis);

	mov	edx, DWORD PTR axis$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z ; ImGui::GetScrollbarID
	mov	DWORD PTR id$[rsp], eax

; 839  : 	KeepAliveID(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID

; 840  : 
; 841  : 	// Render background
; 842  : 	bool other_scrollbar = (horizontal ? window->ScrollbarY : window->ScrollbarX);

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	je	SHORT $LN21@Scrollbar
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+101]
	mov	BYTE PTR tv76[rsp], al
	jmp	SHORT $LN22@Scrollbar
$LN21@Scrollbar:
	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+100]
	mov	BYTE PTR tv76[rsp], al
$LN22@Scrollbar:
	movzx	eax, BYTE PTR tv76[rsp]
	mov	BYTE PTR other_scrollbar$[rsp], al

; 843  : 	float other_scrollbar_size_w = other_scrollbar ? style.ScrollbarSize : 0.0f;

	movzx	eax, BYTE PTR other_scrollbar$[rsp]
	test	eax, eax
	je	SHORT $LN23@Scrollbar
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+100]
	movss	DWORD PTR tv80[rsp], xmm0
	jmp	SHORT $LN24@Scrollbar
$LN23@Scrollbar:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv80[rsp], xmm0
$LN24@Scrollbar:
	movss	xmm0, DWORD PTR tv80[rsp]
	movss	DWORD PTR other_scrollbar_size_w$[rsp], xmm0

; 844  : 	const ImRect window_rect = window->Rect();

	lea	rdx, QWORD PTR window_rect$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ	; ImGuiWindow::Rect

; 845  : 	const float border_size = window->WindowBorderSize;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	movss	DWORD PTR border_size$[rsp], xmm0

; 846  : 	ImRect bb = horizontal

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	je	SHORT $LN25@Scrollbar
	movss	xmm0, DWORD PTR window_rect$[rsp+12]
	subss	xmm0, DWORD PTR border_size$[rsp]
	movss	xmm1, DWORD PTR window_rect$[rsp+8]
	subss	xmm1, DWORD PTR other_scrollbar_size_w$[rsp]
	subss	xmm1, DWORD PTR border_size$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR window_rect$[rsp+12]
	subss	xmm2, DWORD PTR [rax+100]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm3, DWORD PTR [rax+48]
	addss	xmm3, DWORD PTR border_size$[rsp]
	movss	DWORD PTR tv128[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv128[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	QWORD PTR tv146[rsp], rax
	jmp	SHORT $LN26@Scrollbar
$LN25@Scrollbar:
	movss	xmm0, DWORD PTR window_rect$[rsp+12]
	subss	xmm0, DWORD PTR other_scrollbar_size_w$[rsp]
	subss	xmm0, DWORD PTR border_size$[rsp]
	movss	xmm1, DWORD PTR window_rect$[rsp+8]
	subss	xmm1, DWORD PTR border_size$[rsp]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm2, DWORD PTR [rax+52]
	addss	xmm2, DWORD PTR border_size$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm3, DWORD PTR window_rect$[rsp+8]
	subss	xmm3, DWORD PTR [rax+100]
	movss	DWORD PTR tv142[rsp], xmm3
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv142[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	QWORD PTR tv146[rsp], rax
$LN26@Scrollbar:
	mov	rax, QWORD PTR tv146[rsp]
	mov	QWORD PTR $T7[rsp], rax

; 847  : 		? ImRect(window->Pos.x + border_size, window_rect.Max.y - style.ScrollbarSize, window_rect.Max.x - other_scrollbar_size_w - border_size, window_rect.Max.y - border_size)
; 848  : 		: ImRect(window_rect.Max.x - style.ScrollbarSize, window->Pos.y + border_size, window_rect.Max.x - border_size, window_rect.Max.y - other_scrollbar_size_w - border_size);
; 849  : 	if (!horizontal)

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	jne	SHORT $LN2@Scrollbar

; 850  : 		bb.Min.y += window->TitleBarHeight() + ((window->Flags & ImGuiWindowFlags_MenuBar) ? window->MenuBarHeight() : 0.0f);

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $LN27@Scrollbar
	mov	rcx, QWORD PTR window$[rsp]
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	movss	DWORD PTR tv156[rsp], xmm0
	jmp	SHORT $LN28@Scrollbar
$LN27@Scrollbar:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv156[rsp], xmm0
$LN28@Scrollbar:
	mov	rcx, QWORD PTR window$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	addss	xmm0, DWORD PTR tv156[rsp]
	movss	xmm1, DWORD PTR bb$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR bb$[rsp+4], xmm0
$LN2@Scrollbar:

; 851  : 
; 852  : 	const float bb_height = bb.GetHeight();

	lea	rcx, QWORD PTR bb$[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	DWORD PTR bb_height$[rsp], xmm0

; 853  : 	if (bb.GetWidth() <= 0.0f || bb_height <= 0.0f)

	lea	rcx, QWORD PTR bb$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jae	SHORT $LN4@Scrollbar
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR bb_height$[rsp]
	jb	SHORT $LN3@Scrollbar
$LN4@Scrollbar:

; 854  : 		return;

	jmp	$LN1@Scrollbar
$LN3@Scrollbar:

; 855  : 
; 856  : 	// When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the resize grab)
; 857  : 	float alpha = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR alpha$[rsp], xmm0

; 858  : 	if ((axis == ImGuiAxis_Y) && bb_height < g.FontSize + g.Style.FramePadding.y * 2.0f)

	cmp	DWORD PTR axis$[rsp], 1
	jne	$LN5@Scrollbar
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5528]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	comiss	xmm0, DWORD PTR bb_height$[rsp]
	jbe	SHORT $LN5@Scrollbar

; 859  : 	{
; 860  : 		alpha = ImSaturate((bb_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR bb_height$[rsp]
	subss	xmm0, DWORD PTR [rax+6408]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5528]
	mulss	xmm1, DWORD PTR __real@40000000
	divss	xmm0, xmm1
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR alpha$[rsp], xmm0

; 861  : 		if (alpha <= 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR alpha$[rsp]
	jb	SHORT $LN6@Scrollbar

; 862  : 			return;

	jmp	$LN1@Scrollbar
$LN6@Scrollbar:
$LN5@Scrollbar:

; 863  : 	}
; 864  : 	const bool allow_interaction = (alpha >= 1.0f);

	movss	xmm0, DWORD PTR alpha$[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN29@Scrollbar
	mov	BYTE PTR tv184[rsp], 1
	jmp	SHORT $LN30@Scrollbar
$LN29@Scrollbar:
	mov	BYTE PTR tv184[rsp], 0
$LN30@Scrollbar:
	movzx	eax, BYTE PTR tv184[rsp]
	mov	BYTE PTR allow_interaction$[rsp], al

; 865  : 
; 866  : 	int window_rounding_corners;
; 867  : 	if (horizontal)

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	je	SHORT $LN7@Scrollbar

; 868  : 		window_rounding_corners = ImDrawCornerFlags_BotLeft | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);

	movzx	eax, BYTE PTR other_scrollbar$[rsp]
	test	eax, eax
	je	SHORT $LN31@Scrollbar
	mov	DWORD PTR tv189[rsp], 0
	jmp	SHORT $LN32@Scrollbar
$LN31@Scrollbar:
	mov	DWORD PTR tv189[rsp], 8
$LN32@Scrollbar:
	mov	eax, DWORD PTR tv189[rsp]
	or	eax, 4
	mov	DWORD PTR window_rounding_corners$[rsp], eax
	jmp	SHORT $LN8@Scrollbar
$LN7@Scrollbar:

; 869  : 	else
; 870  : 		window_rounding_corners = (((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar)) ? ImDrawCornerFlags_TopRight : 0) | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN33@Scrollbar
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1024				; 00000400H
	test	eax, eax
	jne	SHORT $LN33@Scrollbar
	mov	DWORD PTR tv197[rsp], 2
	jmp	SHORT $LN34@Scrollbar
$LN33@Scrollbar:
	mov	DWORD PTR tv197[rsp], 0
$LN34@Scrollbar:
	movzx	eax, BYTE PTR other_scrollbar$[rsp]
	test	eax, eax
	je	SHORT $LN35@Scrollbar
	mov	DWORD PTR tv200[rsp], 0
	jmp	SHORT $LN36@Scrollbar
$LN35@Scrollbar:
	mov	DWORD PTR tv200[rsp], 8
$LN36@Scrollbar:
	mov	eax, DWORD PTR tv200[rsp]
	mov	ecx, DWORD PTR tv197[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR window_rounding_corners$[rsp], eax
$LN8@Scrollbar:

; 871  : 	window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_ScrollbarBg), window->WindowRounding, window_rounding_corners);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv218[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+88]
	movss	DWORD PTR tv216[rsp], xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 14
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv214[rsp], eax
	mov	eax, DWORD PTR window_rounding_corners$[rsp]
	mov	DWORD PTR [rsp+40], eax
	movss	xmm0, DWORD PTR tv216[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv214[rsp]
	lea	r8, QWORD PTR bb$[rsp+8]
	lea	rdx, QWORD PTR bb$[rsp]
	mov	rcx, QWORD PTR tv218[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1

; 872  : 	bb.Expand(ImVec2(-ImClamp((float)(int)((bb.Max.x - bb.Min.x - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb.Max.y - bb.Min.y - 2.0f) * 0.5f), 0.0f, 3.0f)));

	movss	xmm0, DWORD PTR bb$[rsp+12]
	subss	xmm0, DWORD PTR bb$[rsp+4]
	subss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	xmm2, DWORD PTR __real@40400000
	xorps	xmm1, xmm1
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv249[rsp], xmm0
	movss	xmm0, DWORD PTR bb$[rsp+8]
	subss	xmm0, DWORD PTR bb$[rsp]
	subss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	xmm2, DWORD PTR __real@40400000
	xorps	xmm1, xmm1
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv247[rsp], xmm0
	movss	xmm2, DWORD PTR tv249[rsp]
	movss	xmm1, DWORD PTR tv247[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, QWORD PTR bb$[rsp]
	call	?Expand@ImRect@@QEAAXAEBUImVec2@@@Z	; ImRect::Expand
	npad	1

; 873  : 
; 874  : 	// V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
; 875  : 	float scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	je	SHORT $LN37@Scrollbar
	lea	rcx, QWORD PTR bb$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	DWORD PTR tv257[rsp], xmm0
	jmp	SHORT $LN38@Scrollbar
$LN37@Scrollbar:
	lea	rcx, QWORD PTR bb$[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	DWORD PTR tv257[rsp], xmm0
$LN38@Scrollbar:
	movss	xmm0, DWORD PTR tv257[rsp]
	movss	DWORD PTR scrollbar_size_v$[rsp], xmm0

; 876  : 	float scroll_v = horizontal ? window->Scroll.x : window->Scroll.y;

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	je	SHORT $LN39@Scrollbar
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+92]
	movss	DWORD PTR tv264[rsp], xmm0
	jmp	SHORT $LN40@Scrollbar
$LN39@Scrollbar:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+96]
	movss	DWORD PTR tv264[rsp], xmm0
$LN40@Scrollbar:
	movss	xmm0, DWORD PTR tv264[rsp]
	movss	DWORD PTR scroll_v$[rsp], xmm0

; 877  : 	float win_size_avail_v = (horizontal ? window->SizeFull.x : window->SizeFull.y) - other_scrollbar_size_w;

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	je	SHORT $LN41@Scrollbar
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+32]
	movss	DWORD PTR tv271[rsp], xmm0
	jmp	SHORT $LN42@Scrollbar
$LN41@Scrollbar:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	movss	DWORD PTR tv271[rsp], xmm0
$LN42@Scrollbar:
	movss	xmm0, DWORD PTR tv271[rsp]
	subss	xmm0, DWORD PTR other_scrollbar_size_w$[rsp]
	movss	DWORD PTR win_size_avail_v$[rsp], xmm0

; 878  : 	float win_size_contents_v = horizontal ? window->SizeContents.x : window->SizeContents.y;

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	je	SHORT $LN43@Scrollbar
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	movss	DWORD PTR tv279[rsp], xmm0
	jmp	SHORT $LN44@Scrollbar
$LN43@Scrollbar:
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	movss	DWORD PTR tv279[rsp], xmm0
$LN44@Scrollbar:
	movss	xmm0, DWORD PTR tv279[rsp]
	movss	DWORD PTR win_size_contents_v$[rsp], xmm0

; 879  : 
; 880  : 	// Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
; 881  : 	// But we maintain a minimum size in pixel to allow for the user to still aim inside.
; 882  : 	IM_ASSERT(ImMax(win_size_contents_v, win_size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
; 883  : 	const float win_size_v = ImMax(ImMax(win_size_contents_v, win_size_avail_v), 1.0f);

	movss	xmm1, DWORD PTR win_size_avail_v$[rsp]
	movss	xmm0, DWORD PTR win_size_contents_v$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	xmm1, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR win_size_v$[rsp], xmm0

; 884  : 	const float grab_h_pixels = ImClamp(scrollbar_size_v * (win_size_avail_v / win_size_v), style.GrabMinSize, scrollbar_size_v);

	movss	xmm0, DWORD PTR win_size_avail_v$[rsp]
	divss	xmm0, DWORD PTR win_size_v$[rsp]
	movss	xmm1, DWORD PTR scrollbar_size_v$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR scrollbar_size_v$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+108]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR grab_h_pixels$[rsp], xmm0

; 885  : 	const float grab_h_norm = grab_h_pixels / scrollbar_size_v;

	movss	xmm0, DWORD PTR grab_h_pixels$[rsp]
	divss	xmm0, DWORD PTR scrollbar_size_v$[rsp]
	movss	DWORD PTR grab_h_norm$[rsp], xmm0

; 886  : 
; 887  : 	// Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
; 888  : 	bool held = false;

	mov	BYTE PTR held$[rsp], 0

; 889  : 	bool hovered = false;

	mov	BYTE PTR hovered$[rsp], 0

; 890  : 	const bool previously_held = (g.ActiveId == id);

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN45@Scrollbar
	mov	BYTE PTR tv328[rsp], 1
	jmp	SHORT $LN46@Scrollbar
$LN45@Scrollbar:
	mov	BYTE PTR tv328[rsp], 0
$LN46@Scrollbar:
	movzx	eax, BYTE PTR tv328[rsp]
	mov	BYTE PTR previously_held$[rsp], al

; 891  : 	ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);

	mov	DWORD PTR [rsp+32], 8192		; 00002000H
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior

; 892  : 
; 893  : 	float scroll_max = ImMax(1.0f, win_size_contents_v - win_size_avail_v);

	movss	xmm0, DWORD PTR win_size_contents_v$[rsp]
	subss	xmm0, DWORD PTR win_size_avail_v$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR scroll_max$[rsp], xmm0

; 894  : 	float scroll_ratio = ImSaturate(scroll_v / scroll_max);

	movss	xmm0, DWORD PTR scroll_v$[rsp]
	divss	xmm0, DWORD PTR scroll_max$[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR scroll_ratio$[rsp], xmm0

; 895  : 	float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

	movss	xmm0, DWORD PTR scrollbar_size_v$[rsp]
	subss	xmm0, DWORD PTR grab_h_pixels$[rsp]
	movss	xmm1, DWORD PTR scroll_ratio$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR scrollbar_size_v$[rsp]
	movss	DWORD PTR grab_v_norm$[rsp], xmm0

; 896  : 	if (held && allow_interaction && grab_h_norm < 1.0f)

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	$LN9@Scrollbar
	movzx	eax, BYTE PTR allow_interaction$[rsp]
	test	eax, eax
	je	$LN9@Scrollbar
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR grab_h_norm$[rsp]
	jbe	$LN9@Scrollbar

; 897  : 	{
; 898  : 		float scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	je	SHORT $LN47@Scrollbar
	movss	xmm0, DWORD PTR bb$[rsp]
	movss	DWORD PTR tv351[rsp], xmm0
	jmp	SHORT $LN48@Scrollbar
$LN47@Scrollbar:
	movss	xmm0, DWORD PTR bb$[rsp+4]
	movss	DWORD PTR tv351[rsp], xmm0
$LN48@Scrollbar:
	movss	xmm0, DWORD PTR tv351[rsp]
	movss	DWORD PTR scrollbar_pos_v$5[rsp], xmm0

; 899  : 		float mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	je	SHORT $LN49@Scrollbar
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+316]
	movss	DWORD PTR tv360[rsp], xmm0
	jmp	SHORT $LN50@Scrollbar
$LN49@Scrollbar:
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+320]
	movss	DWORD PTR tv360[rsp], xmm0
$LN50@Scrollbar:
	movss	xmm0, DWORD PTR tv360[rsp]
	movss	DWORD PTR mouse_pos_v$4[rsp], xmm0

; 900  : 		float* click_delta_to_grab_center_v = horizontal ? &g.ScrollbarClickDeltaToGrabCenter.x : &g.ScrollbarClickDeltaToGrabCenter.y;

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	je	SHORT $LN51@Scrollbar
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 11720				; 00002dc8H
	mov	QWORD PTR tv367[rsp], rax
	jmp	SHORT $LN52@Scrollbar
$LN51@Scrollbar:
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 11724				; 00002dccH
	mov	QWORD PTR tv367[rsp], rax
$LN52@Scrollbar:
	mov	rax, QWORD PTR tv367[rsp]
	mov	QWORD PTR click_delta_to_grab_center_v$3[rsp], rax

; 901  : 
; 902  : 		// Click position in scrollbar normalized space (0.0f->1.0f)
; 903  : 		const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);

	movss	xmm0, DWORD PTR mouse_pos_v$4[rsp]
	subss	xmm0, DWORD PTR scrollbar_pos_v$5[rsp]
	divss	xmm0, DWORD PTR scrollbar_size_v$[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR clicked_v_norm$2[rsp], xmm0

; 904  : 		SetHoveredID(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID

; 905  : 
; 906  : 		bool seek_absolute = false;

	mov	BYTE PTR seek_absolute$1[rsp], 0

; 907  : 		if (!previously_held)

	movzx	eax, BYTE PTR previously_held$[rsp]
	test	eax, eax
	jne	SHORT $LN10@Scrollbar

; 908  : 		{
; 909  : 			// On initial click calculate the distance between mouse and the center of the grab
; 910  : 			if (clicked_v_norm >= grab_v_norm && clicked_v_norm <= grab_v_norm + grab_h_norm)

	movss	xmm0, DWORD PTR clicked_v_norm$2[rsp]
	comiss	xmm0, DWORD PTR grab_v_norm$[rsp]
	jb	SHORT $LN11@Scrollbar
	movss	xmm0, DWORD PTR grab_v_norm$[rsp]
	addss	xmm0, DWORD PTR grab_h_norm$[rsp]
	comiss	xmm0, DWORD PTR clicked_v_norm$2[rsp]
	jb	SHORT $LN11@Scrollbar

; 911  : 			{
; 912  : 				*click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;

	movss	xmm0, DWORD PTR clicked_v_norm$2[rsp]
	subss	xmm0, DWORD PTR grab_v_norm$[rsp]
	movss	xmm1, DWORD PTR grab_h_norm$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	mov	rax, QWORD PTR click_delta_to_grab_center_v$3[rsp]
	movss	DWORD PTR [rax], xmm0

; 913  : 			}

	jmp	SHORT $LN12@Scrollbar
$LN11@Scrollbar:

; 914  : 			else
; 915  : 			{
; 916  : 				seek_absolute = true;

	mov	BYTE PTR seek_absolute$1[rsp], 1

; 917  : 				*click_delta_to_grab_center_v = 0.0f;

	mov	rax, QWORD PTR click_delta_to_grab_center_v$3[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
$LN12@Scrollbar:
$LN10@Scrollbar:

; 918  : 			}
; 919  : 		}
; 920  : 
; 921  : 		// Apply scroll
; 922  : 		// It is ok to modify Scroll here because we are being called in Begin() after the calculation of SizeContents and before setting up our starting position
; 923  : 		const float scroll_v_norm = ImSaturate((clicked_v_norm - *click_delta_to_grab_center_v - grab_h_norm * 0.5f) / (1.0f - grab_h_norm));

	mov	rax, QWORD PTR click_delta_to_grab_center_v$3[rsp]
	movss	xmm0, DWORD PTR clicked_v_norm$2[rsp]
	subss	xmm0, DWORD PTR [rax]
	movss	xmm1, DWORD PTR grab_h_norm$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR grab_h_norm$[rsp]
	divss	xmm0, xmm1
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR scroll_v_norm$6[rsp], xmm0

; 924  : 		scroll_v = (float)(int)(0.5f + scroll_v_norm * scroll_max);//(win_size_contents_v - win_size_v));

	movss	xmm0, DWORD PTR scroll_v_norm$6[rsp]
	mulss	xmm0, DWORD PTR scroll_max$[rsp]
	movss	xmm1, DWORD PTR __real@3f000000
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR scroll_v$[rsp], xmm0

; 925  : 		if (horizontal)

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	je	SHORT $LN13@Scrollbar

; 926  : 			window->Scroll.x = scroll_v;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR scroll_v$[rsp]
	movss	DWORD PTR [rax+92], xmm0
	jmp	SHORT $LN14@Scrollbar
$LN13@Scrollbar:

; 927  : 		else
; 928  : 			window->Scroll.y = scroll_v;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR scroll_v$[rsp]
	movss	DWORD PTR [rax+96], xmm0
$LN14@Scrollbar:

; 929  : 
; 930  : 		// Update values for rendering
; 931  : 		scroll_ratio = ImSaturate(scroll_v / scroll_max);

	movss	xmm0, DWORD PTR scroll_v$[rsp]
	divss	xmm0, DWORD PTR scroll_max$[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR scroll_ratio$[rsp], xmm0

; 932  : 		grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

	movss	xmm0, DWORD PTR scrollbar_size_v$[rsp]
	subss	xmm0, DWORD PTR grab_h_pixels$[rsp]
	movss	xmm1, DWORD PTR scroll_ratio$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR scrollbar_size_v$[rsp]
	movss	DWORD PTR grab_v_norm$[rsp], xmm0

; 933  : 
; 934  : 		// Update distance to grab now that we have seeked and saturated
; 935  : 		if (seek_absolute)

	movzx	eax, BYTE PTR seek_absolute$1[rsp]
	test	eax, eax
	je	SHORT $LN15@Scrollbar

; 936  : 			*click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;

	movss	xmm0, DWORD PTR clicked_v_norm$2[rsp]
	subss	xmm0, DWORD PTR grab_v_norm$[rsp]
	movss	xmm1, DWORD PTR grab_h_norm$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	mov	rax, QWORD PTR click_delta_to_grab_center_v$3[rsp]
	movss	DWORD PTR [rax], xmm0
$LN15@Scrollbar:
$LN9@Scrollbar:

; 937  : 	}
; 938  : 
; 939  : 	// Render grab
; 940  : 	const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);

	movss	xmm0, DWORD PTR alpha$[rsp]
	movss	DWORD PTR tv420[rsp], xmm0
	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN55@Scrollbar
	mov	DWORD PTR tv417[rsp], 17
	jmp	SHORT $LN56@Scrollbar
$LN55@Scrollbar:
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN53@Scrollbar
	mov	DWORD PTR tv414[rsp], 16
	jmp	SHORT $LN54@Scrollbar
$LN53@Scrollbar:
	mov	DWORD PTR tv414[rsp], 15
$LN54@Scrollbar:
	mov	eax, DWORD PTR tv414[rsp]
	mov	DWORD PTR tv417[rsp], eax
$LN56@Scrollbar:
	movss	xmm1, DWORD PTR tv420[rsp]
	mov	ecx, DWORD PTR tv417[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR grab_col$[rsp], eax

; 941  : 	ImRect grab_rect;

	lea	rcx, QWORD PTR grab_rect$[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	npad	1

; 942  : 	if (horizontal)

	movzx	eax, BYTE PTR horizontal$[rsp]
	test	eax, eax
	je	$LN16@Scrollbar

; 943  : 		grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImMin(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, window_rect.Max.x), bb.Max.y);

	movss	xmm2, DWORD PTR grab_v_norm$[rsp]
	movss	xmm1, DWORD PTR bb$[rsp+8]
	movss	xmm0, DWORD PTR bb$[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	addss	xmm0, DWORD PTR grab_h_pixels$[rsp]
	movss	xmm1, DWORD PTR window_rect$[rsp+8]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR tv445[rsp], xmm0
	movss	xmm2, DWORD PTR grab_v_norm$[rsp]
	movss	xmm1, DWORD PTR bb$[rsp+8]
	movss	xmm0, DWORD PTR bb$[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR tv443[rsp], xmm0
	movss	xmm0, DWORD PTR bb$[rsp+12]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR tv445[rsp]
	movss	xmm2, DWORD PTR bb$[rsp+4]
	movss	xmm1, DWORD PTR tv443[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	lea	rcx, QWORD PTR grab_rect$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	jmp	$LN17@Scrollbar
$LN16@Scrollbar:

; 944  : 	else
; 945  : 		grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImMin(ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels, window_rect.Max.y));

	movss	xmm2, DWORD PTR grab_v_norm$[rsp]
	movss	xmm1, DWORD PTR bb$[rsp+12]
	movss	xmm0, DWORD PTR bb$[rsp+4]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	addss	xmm0, DWORD PTR grab_h_pixels$[rsp]
	movss	xmm1, DWORD PTR window_rect$[rsp+12]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR tv468[rsp], xmm0
	movss	xmm2, DWORD PTR grab_v_norm$[rsp]
	movss	xmm1, DWORD PTR bb$[rsp+12]
	movss	xmm0, DWORD PTR bb$[rsp+4]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	DWORD PTR tv466[rsp], xmm0
	movss	xmm0, DWORD PTR tv468[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR bb$[rsp+8]
	movss	xmm2, DWORD PTR tv466[rsp]
	movss	xmm1, DWORD PTR bb$[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	lea	rcx, QWORD PTR grab_rect$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN17@Scrollbar:

; 946  : 	window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv479[rsp], rax
	mov	DWORD PTR [rsp+40], 15
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+104]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR grab_col$[rsp]
	lea	r8, QWORD PTR grab_rect$[rsp+8]
	lea	rdx, QWORD PTR grab_rect$[rsp]
	mov	rcx, QWORD PTR tv479[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1
$LN1@Scrollbar:

; 947  : }

	add	rsp, 440				; 000001b8H
	pop	rdi
	pop	rsi
	ret	0
?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z ENDP		; ImGui::Scrollbar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
hovered$ = 48
held$ = 49
pressed$ = 50
id$ = 52
tv88 = 56
tv148 = 60
tv149 = 64
window$ = 72
g$ = 80
default_size$ = 88
col$ = 92
tv183 = 96
tv181 = 100
bb$ = 104
$T1 = 120
$T2 = 128
$T3 = 136
str_id$ = 160
dir$ = 168
size$ = 176
flags$ = 184
?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z PROC	; ImGui::ArrowButtonEx

; 735  : {

$LN12:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 736  : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 737  : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@ArrowButto

; 738  : 		return false;

	xor	al, al
	jmp	$LN1@ArrowButto
$LN2@ArrowButto:

; 739  : 
; 740  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 741  : 	const ImGuiID id = window->GetID(str_id);

	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 742  : 	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	lea	r8, QWORD PTR size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 743  : 	const float default_size = GetFrameHeight();

	call	?GetFrameHeight@ImGui@@YAMXZ		; ImGui::GetFrameHeight
	movss	DWORD PTR default_size$[rsp], xmm0

; 744  : 	ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);

	movss	xmm0, DWORD PTR size$[rsp+4]
	comiss	xmm0, DWORD PTR default_size$[rsp]
	jb	SHORT $LN6@ArrowButto
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5528]
	movss	DWORD PTR tv88[rsp], xmm0
	jmp	SHORT $LN7@ArrowButto
$LN6@ArrowButto:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv88[rsp], xmm0
$LN7@ArrowButto:
	movss	xmm1, DWORD PTR tv88[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 745  : 	if (!ItemAdd(bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@ArrowButto

; 746  : 		return false;

	xor	al, al
	jmp	$LN1@ArrowButto
$LN3@ArrowButto:

; 747  : 
; 748  : 	if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+476]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN4@ArrowButto

; 749  : 		flags |= ImGuiButtonFlags_Repeat;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 1
	mov	DWORD PTR flags$[rsp], eax
$LN4@ArrowButto:

; 750  : 
; 751  : 	bool hovered, held;
; 752  : 	bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 753  : 
; 754  : 	// Render
; 755  : 	const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN8@ArrowButto
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN8@ArrowButto
	mov	DWORD PTR tv149[rsp], 23
	jmp	SHORT $LN11@ArrowButto
$LN8@ArrowButto:
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN9@ArrowButto
	mov	DWORD PTR tv148[rsp], 22
	jmp	SHORT $LN10@ArrowButto
$LN9@ArrowButto:
	mov	DWORD PTR tv148[rsp], 21
$LN10@ArrowButto:
	mov	eax, DWORD PTR tv148[rsp]
	mov	DWORD PTR tv149[rsp], eax
$LN11@ArrowButto:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv149[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR col$[rsp], eax

; 756  : 	RenderNavHighlight(bb, id);

	mov	r8d, 1
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 757  : 	RenderFrame(bb.Min, bb.Max, col, true, g.Style.FrameRounding);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5532]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	r8d, DWORD PTR col$[rsp]
	mov	rdx, QWORD PTR bb$[rsp+8]
	mov	rcx, QWORD PTR bb$[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	npad	1

; 758  : 	RenderArrow(bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), dir);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR size$[rsp+4]
	subss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f000000
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR tv183[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR size$[rsp]
	subss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f000000
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR tv181[rsp], xmm0
	movss	xmm2, DWORD PTR tv183[rsp]
	movss	xmm1, DWORD PTR tv181[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR bb$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	movss	xmm2, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderArrow@ImGui@@YAXUImVec2@@HM@Z	; ImGui::RenderArrow
	npad	1

; 759  : 
; 760  : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@ArrowButto:

; 761  : }

	add	rsp, 152				; 00000098H
	ret	0
?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z ENDP	; ImGui::ArrowButtonEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
hovered$ = 48
held$ = 49
pressed$ = 50
g$ = 56
tv141 = 64
tv142 = 68
tv182 = 72
col$ = 76
tv175 = 80
window$ = 88
bb$ = 96
tv90 = 112
tv88 = 120
tv170 = 128
tv168 = 136
tv173 = 144
tv177 = 152
$T1 = 160
$T2 = 168
$T3 = 176
$T4 = 184
$T5 = 192
$T6 = 200
$T7 = 208
$T8 = 216
id$ = 240
pos$ = 248
?CollapseButton@ImGui@@YA_NIAEBUImVec2@@@Z PROC		; ImGui::CollapseButton

; 800  : {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 232				; 000000e8H

; 801  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 802  : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 803  : 
; 804  : 	ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5524				; 00001594H
	movss	xmm2, DWORD PTR __real@40000000
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR [rax+6408]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	mov	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv88[rsp], rax
	mov	r8, QWORD PTR tv90[rsp]
	mov	rdx, QWORD PTR tv88[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	mov	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 805  : 	ItemAdd(bb, id);

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd

; 806  : 	bool hovered, held;
; 807  : 	bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);

	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 808  : 
; 809  : 	ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN6@CollapseBu
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN6@CollapseBu
	mov	DWORD PTR tv142[rsp], 23
	jmp	SHORT $LN9@CollapseBu
$LN6@CollapseBu:
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN7@CollapseBu
	mov	DWORD PTR tv141[rsp], 22
	jmp	SHORT $LN8@CollapseBu
$LN7@CollapseBu:
	mov	DWORD PTR tv141[rsp], 21
$LN8@CollapseBu:
	mov	eax, DWORD PTR tv141[rsp]
	mov	DWORD PTR tv142[rsp], eax
$LN9@CollapseBu:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv142[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR col$[rsp], eax

; 810  : 	if (hovered || held)

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	jne	SHORT $LN3@CollapseBu
	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	$LN2@CollapseBu
$LN3@CollapseBu:

; 811  : 		window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0.0f, -0.5f), g.FontSize * 0.5f + 1.0f, col, 9);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv177[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv175[rsp], xmm0
	movss	xmm2, DWORD PTR __real@bf000000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv170[rsp], rax
	lea	rdx, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?GetCenter@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetCenter
	mov	QWORD PTR tv168[rsp], rax
	mov	r8, QWORD PTR tv170[rsp]
	mov	rdx, QWORD PTR tv168[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv173[rsp], rax
	mov	DWORD PTR [rsp+32], 9
	mov	r9d, DWORD PTR col$[rsp]
	movss	xmm2, DWORD PTR tv175[rsp]
	mov	rdx, QWORD PTR tv173[rsp]
	mov	rcx, QWORD PTR tv177[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1
$LN2@CollapseBu:

; 812  : 	RenderArrow(bb.Min + g.Style.FramePadding, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+113]
	test	eax, eax
	je	SHORT $LN10@CollapseBu
	mov	DWORD PTR tv182[rsp], 1
	jmp	SHORT $LN11@CollapseBu
$LN10@CollapseBu:
	mov	DWORD PTR tv182[rsp], 3
$LN11@CollapseBu:
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5524				; 00001594H
	mov	r8, rax
	lea	rdx, QWORD PTR bb$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	movss	xmm2, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR tv182[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderArrow@ImGui@@YAXUImVec2@@HM@Z	; ImGui::RenderArrow
	npad	1

; 813  : 
; 814  : 	// Switch to moving the window after mouse is moved beyond the initial drag threshold
; 815  : 	if (IsItemActive() && IsMouseDragging())

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@CollapseBu
	movss	xmm1, DWORD PTR __real@bf800000
	xor	ecx, ecx
	call	?IsMouseDragging@ImGui@@YA_NHM@Z	; ImGui::IsMouseDragging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@CollapseBu

; 816  : 		StartMouseMovingWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?StartMouseMovingWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::StartMouseMovingWindow
	npad	1
$LN4@CollapseBu:

; 817  : 
; 818  : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]

; 819  : }

	add	rsp, 232				; 000000e8H
	ret	0
?CollapseButton@ImGui@@YA_NIAEBUImVec2@@@Z ENDP		; ImGui::CollapseButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
pressed$ = 48
cross_extent$ = 52
is_clipped$ = 56
hovered$ = 57
held$ = 58
center$ = 64
tv94 = 72
tv147 = 76
cross_col$ = 80
tv158 = 84
tv156 = 88
window$ = 96
g$ = 104
tv88 = 112
tv86 = 120
tv160 = 128
tv199 = 136
tv197 = 144
tv201 = 152
tv229 = 160
tv227 = 168
tv231 = 176
bb$ = 184
$T1 = 200
$T2 = 208
$T3 = 216
$T4 = 224
$T5 = 232
$T6 = 240
$T7 = 248
$T8 = 256
$T9 = 264
$T10 = 272
$T11 = 280
$T12 = 288
$T13 = 296
id$ = 320
pos$ = 328
radius$ = 336
?CloseButton@ImGui@@YA_NIAEBUImVec2@@M@Z PROC		; ImGui::CloseButton

; 771  : {

$LN9:
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 312				; 00000138H

; 772  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 773  : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 774  : 
; 775  : 	// We intentionally allow interaction when clipped so that a mechanical Alt,Right,Validate sequence close a window.
; 776  : 	// (this isn't the regular behavior of buttons, but it doesn't affect the user much because navigation tends to keep items visible).
; 777  : 	const ImRect bb(pos - ImVec2(radius, radius), pos + ImVec2(radius, radius));

	movss	xmm2, DWORD PTR radius$[rsp]
	movss	xmm1, DWORD PTR radius$[rsp]
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	mov	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv88[rsp], rax
	movss	xmm2, DWORD PTR radius$[rsp]
	movss	xmm1, DWORD PTR radius$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	mov	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv86[rsp], rax
	mov	r8, QWORD PTR tv88[rsp]
	mov	rdx, QWORD PTR tv86[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 778  : 	bool is_clipped = !ItemAdd(bb, id);

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@CloseButto
	mov	DWORD PTR tv94[rsp], 1
	jmp	SHORT $LN6@CloseButto
$LN5@CloseButto:
	mov	DWORD PTR tv94[rsp], 0
$LN6@CloseButto:
	movzx	eax, BYTE PTR tv94[rsp]
	mov	BYTE PTR is_clipped$[rsp], al

; 779  : 
; 780  : 	bool hovered, held;
; 781  : 	bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 782  : 	if (is_clipped)

	movzx	eax, BYTE PTR is_clipped$[rsp]
	test	eax, eax
	je	SHORT $LN2@CloseButto

; 783  : 		return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
	jmp	$LN1@CloseButto
$LN2@CloseButto:

; 784  : 
; 785  : 	// Render
; 786  : 	ImVec2 center = bb.GetCenter();

	lea	rdx, QWORD PTR center$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?GetCenter@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetCenter
	npad	1

; 787  : 	if (hovered)

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	$LN3@CloseButto

; 788  : 		window->DrawList->AddCircleFilled(center, ImMax(2.0f, radius), GetColorU32(held ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered), 9);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv160[rsp], rax
	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN7@CloseButto
	mov	DWORD PTR tv147[rsp], 23
	jmp	SHORT $LN8@CloseButto
$LN7@CloseButto:
	mov	DWORD PTR tv147[rsp], 22
$LN8@CloseButto:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv147[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv158[rsp], eax
	movss	xmm1, DWORD PTR radius$[rsp]
	movss	xmm0, DWORD PTR __real@40000000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR tv156[rsp], xmm0
	mov	DWORD PTR [rsp+32], 9
	mov	r9d, DWORD PTR tv158[rsp]
	movss	xmm2, DWORD PTR tv156[rsp]
	lea	rdx, QWORD PTR center$[rsp]
	mov	rcx, QWORD PTR tv160[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1
$LN3@CloseButto:

; 789  : 
; 790  : 	float cross_extent = (radius * 0.7071f) - 1.0f;

	movss	xmm0, DWORD PTR radius$[rsp]
	mulss	xmm0, DWORD PTR __real@3f350481
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR cross_extent$[rsp], xmm0

; 791  : 	ImU32 cross_col = GetColorU32(ImGuiCol_Text);

	movss	xmm1, DWORD PTR __real@3f800000
	xor	ecx, ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR cross_col$[rsp], eax

; 792  : 	center -= ImVec2(0.5f, 0.5f);

	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, QWORD PTR center$[rsp]
	call	??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z	; operator-=
	npad	1

; 793  : 	window->DrawList->AddLine(center + ImVec2(+cross_extent, +cross_extent), center + ImVec2(-cross_extent, -cross_extent), cross_col, 1.0f);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv201[rsp], rax
	movss	xmm0, DWORD PTR cross_extent$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR cross_extent$[rsp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR center$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv199[rsp], rax
	movss	xmm2, DWORD PTR cross_extent$[rsp]
	movss	xmm1, DWORD PTR cross_extent$[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR center$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv197[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR cross_col$[rsp]
	mov	r8, QWORD PTR tv199[rsp]
	mov	rdx, QWORD PTR tv197[rsp]
	mov	rcx, QWORD PTR tv201[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 794  : 	window->DrawList->AddLine(center + ImVec2(+cross_extent, -cross_extent), center + ImVec2(-cross_extent, +cross_extent), cross_col, 1.0f);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv231[rsp], rax
	movss	xmm0, DWORD PTR cross_extent$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm2, DWORD PTR cross_extent$[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR center$[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv229[rsp], rax
	movss	xmm0, DWORD PTR cross_extent$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR cross_extent$[rsp]
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR center$[rsp]
	lea	rcx, QWORD PTR $T12[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv227[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR cross_col$[rsp]
	mov	r8, QWORD PTR tv229[rsp]
	mov	rdx, QWORD PTR tv227[rsp]
	mov	rcx, QWORD PTR tv231[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 795  : 
; 796  : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@CloseButto:

; 797  : }

	add	rsp, 312				; 00000138H
	ret	0
?CloseButton@ImGui@@YA_NIAEBUImVec2@@M@Z ENDP		; ImGui::CloseButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
hovered$ = 64
pressed$ = 65
held$ = 66
id$ = 68
style$ = 72
window$ = 80
tv177 = 88
tv178 = 92
pos$ = 96
bb$ = 104
col$ = 120
label_size$ = 128
size$ = 136
g$ = 144
tv210 = 152
tv208 = 160
$T1 = 168
$T2 = 176
$T3 = 184
label$ = 208
size_arg$ = 216
flags$ = 224
?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z PROC		; ImGui::ButtonEx

; 653  : {

$LN15:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 654  : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 655  : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN5@ButtonEx

; 656  : 		return false;

	xor	al, al
	jmp	$LN1@ButtonEx
$LN5@ButtonEx:

; 657  : 
; 658  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 659  : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 660  : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 661  : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 662  : 
; 663  : 	ImVec2 pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR pos$[rsp], rax

; 664  : 	if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrentLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN6@ButtonEx
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+328]
	comiss	xmm0, DWORD PTR [rcx+56]
	jbe	SHORT $LN6@ButtonEx

; 665  : 		pos.y += window->DC.CurrentLineTextBaseOffset - style.FramePadding.y;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+328]
	subss	xmm0, DWORD PTR [rcx+56]
	movss	xmm1, DWORD PTR pos$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR pos$[rsp+4], xmm0
$LN6@ButtonEx:

; 666  : 	ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+52]
	mulss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR label_size$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	mov	rax, QWORD PTR size_arg$[rsp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, QWORD PTR size$[rsp]
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
	npad	1

; 667  : 
; 668  : 	const ImRect bb(pos, pos + size);

	lea	r8, QWORD PTR size$[rsp]
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 669  : 	ItemSize(size, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR size$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 670  : 	if (!ItemAdd(bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@ButtonEx

; 671  : 		return false;

	xor	al, al
	jmp	$LN1@ButtonEx
$LN7@ButtonEx:

; 672  : 
; 673  : 	if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+476]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN8@ButtonEx

; 674  : 		flags |= ImGuiButtonFlags_Repeat;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 1
	mov	DWORD PTR flags$[rsp], eax
$LN8@ButtonEx:

; 675  : 	bool hovered, held;
; 676  : 	bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 677  : 	if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN9@ButtonEx

; 678  : 		MarkItemEdited(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN9@ButtonEx:

; 679  : 
; 680  : 	// Render
; 681  : 	const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN11@ButtonEx
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN11@ButtonEx
	mov	DWORD PTR tv178[rsp], 23
	jmp	SHORT $LN14@ButtonEx
$LN11@ButtonEx:
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN12@ButtonEx
	mov	DWORD PTR tv177[rsp], 22
	jmp	SHORT $LN13@ButtonEx
$LN12@ButtonEx:
	mov	DWORD PTR tv177[rsp], 21
$LN13@ButtonEx:
	mov	eax, DWORD PTR tv177[rsp]
	mov	DWORD PTR tv178[rsp], eax
$LN14@ButtonEx:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv178[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR col$[rsp], eax

; 682  : 	RenderNavHighlight(bb, id);

	mov	r8d, 1
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 683  : 	RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	r8d, DWORD PTR col$[rsp]
	mov	rdx, QWORD PTR bb$[rsp+8]
	mov	rcx, QWORD PTR bb$[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	npad	1

; 684  : 	RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	mov	rax, QWORD PTR style$[rsp]
	add	rax, 52					; 00000034H
	mov	r8, rax
	lea	rdx, QWORD PTR bb$[rsp+8]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv210[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	add	rax, 52					; 00000034H
	mov	r8, rax
	lea	rdx, QWORD PTR bb$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv208[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	add	rax, 124				; 0000007cH
	lea	rcx, QWORD PTR bb$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR label_size$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR label$[rsp]
	mov	rdx, QWORD PTR tv210[rsp]
	mov	rcx, QWORD PTR tv208[rsp]
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
	npad	1
$LN4@ButtonEx:

; 685  : 
; 686  : 	// Automatically close popups
; 687  : 	//if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
; 688  : 	//    CloseCurrentPopup();
; 689  : 
; 690  : 	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.LastItemStatusFlags);

	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@ButtonEx

; 691  : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@ButtonEx:

; 692  : }

	add	rsp, 200				; 000000c8H
	ret	0
?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ENDP		; ImGui::ButtonEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
rounding_corners_flags_cell$1 = 48
y$2 = 52
x$3 = 56
x2$4 = 60
x1$5 = 64
yi$6 = 68
y2$7 = 72
y1$8 = 76
tv164 = 80
col_bg1$9 = 84
tv182 = 88
col_bg2$10 = 92
window$ = 96
tv86 = 104
tv180 = 112
tv178 = 120
tv184 = 128
tv193 = 136
$T11 = 144
$T12 = 152
p_min$ = 176
p_max$ = 184
col$ = 192
grid_step$ = 200
grid_off$ = 208
rounding$ = 216
rounding_corners_flags$ = 224
?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z PROC ; ImGui::RenderColorRectWithAlphaCheckerboard

; 4514 : {

$LN21:
	movss	DWORD PTR [rsp+32], xmm3
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 4515 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 4516 : 	if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)

	mov	eax, DWORD PTR col$[rsp]
	and	eax, -16777216				; ff000000H
	shr	eax, 24
	cmp	eax, 255				; 000000ffH
	jae	$LN8@RenderColo

; 4517 : 	{
; 4518 : 		ImU32 col_bg1 = GetColorU32(ImAlphaBlendColor(IM_COL32(204, 204, 204, 255), col));

	mov	edx, DWORD PTR col$[rsp]
	mov	ecx, -3355444				; ffccccccH
	call	?ImAlphaBlendColor@@YAIII@Z		; ImAlphaBlendColor
	mov	ecx, eax
	call	?GetColorU32@ImGui@@YAII@Z		; ImGui::GetColorU32
	mov	DWORD PTR col_bg1$9[rsp], eax

; 4519 : 		ImU32 col_bg2 = GetColorU32(ImAlphaBlendColor(IM_COL32(128, 128, 128, 255), col));

	mov	edx, DWORD PTR col$[rsp]
	mov	ecx, -8355712				; ff808080H
	call	?ImAlphaBlendColor@@YAIII@Z		; ImAlphaBlendColor
	mov	ecx, eax
	call	?GetColorU32@ImGui@@YAII@Z		; ImGui::GetColorU32
	mov	DWORD PTR col_bg2$10[rsp], eax

; 4520 : 		window->DrawList->AddRectFilled(p_min, p_max, col_bg1, rounding, rounding_corners_flags);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv86[rsp], rax
	mov	eax, DWORD PTR rounding_corners_flags$[rsp]
	mov	DWORD PTR [rsp+40], eax
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR col_bg1$9[rsp]
	lea	r8, QWORD PTR p_max$[rsp]
	lea	rdx, QWORD PTR p_min$[rsp]
	mov	rcx, QWORD PTR tv86[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 4521 : 
; 4522 : 		int yi = 0;

	mov	DWORD PTR yi$6[rsp], 0

; 4523 : 		for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)

	movss	xmm0, DWORD PTR p_min$[rsp+4]
	addss	xmm0, DWORD PTR grid_off$[rsp+4]
	movss	DWORD PTR y$2[rsp], xmm0
	jmp	SHORT $LN4@RenderColo
$LN2@RenderColo:
	movss	xmm0, DWORD PTR y$2[rsp]
	addss	xmm0, DWORD PTR grid_step$[rsp]
	movss	DWORD PTR y$2[rsp], xmm0
	mov	eax, DWORD PTR yi$6[rsp]
	inc	eax
	mov	DWORD PTR yi$6[rsp], eax
$LN4@RenderColo:
	movss	xmm0, DWORD PTR p_max$[rsp+4]
	comiss	xmm0, DWORD PTR y$2[rsp]
	jbe	$LN3@RenderColo

; 4524 : 		{
; 4525 : 			float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);

	movss	xmm2, DWORD PTR p_max$[rsp+4]
	movss	xmm1, DWORD PTR p_min$[rsp+4]
	movss	xmm0, DWORD PTR y$2[rsp]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR y1$8[rsp], xmm0
	movss	xmm0, DWORD PTR y$2[rsp]
	addss	xmm0, DWORD PTR grid_step$[rsp]
	movss	xmm1, DWORD PTR p_max$[rsp+4]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR y2$7[rsp], xmm0

; 4526 : 			if (y2 <= y1)

	movss	xmm0, DWORD PTR y1$8[rsp]
	comiss	xmm0, DWORD PTR y2$7[rsp]
	jb	SHORT $LN10@RenderColo

; 4527 : 				continue;

	jmp	$LN2@RenderColo
$LN10@RenderColo:

; 4528 : 			for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)

	movss	xmm0, DWORD PTR p_min$[rsp]
	addss	xmm0, DWORD PTR grid_off$[rsp]
	mov	eax, DWORD PTR yi$6[rsp]
	and	eax, 1
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR grid_step$[rsp]
	addss	xmm0, xmm1
	movss	DWORD PTR x$3[rsp], xmm0
	jmp	SHORT $LN7@RenderColo
$LN5@RenderColo:
	movss	xmm0, DWORD PTR grid_step$[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR x$3[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR x$3[rsp], xmm0
$LN7@RenderColo:
	movss	xmm0, DWORD PTR p_max$[rsp]
	comiss	xmm0, DWORD PTR x$3[rsp]
	jbe	$LN6@RenderColo

; 4529 : 			{
; 4530 : 				float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);

	movss	xmm2, DWORD PTR p_max$[rsp]
	movss	xmm1, DWORD PTR p_min$[rsp]
	movss	xmm0, DWORD PTR x$3[rsp]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR x1$5[rsp], xmm0
	movss	xmm0, DWORD PTR x$3[rsp]
	addss	xmm0, DWORD PTR grid_step$[rsp]
	movss	xmm1, DWORD PTR p_max$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR x2$4[rsp], xmm0

; 4531 : 				if (x2 <= x1)

	movss	xmm0, DWORD PTR x1$5[rsp]
	comiss	xmm0, DWORD PTR x2$4[rsp]
	jb	SHORT $LN11@RenderColo

; 4532 : 					continue;

	jmp	$LN5@RenderColo
$LN11@RenderColo:

; 4533 : 				int rounding_corners_flags_cell = 0;

	mov	DWORD PTR rounding_corners_flags_cell$1[rsp], 0

; 4534 : 				if (y1 <= p_min.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopRight; }

	movss	xmm0, DWORD PTR p_min$[rsp+4]
	comiss	xmm0, DWORD PTR y1$8[rsp]
	jb	SHORT $LN12@RenderColo
	movss	xmm0, DWORD PTR p_min$[rsp]
	comiss	xmm0, DWORD PTR x1$5[rsp]
	jb	SHORT $LN13@RenderColo
	mov	eax, DWORD PTR rounding_corners_flags_cell$1[rsp]
	or	eax, 1
	mov	DWORD PTR rounding_corners_flags_cell$1[rsp], eax
$LN13@RenderColo:
	movss	xmm0, DWORD PTR x2$4[rsp]
	comiss	xmm0, DWORD PTR p_max$[rsp]
	jb	SHORT $LN14@RenderColo
	mov	eax, DWORD PTR rounding_corners_flags_cell$1[rsp]
	or	eax, 2
	mov	DWORD PTR rounding_corners_flags_cell$1[rsp], eax
$LN14@RenderColo:
$LN12@RenderColo:

; 4535 : 				if (y2 >= p_max.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotRight; }

	movss	xmm0, DWORD PTR y2$7[rsp]
	comiss	xmm0, DWORD PTR p_max$[rsp+4]
	jb	SHORT $LN15@RenderColo
	movss	xmm0, DWORD PTR p_min$[rsp]
	comiss	xmm0, DWORD PTR x1$5[rsp]
	jb	SHORT $LN16@RenderColo
	mov	eax, DWORD PTR rounding_corners_flags_cell$1[rsp]
	or	eax, 4
	mov	DWORD PTR rounding_corners_flags_cell$1[rsp], eax
$LN16@RenderColo:
	movss	xmm0, DWORD PTR x2$4[rsp]
	comiss	xmm0, DWORD PTR p_max$[rsp]
	jb	SHORT $LN17@RenderColo
	mov	eax, DWORD PTR rounding_corners_flags_cell$1[rsp]
	or	eax, 8
	mov	DWORD PTR rounding_corners_flags_cell$1[rsp], eax
$LN17@RenderColo:
$LN15@RenderColo:

; 4536 : 				rounding_corners_flags_cell &= rounding_corners_flags;

	mov	eax, DWORD PTR rounding_corners_flags$[rsp]
	mov	ecx, DWORD PTR rounding_corners_flags_cell$1[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR rounding_corners_flags_cell$1[rsp], eax

; 4537 : 				window->DrawList->AddRectFilled(ImVec2(x1, y1), ImVec2(x2, y2), col_bg2, rounding_corners_flags_cell ? rounding : 0.0f, rounding_corners_flags_cell);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv184[rsp], rax
	mov	eax, DWORD PTR rounding_corners_flags_cell$1[rsp]
	mov	DWORD PTR tv182[rsp], eax
	cmp	DWORD PTR rounding_corners_flags_cell$1[rsp], 0
	je	SHORT $LN19@RenderColo
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR tv164[rsp], xmm0
	jmp	SHORT $LN20@RenderColo
$LN19@RenderColo:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv164[rsp], xmm0
$LN20@RenderColo:
	movss	xmm2, DWORD PTR y2$7[rsp]
	movss	xmm1, DWORD PTR x2$4[rsp]
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv180[rsp], rax
	movss	xmm2, DWORD PTR y1$8[rsp]
	movss	xmm1, DWORD PTR x1$5[rsp]
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv178[rsp], rax
	mov	eax, DWORD PTR tv182[rsp]
	mov	DWORD PTR [rsp+40], eax
	movss	xmm0, DWORD PTR tv164[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR col_bg2$10[rsp]
	mov	r8, QWORD PTR tv180[rsp]
	mov	rdx, QWORD PTR tv178[rsp]
	mov	rcx, QWORD PTR tv184[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1

; 4538 : 			}

	jmp	$LN5@RenderColo
$LN6@RenderColo:

; 4539 : 		}

	jmp	$LN2@RenderColo
$LN3@RenderColo:

; 4540 : 	}

	jmp	SHORT $LN9@RenderColo
$LN8@RenderColo:

; 4541 : 	else
; 4542 : 	{
; 4543 : 		window->DrawList->AddRectFilled(p_min, p_max, col, rounding, rounding_corners_flags);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv193[rsp], rax
	mov	eax, DWORD PTR rounding_corners_flags$[rsp]
	mov	DWORD PTR [rsp+40], eax
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR col$[rsp]
	lea	r8, QWORD PTR p_max$[rsp]
	lea	rdx, QWORD PTR p_min$[rsp]
	mov	rcx, QWORD PTR tv193[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1
$LN9@RenderColo:

; 4544 : 	}
; 4545 : }

	add	rsp, 168				; 000000a8H
	ret	0
?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z ENDP ; ImGui::RenderColorRectWithAlphaCheckerboard
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
close_button_visible$ = 64
close_button_pressed$ = 65
label_end$1 = 72
g$ = 80
close_button_sz$2 = 88
label_size_clipped_x$3 = 92
text_pixel_clip_bb$ = 96
ellipsis_x$4 = 112
label_display_end$ = 120
label_size$ = 128
tv87 = 136
tv155 = 140
tv153 = 144
tv272 = 148
tv270 = 152
tv358 = 156
TAB_UNSAVED_MARKER$ = 160
ellipsis_width$5 = 168
tv175 = 176
tv173 = 184
unsaved_marker_pos$6 = 192
tv274 = 200
tv295 = 208
tv318 = 216
tv336 = 224
tv334 = 232
$T7 = 240
ellipsis_dot_count$8 = 248
text_ellipsis_clip_bb$ = 256
$T9 = 272
$T10 = 280
$T11 = 288
$T12 = 296
$T13 = 304
$T14 = 312
$T15 = 320
$T16 = 328
$T17 = 336
$T18 = 344
last_item_backup$19 = 352
draw_list$ = 432
bb$ = 440
flags$ = 448
frame_padding$ = 456
label$ = 464
tab_id$ = 472
close_button_id$ = 480
?TabItemLabelAndCloseButton@ImGui@@YA_NPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII@Z PROC ; ImGui::TabItemLabelAndCloseButton

; 7169 : {

$LN17:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 408				; 00000198H

; 7170 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7171 : 	ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	npad	1

; 7172 : 	if (bb.GetWidth() <= 1.0f)

	mov	rcx, QWORD PTR bb$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jb	SHORT $LN4@TabItemLab

; 7173 : 		return false;

	xor	al, al
	jmp	$LN1@TabItemLab
$LN4@TabItemLab:

; 7174 : 
; 7175 : 	// Render text label (with clipping + alpha gradient) + unsaved marker
; 7176 : 	const char* TAB_UNSAVED_MARKER = "*";

	lea	rax, OFFSET FLAT:??_C@_01NBENCBCI@?$CK@
	mov	QWORD PTR TAB_UNSAVED_MARKER$[rsp], rax

; 7177 : 	ImRect text_pixel_clip_bb(bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y);

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR frame_padding$[rsp]
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR frame_padding$[rsp+4]
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, DWORD PTR frame_padding$[rsp]
	movss	DWORD PTR tv87[rsp], xmm2
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm3, DWORD PTR [rax+12]
	movss	DWORD PTR [rsp+32], xmm3
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv87[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR text_pixel_clip_bb$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	npad	1

; 7178 : 	if (flags & ImGuiTabItemFlags_UnsavedDocument)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	$LN5@TabItemLab

; 7179 : 	{
; 7180 : 		text_pixel_clip_bb.Max.x -= CalcTextSize(TAB_UNSAVED_MARKER, NULL, false).x;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR TAB_UNSAVED_MARKER$[rsp]
	lea	rcx, QWORD PTR $T18[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	movss	xmm0, DWORD PTR text_pixel_clip_bb$[rsp+8]
	subss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR text_pixel_clip_bb$[rsp+8], xmm0

; 7181 : 		ImVec2 unsaved_marker_pos(ImMin(bb.Min.x + frame_padding.x + label_size.x + 2, text_pixel_clip_bb.Max.x), bb.Min.y + frame_padding.y + (float)(int)(-g.FontSize * 0.25f));

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR frame_padding$[rsp+4]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, DWORD PTR __real@3e800000
	cvttss2si eax, xmm1
	cvtsi2ss xmm1, eax
	addss	xmm0, xmm1
	movss	DWORD PTR tv155[rsp], xmm0
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR frame_padding$[rsp]
	addss	xmm0, DWORD PTR label_size$[rsp]
	addss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR text_pixel_clip_bb$[rsp+8]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR tv153[rsp], xmm0
	movss	xmm2, DWORD PTR tv155[rsp]
	movss	xmm1, DWORD PTR tv153[rsp]
	lea	rcx, QWORD PTR unsaved_marker_pos$6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 7182 : 		RenderTextClippedEx(draw_list, unsaved_marker_pos, bb.Max - frame_padding, TAB_UNSAVED_MARKER, NULL, NULL);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv175[rsp], rax
	mov	rax, QWORD PTR bb$[rsp]
	add	rax, 8
	lea	r8, QWORD PTR frame_padding$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T10[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv173[rsp], rax
	mov	QWORD PTR [rsp+56], 0
	mov	rax, QWORD PTR tv175[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR TAB_UNSAVED_MARKER$[rsp]
	mov	r8, QWORD PTR tv173[rsp]
	lea	rdx, QWORD PTR unsaved_marker_pos$6[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z ; ImGui::RenderTextClippedEx
	npad	1
$LN5@TabItemLab:

; 7183 : 	}
; 7184 : 	ImRect text_ellipsis_clip_bb = text_pixel_clip_bb;

	lea	rax, QWORD PTR text_ellipsis_clip_bb$[rsp]
	lea	rcx, QWORD PTR text_pixel_clip_bb$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 7185 : 
; 7186 : 	// Close Button
; 7187 : 	// We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
; 7188 : 	//  'hovered' will be true when hovering the Tab but NOT when hovering the close button
; 7189 : 	//  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button
; 7190 : 	//  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false
; 7191 : 	bool close_button_pressed = false;

	mov	BYTE PTR close_button_pressed$[rsp], 0

; 7192 : 	bool close_button_visible = false;

	mov	BYTE PTR close_button_visible$[rsp], 0

; 7193 : 	if (close_button_id != 0)

	cmp	DWORD PTR close_button_id$[rsp], 0
	je	SHORT $LN6@TabItemLab

; 7194 : 		if (g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == close_button_id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR tab_id$[rsp]
	cmp	DWORD PTR [rax+6696], ecx
	je	SHORT $LN8@TabItemLab
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR close_button_id$[rsp]
	cmp	DWORD PTR [rax+6696], ecx
	je	SHORT $LN8@TabItemLab
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR close_button_id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN7@TabItemLab
$LN8@TabItemLab:

; 7195 : 			close_button_visible = true;

	mov	BYTE PTR close_button_visible$[rsp], 1
$LN7@TabItemLab:
$LN6@TabItemLab:

; 7196 : 	if (close_button_visible)

	movzx	eax, BYTE PTR close_button_visible$[rsp]
	test	eax, eax
	je	$LN9@TabItemLab

; 7197 : 	{
; 7198 : 		ImGuiItemHoveredDataBackup last_item_backup;

	lea	rcx, QWORD PTR last_item_backup$19[rsp]
	call	??0ImGuiItemHoveredDataBackup@@QEAA@XZ	; ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup

; 7199 : 		const float close_button_sz = g.FontSize * 0.5f;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR close_button_sz$2[rsp], xmm0

; 7200 : 		if (CloseButton(close_button_id, ImVec2(bb.Max.x - frame_padding.x - close_button_sz, bb.Min.y + frame_padding.y + close_button_sz), close_button_sz))

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR frame_padding$[rsp+4]
	addss	xmm0, DWORD PTR close_button_sz$2[rsp]
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR frame_padding$[rsp]
	subss	xmm1, DWORD PTR close_button_sz$2[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR close_button_sz$2[rsp]
	mov	rdx, rax
	mov	ecx, DWORD PTR close_button_id$[rsp]
	call	?CloseButton@ImGui@@YA_NIAEBUImVec2@@M@Z ; ImGui::CloseButton
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@TabItemLab

; 7201 : 			close_button_pressed = true;

	mov	BYTE PTR close_button_pressed$[rsp], 1
$LN10@TabItemLab:

; 7202 : 		last_item_backup.Restore();

	lea	rcx, QWORD PTR last_item_backup$19[rsp]
	call	?Restore@ImGuiItemHoveredDataBackup@@QEBAXXZ ; ImGuiItemHoveredDataBackup::Restore
	npad	1

; 7203 : 
; 7204 : 		// Close with middle mouse button
; 7205 : 		if (!(flags & ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) && IsMouseClicked(2))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN11@TabItemLab
	xor	edx, edx
	mov	ecx, 2
	call	?IsMouseClicked@ImGui@@YA_NH_N@Z	; ImGui::IsMouseClicked
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@TabItemLab

; 7206 : 			close_button_pressed = true;

	mov	BYTE PTR close_button_pressed$[rsp], 1
$LN11@TabItemLab:

; 7207 : 
; 7208 : 		text_pixel_clip_bb.Max.x -= close_button_sz * 2.0f;

	movss	xmm0, DWORD PTR close_button_sz$2[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR text_pixel_clip_bb$[rsp+8]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR text_pixel_clip_bb$[rsp+8], xmm0
$LN9@TabItemLab:

; 7209 : 	}
; 7210 : 
; 7211 : 	// Label with ellipsis
; 7212 : 	// FIXME: This should be extracted into a helper but the use of text_pixel_clip_bb and !close_button_visible makes it tricky to abstract at the moment
; 7213 : 	const char* label_display_end = FindRenderedTextEnd(label);

	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	QWORD PTR label_display_end$[rsp], rax

; 7214 : 	if (label_size.x > text_ellipsis_clip_bb.GetWidth())

	lea	rcx, QWORD PTR text_ellipsis_clip_bb$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	xmm1, DWORD PTR label_size$[rsp]
	comiss	xmm1, xmm0
	jbe	$LN12@TabItemLab

; 7215 : 	{
; 7216 : 		const int ellipsis_dot_count = 3;

	mov	DWORD PTR ellipsis_dot_count$8[rsp], 3

; 7217 : 		const float ellipsis_width = (1.0f + 1.0f) * ellipsis_dot_count - 1.0f;

	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR ellipsis_width$5[rsp], xmm0

; 7218 : 		const char* label_end = NULL;

	mov	QWORD PTR label_end$1[rsp], 0

; 7219 : 		float label_size_clipped_x = g.Font->CalcTextSizeA(g.FontSize, text_ellipsis_clip_bb.GetWidth() - ellipsis_width + 1.0f, 0.0f, label, label_display_end, &label_end).x;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv274[rsp], rax
	lea	rcx, QWORD PTR text_ellipsis_clip_bb$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	subss	xmm0, DWORD PTR __real@40a00000
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv272[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv270[rsp], xmm0
	lea	rax, QWORD PTR label_end$1[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR label_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR label$[rsp]
	mov	QWORD PTR [rsp+40], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR tv272[rsp]
	movss	xmm2, DWORD PTR tv270[rsp]
	lea	rdx, QWORD PTR $T12[rsp]
	mov	rcx, QWORD PTR tv274[rsp]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR label_size_clipped_x$3[rsp], xmm0

; 7220 : 		if (label_end == label && label_end < label_display_end)    // Always display at least 1 character if there's no room for character + ellipsis

	mov	rax, QWORD PTR label$[rsp]
	cmp	QWORD PTR label_end$1[rsp], rax
	jne	$LN14@TabItemLab
	mov	rax, QWORD PTR label_display_end$[rsp]
	cmp	QWORD PTR label_end$1[rsp], rax
	jae	$LN14@TabItemLab

; 7221 : 		{
; 7222 : 			label_end = label + ImTextCountUtf8BytesFromChar(label, label_display_end);

	mov	rdx, QWORD PTR label_display_end$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?ImTextCountUtf8BytesFromChar@@YAHPEBD0@Z ; ImTextCountUtf8BytesFromChar
	cdqe
	mov	rcx, QWORD PTR label$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR label_end$1[rsp], rax

; 7223 : 			label_size_clipped_x = g.Font->CalcTextSizeA(g.FontSize, FLT_MAX, 0.0f, label, label_end).x;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv295[rsp], rax
	mov	QWORD PTR [rsp+56], 0
	mov	rax, QWORD PTR label_end$1[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR label$[rsp]
	mov	QWORD PTR [rsp+40], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@7f7fffff
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR [rax+6408]
	lea	rdx, QWORD PTR $T13[rsp]
	mov	rcx, QWORD PTR tv295[rsp]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR label_size_clipped_x$3[rsp], xmm0
$LN14@TabItemLab:
$LN2@TabItemLab:

; 7224 : 		}
; 7225 : 		while (label_end > label && ImCharIsBlankA(label_end[-1])) // Trim trailing space

	mov	rax, QWORD PTR label$[rsp]
	cmp	QWORD PTR label_end$1[rsp], rax
	jbe	$LN3@TabItemLab
	mov	eax, 1
	imul	rax, rax, -1
	mov	rcx, QWORD PTR label_end$1[rsp]
	movzx	ecx, BYTE PTR [rcx+rax]
	call	?ImCharIsBlankA@@YA_ND@Z		; ImCharIsBlankA
	movzx	eax, al
	test	eax, eax
	je	$LN3@TabItemLab

; 7226 : 		{
; 7227 : 			label_end--;

	mov	rax, QWORD PTR label_end$1[rsp]
	dec	rax
	mov	QWORD PTR label_end$1[rsp], rax

; 7228 : 			label_size_clipped_x -= g.Font->CalcTextSizeA(g.FontSize, FLT_MAX, 0.0f, label_end, label_end + 1).x; // Ascii blanks are always 1 byte

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv318[rsp], rax
	mov	rax, QWORD PTR label_end$1[rsp]
	inc	rax
	mov	QWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR label_end$1[rsp]
	mov	QWORD PTR [rsp+40], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@7f7fffff
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR [rax+6408]
	lea	rdx, QWORD PTR $T14[rsp]
	mov	rcx, QWORD PTR tv318[rsp]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA
	movss	xmm0, DWORD PTR label_size_clipped_x$3[rsp]
	subss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR label_size_clipped_x$3[rsp], xmm0

; 7229 : 		}

	jmp	$LN2@TabItemLab
$LN3@TabItemLab:

; 7230 : 		RenderTextClippedEx(draw_list, text_pixel_clip_bb.Min, text_pixel_clip_bb.Max, label, label_end, &label_size, ImVec2(0.0f, 0.0f));

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv336[rsp], rax
	mov	rax, QWORD PTR label_end$1[rsp]
	mov	QWORD PTR tv334[rsp], rax
	mov	QWORD PTR [rsp+56], 0
	mov	rax, QWORD PTR tv336[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR label_size$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv334[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR label$[rsp]
	lea	r8, QWORD PTR text_pixel_clip_bb$[rsp+8]
	lea	rdx, QWORD PTR text_pixel_clip_bb$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z ; ImGui::RenderTextClippedEx
	npad	1

; 7231 : 
; 7232 : 		const float ellipsis_x = text_pixel_clip_bb.Min.x + label_size_clipped_x + 1.0f;

	movss	xmm0, DWORD PTR text_pixel_clip_bb$[rsp]
	addss	xmm0, DWORD PTR label_size_clipped_x$3[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR ellipsis_x$4[rsp], xmm0

; 7233 : 		if (!close_button_visible && ellipsis_x + ellipsis_width <= bb.Max.x)

	movzx	eax, BYTE PTR close_button_visible$[rsp]
	test	eax, eax
	jne	SHORT $LN15@TabItemLab
	movss	xmm0, DWORD PTR ellipsis_x$4[rsp]
	addss	xmm0, DWORD PTR __real@40a00000
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	comiss	xmm1, xmm0
	jb	SHORT $LN15@TabItemLab

; 7234 : 			RenderPixelEllipsis(draw_list, ImVec2(ellipsis_x, text_pixel_clip_bb.Min.y), ellipsis_dot_count, GetColorU32(ImGuiCol_Text));

	movss	xmm1, DWORD PTR __real@3f800000
	xor	ecx, ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv358[rsp], eax
	movss	xmm2, DWORD PTR text_pixel_clip_bb$[rsp+4]
	movss	xmm1, DWORD PTR ellipsis_x$4[rsp]
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T7[rsp], rax
	mov	r9d, DWORD PTR tv358[rsp]
	mov	r8d, 3
	mov	rdx, QWORD PTR $T7[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?RenderPixelEllipsis@ImGui@@YAXPEAUImDrawList@@UImVec2@@HI@Z ; ImGui::RenderPixelEllipsis
	npad	1
$LN15@TabItemLab:

; 7235 : 	}

	jmp	SHORT $LN13@TabItemLab
$LN12@TabItemLab:

; 7236 : 	else
; 7237 : 	{
; 7238 : 		RenderTextClippedEx(draw_list, text_pixel_clip_bb.Min, text_pixel_clip_bb.Max, label, label_display_end, &label_size, ImVec2(0.0f, 0.0f));

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR label_size$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR label_display_end$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR label$[rsp]
	lea	r8, QWORD PTR text_pixel_clip_bb$[rsp+8]
	lea	rdx, QWORD PTR text_pixel_clip_bb$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z ; ImGui::RenderTextClippedEx
	npad	1
$LN13@TabItemLab:

; 7239 : 	}
; 7240 : 
; 7241 : 	return close_button_pressed;

	movzx	eax, BYTE PTR close_button_pressed$[rsp]
$LN1@TabItemLab:

; 7242 : }

	add	rsp, 408				; 00000198H
	pop	rdi
	pop	rsi
	ret	0
?TabItemLabelAndCloseButton@ImGui@@YA_NPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII@Z ENDP ; ImGui::TabItemLabelAndCloseButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
rounding$ = 48
y1$ = 52
y2$ = 56
width$ = 60
tv221 = 64
tv219 = 68
g$ = 72
$T1 = 80
$T2 = 88
$T3 = 96
$T4 = 104
$T5 = 112
$T6 = 120
$T7 = 128
$T8 = 136
draw_list$ = 160
bb$ = 168
flags$ = 176
col$ = 184
?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z PROC ; ImGui::TabItemBackground

; 7142 : {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 7143 : 	// While rendering tabs, we trim 1 pixel off the top of our bounding box so they can fit within a regular frame height while looking "detached" from it.
; 7144 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7145 : 	const float width = bb.GetWidth();

	mov	rcx, QWORD PTR bb$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	DWORD PTR width$[rsp], xmm0

; 7146 : 	IM_UNUSED(flags);
; 7147 : 	IM_ASSERT(width > 0.0f);
; 7148 : 	const float rounding = ImMax(0.0f, ImMin(g.Style.TabRounding, width * 0.5f - 1.0f));

	movss	xmm0, DWORD PTR width$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	subss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm1, xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5588]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR rounding$[rsp], xmm0

; 7149 : 	const float y1 = bb.Min.y + 1.0f;

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR y1$[rsp], xmm0

; 7150 : 	const float y2 = bb.Max.y - 1.0f;

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR y2$[rsp], xmm0

; 7151 : 	draw_list->PathLineTo(ImVec2(bb.Min.x, y2));

	movss	xmm2, DWORD PTR y2$[rsp]
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 7152 : 	draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);

	movss	xmm0, DWORD PTR y1$[rsp]
	addss	xmm0, DWORD PTR rounding$[rsp]
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR rounding$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], 9
	mov	r9d, 6
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1

; 7153 : 	draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding, y1 + rounding), rounding, 9, 12);

	movss	xmm0, DWORD PTR y1$[rsp]
	addss	xmm0, DWORD PTR rounding$[rsp]
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR rounding$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, 9
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1

; 7154 : 	draw_list->PathLineTo(ImVec2(bb.Max.x, y2));

	movss	xmm2, DWORD PTR y2$[rsp]
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 7155 : 	draw_list->PathFillConvex(col);

	mov	edx, DWORD PTR col$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathFillConvex@ImDrawList@@QEAAXI@Z	; ImDrawList::PathFillConvex
	npad	1

; 7156 : 	if (g.Style.TabBorderSize > 0.0f)

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5592]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN2@TabItemBac

; 7157 : 	{
; 7158 : 		draw_list->PathLineTo(ImVec2(bb.Min.x + 0.5f, y2));

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR y2$[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 7159 : 		draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);

	movss	xmm0, DWORD PTR y1$[rsp]
	addss	xmm0, DWORD PTR rounding$[rsp]
	addss	xmm0, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR rounding$[rsp]
	addss	xmm1, DWORD PTR __real@3f000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], 9
	mov	r9d, 6
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1

; 7160 : 		draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f), rounding, 9, 12);

	movss	xmm0, DWORD PTR y1$[rsp]
	addss	xmm0, DWORD PTR rounding$[rsp]
	addss	xmm0, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR rounding$[rsp]
	subss	xmm1, DWORD PTR __real@3f000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, 9
	movss	xmm2, DWORD PTR rounding$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	npad	1

; 7161 : 		draw_list->PathLineTo(ImVec2(bb.Max.x - 0.5f, y2));

	mov	rax, QWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR y2$[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 7162 : 		draw_list->PathStroke(GetColorU32(ImGuiCol_Border), false, g.Style.TabBorderSize);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5592]
	movss	DWORD PTR tv221[rsp], xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 5
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv219[rsp], eax
	movss	xmm3, DWORD PTR tv221[rsp]
	xor	r8d, r8d
	mov	edx, DWORD PTR tv219[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathStroke@ImDrawList@@QEAAXI_NM@Z	; ImDrawList::PathStroke
	npad	1
$LN2@TabItemBac:

; 7163 : 	}
; 7164 : }

	add	rsp, 152				; 00000098H
	ret	0
?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z ENDP ; ImGui::TabItemBackground
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 48
size$ = 56
label_size$ = 64
__$ReturnUdt$ = 96
label$ = 104
has_close_button$ = 112
?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z PROC	; ImGui::TabItemCalcSize

; 7130 : {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 7131 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7132 : 	ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 7133 : 	ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5528]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR label_size$[rsp]
	addss	xmm1, DWORD PTR [rax+5524]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR size$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 7134 : 	if (has_close_button)

	movzx	eax, BYTE PTR has_close_button$[rsp]
	test	eax, eax
	je	SHORT $LN2@TabItemCal

; 7135 : 		size.x += g.Style.FramePadding.x + (g.Style.ItemInnerSpacing.x + g.FontSize); // We use Y intentionally to fit the close button circle.

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5548]
	addss	xmm0, DWORD PTR [rcx+6408]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5524]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR size$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR size$[rsp], xmm0
	jmp	SHORT $LN3@TabItemCal
$LN2@TabItemCal:

; 7136 : 	else
; 7137 : 		size.x += g.Style.FramePadding.x + 1.0f;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5524]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR size$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR size$[rsp], xmm0
$LN3@TabItemCal:

; 7138 : 	return ImVec2(ImMin(size.x, TabBarCalcMaxTabWidth()), size.y);

	call	?TabBarCalcMaxTabWidth@ImGui@@YAMXZ	; ImGui::TabBarCalcMaxTabWidth
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR size$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	xmm2, DWORD PTR size$[rsp+4]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 7139 : }

	add	rsp, 88					; 00000058H
	ret	0
?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z ENDP	; ImGui::TabItemCalcSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tab_contents_visible$ = 64
tab_appearing$ = 65
held$ = 66
id$ = 68
tab_bar_appearing$ = 72
hovered$ = 73
want_clip_rect$ = 74
tv88 = 75
tv154 = 76
tv158 = 77
tv163 = 78
tab_is_new$ = 79
tab_bar_focused$ = 80
tab$ = 88
g$ = 96
pressed$ = 104
hovered_unblocked$ = 105
just_closed$ = 106
window$ = 112
button_flags$ = 120
bb$ = 128
tv441 = 144
tv444 = 148
tv445 = 152
tv478 = 156
tv372 = 160
tv210 = 164
tv284 = 168
tv438 = 172
size$ = 176
tv374 = 184
tab_col$ = 188
tv299 = 192
close_button_id$ = 196
pos$ = 200
display_draw_list$ = 208
backup_main_cursor_pos$ = 216
tv133 = 224
tv145 = 232
tv180 = 240
tv312 = 248
tv310 = 256
style$ = 264
$T1 = 272
$T2 = 280
$T3 = 288
$T4 = 296
$T5 = 304
$T6 = 312
$T7 = 328
$T8 = 344
tab_bar$ = 400
label$ = 408
p_open$ = 416
flags$ = 424
?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NH@Z PROC ; ImGui::TabItemEx

; 6926 : {

$LN63:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 392				; 00000188H

; 6927 : 	// Layout whole tab bar if not already done
; 6928 : 	if (tab_bar->WantLayout)

	mov	rax, QWORD PTR tab_bar$[rsp]
	movzx	eax, BYTE PTR [rax+88]
	test	eax, eax
	je	SHORT $LN2@TabItemEx

; 6929 : 		TabBarLayout(tab_bar);

	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z ; ImGui::TabBarLayout
	npad	1
$LN2@TabItemEx:

; 6930 : 
; 6931 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6932 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 6933 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN3@TabItemEx

; 6934 : 		return false;

	xor	al, al
	jmp	$LN1@TabItemEx
$LN3@TabItemEx:

; 6935 : 
; 6936 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 6937 : 	const ImGuiID id = TabBarCalcTabID(tab_bar, label);

	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarCalcTabID@ImGui@@YAIPEAUImGuiTabBar@@PEBD@Z ; ImGui::TabBarCalcTabID
	mov	DWORD PTR id$[rsp], eax

; 6938 : 
; 6939 : 	// If the user called us with *p_open == false, we early out and don't render. We make a dummy call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.
; 6940 : 	if (p_open && !*p_open)

	cmp	QWORD PTR p_open$[rsp], 0
	je	SHORT $LN4@TabItemEx
	mov	rax, QWORD PTR p_open$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN4@TabItemEx

; 6941 : 	{
; 6942 : 		PushItemFlag(ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true);

	mov	dl, 1
	mov	ecx, 24
	call	?PushItemFlag@ImGui@@YAXH_N@Z		; ImGui::PushItemFlag
	npad	1

; 6943 : 		ItemAdd(ImRect(), id);

	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, rax
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	npad	1

; 6944 : 		PopItemFlag();

	call	?PopItemFlag@ImGui@@YAXXZ		; ImGui::PopItemFlag

; 6945 : 		return false;

	xor	al, al
	jmp	$LN1@TabItemEx
$LN4@TabItemEx:

; 6946 : 	}
; 6947 : 
; 6948 : 	// Calculate tab contents size
; 6949 : 	ImVec2 size = TabItemCalcSize(label, p_open != NULL);

	cmp	QWORD PTR p_open$[rsp], 0
	je	SHORT $LN39@TabItemEx
	mov	BYTE PTR tv88[rsp], 1
	jmp	SHORT $LN40@TabItemEx
$LN39@TabItemEx:
	mov	BYTE PTR tv88[rsp], 0
$LN40@TabItemEx:
	movzx	r8d, BYTE PTR tv88[rsp]
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR size$[rsp]
	call	?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z ; ImGui::TabItemCalcSize

; 6950 : 
; 6951 : 	// Acquire tab data
; 6952 : 	ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, id);

	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
	mov	QWORD PTR tab$[rsp], rax

; 6953 : 	bool tab_is_new = false;

	mov	BYTE PTR tab_is_new$[rsp], 0

; 6954 : 	if (tab == NULL)

	cmp	QWORD PTR tab$[rsp], 0
	jne	SHORT $LN5@TabItemEx

; 6955 : 	{
; 6956 : 		tab_bar->Tabs.push_back(ImGuiTabItem());

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv133[rsp], rax
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImGuiTabItem@@QEAA@XZ		; ImGuiTabItem::ImGuiTabItem
	mov	rdx, rax
	mov	rcx, QWORD PTR tv133[rsp]
	call	?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z ; ImVector<ImGuiTabItem>::push_back
	npad	1

; 6957 : 		tab = &tab_bar->Tabs.back();

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	?back@?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@XZ ; ImVector<ImGuiTabItem>::back
	mov	QWORD PTR tab$[rsp], rax

; 6958 : 		tab->ID = id;

	mov	rax, QWORD PTR tab$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 6959 : 		tab->Width = size.x;

	mov	rax, QWORD PTR tab$[rsp]
	movss	xmm0, DWORD PTR size$[rsp]
	movss	DWORD PTR [rax+24], xmm0

; 6960 : 		tab_is_new = true;

	mov	BYTE PTR tab_is_new$[rsp], 1
$LN5@TabItemEx:

; 6961 : 	}
; 6962 : 	tab_bar->LastTabItemIdx = (short)tab_bar->Tabs.index_from_ptr(tab);

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv145[rsp], rax
	mov	rdx, QWORD PTR tab$[rsp]
	mov	rcx, QWORD PTR tv145[rsp]
	call	?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QEBAHPEBUImGuiTabItem@@@Z ; ImVector<ImGuiTabItem>::index_from_ptr
	mov	rcx, QWORD PTR tab_bar$[rsp]
	mov	WORD PTR [rcx+122], ax

; 6963 : 	tab->WidthContents = size.x;

	mov	rax, QWORD PTR tab$[rsp]
	movss	xmm0, DWORD PTR size$[rsp]
	movss	DWORD PTR [rax+28], xmm0

; 6964 : 
; 6965 : 	if (p_open == NULL)

	cmp	QWORD PTR p_open$[rsp], 0
	jne	SHORT $LN6@TabItemEx

; 6966 : 		flags |= ImGuiTabItemFlags_NoCloseButton;

	mov	eax, DWORD PTR flags$[rsp]
	bts	eax, 20
	mov	DWORD PTR flags$[rsp], eax
$LN6@TabItemEx:

; 6967 : 
; 6968 : 	const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+12]
	inc	eax
	mov	rcx, QWORD PTR g$[rsp]
	cmp	eax, DWORD PTR [rcx+6552]
	jge	SHORT $LN41@TabItemEx
	mov	BYTE PTR tv154[rsp], 1
	jmp	SHORT $LN42@TabItemEx
$LN41@TabItemEx:
	mov	BYTE PTR tv154[rsp], 0
$LN42@TabItemEx:
	movzx	eax, BYTE PTR tv154[rsp]
	mov	BYTE PTR tab_bar_appearing$[rsp], al

; 6969 : 	const bool tab_bar_focused = (tab_bar->Flags & ImGuiTabBarFlags_IsFocused) != 0;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 2097152				; 00200000H
	test	eax, eax
	je	SHORT $LN43@TabItemEx
	mov	BYTE PTR tv158[rsp], 1
	jmp	SHORT $LN44@TabItemEx
$LN43@TabItemEx:
	mov	BYTE PTR tv158[rsp], 0
$LN44@TabItemEx:
	movzx	eax, BYTE PTR tv158[rsp]
	mov	BYTE PTR tab_bar_focused$[rsp], al

; 6970 : 	const bool tab_appearing = (tab->LastFrameVisible + 1 < g.FrameCount);

	mov	rax, QWORD PTR tab$[rsp]
	mov	eax, DWORD PTR [rax+16]
	inc	eax
	mov	rcx, QWORD PTR g$[rsp]
	cmp	eax, DWORD PTR [rcx+6552]
	jge	SHORT $LN45@TabItemEx
	mov	BYTE PTR tv163[rsp], 1
	jmp	SHORT $LN46@TabItemEx
$LN45@TabItemEx:
	mov	BYTE PTR tv163[rsp], 0
$LN46@TabItemEx:
	movzx	eax, BYTE PTR tv163[rsp]
	mov	BYTE PTR tab_appearing$[rsp], al

; 6971 : 	tab->LastFrameVisible = g.FrameCount;

	mov	rax, QWORD PTR tab$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	mov	DWORD PTR [rax+16], ecx

; 6972 : 	tab->Flags = flags;

	mov	rax, QWORD PTR tab$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 6973 : 
; 6974 : 	// Append name with zero-terminator
; 6975 : 	tab->NameOffset = tab_bar->TabsNames.size();

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 104				; 00000068H
	mov	rcx, rax
	call	?size@ImGuiTextBuffer@@QEBAHXZ		; ImGuiTextBuffer::size
	mov	rcx, QWORD PTR tab$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 6976 : 	tab_bar->TabsNames.append(label, label + strlen(label) + 1);

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 104				; 00000068H
	mov	QWORD PTR tv180[rsp], rax
	mov	rcx, QWORD PTR label$[rsp]
	call	strlen
	mov	rcx, QWORD PTR label$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	r8, rax
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR tv180[rsp]
	call	?append@ImGuiTextBuffer@@QEAAXPEBD0@Z	; ImGuiTextBuffer::append
	npad	1

; 6977 : 
; 6978 : 	// If we are not reorderable, always reset offset based on submission order.
; 6979 : 	// (We already handled layout and sizing using the previous known order, but sizing is not affected by order!)
; 6980 : 	if (!tab_appearing && !(tab_bar->Flags & ImGuiTabBarFlags_Reorderable))

	movzx	eax, BYTE PTR tab_appearing$[rsp]
	test	eax, eax
	jne	SHORT $LN7@TabItemEx
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN7@TabItemEx

; 6981 : 	{
; 6982 : 		tab->Offset = tab_bar->OffsetNextTab;

	mov	rax, QWORD PTR tab$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rcx+64]
	movss	DWORD PTR [rax+20], xmm0

; 6983 : 		tab_bar->OffsetNextTab += tab->Width + g.Style.ItemInnerSpacing.x;

	mov	rax, QWORD PTR tab$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	addss	xmm0, DWORD PTR [rcx+5548]
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm1, DWORD PTR [rax+64]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	DWORD PTR [rax+64], xmm0
$LN7@TabItemEx:

; 6984 : 	}
; 6985 : 
; 6986 : 	// Update selected tab
; 6987 : 	if (tab_appearing && (tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs) && tab_bar->NextSelectedTabId == 0)

	movzx	eax, BYTE PTR tab_appearing$[rsp]
	test	eax, eax
	je	SHORT $LN8@TabItemEx
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN8@TabItemEx
	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN8@TabItemEx

; 6988 : 		if (!tab_bar_appearing || tab_bar->SelectedTabId == 0)

	movzx	eax, BYTE PTR tab_bar_appearing$[rsp]
	test	eax, eax
	je	SHORT $LN10@TabItemEx
	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN9@TabItemEx
$LN10@TabItemEx:

; 6989 : 			tab_bar->NextSelectedTabId = id;  // New tabs gets activated

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+32], ecx
$LN9@TabItemEx:
$LN8@TabItemEx:

; 6990 : 
; 6991 : 	// Lock visibility
; 6992 : 	bool tab_contents_visible = (tab_bar->VisibleTabId == id);

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN47@TabItemEx
	mov	DWORD PTR tv210[rsp], 1
	jmp	SHORT $LN48@TabItemEx
$LN47@TabItemEx:
	mov	DWORD PTR tv210[rsp], 0
$LN48@TabItemEx:
	movzx	eax, BYTE PTR tv210[rsp]
	mov	BYTE PTR tab_contents_visible$[rsp], al

; 6993 : 	if (tab_contents_visible)

	movzx	eax, BYTE PTR tab_contents_visible$[rsp]
	test	eax, eax
	je	SHORT $LN11@TabItemEx

; 6994 : 		tab_bar->VisibleTabWasSubmitted = true;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	BYTE PTR [rax+120], 1
$LN11@TabItemEx:

; 6995 : 
; 6996 : 	// On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches
; 6997 : 	if (!tab_contents_visible && tab_bar->SelectedTabId == 0 && tab_bar_appearing)

	movzx	eax, BYTE PTR tab_contents_visible$[rsp]
	test	eax, eax
	jne	SHORT $LN12@TabItemEx
	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN12@TabItemEx
	movzx	eax, BYTE PTR tab_bar_appearing$[rsp]
	test	eax, eax
	je	SHORT $LN12@TabItemEx

; 6998 : 		if (tab_bar->Tabs.Size == 1 && !(tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs))

	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax+16], 1
	jne	SHORT $LN13@TabItemEx
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN13@TabItemEx

; 6999 : 			tab_contents_visible = true;

	mov	BYTE PTR tab_contents_visible$[rsp], 1
$LN13@TabItemEx:
$LN12@TabItemEx:

; 7000 : 
; 7001 : 	if (tab_appearing && !(tab_bar_appearing && !tab_is_new))

	movzx	eax, BYTE PTR tab_appearing$[rsp]
	test	eax, eax
	je	SHORT $LN14@TabItemEx
	movzx	eax, BYTE PTR tab_bar_appearing$[rsp]
	test	eax, eax
	je	SHORT $LN15@TabItemEx
	movzx	eax, BYTE PTR tab_is_new$[rsp]
	test	eax, eax
	je	SHORT $LN14@TabItemEx
$LN15@TabItemEx:

; 7002 : 	{
; 7003 : 		PushItemFlag(ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true);

	mov	dl, 1
	mov	ecx, 24
	call	?PushItemFlag@ImGui@@YAXH_N@Z		; ImGui::PushItemFlag
	npad	1

; 7004 : 		ItemAdd(ImRect(), id);

	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, rax
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	npad	1

; 7005 : 		PopItemFlag();

	call	?PopItemFlag@ImGui@@YAXXZ		; ImGui::PopItemFlag

; 7006 : 		return tab_contents_visible;

	movzx	eax, BYTE PTR tab_contents_visible$[rsp]
	jmp	$LN1@TabItemEx
$LN14@TabItemEx:

; 7007 : 	}
; 7008 : 
; 7009 : 	if (tab_bar->SelectedTabId == id)

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN16@TabItemEx

; 7010 : 		tab->LastFrameSelected = g.FrameCount;

	mov	rax, QWORD PTR tab$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	mov	DWORD PTR [rax], ecx
$LN16@TabItemEx:

; 7011 : 
; 7012 : 	// Backup current layout position
; 7013 : 	const ImVec2 backup_main_cursor_pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR backup_main_cursor_pos$[rsp], rax

; 7014 : 
; 7015 : 	// Layout
; 7016 : 	size.x = tab->Width;

	mov	rax, QWORD PTR tab$[rsp]
	movss	xmm0, DWORD PTR [rax+24]
	movss	DWORD PTR size$[rsp], xmm0

; 7017 : 	window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2((float)(int)tab->Offset - tab_bar->ScrollingAnim, 0.0f);

	mov	rax, QWORD PTR tab$[rsp]
	cvttss2si eax, DWORD PTR [rax+20]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR tab_bar$[rsp]
	subss	xmm0, DWORD PTR [rax+68]
	xorps	xmm2, xmm2
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR tab_bar$[rsp]
	add	rcx, 36					; 00000024H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+340], rax

; 7018 : 	ImVec2 pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR pos$[rsp], rax

; 7019 : 	ImRect bb(pos, pos + size);

	lea	r8, QWORD PTR size$[rsp]
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 7020 : 
; 7021 : 	// We don't have CPU clipping primitives to clip the CloseButton (until it becomes a texture), so need to add an extra draw call (temporary in the case of vertical animation)
; 7022 : 	bool want_clip_rect = (bb.Min.x < tab_bar->BarRect.Min.x) || (bb.Max.x >= tab_bar->BarRect.Max.x);

	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	comiss	xmm0, DWORD PTR bb$[rsp]
	ja	SHORT $LN49@TabItemEx
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR bb$[rsp+8]
	comiss	xmm0, DWORD PTR [rax+44]
	jae	SHORT $LN49@TabItemEx
	mov	DWORD PTR tv284[rsp], 0
	jmp	SHORT $LN50@TabItemEx
$LN49@TabItemEx:
	mov	DWORD PTR tv284[rsp], 1
$LN50@TabItemEx:
	movzx	eax, BYTE PTR tv284[rsp]
	mov	BYTE PTR want_clip_rect$[rsp], al

; 7023 : 	if (want_clip_rect)

	movzx	eax, BYTE PTR want_clip_rect$[rsp]
	test	eax, eax
	je	$LN17@TabItemEx

; 7024 : 		PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->BarRect.Min.x), bb.Min.y - 1), ImVec2(tab_bar->BarRect.Max.x, bb.Max.y), true);

	movss	xmm2, DWORD PTR bb$[rsp+12]
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm1, DWORD PTR [rax+44]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv312[rsp], rax
	movss	xmm0, DWORD PTR bb$[rsp+4]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv299[rsp], xmm0
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm1, DWORD PTR [rax+36]
	movss	xmm0, DWORD PTR bb$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	xmm1, DWORD PTR tv299[rsp]
	movaps	xmm2, xmm1
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv310[rsp], rax
	mov	r8b, 1
	mov	rdx, QWORD PTR tv312[rsp]
	mov	rcx, QWORD PTR tv310[rsp]
	call	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z ; ImGui::PushClipRect
	npad	1
$LN17@TabItemEx:

; 7025 : 
; 7026 : 	ItemSize(bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 7027 : 	if (!ItemAdd(bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@TabItemEx

; 7028 : 	{
; 7029 : 		if (want_clip_rect)

	movzx	eax, BYTE PTR want_clip_rect$[rsp]
	test	eax, eax
	je	SHORT $LN19@TabItemEx

; 7030 : 			PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect
	npad	1
$LN19@TabItemEx:

; 7031 : 		window->DC.CursorPos = backup_main_cursor_pos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR backup_main_cursor_pos$[rsp]
	mov	QWORD PTR [rax+340], rcx

; 7032 : 		return tab_contents_visible;

	movzx	eax, BYTE PTR tab_contents_visible$[rsp]
	jmp	$LN1@TabItemEx
$LN18@TabItemEx:

; 7033 : 	}
; 7034 : 
; 7035 : 	// Click to Select a tab
; 7036 : 	ImGuiButtonFlags button_flags = (ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_AllowItemOverlap);

	mov	DWORD PTR button_flags$[rsp], 68	; 00000044H

; 7037 : 	if (g.DragDropActive)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	je	SHORT $LN20@TabItemEx

; 7038 : 		button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;

	mov	eax, DWORD PTR button_flags$[rsp]
	bts	eax, 12
	mov	DWORD PTR button_flags$[rsp], eax
$LN20@TabItemEx:

; 7039 : 	bool hovered, held;
; 7040 : 	bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);

	mov	eax, DWORD PTR button_flags$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 7041 : 	hovered |= (g.HoveredId == id);

	movzx	eax, BYTE PTR hovered$[rsp]
	mov	DWORD PTR tv374[rsp], eax
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6696], ecx
	jne	SHORT $LN51@TabItemEx
	mov	DWORD PTR tv372[rsp], 1
	jmp	SHORT $LN52@TabItemEx
$LN51@TabItemEx:
	mov	DWORD PTR tv372[rsp], 0
$LN52@TabItemEx:
	mov	eax, DWORD PTR tv372[rsp]
	mov	ecx, DWORD PTR tv374[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR hovered$[rsp], al

; 7042 : 	if (pressed || ((flags & ImGuiTabItemFlags_SetSelected) && !tab_contents_visible)) // SetSelected can only be passed on explicit tab bar

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	jne	SHORT $LN22@TabItemEx
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN21@TabItemEx
	movzx	eax, BYTE PTR tab_contents_visible$[rsp]
	test	eax, eax
	jne	SHORT $LN21@TabItemEx
$LN22@TabItemEx:

; 7043 : 		tab_bar->NextSelectedTabId = id;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+32], ecx
$LN21@TabItemEx:

; 7044 : 
; 7045 : 	// Allow the close button to overlap unless we are dragging (in which case we don't want any overlapping tabs to be hovered)
; 7046 : 	if (!held)

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	jne	SHORT $LN23@TabItemEx

; 7047 : 		SetItemAllowOverlap();

	call	?SetItemAllowOverlap@ImGui@@YAXXZ	; ImGui::SetItemAllowOverlap
	npad	1
$LN23@TabItemEx:

; 7048 : 
; 7049 : 	// Drag and drop: re-order tabs
; 7050 : 	if (held && !tab_appearing && IsMouseDragging(0))

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	$LN24@TabItemEx
	movzx	eax, BYTE PTR tab_appearing$[rsp]
	test	eax, eax
	jne	$LN24@TabItemEx
	movss	xmm1, DWORD PTR __real@bf800000
	xor	ecx, ecx
	call	?IsMouseDragging@ImGui@@YA_NHM@Z	; ImGui::IsMouseDragging
	movzx	eax, al
	test	eax, eax
	je	$LN24@TabItemEx

; 7051 : 	{
; 7052 : 		if (!g.DragDropActive && (tab_bar->Flags & ImGuiTabBarFlags_Reorderable))

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7596]
	test	eax, eax
	jne	$LN25@TabItemEx
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	je	$LN25@TabItemEx

; 7053 : 		{
; 7054 : 			// While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x
; 7055 : 			if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < bb.Min.x)

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+968]
	jbe	SHORT $LN26@TabItemEx
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR bb$[rsp]
	comiss	xmm0, DWORD PTR [rax+316]
	jbe	SHORT $LN26@TabItemEx

; 7056 : 			{
; 7057 : 				if (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN28@TabItemEx

; 7058 : 					TabBarQueueChangeTabOrder(tab_bar, tab, -1);

	mov	r8d, -1
	mov	rdx, QWORD PTR tab$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarQueueChangeTabOrder@ImGui@@YAXPEAUImGuiTabBar@@PEBUImGuiTabItem@@H@Z ; ImGui::TabBarQueueChangeTabOrder
	npad	1
$LN28@TabItemEx:

; 7059 : 			}

	jmp	SHORT $LN27@TabItemEx
$LN26@TabItemEx:

; 7060 : 			else if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > bb.Max.x)

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+968]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN29@TabItemEx
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+316]
	comiss	xmm0, DWORD PTR bb$[rsp+8]
	jbe	SHORT $LN29@TabItemEx

; 7061 : 			{
; 7062 : 				if (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN30@TabItemEx

; 7063 : 					TabBarQueueChangeTabOrder(tab_bar, tab, +1);

	mov	r8d, 1
	mov	rdx, QWORD PTR tab$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarQueueChangeTabOrder@ImGui@@YAXPEAUImGuiTabBar@@PEBUImGuiTabItem@@H@Z ; ImGui::TabBarQueueChangeTabOrder
	npad	1
$LN30@TabItemEx:
$LN29@TabItemEx:
$LN27@TabItemEx:
$LN25@TabItemEx:
$LN24@TabItemEx:

; 7064 : 			}
; 7065 : 		}
; 7066 : 	}
; 7067 : 
; 7068 : #if 0
; 7069 : 	if (hovered && g.HoveredIdNotActiveTimer > 0.50f && bb.GetWidth() < tab->WidthContents)
; 7070 : 	{
; 7071 : 		// Enlarge tab display when hovering
; 7072 : 		bb.Max.x = bb.Min.x + (float)(int)ImLerp(bb.GetWidth(), tab->WidthContents, ImSaturate((g.HoveredIdNotActiveTimer - 0.40f) * 6.0f));
; 7073 : 		display_draw_list = GetOverlayDrawList(window);
; 7074 : 		TabItemBackground(display_draw_list, bb, flags, GetColorU32(ImGuiCol_TitleBgActive));
; 7075 : 	}
; 7076 : #endif
; 7077 : 
; 7078 : 	// Render tab shape
; 7079 : 	ImDrawList* display_draw_list = window->DrawList;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR display_draw_list$[rsp], rax

; 7080 : 	const ImU32 tab_col = GetColorU32((held || hovered) ? ImGuiCol_TabHovered : tab_contents_visible ? (tab_bar_focused ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive) : (tab_bar_focused ? ImGuiCol_Tab : ImGuiCol_TabUnfocused));

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	jne	$LN53@TabItemEx
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	jne	SHORT $LN53@TabItemEx
	movzx	eax, BYTE PTR tab_contents_visible$[rsp]
	test	eax, eax
	je	SHORT $LN58@TabItemEx
	movzx	eax, BYTE PTR tab_bar_focused$[rsp]
	test	eax, eax
	je	SHORT $LN54@TabItemEx
	mov	DWORD PTR tv438[rsp], 35		; 00000023H
	jmp	SHORT $LN55@TabItemEx
$LN54@TabItemEx:
	mov	DWORD PTR tv438[rsp], 37		; 00000025H
$LN55@TabItemEx:
	mov	eax, DWORD PTR tv438[rsp]
	mov	DWORD PTR tv444[rsp], eax
	jmp	SHORT $LN59@TabItemEx
$LN58@TabItemEx:
	movzx	eax, BYTE PTR tab_bar_focused$[rsp]
	test	eax, eax
	je	SHORT $LN56@TabItemEx
	mov	DWORD PTR tv441[rsp], 33		; 00000021H
	jmp	SHORT $LN57@TabItemEx
$LN56@TabItemEx:
	mov	DWORD PTR tv441[rsp], 36		; 00000024H
$LN57@TabItemEx:
	mov	eax, DWORD PTR tv441[rsp]
	mov	DWORD PTR tv444[rsp], eax
$LN59@TabItemEx:
	mov	eax, DWORD PTR tv444[rsp]
	mov	DWORD PTR tv445[rsp], eax
	jmp	SHORT $LN60@TabItemEx
$LN53@TabItemEx:
	mov	DWORD PTR tv445[rsp], 34		; 00000022H
$LN60@TabItemEx:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv445[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tab_col$[rsp], eax

; 7081 : 	TabItemBackground(display_draw_list, bb, flags, tab_col);

	mov	r9d, DWORD PTR tab_col$[rsp]
	mov	r8d, DWORD PTR flags$[rsp]
	lea	rdx, QWORD PTR bb$[rsp]
	mov	rcx, QWORD PTR display_draw_list$[rsp]
	call	?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z ; ImGui::TabItemBackground

; 7082 : 	RenderNavHighlight(bb, id);

	mov	r8d, 1
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 7083 : 
; 7084 : 	// Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.
; 7085 : 	const bool hovered_unblocked = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);

	mov	ecx, 8
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	mov	BYTE PTR hovered_unblocked$[rsp], al

; 7086 : 	if (hovered_unblocked && (IsMouseClicked(1) || IsMouseReleased(1)))

	movzx	eax, BYTE PTR hovered_unblocked$[rsp]
	test	eax, eax
	je	SHORT $LN31@TabItemEx
	xor	edx, edx
	mov	ecx, 1
	call	?IsMouseClicked@ImGui@@YA_NH_N@Z	; ImGui::IsMouseClicked
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN32@TabItemEx
	mov	ecx, 1
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN31@TabItemEx
$LN32@TabItemEx:

; 7087 : 		tab_bar->NextSelectedTabId = id;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+32], ecx
$LN31@TabItemEx:

; 7088 : 
; 7089 : 	if (tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN33@TabItemEx

; 7090 : 		flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 4
	mov	DWORD PTR flags$[rsp], eax
$LN33@TabItemEx:

; 7091 : 
; 7092 : 	// Render tab label, process close button
; 7093 : 	const ImGuiID close_button_id = p_open ? window->GetID((void*)((intptr_t)id + 1)) : 0;

	cmp	QWORD PTR p_open$[rsp], 0
	je	SHORT $LN61@TabItemEx
	mov	eax, DWORD PTR id$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBX@Z		; ImGuiWindow::GetID
	mov	DWORD PTR tv478[rsp], eax
	jmp	SHORT $LN62@TabItemEx
$LN61@TabItemEx:
	mov	DWORD PTR tv478[rsp], 0
$LN62@TabItemEx:
	mov	eax, DWORD PTR tv478[rsp]
	mov	DWORD PTR close_button_id$[rsp], eax

; 7094 : 	bool just_closed = TabItemLabelAndCloseButton(display_draw_list, bb, flags, tab_bar->FramePadding, label, id, close_button_id);

	mov	eax, DWORD PTR close_button_id$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR id$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR label$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	r9, QWORD PTR [rax+92]
	mov	r8d, DWORD PTR flags$[rsp]
	lea	rdx, QWORD PTR bb$[rsp]
	mov	rcx, QWORD PTR display_draw_list$[rsp]
	call	?TabItemLabelAndCloseButton@ImGui@@YA_NPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII@Z ; ImGui::TabItemLabelAndCloseButton
	mov	BYTE PTR just_closed$[rsp], al

; 7095 : 	if (just_closed && p_open != NULL)

	movzx	eax, BYTE PTR just_closed$[rsp]
	test	eax, eax
	je	SHORT $LN34@TabItemEx
	cmp	QWORD PTR p_open$[rsp], 0
	je	SHORT $LN34@TabItemEx

; 7096 : 	{
; 7097 : 		*p_open = false;

	mov	rax, QWORD PTR p_open$[rsp]
	mov	BYTE PTR [rax], 0

; 7098 : 		TabBarCloseTab(tab_bar, tab);

	mov	rdx, QWORD PTR tab$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarCloseTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z ; ImGui::TabBarCloseTab
	npad	1
$LN34@TabItemEx:

; 7099 : 	}
; 7100 : 
; 7101 : 	// Restore main window position so user can draw there
; 7102 : 	if (want_clip_rect)

	movzx	eax, BYTE PTR want_clip_rect$[rsp]
	test	eax, eax
	je	SHORT $LN35@TabItemEx

; 7103 : 		PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect
	npad	1
$LN35@TabItemEx:

; 7104 : 	window->DC.CursorPos = backup_main_cursor_pos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR backup_main_cursor_pos$[rsp]
	mov	QWORD PTR [rax+340], rcx

; 7105 : 
; 7106 : 	// Tooltip (FIXME: Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer)
; 7107 : 	if (g.HoveredId == id && !held && g.HoveredIdNotActiveTimer > 0.50f)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6696], ecx
	jne	SHORT $LN36@TabItemEx
	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	jne	SHORT $LN36@TabItemEx
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6712]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN36@TabItemEx

; 7108 : 		if (!(tab_bar->Flags & ImGuiTabBarFlags_NoTooltip))

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN37@TabItemEx

; 7109 : 			SetTooltip(("%.*s"), (int)(FindRenderedTextEnd(label) - label), label);

	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	sub	rax, QWORD PTR label$[rsp]
	mov	r8, QWORD PTR label$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_04EBNJJJJI@?$CF?4?$CKs@
	call	?SetTooltip@ImGui@@YAXPEBDZZ		; ImGui::SetTooltip
	npad	1
$LN37@TabItemEx:
$LN36@TabItemEx:

; 7110 : 
; 7111 : 	return tab_contents_visible;

	movzx	eax, BYTE PTR tab_contents_visible$[rsp]
$LN1@TabItemEx:

; 7112 : }

	add	rsp, 392				; 00000188H
	ret	0
?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NH@Z ENDP ; ImGui::TabItemEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tab_bar$ = 8
tab$ = 16
dir$ = 24
?TabBarQueueChangeTabOrder@ImGui@@YAXPEAUImGuiTabBar@@PEBUImGuiTabItem@@H@Z PROC ; ImGui::TabBarQueueChangeTabOrder

; 6783 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 6784 : 	IM_ASSERT(dir == -1 || dir == +1);
; 6785 : 	IM_ASSERT(tab_bar->ReorderRequestTabId == 0);
; 6786 : 	tab_bar->ReorderRequestTabId = tab->ID;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tab$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+76], ecx

; 6787 : 	tab_bar->ReorderRequestDir = dir;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR dir$[rsp]
	mov	DWORD PTR [rax+84], ecx

; 6788 : }

	ret	0
?TabBarQueueChangeTabOrder@ImGui@@YAXPEAUImGuiTabBar@@PEBUImGuiTabItem@@H@Z ENDP ; ImGui::TabBarQueueChangeTabOrder
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tab_bar$ = 8
tab$ = 16
?TabBarCloseTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z PROC ; ImGui::TabBarCloseTab

; 6748 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 6749 : 	if ((tab_bar->VisibleTabId == tab->ID) && !(tab->Flags & ImGuiTabItemFlags_UnsavedDocument))

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tab$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN2@TabBarClos
	mov	rax, QWORD PTR tab$[rsp]
	mov	eax, DWORD PTR [rax+12]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN2@TabBarClos

; 6750 : 	{
; 6751 : 		// This will remove a frame of lag for selecting another tab on closure.
; 6752 : 		// However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure
; 6753 : 		tab->LastFrameVisible = -1;

	mov	rax, QWORD PTR tab$[rsp]
	mov	DWORD PTR [rax+16], -1

; 6754 : 		tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	DWORD PTR [rax+32], 0
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	DWORD PTR [rax], 0

; 6755 : 	}

	jmp	SHORT $LN3@TabBarClos
$LN2@TabBarClos:

; 6756 : 	else if ((tab_bar->VisibleTabId != tab->ID) && (tab->Flags & ImGuiTabItemFlags_UnsavedDocument))

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tab$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	je	SHORT $LN4@TabBarClos
	mov	rax, QWORD PTR tab$[rsp]
	mov	eax, DWORD PTR [rax+12]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@TabBarClos

; 6757 : 	{
; 6758 : 		// Actually select before expecting closure
; 6759 : 		tab_bar->NextSelectedTabId = tab->ID;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tab$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+32], ecx
$LN4@TabBarClos:
$LN3@TabBarClos:

; 6760 : 	}
; 6761 : }

	ret	0
?TabBarCloseTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z ENDP ; ImGui::TabBarCloseTab
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tab$1 = 32
tv73 = 40
tab_bar$ = 64
tab_id$ = 72
?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z PROC	; ImGui::TabBarRemoveTab

; 6738 : {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6739 : 	if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))

	mov	edx, DWORD PTR tab_id$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
	mov	QWORD PTR tab$1[rsp], rax
	cmp	QWORD PTR tab$1[rsp], 0
	je	SHORT $LN2@TabBarRemo

; 6740 : 		tab_bar->Tabs.erase(tab);

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR tab$1[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z ; ImVector<ImGuiTabItem>::erase
	npad	1
$LN2@TabBarRemo:

; 6741 : 	if (tab_bar->VisibleTabId == tab_id) { tab_bar->VisibleTabId = 0; }

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR tab_id$[rsp]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN3@TabBarRemo
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	DWORD PTR [rax+4], 0
$LN3@TabBarRemo:

; 6742 : 	if (tab_bar->SelectedTabId == tab_id) { tab_bar->SelectedTabId = 0; }

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR tab_id$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN4@TabBarRemo
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	DWORD PTR [rax], 0
$LN4@TabBarRemo:

; 6743 : 	if (tab_bar->NextSelectedTabId == tab_id) { tab_bar->NextSelectedTabId = 0; }

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR tab_id$[rsp]
	cmp	DWORD PTR [rax+32], ecx
	jne	SHORT $LN5@TabBarRemo
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	DWORD PTR [rax+32], 0
$LN5@TabBarRemo:

; 6744 : }

	add	rsp, 56					; 00000038H
	ret	0
?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z ENDP	; ImGui::TabBarRemoveTab
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
n$1 = 32
tv74 = 40
tv82 = 48
tab_bar$ = 80
tab_id$ = 88
?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z PROC ; ImGui::TabBarFindTabByID

; 6728 : {

$LN8:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 6729 : 	if (tab_id != 0)

	cmp	DWORD PTR tab_id$[rsp], 0
	je	SHORT $LN5@TabBarFind

; 6730 : 		for (int n = 0; n < tab_bar->Tabs.Size; n++)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN4@TabBarFind
$LN2@TabBarFind:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@TabBarFind:
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR n$1[rsp], eax
	jge	SHORT $LN3@TabBarFind

; 6731 : 			if (tab_bar->Tabs[n].ID == tab_id)

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv74[rsp], rax
	mov	edx, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	mov	ecx, DWORD PTR tab_id$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN6@TabBarFind

; 6732 : 				return &tab_bar->Tabs[n];

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv82[rsp], rax
	mov	edx, DWORD PTR n$1[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	jmp	SHORT $LN1@TabBarFind
$LN6@TabBarFind:
	jmp	SHORT $LN2@TabBarFind
$LN3@TabBarFind:
$LN5@TabBarFind:

; 6733 : 	return NULL;

	xor	eax, eax
$LN1@TabBarFind:

; 6734 : }

	add	rsp, 72					; 00000048H
	ret	0
?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z ENDP ; ImGui::TabBarFindTabByID
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 48
tv174 = 56
y$ = 60
g$ = 64
tv162 = 72
tv160 = 76
separator_max_x$1 = 80
separator_min_x$2 = 84
col$ = 88
tv75 = 96
tv80 = 104
tv209 = 112
tv207 = 120
tv211 = 128
$T3 = 136
$T4 = 144
$T5 = 152
tab_bar$ = 192
tab_bar_bb$ = 200
flags$ = 208
?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@H@Z PROC ; ImGui::BeginTabBarEx

; 6464 : {

$LN10:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 168				; 000000a8H

; 6465 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6466 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 6467 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@BeginTabBa

; 6468 : 		return false;

	xor	al, al
	jmp	$LN1@BeginTabBa
$LN2@BeginTabBa:

; 6469 : 
; 6470 : 	if ((flags & ImGuiTabBarFlags_DockNode) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	jne	SHORT $LN3@BeginTabBa

; 6471 : 		window->IDStack.push_back(tab_bar->ID);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 232				; 000000e8H
	mov	QWORD PTR tv75[rsp], rax
	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 8
	mov	rdx, rax
	mov	rcx, QWORD PTR tv75[rsp]
	call	?push_back@?$ImVector@I@@QEAAXAEBI@Z	; ImVector<unsigned int>::push_back
	npad	1
$LN3@BeginTabBa:

; 6472 : 
; 6473 : 	g.CurrentTabBar.push_back(tab_bar);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7800				; 00001e78H
	mov	QWORD PTR tv80[rsp], rax
	lea	rdx, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	?push_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXAEBQEAUImGuiTabBar@@@Z ; ImVector<ImGuiTabBar *>::push_back
	npad	1

; 6474 : 	if (tab_bar->CurrFrameVisible == g.FrameCount)

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	cmp	DWORD PTR [rax+52], ecx
	jne	SHORT $LN4@BeginTabBa

; 6475 : 	{
; 6476 : 		//IMGUI_DEBUG_LOG("BeginTabBarEx already called this frame\n", g.FrameCount);
; 6477 : 		IM_ASSERT(0);
; 6478 : 		return true;

	mov	al, 1
	jmp	$LN1@BeginTabBa
$LN4@BeginTabBa:

; 6479 : 	}
; 6480 : 
; 6481 : 	// When toggling back from ordered to manually-reorderable, shuffle tabs to enforce the last visible order.
; 6482 : 	// Otherwise, the most recently inserted tabs would move at the end of visible list which can be a little too confusing or magic for the user.
; 6483 : 	if ((flags & ImGuiTabBarFlags_Reorderable) && !(tab_bar->Flags & ImGuiTabBarFlags_Reorderable) && tab_bar->Tabs.Size > 1 && tab_bar->PrevFrameVisible != -1)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@BeginTabBa
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN5@BeginTabBa
	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax+16], 1
	jle	SHORT $LN5@BeginTabBa
	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax+12], -1
	je	SHORT $LN5@BeginTabBa

; 6484 : 		ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerByVisibleOffset);

	mov	rax, QWORD PTR tab_bar$[rsp]
	movsxd	rax, DWORD PTR [rax+16]
	lea	r9, OFFSET FLAT:?TabItemComparerByVisibleOffset@@YAHPEBX0@Z ; TabItemComparerByVisibleOffset
	mov	r8d, 32					; 00000020H
	mov	rdx, rax
	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	qsort
	npad	1
$LN5@BeginTabBa:

; 6485 : 
; 6486 : 	// Flags
; 6487 : 	if ((flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 192				; 000000c0H
	test	eax, eax
	jne	SHORT $LN6@BeginTabBa

; 6488 : 		flags |= ImGuiTabBarFlags_FittingPolicyDefault_;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR flags$[rsp], eax
$LN6@BeginTabBa:

; 6489 : 
; 6490 : 	tab_bar->Flags = flags;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rax+72], ecx

; 6491 : 	tab_bar->BarRect = tab_bar_bb;

	mov	rax, QWORD PTR tab_bar$[rsp]
	lea	rdi, QWORD PTR [rax+36]
	mov	rsi, QWORD PTR tab_bar_bb$[rsp]
	mov	ecx, 16
	rep movsb

; 6492 : 	tab_bar->WantLayout = true; // Layout will be done on the first call to ItemTab()

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	BYTE PTR [rax+88], 1

; 6493 : 	tab_bar->PrevFrameVisible = tab_bar->CurrFrameVisible;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR [rcx+52]
	mov	DWORD PTR [rax+12], ecx

; 6494 : 	tab_bar->CurrFrameVisible = g.FrameCount;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6552]
	mov	DWORD PTR [rax+52], ecx

; 6495 : 	tab_bar->FramePadding = g.Style.FramePadding;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+5524]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	mov	QWORD PTR [rcx+92], rax

; 6496 : 
; 6497 : 	// Layout
; 6498 : 	ItemSize(ImVec2(tab_bar->OffsetMax, tab_bar->BarRect.GetHeight()));

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 36					; 00000024H
	mov	rcx, rax
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	DWORD PTR tv162[rsp], xmm0
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	movss	DWORD PTR tv160[rsp], xmm0
	movss	xmm2, DWORD PTR tv162[rsp]
	movss	xmm1, DWORD PTR tv160[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm1, xmm1
	mov	rcx, rax
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 6499 : 	window->DC.CursorPos.x = tab_bar->BarRect.Min.x;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rcx+36]
	movss	DWORD PTR [rax+340], xmm0

; 6500 : 
; 6501 : 	// Draw separator
; 6502 : 	const ImU32 col = GetColorU32((flags & ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabActive : ImGuiCol_Tab);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2097152				; 00200000H
	test	eax, eax
	je	SHORT $LN8@BeginTabBa
	mov	DWORD PTR tv174[rsp], 35		; 00000023H
	jmp	SHORT $LN9@BeginTabBa
$LN8@BeginTabBa:
	mov	DWORD PTR tv174[rsp], 33		; 00000021H
$LN9@BeginTabBa:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv174[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR col$[rsp], eax

; 6503 : 	const float y = tab_bar->BarRect.Max.y - 1.0f;

	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR y$[rsp], xmm0

; 6504 : 	{
; 6505 : 		const float separator_min_x = tab_bar->BarRect.Min.x - window->WindowPadding.x;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+36]
	subss	xmm0, DWORD PTR [rcx+80]
	movss	DWORD PTR separator_min_x$2[rsp], xmm0

; 6506 : 		const float separator_max_x = tab_bar->BarRect.Max.x + window->WindowPadding.x;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+44]
	addss	xmm0, DWORD PTR [rcx+80]
	movss	DWORD PTR separator_max_x$1[rsp], xmm0

; 6507 : 		window->DrawList->AddLine(ImVec2(separator_min_x, y), ImVec2(separator_max_x, y), col, 1.0f);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv211[rsp], rax
	movss	xmm2, DWORD PTR y$[rsp]
	movss	xmm1, DWORD PTR separator_max_x$1[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv209[rsp], rax
	movss	xmm2, DWORD PTR y$[rsp]
	movss	xmm1, DWORD PTR separator_min_x$2[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv207[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR col$[rsp]
	mov	r8, QWORD PTR tv209[rsp]
	mov	rdx, QWORD PTR tv207[rsp]
	mov	rcx, QWORD PTR tv211[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 6508 : 	}
; 6509 : 	return true;

	mov	al, 1
$LN1@BeginTabBa:

; 6510 : }

	add	rsp, 168				; 000000a8H
	pop	rdi
	pop	rsi
	ret	0
?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@H@Z ENDP ; ImGui::BeginTabBarEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z
_TEXT	SEGMENT
tv68 = 32
n$ = 64
mode$ = 72
?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z PROC ; ImGui::IsNavInputPressed, COMDAT

; 1421 :     inline bool             IsNavInputPressed(ImGuiNavInput n, ImGuiInputReadMode mode) { return GetNavInputAmount(n, mode) > 0.0f; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	mov	edx, DWORD PTR mode$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	call	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@IsNavInput
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@IsNavInput
$LN3@IsNavInput:
	mov	DWORD PTR tv68[rsp], 0
$LN4@IsNavInput:
	movzx	eax, BYTE PTR tv68[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?IsNavInputPressed@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ENDP ; ImGui::IsNavInputPressed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?IsNavInputDown@ImGui@@YA_NH@Z
_TEXT	SEGMENT
tv70 = 0
n$ = 32
?IsNavInputDown@ImGui@@YA_NH@Z PROC			; ImGui::IsNavInputDown, COMDAT

; 1420 :     inline bool             IsNavInputDown(ImGuiNavInput n) { return GImGui->IO.NavInputs[n] > 0.0f; }

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm0, DWORD PTR [rcx+rax*4+848]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@IsNavInput
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN4@IsNavInput
$LN3@IsNavInput:
	mov	DWORD PTR tv70[rsp], 0
$LN4@IsNavInput:
	movzx	eax, BYTE PTR tv70[rsp]
	add	rsp, 24
	ret	0
?IsNavInputDown@ImGui@@YA_NH@Z ENDP			; ImGui::IsNavInputDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?IsKeyPressedMap@ImGui@@YA_NH_N@Z
_TEXT	SEGMENT
tv73 = 32
key_index$ = 36
key$ = 64
repeat$ = 72
?IsKeyPressedMap@ImGui@@YA_NH_N@Z PROC			; ImGui::IsKeyPressedMap, COMDAT

; 1419 :     inline bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true) { const int key_index = GImGui->IO.KeyMap[key]; return (key_index >= 0) ? IsKeyPressed(key_index, repeat) : false; }

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	movsxd	rax, DWORD PTR key$[rsp]
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	eax, DWORD PTR [rcx+rax*4+60]
	mov	DWORD PTR key_index$[rsp], eax
	cmp	DWORD PTR key_index$[rsp], 0
	jl	SHORT $LN3@IsKeyPress
	movzx	edx, BYTE PTR repeat$[rsp]
	mov	ecx, DWORD PTR key_index$[rsp]
	call	?IsKeyPressed@ImGui@@YA_NH_N@Z		; ImGui::IsKeyPressed
	mov	BYTE PTR tv73[rsp], al
	jmp	SHORT $LN4@IsKeyPress
$LN3@IsKeyPress:
	mov	BYTE PTR tv73[rsp], 0
$LN4@IsKeyPress:
	movzx	eax, BYTE PTR tv73[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?IsKeyPressedMap@ImGui@@YA_NH_N@Z ENDP			; ImGui::IsKeyPressedMap
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ
_TEXT	SEGMENT
g$ = 0
?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ PROC	; ImGui::GetCurrentWindow, COMDAT

; 1326 :     inline    ImGuiWindow* GetCurrentWindow() { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

$LN3:
	sub	rsp, 24
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	BYTE PTR [rax+112], 1
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	add	rsp, 24
	ret	0
?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ENDP	; ImGui::GetCurrentWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetTabName@ImGuiTabBar@@QEBAPEBDPEBUImGuiTabItem@@@Z
_TEXT	SEGMENT
this$ = 8
tab$ = 16
?GetTabName@ImGuiTabBar@@QEBAPEBDPEBUImGuiTabItem@@@Z PROC ; ImGuiTabBar::GetTabName, COMDAT

; 1308 :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1309 :         IM_ASSERT(tab->NameOffset != -1 && tab->NameOffset < TabsNames.Buf.Size);
; 1310 :         return TabsNames.Buf.Data + tab->NameOffset;

	mov	rax, QWORD PTR tab$[rsp]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+112]

; 1311 :     }

	ret	0
?GetTabName@ImGuiTabBar@@QEBAPEBDPEBUImGuiTabItem@@@Z ENDP ; ImGuiTabBar::GetTabName
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetTabOrder@ImGuiTabBar@@QEBAHPEBUImGuiTabItem@@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
tab$ = 72
?GetTabOrder@ImGuiTabBar@@QEBAHPEBUImGuiTabItem@@@Z PROC ; ImGuiTabBar::GetTabOrder, COMDAT

; 1306 :     int                 GetTabOrder(const ImGuiTabItem* tab) const { return Tabs.index_from_ptr(tab); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR tab$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QEBAHPEBUImGuiTabItem@@@Z ; ImVector<ImGuiTabItem>::index_from_ptr
	add	rsp, 56					; 00000038H
	ret	0
?GetTabOrder@ImGuiTabBar@@QEBAHPEBUImGuiTabItem@@@Z ENDP ; ImGuiTabBar::GetTabOrder
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
this$ = 48
??0ImGuiTabBar@@QEAA@XZ PROC				; ImGuiTabBar::ImGuiTabBar

; 6419 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??0?$ImVector@UImGuiTabItem@@@@QEAA@XZ	; ImVector<ImGuiTabItem>::ImVector<ImGuiTabItem>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 36					; 00000024H
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 92					; 0000005cH
	mov	rcx, rax
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	rcx, rax
	call	??0ImGuiTextBuffer@@QEAA@XZ		; ImGuiTextBuffer::ImGuiTextBuffer
	npad	1

; 6420 : 	ID = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], 0

; 6421 : 	SelectedTabId = NextSelectedTabId = VisibleTabId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+32], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0

; 6422 : 	CurrFrameVisible = PrevFrameVisible = -1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], -1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+52], -1

; 6423 : 	ContentsHeight = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+56], xmm0

; 6424 : 	OffsetMax = OffsetNextTab = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+64], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+60], xmm0

; 6425 : 	ScrollingAnim = ScrollingTarget = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+80], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+68], xmm0

; 6426 : 	Flags = ImGuiTabBarFlags_None;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+72], 0

; 6427 : 	ReorderRequestTabId = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+76], 0

; 6428 : 	ReorderRequestDir = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+84], 0

; 6429 : 	WantLayout = VisibleTabWasSubmitted = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+120], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+88], 0

; 6430 : 	LastTabItemIdx = -1;

	mov	eax, -1
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+122], ax

; 6431 : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiTabBar@@QEAA@XZ ENDP				; ImGuiTabBar::ImGuiTabBar
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0ImGuiTabBar@@QEAA@XZ@4HA PROC		; `ImGuiTabBar::ImGuiTabBar'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 16
	call	??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ	; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImGuiTabBar@@QEAA@XZ@4HA ENDP		; `ImGuiTabBar::ImGuiTabBar'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0ImGuiTabBar@@QEAA@XZ@4HA PROC		; `ImGuiTabBar::ImGuiTabBar'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 104				; 00000068H
	call	??1ImGuiTextBuffer@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ImGuiTabBar@@QEAA@XZ@4HA ENDP		; `ImGuiTabBar::ImGuiTabBar'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QEBAHPEBUImGuiTabItem@@@Z
_TEXT	SEGMENT
off$ = 0
this$ = 32
it$ = 40
?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QEBAHPEBUImGuiTabItem@@@Z PROC ; ImVector<ImGuiTabItem>::index_from_ptr, COMDAT

; 1256 : 	inline int          index_from_ptr(const T* it) const { IM_ASSERT(it >= Data && it <= Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR it$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 5
	mov	QWORD PTR off$[rsp], rax
	mov	eax, DWORD PTR off$[rsp]
	add	rsp, 24
	ret	0
?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QEBAHPEBUImGuiTabItem@@@Z ENDP ; ImVector<ImGuiTabItem>::index_from_ptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z
_TEXT	SEGMENT
off$ = 32
tv81 = 40
this$ = 64
it$ = 72
?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z PROC ; ImVector<ImGuiTabItem>::erase, COMDAT

; 1251 : 	inline T* erase(const T* it) { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR it$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 5
	mov	QWORD PTR off$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	sub	rax, QWORD PTR off$[rsp]
	dec	rax
	imul	rax, rax, 32				; 00000020H
	imul	rcx, QWORD PTR off$[rsp], 32		; 00000020H
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR [rdx+rcx+32]
	imul	rdx, QWORD PTR off$[rsp], 32		; 00000020H
	mov	r8, QWORD PTR this$[rsp]
	add	rdx, QWORD PTR [r8+8]
	mov	QWORD PTR tv81[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv81[rsp]
	mov	rcx, rax
	call	memmove
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	imul	rax, QWORD PTR off$[rsp], 32		; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	add	rsp, 56					; 00000038H
	ret	0
?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z ENDP ; ImVector<ImGuiTabItem>::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z PROC ; ImVector<ImGuiTabItem>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z ; ImVector<ImGuiTabItem>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z ; ImVector<ImGuiTabItem>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, 32					; 00000020H
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z ENDP ; ImVector<ImGuiTabItem>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z PROC	; ImVector<ImGuiTabItem>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 32				; 00000020H
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z ENDP	; ImVector<ImGuiTabItem>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z PROC	; ImVector<ImGuiTabItem>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z ; ImVector<ImGuiTabItem>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z ; ImVector<ImGuiTabItem>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z ENDP	; ImVector<ImGuiTabItem>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z PROC ; ImVector<ImGuiTabItem>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z ENDP ; ImVector<ImGuiTabItem>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@XZ PROC ; ImVector<ImGuiTabItem>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@XZ ENDP ; ImVector<ImGuiTabItem>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z PROC ; ImVector<ImGuiTabItem>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ENDP ; ImVector<ImGuiTabItem>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ PROC		; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@UImGuiTabItem@@@@QEAA@XZ ENDP		; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiTabItem@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImGuiTabItem@@@@QEAA@XZ PROC		; ImVector<ImGuiTabItem>::ImVector<ImGuiTabItem>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@UImGuiTabItem@@@@QEAA@XZ ENDP		; ImVector<ImGuiTabItem>::ImVector<ImGuiTabItem>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImGuiTabItem@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImGuiTabItem@@QEAA@XZ PROC				; ImGuiTabItem::ImGuiTabItem, COMDAT

; 1275 :     ImGuiTabItem() { ID = Flags = 0; LastFrameVisible = LastFrameSelected = -1; NameOffset = -1; Offset = Width = WidthContents = 0.0f; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], -1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+16], -1
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], -1
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+28], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+24], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+20], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImGuiTabItem@@QEAA@XZ ENDP				; ImGuiTabItem::ImGuiTabItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Restore@ImGuiItemHoveredDataBackup@@QEBAXXZ
_TEXT	SEGMENT
window$ = 0
this$ = 48
?Restore@ImGuiItemHoveredDataBackup@@QEBAXXZ PROC	; ImGuiItemHoveredDataBackup::Restore, COMDAT

; 1244 :     void Restore() const { ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemStatusFlags = LastItemStatusFlags; window->DC.LastItemRect = LastItemRect; window->DC.LastItemDisplayRect = LastItemDisplayRect; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 24
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+32]
	mov	DWORD PTR [rax+412], ecx
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+416], ecx
	mov	rax, QWORD PTR window$[rsp]
	lea	rdi, QWORD PTR [rax+368]
	mov	rsi, QWORD PTR this$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rax+384]
	lea	rsi, QWORD PTR [rcx+16]
	mov	ecx, 16
	rep movsb
	add	rsp, 24
	pop	rdi
	pop	rsi
	ret	0
?Restore@ImGuiItemHoveredDataBackup@@QEBAXXZ ENDP	; ImGuiItemHoveredDataBackup::Restore
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Backup@ImGuiItemHoveredDataBackup@@QEAAXXZ
_TEXT	SEGMENT
window$ = 0
this$ = 48
?Backup@ImGuiItemHoveredDataBackup@@QEAAXXZ PROC	; ImGuiItemHoveredDataBackup::Backup, COMDAT

; 1243 :     void Backup() { ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemStatusFlags = window->DC.LastItemStatusFlags; LastItemRect = window->DC.LastItemRect; LastItemDisplayRect = window->DC.LastItemDisplayRect; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 24
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+412]
	mov	DWORD PTR [rax+32], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+416]
	mov	DWORD PTR [rax+36], ecx
	mov	rax, QWORD PTR window$[rsp]
	mov	rdi, QWORD PTR this$[rsp]
	lea	rsi, QWORD PTR [rax+368]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	lea	rdi, QWORD PTR [rax+16]
	lea	rsi, QWORD PTR [rcx+384]
	mov	ecx, 16
	rep movsb
	add	rsp, 24
	pop	rdi
	pop	rsi
	ret	0
?Backup@ImGuiItemHoveredDataBackup@@QEAAXXZ ENDP	; ImGuiItemHoveredDataBackup::Backup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImGuiItemHoveredDataBackup@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImGuiItemHoveredDataBackup@@QEAA@XZ PROC		; ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup, COMDAT

; 1242 :     ImGuiItemHoveredDataBackup() { Backup(); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect
	mov	rcx, QWORD PTR this$[rsp]
	call	?Backup@ImGuiItemHoveredDataBackup@@QEAAXXZ ; ImGuiItemHoveredDataBackup::Backup
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiItemHoveredDataBackup@@QEAA@XZ ENDP		; ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ
_TEXT	SEGMENT
y1$ = 48
tv88 = 52
tv90 = 56
tv86 = 60
this$ = 80
__$ReturnUdt$ = 88
?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ PROC	; ImGuiWindow::MenuBarRect, COMDAT

; 1231 :     ImRect      MenuBarRect() const { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rcx, QWORD PTR this$[rsp]
	call	?TitleBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::TitleBarHeight
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR y1$[rsp], xmm0
	mov	rcx, QWORD PTR this$[rsp]
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	movss	xmm1, DWORD PTR y1$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv88[rsp], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx+32]
	movss	DWORD PTR tv90[rsp], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	movss	DWORD PTR tv86[rsp], xmm0
	movss	xmm0, DWORD PTR tv88[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR tv90[rsp]
	movss	xmm2, DWORD PTR y1$[rsp]
	movss	xmm1, DWORD PTR tv86[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ ENDP	; ImGuiWindow::MenuBarRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?MenuBarHeight@ImGuiWindow@@QEBAMXZ
_TEXT	SEGMENT
tv78 = 32
this$ = 64
?MenuBarHeight@ImGuiWindow@@QEBAMXZ PROC		; ImGuiWindow::MenuBarHeight, COMDAT

; 1230 :     float       MenuBarHeight() const { return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $LN3@MenuBarHei
	mov	rcx, QWORD PTR this$[rsp]
	call	?CalcFontSize@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::CalcFontSize
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+464]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+5528]
	mulss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN4@MenuBarHei
$LN3@MenuBarHei:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv78[rsp], xmm0
$LN4@MenuBarHei:
	movss	xmm0, DWORD PTR tv78[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?MenuBarHeight@ImGuiWindow@@QEBAMXZ ENDP		; ImGuiWindow::MenuBarHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?TitleBarHeight@ImGuiWindow@@QEBAMXZ
_TEXT	SEGMENT
tv74 = 32
this$ = 64
?TitleBarHeight@ImGuiWindow@@QEBAMXZ PROC		; ImGuiWindow::TitleBarHeight, COMDAT

; 1228 :     float       TitleBarHeight() const { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN3@TitleBarHe
	xorps	xmm0, xmm0
	movss	DWORD PTR tv74[rsp], xmm0
	jmp	SHORT $LN4@TitleBarHe
$LN3@TitleBarHe:
	mov	rcx, QWORD PTR this$[rsp]
	call	?CalcFontSize@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::CalcFontSize
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+5528]
	mulss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	movss	DWORD PTR tv74[rsp], xmm0
$LN4@TitleBarHe:
	movss	xmm0, DWORD PTR tv74[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?TitleBarHeight@ImGuiWindow@@QEBAMXZ ENDP		; ImGuiWindow::TitleBarHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?CalcFontSize@ImGuiWindow@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?CalcFontSize@ImGuiWindow@@QEBAMXZ PROC			; ImGuiWindow::CalcFontSize, COMDAT

; 1227 :     float       CalcFontSize() const { return GImGui->FontBaseSize * FontWindowScale; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+6412]
	mulss	xmm0, DWORD PTR [rcx+680]
	ret	0
?CalcFontSize@ImGuiWindow@@QEBAMXZ ENDP			; ImGuiWindow::CalcFontSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ PROC		; ImGuiWindow::Rect, COMDAT

; 1226 :     ImRect      Rect() const { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+48]
	addss	xmm1, DWORD PTR [rcx]
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax+52]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+48]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ ENDP		; ImGuiWindow::Rect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@I@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@I@@QEAAXXZ PROC			; ImVector<unsigned int>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@I@@QEAAXXZ ENDP			; ImVector<unsigned int>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@I@@QEAAXAEBI@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@I@@QEAAXAEBI@Z PROC		; ImVector<unsigned int>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@I@@QEBAHH@Z	; ImVector<unsigned int>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@I@@QEAAXH@Z		; ImVector<unsigned int>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	r8d, 4
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@I@@QEAAXAEBI@Z ENDP		; ImVector<unsigned int>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@I@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@I@@QEAAXH@Z PROC			; ImVector<unsigned int>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 2
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 2
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@I@@QEAAXH@Z ENDP			; ImVector<unsigned int>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@I@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@I@@QEBAHH@Z PROC		; ImVector<unsigned int>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@I@@QEBAHH@Z ENDP		; ImVector<unsigned int>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@I@@QEAAAEAIXZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@I@@QEAAAEAIXZ PROC			; ImVector<unsigned int>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	ret	0
?back@?$ImVector@I@@QEAAAEAIXZ ENDP			; ImVector<unsigned int>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiGroupData@@@@QEAAAEAUImGuiGroupData@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImGuiGroupData@@@@QEAAAEAUImGuiGroupData@@XZ PROC ; ImVector<ImGuiGroupData>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImGuiGroupData@@@@QEAAAEAUImGuiGroupData@@XZ ENDP ; ImVector<ImGuiGroupData>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImGuiGroupData@@@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?empty@?$ImVector@UImGuiGroupData@@@@QEBA_NXZ PROC	; ImVector<ImGuiGroupData>::empty, COMDAT

; 1224 : 	inline bool         empty() const { return Size == 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv66[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv66[rsp]
	add	rsp, 24
	ret	0
?empty@?$ImVector@UImGuiGroupData@@@@QEBA_NXZ ENDP	; ImVector<ImGuiGroupData>::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXXZ PROC	; ImVector<ImGuiTabBar *>::pop_back, COMDAT

; 1249 : 	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	ret	0
?pop_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXXZ ENDP	; ImVector<ImGuiTabBar *>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXAEBQEAUImGuiTabBar@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXAEBQEAUImGuiTabBar@@@Z PROC ; ImVector<ImGuiTabBar *>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@PEAUImGuiTabBar@@@@QEBAHH@Z ; ImVector<ImGuiTabBar *>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@PEAUImGuiTabBar@@@@QEAAXH@Z ; ImVector<ImGuiTabBar *>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	r8d, 8
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXAEBQEAUImGuiTabBar@@@Z ENDP ; ImVector<ImGuiTabBar *>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PEAUImGuiTabBar@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@PEAUImGuiTabBar@@@@QEAAXH@Z PROC	; ImVector<ImGuiTabBar *>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 3
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 3
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@PEAUImGuiTabBar@@@@QEAAXH@Z ENDP	; ImVector<ImGuiTabBar *>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PEAUImGuiTabBar@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@PEAUImGuiTabBar@@@@QEBAHH@Z PROC ; ImVector<ImGuiTabBar *>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@PEAUImGuiTabBar@@@@QEBAHH@Z ENDP ; ImVector<ImGuiTabBar *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@PEAUImGuiTabBar@@@@QEAAAEAPEAUImGuiTabBar@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@PEAUImGuiTabBar@@@@QEAAAEAPEAUImGuiTabBar@@XZ PROC ; ImVector<ImGuiTabBar *>::back, COMDAT

; 1238 : 	inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	ret	0
?back@?$ImVector@PEAUImGuiTabBar@@@@QEAAAEAPEAUImGuiTabBar@@XZ ENDP ; ImVector<ImGuiTabBar *>::back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z PROC ; ImVector<ImGuiTabBarSortItem>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 3
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 3
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z ENDP ; ImVector<ImGuiTabBarSortItem>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z PROC ; ImVector<ImGuiTabBarSortItem>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImGuiTabBarSortItem@@@@QEBAHH@Z ; ImVector<ImGuiTabBarSortItem>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z ; ImVector<ImGuiTabBarSortItem>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImGuiTabBarSortItem@@@@QEAAXH@Z ENDP ; ImVector<ImGuiTabBarSortItem>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiTabBarSortItem@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImGuiTabBarSortItem@@@@QEBAHH@Z PROC ; ImVector<ImGuiTabBarSortItem>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImGuiTabBarSortItem@@@@QEBAHH@Z ENDP ; ImVector<ImGuiTabBarSortItem>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z PROC ; ImVector<ImGuiTabBarSortItem>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	ret	0
??A?$ImVector@UImGuiTabBarSortItem@@@@QEAAAEAUImGuiTabBarSortItem@@H@Z ENDP ; ImVector<ImGuiTabBarSortItem>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ
_TEXT	SEGMENT
idx$ = 32
$T1 = 36
$T2 = 40
tv139 = 48
tv75 = 56
tv86 = 64
tv95 = 72
$T3 = 80
$T4 = 88
tv144 = 96
$T5 = 104
this$ = 128
?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ PROC ; ImPool<ImGuiTabBar>::Add, COMDAT

; 279  :     T* Add() { int idx = FreeIdx; if (idx == Data.Size) { Data.resize(Data.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Data[idx]; } IM_PLACEMENT_NEW(&Data[idx]) T(); return &Data[idx]; }

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR idx$[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR idx$[rsp], eax
	jne	SHORT $LN2@Add
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv75[rsp]
	call	?resize@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z ; ImVector<ImGuiTabBar>::resize
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+32]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+32], eax
	jmp	SHORT $LN3@Add
$LN2@Add:
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv86[rsp], rax
	mov	edx, DWORD PTR idx$[rsp]
	mov	rcx, QWORD PTR tv86[rsp]
	call	??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx+32], eax
$LN3@Add:
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv95[rsp], rax
	mov	edx, DWORD PTR idx$[rsp]
	mov	rcx, QWORD PTR tv95[rsp]
	call	??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
	mov	QWORD PTR $T3[rsp], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	r8, QWORD PTR $T3[rsp]
	mov	rax, QWORD PTR $T4[rsp]
	movzx	edx, BYTE PTR [rax]
	mov	ecx, 128				; 00000080H
	call	??2@YAPEAX_KUImNewDummy@@PEAX@Z		; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN5@Add
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0ImGuiTabBar@@QEAA@XZ			; ImGuiTabBar::ImGuiTabBar
	mov	QWORD PTR tv139[rsp], rax
	jmp	SHORT $LN6@Add
$LN5@Add:
	mov	QWORD PTR tv139[rsp], 0
$LN6@Add:
	mov	rax, QWORD PTR tv139[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv144[rsp], rax
	mov	edx, DWORD PTR idx$[rsp]
	mov	rcx, QWORD PTR tv144[rsp]
	call	??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
	add	rsp, 120				; 00000078H
	ret	0
?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ ENDP ; ImPool<ImGuiTabBar>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
idx$ = 32
$T1 = 36
$T2 = 40
tv139 = 48
tv75 = 56
tv86 = 64
tv95 = 72
$T3 = 80
$T4 = 88
tv144 = 96
$T5 = 104
this$ = 128
?dtor$0@?0??Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ@4HA PROC ; `ImPool<ImGuiTabBar>::Add'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	r8, QWORD PTR $T3[rbp]
	mov	rdx, QWORD PTR $T4[rbp]
	movzx	edx, BYTE PTR [rdx]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAXUImNewDummy@@0@Z		; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ@4HA ENDP ; `ImPool<ImGuiTabBar>::Add'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@I@Z
_TEXT	SEGMENT
p_idx$ = 32
tv70 = 40
tv77 = 48
this$ = 80
key$ = 88
?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@I@Z PROC ; ImPool<ImGuiTabBar>::GetOrAddByKey, COMDAT

; 277  :     T* GetOrAddByKey(ImGuiID key) { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Data[*p_idx]; *p_idx = FreeIdx; return Add(); }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv70[rsp], rax
	mov	r8d, -1
	mov	edx, DWORD PTR key$[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z	; ImGuiStorage::GetIntRef
	mov	QWORD PTR p_idx$[rsp], rax
	mov	rax, QWORD PTR p_idx$[rsp]
	cmp	DWORD PTR [rax], -1
	je	SHORT $LN2@GetOrAddBy
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	rax, QWORD PTR p_idx$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
	jmp	SHORT $LN1@GetOrAddBy
$LN2@GetOrAddBy:
	mov	rax, QWORD PTR p_idx$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+32]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR this$[rsp]
	call	?Add@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@XZ ; ImPool<ImGuiTabBar>::Add
$LN1@GetOrAddBy:
	add	rsp, 72					; 00000048H
	ret	0
?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@I@Z ENDP ; ImPool<ImGuiTabBar>::GetOrAddByKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z PROC	; ImVector<ImGuiTabBar>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	imul	rax, rax, 128				; 00000080H
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	imul	rax, rax, 128				; 00000080H
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z ENDP	; ImVector<ImGuiTabBar>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z PROC	; ImVector<ImGuiTabBar>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QEBAHH@Z ; ImVector<ImGuiTabBar>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z ; ImVector<ImGuiTabBar>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@UImGuiTabBar@@@@QEAAXH@Z ENDP	; ImVector<ImGuiTabBar>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QEBAHH@Z PROC ; ImVector<ImGuiTabBar>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QEBAHH@Z ENDP ; ImVector<ImGuiTabBar>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z PROC ; ImVector<ImGuiTabBar>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 128				; 00000080H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImGuiTabBar@@@@QEAAAEAUImGuiTabBar@@H@Z ENDP ; ImVector<ImGuiTabBar>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z PROC ; ImVector<ImGuiPopupRef>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ENDP ; ImVector<ImGuiPopupRef>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMin@H@@YAHHH@Z PROC				; ImMin<int>

; 227  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	mov	eax, DWORD PTR rhs$[rsp]
	cmp	DWORD PTR lhs$[rsp], eax
	jge	SHORT $LN3@ImMin
	mov	eax, DWORD PTR lhs$[rsp]
	mov	DWORD PTR tv65[rsp], eax
	jmp	SHORT $LN4@ImMin
$LN3@ImMin:
	mov	eax, DWORD PTR rhs$[rsp]
	mov	DWORD PTR tv65[rsp], eax
$LN4@ImMin:
	mov	eax, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMin@H@@YAHHH@Z ENDP				; ImMin<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
this$ = 48
key$ = 56
?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z PROC	; ImGuiInputTextState::OnKeyPressed

; 3449 : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3450 : 	stb_textedit_key(this, &StbState, key);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 80					; 00000050H
	mov	r8d, DWORD PTR key$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?stb_textedit_key@ImGuiStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImGuiStb::stb_textedit_key

; 3451 : 	CursorFollow = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+3700], 1

; 3452 : 	CursorAnimReset();

	mov	rcx, QWORD PTR this$[rsp]
	call	?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ ; ImGuiInputTextState::CursorAnimReset
	npad	1

; 3453 : }

	add	rsp, 40					; 00000028H
	ret	0
?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ENDP	; ImGuiInputTextState::OnKeyPressed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?SelectAll@ImGuiInputTextState@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?SelectAll@ImGuiInputTextState@@QEAAXXZ PROC		; ImGuiInputTextState::SelectAll, COMDAT

; 585  :     void                SelectAll() { StbState.select_start = 0; StbState.cursor = StbState.select_end = CurLenW; StbState.has_preferred_x = 0; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+84], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+32]
	mov	DWORD PTR [rax+88], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+88]
	mov	DWORD PTR [rax+80], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+95], 0
	ret	0
?SelectAll@ImGuiInputTextState@@QEAAXXZ ENDP		; ImGuiInputTextState::SelectAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?ClearSelection@ImGuiInputTextState@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?ClearSelection@ImGuiInputTextState@@QEAAXXZ PROC	; ImGuiInputTextState::ClearSelection, COMDAT

; 584  :     void                ClearSelection() { StbState.select_start = StbState.select_end = StbState.cursor; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+80]
	mov	DWORD PTR [rax+88], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+88]
	mov	DWORD PTR [rax+84], ecx
	ret	0
?ClearSelection@ImGuiInputTextState@@QEAAXXZ ENDP	; ImGuiInputTextState::ClearSelection
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?HasSelection@ImGuiInputTextState@@QEBA_NXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?HasSelection@ImGuiInputTextState@@QEBA_NXZ PROC	; ImGuiInputTextState::HasSelection, COMDAT

; 583  :     bool                HasSelection() const { return StbState.select_start != StbState.select_end; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+88]
	cmp	DWORD PTR [rax+84], ecx
	je	SHORT $LN3@HasSelecti
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@HasSelecti
$LN3@HasSelecti:
	mov	DWORD PTR tv69[rsp], 0
$LN4@HasSelecti:
	movzx	eax, BYTE PTR tv69[rsp]
	add	rsp, 24
	ret	0
?HasSelection@ImGuiInputTextState@@QEBA_NXZ ENDP	; ImGuiInputTextState::HasSelection
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?CursorClamp@ImGuiInputTextState@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?CursorClamp@ImGuiInputTextState@@QEAAXXZ PROC		; ImGuiInputTextState::CursorClamp, COMDAT

; 582  :     void                CursorClamp() { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR [rax+32]
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rax+80]
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+80], eax
	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR [rax+32]
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rax+84]
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+84], eax
	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR [rax+32]
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rax+88]
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+88], eax
	add	rsp, 40					; 00000028H
	ret	0
?CursorClamp@ImGuiInputTextState@@QEAAXXZ ENDP		; ImGuiInputTextState::CursorClamp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ PROC	; ImGuiInputTextState::CursorAnimReset, COMDAT

; 581  :     void                CursorAnimReset() { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR [rax+24], xmm0
	ret	0
?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ ENDP	; ImGuiInputTextState::CursorAnimReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
this$ = 48
avail_w$ = 56
?CalcExtraSpace@ImGuiMenuColumns@@QEAAMM@Z PROC		; ImGuiMenuColumns::CalcExtraSpace

; 6070 : {

$LN3:
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 6071 : 	return ImMax(0.0f, avail_w - Width);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR avail_w$[rsp]
	subss	xmm0, DWORD PTR [rax]
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>

; 6072 : }

	add	rsp, 40					; 00000028H
	ret	0
?CalcExtraSpace@ImGuiMenuColumns@@QEAAMM@Z ENDP		; ImGuiMenuColumns::CalcExtraSpace
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
i$1 = 32
tv138 = 36
this$ = 64
w0$ = 72
w1$ = 80
w2$ = 88
?DeclColumns@ImGuiMenuColumns@@QEAAMMMM@Z PROC		; ImGuiMenuColumns::DeclColumns

; 6059 : {

$LN8:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6060 : 	NextWidth = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0

; 6061 : 	NextWidths[0] = ImMax(NextWidths[0], w0);

	mov	eax, 4
	imul	rax, rax, 0
	movss	xmm1, DWORD PTR w0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+32]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movss	DWORD PTR [rcx+rax+32], xmm0

; 6062 : 	NextWidths[1] = ImMax(NextWidths[1], w1);

	mov	eax, 4
	imul	rax, rax, 1
	movss	xmm1, DWORD PTR w1$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+32]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	movss	DWORD PTR [rcx+rax+32], xmm0

; 6063 : 	NextWidths[2] = ImMax(NextWidths[2], w2);

	mov	eax, 4
	imul	rax, rax, 2
	movss	xmm1, DWORD PTR w2$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+32]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	movss	DWORD PTR [rcx+rax+32], xmm0

; 6064 : 	for (int i = 0; i < 3; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@DeclColumn
$LN2@DeclColumn:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@DeclColumn:
	cmp	DWORD PTR i$1[rsp], 3
	jge	SHORT $LN3@DeclColumn

; 6065 : 		NextWidth += NextWidths[i] + ((i > 0 && NextWidths[i] > 0.0f) ? Spacing : 0.0f);

	cmp	DWORD PTR i$1[rsp], 0
	jle	SHORT $LN6@DeclColumn
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+32]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@DeclColumn
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	movss	DWORD PTR tv138[rsp], xmm0
	jmp	SHORT $LN7@DeclColumn
$LN6@DeclColumn:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv138[rsp], xmm0
$LN7@DeclColumn:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+32]
	addss	xmm0, DWORD PTR tv138[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	jmp	SHORT $LN2@DeclColumn
$LN3@DeclColumn:

; 6066 : 	return ImMax(Width, NextWidth);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>

; 6067 : }

	add	rsp, 56					; 00000038H
	ret	0
?DeclColumns@ImGuiMenuColumns@@QEAAMMMM@Z ENDP		; ImGuiMenuColumns::DeclColumns
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
i$1 = 32
this$ = 64
count$ = 72
spacing$ = 80
clear$ = 88
?Update@ImGuiMenuColumns@@QEAAXHM_N@Z PROC		; ImGuiMenuColumns::Update

; 6042 : {

$LN8:
	mov	BYTE PTR [rsp+32], r9b
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6043 : 	IM_ASSERT(Count <= IM_ARRAYSIZE(Pos));
; 6044 : 	Count = count;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 6045 : 	Width = NextWidth = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0

; 6046 : 	Spacing = spacing;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR spacing$[rsp]
	movss	DWORD PTR [rax+12], xmm0

; 6047 : 	if (clear) memset(NextWidths, 0, sizeof(NextWidths));

	movzx	eax, BYTE PTR clear$[rsp]
	test	eax, eax
	je	SHORT $LN5@Update
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	r8d, 16
	xor	edx, edx
	mov	rcx, rax
	call	memset
	npad	1
$LN5@Update:

; 6048 : 	for (int i = 0; i < Count; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@Update
$LN2@Update:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@Update:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN3@Update

; 6049 : 	{
; 6050 : 		if (i > 0 && NextWidths[i] > 0.0f)

	cmp	DWORD PTR i$1[rsp], 0
	jle	SHORT $LN6@Update
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4+32]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@Update

; 6051 : 			Width += Spacing;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx+12]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0
$LN6@Update:

; 6052 : 		Pos[i] = (float)(int)Width;

	mov	rax, QWORD PTR this$[rsp]
	cvttss2si eax, DWORD PTR [rax]
	cvtsi2ss xmm0, eax
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	DWORD PTR [rcx+rax*4+16], xmm0

; 6053 : 		Width += NextWidths[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rcx]
	addss	xmm0, DWORD PTR [rdx+rax*4+32]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0

; 6054 : 		NextWidths[i] = 0.0f;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rcx+rax*4+32], xmm0

; 6055 : 	}

	jmp	$LN2@Update
$LN3@Update:

; 6056 : }

	add	rsp, 56					; 00000038H
	ret	0
?Update@ImGuiMenuColumns@@QEAAXHM_N@Z ENDP		; ImGuiMenuColumns::Update
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
this$ = 48
??0ImGuiMenuColumns@@QEAA@XZ PROC			; ImGuiMenuColumns::ImGuiMenuColumns

; 6034 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 6035 : 	Count = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], 0

; 6036 : 	Spacing = Width = NextWidth = 0.0f;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+12], xmm0

; 6037 : 	memset(Pos, 0, sizeof(Pos));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	r8d, 16
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 6038 : 	memset(NextWidths, 0, sizeof(NextWidths));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	r8d, 16
	xor	edx, edx
	mov	rcx, rax
	call	memset
	npad	1

; 6039 : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiMenuColumns@@QEAA@XZ ENDP			; ImGuiMenuColumns::ImGuiMenuColumns
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?ClipWith@ImRect@@QEAAXAEBU1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
r$ = 72
?ClipWith@ImRect@@QEAAXAEBU1@@Z PROC			; ImRect::ClipWith, COMDAT

; 508  :     void        ClipWith(const ImRect& r) { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR r$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 8
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	?ImMin@@YA?AUImVec2@@AEBU1@0@Z		; ImMin
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	add	rsp, 56					; 00000038H
	ret	0
?ClipWith@ImRect@@QEAAXAEBU1@@Z ENDP			; ImRect::ClipWith
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Translate@ImRect@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
this$ = 8
d$ = 16
?Translate@ImRect@@QEAAXAEBUImVec2@@@Z PROC		; ImRect::Translate, COMDAT

; 505  :     void        Translate(const ImVec2& d) { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	ret	0
?Translate@ImRect@@QEAAXAEBUImVec2@@@Z ENDP		; ImRect::Translate
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Expand@ImRect@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
this$ = 8
amount$ = 16
?Expand@ImRect@@QEAAXAEBUImVec2@@@Z PROC		; ImRect::Expand, COMDAT

; 504  :     void        Expand(const ImVec2& amount) { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR amount$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR amount$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR amount$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR amount$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	ret	0
?Expand@ImRect@@QEAAXAEBUImVec2@@@Z ENDP		; ImRect::Expand
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Expand@ImRect@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
amount$ = 16
?Expand@ImRect@@QEAAXM@Z PROC				; ImRect::Expand, COMDAT

; 503  :     void        Expand(const float amount) { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR amount$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR amount$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	addss	xmm0, DWORD PTR amount$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	addss	xmm0, DWORD PTR amount$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	ret	0
?Expand@ImRect@@QEAAXM@Z ENDP				; ImRect::Expand
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Overlaps@ImRect@@QEBA_NAEBU1@@Z
_TEXT	SEGMENT
tv84 = 0
this$ = 32
r$ = 40
?Overlaps@ImRect@@QEBA_NAEBU1@@Z PROC			; ImRect::Overlaps, COMDAT

; 500  :     bool        Overlaps(const ImRect& r) const { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN3@Overlaps
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN3@Overlaps
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN3@Overlaps
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN3@Overlaps
	mov	DWORD PTR tv84[rsp], 1
	jmp	SHORT $LN4@Overlaps
$LN3@Overlaps:
	mov	DWORD PTR tv84[rsp], 0
$LN4@Overlaps:
	movzx	eax, BYTE PTR tv84[rsp]
	add	rsp, 24
	ret	0
?Overlaps@ImRect@@QEBA_NAEBU1@@Z ENDP			; ImRect::Overlaps
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Contains@ImRect@@QEBA_NAEBU1@@Z
_TEXT	SEGMENT
tv84 = 0
this$ = 32
r$ = 40
?Contains@ImRect@@QEBA_NAEBU1@@Z PROC			; ImRect::Contains, COMDAT

; 499  :     bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jb	SHORT $LN3@Contains
	mov	rax, QWORD PTR r$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jb	SHORT $LN3@Contains
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	comiss	xmm0, DWORD PTR [rcx+8]
	jb	SHORT $LN3@Contains
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR [rcx+12]
	jb	SHORT $LN3@Contains
	mov	DWORD PTR tv84[rsp], 1
	jmp	SHORT $LN4@Contains
$LN3@Contains:
	mov	DWORD PTR tv84[rsp], 0
$LN4@Contains:
	movzx	eax, BYTE PTR tv84[rsp]
	add	rsp, 24
	ret	0
?Contains@ImRect@@QEBA_NAEBU1@@Z ENDP			; ImRect::Contains
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z
_TEXT	SEGMENT
tv80 = 0
this$ = 32
p$ = 40
?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z PROC		; ImRect::Contains, COMDAT

; 498  :     bool        Contains(const ImVec2& p) const { return p.x >= Min.x && p.y >= Min.y && p.x < Max.x && p.y < Max.y; }

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jb	SHORT $LN3@Contains
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jb	SHORT $LN3@Contains
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN3@Contains
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN3@Contains
	mov	DWORD PTR tv80[rsp], 1
	jmp	SHORT $LN4@Contains
$LN3@Contains:
	mov	DWORD PTR tv80[rsp], 0
$LN4@Contains:
	movzx	eax, BYTE PTR tv80[rsp]
	add	rsp, 24
	ret	0
?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z ENDP		; ImRect::Contains
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetBR@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?GetBR@ImRect@@QEBA?AUImVec2@@XZ PROC			; ImRect::GetBR, COMDAT

; 497  :     ImVec2      GetBR() const { return Max; }                   // Bottom-right

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	ret	0
?GetBR@ImRect@@QEBA?AUImVec2@@XZ ENDP			; ImRect::GetBR
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetBL@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?GetBL@ImRect@@QEBA?AUImVec2@@XZ PROC			; ImRect::GetBL, COMDAT

; 496  :     ImVec2      GetBL() const { return ImVec2(Min.x, Max.y); }  // Bottom-left

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax+12]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?GetBL@ImRect@@QEBA?AUImVec2@@XZ ENDP			; ImRect::GetBL
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetTR@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?GetTR@ImRect@@QEBA?AUImVec2@@XZ PROC			; ImRect::GetTR, COMDAT

; 495  :     ImVec2      GetTR() const { return ImVec2(Max.x, Min.y); }  // Top-right

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?GetTR@ImRect@@QEBA?AUImVec2@@XZ ENDP			; ImRect::GetTR
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetTL@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?GetTL@ImRect@@QEBA?AUImVec2@@XZ PROC			; ImRect::GetTL, COMDAT

; 494  :     ImVec2      GetTL() const { return Min; }                   // Top-left

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	ret	0
?GetTL@ImRect@@QEBA?AUImVec2@@XZ ENDP			; ImRect::GetTL
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetHeight@ImRect@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?GetHeight@ImRect@@QEBAMXZ PROC				; ImRect::GetHeight, COMDAT

; 493  :     float       GetHeight() const { return Max.y - Min.y; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR [rcx+4]
	ret	0
?GetHeight@ImRect@@QEBAMXZ ENDP				; ImRect::GetHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetWidth@ImRect@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?GetWidth@ImRect@@QEBAMXZ PROC				; ImRect::GetWidth, COMDAT

; 492  :     float       GetWidth() const { return Max.x - Min.x; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR [rcx]
	ret	0
?GetWidth@ImRect@@QEBAMXZ ENDP				; ImRect::GetWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetSize@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?GetSize@ImRect@@QEBA?AUImVec2@@XZ PROC			; ImRect::GetSize, COMDAT

; 491  :     ImVec2      GetSize() const { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	subss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?GetSize@ImRect@@QEBA?AUImVec2@@XZ ENDP			; ImRect::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ?GetCenter@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?GetCenter@ImRect@@QEBA?AUImVec2@@XZ PROC		; ImRect::GetCenter, COMDAT

; 490  :     ImVec2      GetCenter() const { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+12]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx+8]
	mulss	xmm1, DWORD PTR __real@3f000000
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?GetCenter@ImRect@@QEBA?AUImVec2@@XZ ENDP		; ImRect::GetCenter
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@MMMM@Z
_TEXT	SEGMENT
tv70 = 32
tv76 = 40
this$ = 64
x1$ = 72
y1$ = 80
x2$ = 88
y2$ = 96
??0ImRect@@QEAA@MMMM@Z PROC				; ImRect::ImRect, COMDAT

; 488  :     ImRect(float x1, float y1, float x2, float y2) : Min(x1, y1), Max(x2, y2) {}

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	movss	xmm2, DWORD PTR y1$[rsp]
	movss	xmm1, DWORD PTR x1$[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv76[rsp], rax
	movss	xmm2, DWORD PTR y2$[rsp]
	movss	xmm1, DWORD PTR x2$[rsp]
	mov	rcx, QWORD PTR tv76[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0ImRect@@QEAA@MMMM@Z ENDP				; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@AEBUImVec4@@@Z
_TEXT	SEGMENT
tv72 = 32
tv80 = 40
this$ = 64
v$ = 72
??0ImRect@@QEAA@AEBUImVec4@@@Z PROC			; ImRect::ImRect, COMDAT

; 487  :     ImRect(const ImVec4& v) : Min(v.x, v.y), Max(v.z, v.w) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mov	rcx, QWORD PTR tv72[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm2, DWORD PTR [rax+12]
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0ImRect@@QEAA@AEBUImVec4@@@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@AEBUImVec2@@0@Z
_TEXT	SEGMENT
this$ = 8
min$ = 16
max$ = 24
??0ImRect@@QEAA@AEBUImVec2@@0@Z PROC			; ImRect::ImRect, COMDAT

; 486  :     ImRect(const ImVec2& min, const ImVec2& max) : Min(min), Max(max) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR min$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR max$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImRect@@QEAA@AEBUImVec2@@0@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@XZ
_TEXT	SEGMENT
tv70 = 32
tv76 = 40
this$ = 64
??0ImRect@@QEAA@XZ PROC					; ImRect::ImRect, COMDAT

; 485  :     ImRect() : Min(FLT_MAX, FLT_MAX), Max(-FLT_MAX, -FLT_MAX) {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	movss	xmm2, DWORD PTR __real@7f7fffff
	movss	xmm1, DWORD PTR __real@7f7fffff
	mov	rcx, QWORD PTR tv70[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv76[rsp], rax
	movss	xmm2, DWORD PTR __real@ff7fffff
	movss	xmm1, DWORD PTR __real@ff7fffff
	mov	rcx, QWORD PTR tv76[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0ImRect@@QEAA@XZ ENDP					; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMax@M@@YAMMM@Z PROC				; ImMax<float>

; 228  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	movss	xmm0, DWORD PTR lhs$[rsp]
	comiss	xmm0, DWORD PTR rhs$[rsp]
	jb	SHORT $LN3@ImMax
	movss	xmm0, DWORD PTR lhs$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN4@ImMax
$LN3@ImMax:
	movss	xmm0, DWORD PTR rhs$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
$LN4@ImMax:
	movss	xmm0, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMax@M@@YAMMM@Z ENDP				; ImMax<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 0
lhs$ = 32
rhs$ = 40
??$ImMin@M@@YAMMM@Z PROC				; ImMin<float>

; 227  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	movss	xmm0, DWORD PTR rhs$[rsp]
	comiss	xmm0, DWORD PTR lhs$[rsp]
	jbe	SHORT $LN3@ImMin
	movss	xmm0, DWORD PTR lhs$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN4@ImMin
$LN3@ImMin:
	movss	xmm0, DWORD PTR rhs$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
$LN4@ImMin:
	movss	xmm0, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$ImMin@M@@YAMMM@Z ENDP				; ImMin<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
current$ = 48
target$ = 56
speed$ = 64
?ImLinearSweep@@YAMMMM@Z PROC				; ImLinearSweep

; 247  : static inline float  ImLinearSweep(float current, float target, float speed) { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR target$[rsp]
	comiss	xmm0, DWORD PTR current$[rsp]
	jbe	SHORT $LN2@ImLinearSw
	movss	xmm0, DWORD PTR current$[rsp]
	addss	xmm0, DWORD PTR speed$[rsp]
	movss	xmm1, DWORD PTR target$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	jmp	SHORT $LN1@ImLinearSw
$LN2@ImLinearSw:
	movss	xmm0, DWORD PTR current$[rsp]
	comiss	xmm0, DWORD PTR target$[rsp]
	jbe	SHORT $LN3@ImLinearSw
	movss	xmm0, DWORD PTR current$[rsp]
	subss	xmm0, DWORD PTR speed$[rsp]
	movss	xmm1, DWORD PTR target$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	jmp	SHORT $LN1@ImLinearSw
$LN3@ImLinearSw:
	movss	xmm0, DWORD PTR current$[rsp]
$LN1@ImLinearSw:
	add	rsp, 40					; 00000028H
	ret	0
?ImLinearSweep@@YAMMMM@Z ENDP				; ImLinearSweep
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
v$ = 56
cos_a$ = 64
sin_a$ = 72
?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z PROC			; ImRotate

; 246  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a) { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR sin_a$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR cos_a$[rsp]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR cos_a$[rsp]
	mov	rax, QWORD PTR v$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mulss	xmm2, DWORD PTR sin_a$[rsp]
	subss	xmm1, xmm2
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z ENDP			; ImRotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
f$ = 8
?ImFloor@@YAMM@Z PROC					; ImFloor

; 243  : static inline float  ImFloor(float f) { return (float)(int)f; }

	movss	DWORD PTR [rsp+8], xmm0
	cvttss2si eax, DWORD PTR f$[rsp]
	cvtsi2ss xmm0, eax
	ret	0
?ImFloor@@YAMM@Z ENDP					; ImFloor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
?ImLengthSqr@@YAMAEBUImVec2@@@Z PROC			; ImLengthSqr

; 240  : static inline float  ImLengthSqr(const ImVec2& lhs) { return lhs.x * lhs.x + lhs.y * lhs.y; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR lhs$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	ret	0
?ImLengthSqr@@YAMAEBUImVec2@@@Z ENDP			; ImLengthSqr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv66 = 0
tv67 = 4
f$ = 32
?ImSaturate@@YAMM@Z PROC				; ImSaturate

; 239  : static inline float  ImSaturate(float f) { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR f$[rsp]
	jbe	SHORT $LN5@ImSaturate
	xorps	xmm0, xmm0
	movss	DWORD PTR tv67[rsp], xmm0
	jmp	SHORT $LN6@ImSaturate
$LN5@ImSaturate:
	movss	xmm0, DWORD PTR f$[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN3@ImSaturate
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv66[rsp], xmm0
	jmp	SHORT $LN4@ImSaturate
$LN3@ImSaturate:
	movss	xmm0, DWORD PTR f$[rsp]
	movss	DWORD PTR tv66[rsp], xmm0
$LN4@ImSaturate:
	movss	xmm0, DWORD PTR tv66[rsp]
	movss	DWORD PTR tv67[rsp], xmm0
$LN6@ImSaturate:
	movss	xmm0, DWORD PTR tv67[rsp]
	add	rsp, 24
	ret	0
?ImSaturate@@YAMM@Z ENDP				; ImSaturate
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
a$ = 56
b$ = 64
t$ = 72
?ImLerp@@YA?AUImVec2@@AEBU1@00@Z PROC			; ImLerp

; 237  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t) { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR t$[rsp]
	mulss	xmm0, DWORD PTR [rax+4]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR [rcx]
	mov	rax, QWORD PTR t$[rsp]
	mulss	xmm1, DWORD PTR [rax]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?ImLerp@@YA?AUImVec2@@AEBU1@00@Z ENDP			; ImLerp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
a$ = 56
b$ = 64
t$ = 72
?ImLerp@@YA?AUImVec2@@AEBU1@0M@Z PROC			; ImLerp

; 236  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t) { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }

	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mulss	xmm0, DWORD PTR t$[rsp]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR [rcx]
	mulss	xmm1, DWORD PTR t$[rsp]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
?ImLerp@@YA?AUImVec2@@AEBU1@0M@Z ENDP			; ImLerp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv71 = 32
tv78 = 36
__$ReturnUdt$ = 64
lhs$ = 72
rhs$ = 80
?ImMax@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMax

; 234  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jb	SHORT $LN3@ImMax
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv71[rsp], xmm0
	jmp	SHORT $LN4@ImMax
$LN3@ImMax:
	mov	rax, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv71[rsp], xmm0
$LN4@ImMax:
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jb	SHORT $LN5@ImMax
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN6@ImMax
$LN5@ImMax:
	mov	rax, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
$LN6@ImMax:
	movss	xmm2, DWORD PTR tv71[rsp]
	movss	xmm1, DWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?ImMax@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMax
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv71 = 32
tv78 = 36
__$ReturnUdt$ = 64
lhs$ = 72
rhs$ = 80
?ImMin@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMin

; 233  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rcx, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jbe	SHORT $LN3@ImMin
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv71[rsp], xmm0
	jmp	SHORT $LN4@ImMin
$LN3@ImMin:
	mov	rax, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv71[rsp], xmm0
$LN4@ImMin:
	mov	rax, QWORD PTR rhs$[rsp]
	mov	rcx, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN5@ImMin
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN6@ImMin
$LN5@ImMin:
	mov	rax, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
$LN6@ImMin:
	movss	xmm2, DWORD PTR tv71[rsp]
	movss	xmm1, DWORD PTR tv78[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?ImMin@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
s$ = 48
?ImAtof@@YANPEBD@Z PROC					; ImAtof

; 222  : static inline double ImAtof(const char* s) { return atof(s); }

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR s$[rsp]
	call	atof
	add	rsp, 40					; 00000028H
	ret	0
?ImAtof@@YANPEBD@Z ENDP					; ImAtof
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
y$ = 48
x$ = 56
?ImAtan2@@YAMMM@Z PROC					; ImAtan2

; 221  : static inline float  ImAtan2(float y, float x) { return atan2f(y, x); }

	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm1, DWORD PTR x$[rsp]
	movss	xmm0, DWORD PTR y$[rsp]
	call	atan2f
	add	rsp, 40					; 00000028H
	ret	0
?ImAtan2@@YAMMM@Z ENDP					; ImAtan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
?ImSin@@YAMM@Z PROC					; ImSin

; 219  : static inline float  ImSin(float x) { return sinf(x); }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR x$[rsp]
	call	sinf
	add	rsp, 40					; 00000028H
	ret	0
?ImSin@@YAMM@Z ENDP					; ImSin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
?ImCos@@YAMM@Z PROC					; ImCos

; 218  : static inline float  ImCos(float x) { return cosf(x); }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR x$[rsp]
	call	cosf
	add	rsp, 40					; 00000028H
	ret	0
?ImCos@@YAMM@Z ENDP					; ImCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
y$ = 56
?ImFmod@@YAMMM@Z PROC					; ImFmod

; 216  : static inline float  ImFmod(float x, float y) { return fmodf(x, y); }

	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm1, DWORD PTR y$[rsp]
	movss	xmm0, DWORD PTR x$[rsp]
	call	fmodf
	add	rsp, 40					; 00000028H
	ret	0
?ImFmod@@YAMMM@Z ENDP					; ImFmod
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
y$ = 56
?ImPow@@YANNN@Z PROC					; ImPow

; 215  : static inline double ImPow(double x, double y) { return pow(x, y); }

	movsd	QWORD PTR [rsp+16], xmm1
	movsd	QWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movsd	xmm1, QWORD PTR y$[rsp]
	movsd	xmm0, QWORD PTR x$[rsp]
	call	pow
	add	rsp, 40					; 00000028H
	ret	0
?ImPow@@YANNN@Z ENDP					; ImPow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
y$ = 56
?ImPow@@YAMMM@Z PROC					; ImPow

; 214  : static inline float  ImPow(float x, float y) { return powf(x, y); }

	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm1, DWORD PTR y$[rsp]
	movss	xmm0, DWORD PTR x$[rsp]
	call	powf
	add	rsp, 40					; 00000028H
	ret	0
?ImPow@@YAMMM@Z ENDP					; ImPow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 48
?ImFabs@@YAMM@Z PROC					; ImFabs

; 212  : static inline float  ImFabs(float x) { return fabsf(x); }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR x$[rsp]
	call	fabsf
	add	rsp, 40					; 00000028H
	ret	0
?ImFabs@@YAMM@Z ENDP					; ImFabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z PROC			; operator-=

; 201  : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs) { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR lhs$[rsp]
	ret	0
??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z ENDP			; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z PROC			; operator+=

; 200  : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs) { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR lhs$[rsp]
	ret	0
??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z ENDP			; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??G@YA?AUImVec2@@AEBU0@0@Z PROC				; operator-

; 197  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??G@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??H@YA?AUImVec2@@AEBU0@0@Z PROC				; operator+

; 196  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR lhs$[rsp]
	mov	rcx, QWORD PTR rhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??H@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 48
lhs$ = 56
rhs$ = 64
??D@YA?AUImVec2@@AEBU0@M@Z PROC				; operator*

; 194  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR rhs$[rsp]
	mov	rax, QWORD PTR lhs$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR rhs$[rsp]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??D@YA?AUImVec2@@AEBU0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
precision$ = 32
tv94 = 36
fmt$ = 64
default_precision$ = 72
?ImParseFormatPrecision@@YAHPEBDH@Z PROC		; ImParseFormatPrecision

; 2994 : {

$LN15:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2995 : 	fmt = ImParseFormatFindStart(fmt);

	mov	rcx, QWORD PTR fmt$[rsp]
	call	?ImParseFormatFindStart@@YAPEBDPEBD@Z	; ImParseFormatFindStart
	mov	QWORD PTR fmt$[rsp], rax

; 2996 : 	if (fmt[0] != '%')

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN4@ImParseFor

; 2997 : 		return default_precision;

	mov	eax, DWORD PTR default_precision$[rsp]
	jmp	$LN1@ImParseFor
$LN4@ImParseFor:

; 2998 : 	fmt++;

	mov	rax, QWORD PTR fmt$[rsp]
	inc	rax
	mov	QWORD PTR fmt$[rsp], rax
$LN2@ImParseFor:

; 2999 : 	while (*fmt >= '0' && *fmt <= '9')

	mov	rax, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@ImParseFor
	mov	rax, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN3@ImParseFor

; 3000 : 		fmt++;

	mov	rax, QWORD PTR fmt$[rsp]
	inc	rax
	mov	QWORD PTR fmt$[rsp], rax
	jmp	SHORT $LN2@ImParseFor
$LN3@ImParseFor:

; 3001 : 	int precision = INT_MAX;

	mov	DWORD PTR precision$[rsp], 2147483647	; 7fffffffH

; 3002 : 	if (*fmt == '.')

	mov	rax, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN5@ImParseFor

; 3003 : 	{
; 3004 : 		fmt = ImAtoi<int>(fmt + 1, &precision);

	mov	rax, QWORD PTR fmt$[rsp]
	inc	rax
	lea	rdx, QWORD PTR precision$[rsp]
	mov	rcx, rax
	call	??$ImAtoi@H@@YAPEBDPEBDPEAH@Z		; ImAtoi<int>
	mov	QWORD PTR fmt$[rsp], rax

; 3005 : 		if (precision < 0 || precision > 99)

	cmp	DWORD PTR precision$[rsp], 0
	jl	SHORT $LN7@ImParseFor
	cmp	DWORD PTR precision$[rsp], 99		; 00000063H
	jle	SHORT $LN6@ImParseFor
$LN7@ImParseFor:

; 3006 : 			precision = default_precision;

	mov	eax, DWORD PTR default_precision$[rsp]
	mov	DWORD PTR precision$[rsp], eax
$LN6@ImParseFor:
$LN5@ImParseFor:

; 3007 : 	}
; 3008 : 	if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation

	mov	rax, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 101				; 00000065H
	je	SHORT $LN9@ImParseFor
	mov	rax, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 69					; 00000045H
	jne	SHORT $LN8@ImParseFor
$LN9@ImParseFor:

; 3009 : 		precision = -1;

	mov	DWORD PTR precision$[rsp], -1
$LN8@ImParseFor:

; 3010 : 	if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)

	mov	rax, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 103				; 00000067H
	je	SHORT $LN11@ImParseFor
	mov	rax, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 71					; 00000047H
	jne	SHORT $LN10@ImParseFor
$LN11@ImParseFor:
	cmp	DWORD PTR precision$[rsp], 2147483647	; 7fffffffH
	jne	SHORT $LN10@ImParseFor

; 3011 : 		precision = -1;

	mov	DWORD PTR precision$[rsp], -1
$LN10@ImParseFor:

; 3012 : 	return (precision == INT_MAX) ? default_precision : precision;

	cmp	DWORD PTR precision$[rsp], 2147483647	; 7fffffffH
	jne	SHORT $LN13@ImParseFor
	mov	eax, DWORD PTR default_precision$[rsp]
	mov	DWORD PTR tv94[rsp], eax
	jmp	SHORT $LN14@ImParseFor
$LN13@ImParseFor:
	mov	eax, DWORD PTR precision$[rsp]
	mov	DWORD PTR tv94[rsp], eax
$LN14@ImParseFor:
	mov	eax, DWORD PTR tv94[rsp]
$LN1@ImParseFor:

; 3013 : }

	add	rsp, 56					; 00000038H
	ret	0
?ImParseFormatPrecision@@YAHPEBDH@Z ENDP		; ImParseFormatPrecision
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
fmt_start$ = 32
fmt_end$ = 40
fmt$ = 64
buf$ = 72
buf_size$ = 80
?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z PROC	; ImParseFormatTrimDecorations

; 2980 : {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2981 : 	const char* fmt_start = ImParseFormatFindStart(fmt);

	mov	rcx, QWORD PTR fmt$[rsp]
	call	?ImParseFormatFindStart@@YAPEBDPEBD@Z	; ImParseFormatFindStart
	mov	QWORD PTR fmt_start$[rsp], rax

; 2982 : 	if (fmt_start[0] != '%')

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt_start$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN2@ImParseFor

; 2983 : 		return fmt;

	mov	rax, QWORD PTR fmt$[rsp]
	jmp	SHORT $LN1@ImParseFor
$LN2@ImParseFor:

; 2984 : 	const char* fmt_end = ImParseFormatFindEnd(fmt_start);

	mov	rcx, QWORD PTR fmt_start$[rsp]
	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd
	mov	QWORD PTR fmt_end$[rsp], rax

; 2985 : 	if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt_end$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN3@ImParseFor

; 2986 : 		return fmt_start;

	mov	rax, QWORD PTR fmt_start$[rsp]
	jmp	SHORT $LN1@ImParseFor
$LN3@ImParseFor:

; 2987 : 	ImStrncpy(buf, fmt_start, ImMin((size_t)(fmt_end - fmt_start) + 1, buf_size));

	mov	rax, QWORD PTR fmt_start$[rsp]
	mov	rcx, QWORD PTR fmt_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	inc	rax
	mov	rdx, QWORD PTR buf_size$[rsp]
	mov	rcx, rax
	call	??$ImMin@_K@@YA_K_K0@Z			; ImMin<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR fmt_start$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	?ImStrncpy@@YAXPEADPEBD_K@Z		; ImStrncpy

; 2988 : 	return buf;

	mov	rax, QWORD PTR buf$[rsp]
$LN1@ImParseFor:

; 2989 : }

	add	rsp, 56					; 00000038H
	ret	0
?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z ENDP	; ImParseFormatTrimDecorations
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
c$1 = 0
tv133 = 4
tv139 = 8
ignored_uppercase_mask$ = 12
ignored_lowercase_mask$ = 16
fmt$ = 48
?ImParseFormatFindEnd@@YAPEBDPEBD@Z PROC		; ImParseFormatFindEnd

; 2958 : {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2959 : 	// Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.
; 2960 : 	if (fmt[0] != '%')

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN5@ImParseFor

; 2961 : 		return fmt;

	mov	rax, QWORD PTR fmt$[rsp]
	jmp	$LN1@ImParseFor
$LN5@ImParseFor:

; 2962 : 	const unsigned int ignored_uppercase_mask = (1 << ('I' - 'A')) | (1 << ('L' - 'A'));

	mov	DWORD PTR ignored_uppercase_mask$[rsp], 2304 ; 00000900H

; 2963 : 	const unsigned int ignored_lowercase_mask = (1 << ('h' - 'a')) | (1 << ('j' - 'a')) | (1 << ('l' - 'a')) | (1 << ('t' - 'a')) | (1 << ('w' - 'a')) | (1 << ('z' - 'a'));

	mov	DWORD PTR ignored_lowercase_mask$[rsp], 38275712 ; 02480a80H

; 2964 : 	for (char c; (c = *fmt) != 0; fmt++)

	jmp	SHORT $LN4@ImParseFor
$LN2@ImParseFor:
	mov	rax, QWORD PTR fmt$[rsp]
	inc	rax
	mov	QWORD PTR fmt$[rsp], rax
$LN4@ImParseFor:
	mov	rax, QWORD PTR fmt$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$1[rsp], al
	movsx	eax, BYTE PTR c$1[rsp]
	test	eax, eax
	je	$LN3@ImParseFor

; 2965 : 	{
; 2966 : 		if (c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)

	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN6@ImParseFor
	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN6@ImParseFor
	movsx	eax, BYTE PTR c$1[rsp]
	sub	eax, 65					; 00000041H
	mov	ecx, 1
	mov	DWORD PTR tv133[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv133[rsp]
	shl	eax, cl
	and	eax, 2304				; 00000900H
	test	eax, eax
	jne	SHORT $LN6@ImParseFor

; 2967 : 			return fmt + 1;

	mov	rax, QWORD PTR fmt$[rsp]
	inc	rax
	jmp	SHORT $LN1@ImParseFor
$LN6@ImParseFor:

; 2968 : 		if (c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)

	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN7@ImParseFor
	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN7@ImParseFor
	movsx	eax, BYTE PTR c$1[rsp]
	sub	eax, 97					; 00000061H
	mov	ecx, 1
	mov	DWORD PTR tv139[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv139[rsp]
	shl	eax, cl
	and	eax, 38275712				; 02480a80H
	test	eax, eax
	jne	SHORT $LN7@ImParseFor

; 2969 : 			return fmt + 1;

	mov	rax, QWORD PTR fmt$[rsp]
	inc	rax
	jmp	SHORT $LN1@ImParseFor
$LN7@ImParseFor:

; 2970 : 	}

	jmp	$LN2@ImParseFor
$LN3@ImParseFor:

; 2971 : 	return fmt;

	mov	rax, QWORD PTR fmt$[rsp]
$LN1@ImParseFor:

; 2972 : }

	add	rsp, 40					; 00000028H
	ret	0
?ImParseFormatFindEnd@@YAPEBDPEBD@Z ENDP		; ImParseFormatFindEnd
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
c$1 = 0
fmt$ = 32
?ImParseFormatFindStart@@YAPEBDPEBD@Z PROC		; ImParseFormatFindStart

; 2945 : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
$LN2@ImParseFor:

; 2946 : 	while (char c = fmt[0])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR fmt$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR c$1[rsp], al
	movsx	eax, BYTE PTR c$1[rsp]
	test	eax, eax
	je	SHORT $LN3@ImParseFor

; 2947 : 	{
; 2948 : 		if (c == '%' && fmt[1] != '%')

	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN4@ImParseFor
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR fmt$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN4@ImParseFor

; 2949 : 			return fmt;

	mov	rax, QWORD PTR fmt$[rsp]
	jmp	SHORT $LN1@ImParseFor
	jmp	SHORT $LN5@ImParseFor
$LN4@ImParseFor:

; 2950 : 		else if (c == '%')

	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN6@ImParseFor

; 2951 : 			fmt++;

	mov	rax, QWORD PTR fmt$[rsp]
	inc	rax
	mov	QWORD PTR fmt$[rsp], rax
$LN6@ImParseFor:
$LN5@ImParseFor:

; 2952 : 		fmt++;

	mov	rax, QWORD PTR fmt$[rsp]
	inc	rax
	mov	QWORD PTR fmt$[rsp], rax

; 2953 : 	}

	jmp	SHORT $LN2@ImParseFor
$LN3@ImParseFor:

; 2954 : 	return fmt;

	mov	rax, QWORD PTR fmt$[rsp]
$LN1@ImParseFor:

; 2955 : }

	add	rsp, 24
	ret	0
?ImParseFormatFindStart@@YAPEBDPEBD@Z ENDP		; ImParseFormatFindStart
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv67 = 0
c$ = 32
?ImCharIsBlankW@@YA_NI@Z PROC				; ImCharIsBlankW

; 156  : static inline bool      ImCharIsBlankW(unsigned int c) { return c == ' ' || c == '\t' || c == 0x3000; }

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24
	cmp	DWORD PTR c$[rsp], 32			; 00000020H
	je	SHORT $LN3@ImCharIsBl
	cmp	DWORD PTR c$[rsp], 9
	je	SHORT $LN3@ImCharIsBl
	cmp	DWORD PTR c$[rsp], 12288		; 00003000H
	je	SHORT $LN3@ImCharIsBl
	mov	DWORD PTR tv67[rsp], 0
	jmp	SHORT $LN4@ImCharIsBl
$LN3@ImCharIsBl:
	mov	DWORD PTR tv67[rsp], 1
$LN4@ImCharIsBl:
	movzx	eax, BYTE PTR tv67[rsp]
	add	rsp, 24
	ret	0
?ImCharIsBlankW@@YA_NI@Z ENDP				; ImCharIsBlankW
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_internal.h
_TEXT	SEGMENT
tv68 = 0
c$ = 32
?ImCharIsBlankA@@YA_ND@Z PROC				; ImCharIsBlankA

; 155  : static inline bool      ImCharIsBlankA(char c) { return c == ' ' || c == '\t'; }

	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@ImCharIsBl
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 9
	je	SHORT $LN3@ImCharIsBl
	mov	DWORD PTR tv68[rsp], 0
	jmp	SHORT $LN4@ImCharIsBl
$LN3@ImCharIsBl:
	mov	DWORD PTR tv68[rsp], 1
$LN4@ImCharIsBl:
	movzx	eax, BYTE PTR tv68[rsp]
	add	rsp, 24
	ret	0
?ImCharIsBlankA@@YA_ND@Z ENDP				; ImCharIsBlankA
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?GetCharAdvance@ImFont@@QEBAMG@Z
_TEXT	SEGMENT
tv76 = 32
tv74 = 40
this$ = 64
c$ = 72
?GetCharAdvance@ImFont@@QEBAMG@Z PROC			; ImFont::GetCharAdvance, COMDAT

; 2150 : 	float                       GetCharAdvance(ImWchar c) const { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

$LN5:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	movzx	eax, WORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	cmp	eax, DWORD PTR [rcx]
	jge	SHORT $LN3@GetCharAdv
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv74[rsp], rax
	movzx	eax, WORD PTR c$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR tv74[rsp]
	call	??A?$ImVector@M@@QEBAAEBMH@Z		; ImVector<float>::operator[]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv76[rsp], xmm0
	jmp	SHORT $LN4@GetCharAdv
$LN3@GetCharAdv:
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+16]
	movss	DWORD PTR tv76[rsp], xmm0
$LN4@GetCharAdv:
	movss	xmm0, DWORD PTR tv76[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?GetCharAdvance@ImFont@@QEBAMG@Z ENDP			; ImFont::GetCharAdvance
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@M@@QEBAAEBMH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@M@@QEBAAEBMH@Z PROC			; ImVector<float>::operator[], COMDAT

; 1229 : 	inline const T& operator[](int i) const { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*4]
	ret	0
??A?$ImVector@M@@QEBAAEBMH@Z ENDP			; ImVector<float>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z
_TEXT	SEGMENT
this$ = 48
pos$ = 56
uv$ = 64
col$ = 72
?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z PROC		; ImDrawList::PrimVtx, COMDAT

; 1922 : 	inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col) { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, WORD PTR [rax+64]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimWriteIdx@ImDrawList@@QEAAXG@Z	; ImDrawList::PrimWriteIdx
	mov	r9d, DWORD PTR col$[rsp]
	mov	r8, QWORD PTR uv$[rsp]
	mov	rdx, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ; ImDrawList::PrimWriteVtx
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ENDP		; ImDrawList::PrimVtx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PrimWriteIdx@ImDrawList@@QEAAXG@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
?PrimWriteIdx@ImDrawList@@QEAAXG@Z PROC			; ImDrawList::PrimWriteIdx, COMDAT

; 1921 : 	inline    void  PrimWriteIdx(ImDrawIdx idx) { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	movzx	ecx, WORD PTR idx$[rsp]
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	add	rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+88], rax
	ret	0
?PrimWriteIdx@ImDrawList@@QEAAXG@Z ENDP			; ImDrawList::PrimWriteIdx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z
_TEXT	SEGMENT
this$ = 8
pos$ = 16
uv$ = 24
col$ = 32
?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z PROC	; ImDrawList::PrimWriteVtx, COMDAT

; 1920 : 	inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col) { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR pos$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR uv$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	ecx, DWORD PTR col$[rsp]
	mov	DWORD PTR [rax+16], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 20
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+80], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+64]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+64], eax
	ret	0
?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ENDP	; ImDrawList::PrimWriteVtx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PathStroke@ImDrawList@@QEAAXI_NM@Z
_TEXT	SEGMENT
this$ = 64
col$ = 72
closed$ = 80
thickness$ = 88
?PathStroke@ImDrawList@@QEAAXI_NM@Z PROC		; ImDrawList::PathStroke, COMDAT

; 1894 : 	inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); _Path.Size = 0; }

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	movss	xmm0, DWORD PTR thickness$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movzx	eax, BYTE PTR closed$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR col$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR [rax+152]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+160]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z ; ImDrawList::AddPolyline
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+152], 0
	add	rsp, 56					; 00000038H
	ret	0
?PathStroke@ImDrawList@@QEAAXI_NM@Z ENDP		; ImDrawList::PathStroke
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PathFillConvex@ImDrawList@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 48
col$ = 56
?PathFillConvex@ImDrawList@@QEAAXI@Z PROC		; ImDrawList::PathFillConvex, COMDAT

; 1893 : 	inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r9d, DWORD PTR col$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR [rax+152]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+160]
	mov	rcx, QWORD PTR this$[rsp]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+152], 0
	add	rsp, 40					; 00000028H
	ret	0
?PathFillConvex@ImDrawList@@QEAAXI@Z ENDP		; ImDrawList::PathFillConvex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
tv68 = 32
this$ = 64
pos$ = 72
?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z PROC	; ImDrawList::PathLineTo, COMDAT

; 1891 : 	inline    void  PathLineTo(const ImVec2& pos) { _Path.push_back(pos); }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 152				; 00000098H
	mov	QWORD PTR tv68[rsp], rax
	mov	rdx, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	call	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ENDP	; ImDrawList::PathLineTo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?PathClear@ImDrawList@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?PathClear@ImDrawList@@QEAAXXZ PROC			; ImDrawList::PathClear, COMDAT

; 1890 : 	inline    void  PathClear() { _Path.Size = 0; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+152], 0
	ret	0
?PathClear@ImDrawList@@QEAAXXZ ENDP			; ImDrawList::PathClear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z PROC ; ImVector<ImVec2>::push_back, COMDAT

; 1248 : 	inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN2@push_back
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z ; ImVector<ImVec2>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
	npad	1
$LN2@push_back:
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	r8d, 8
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ENDP ; ImVector<ImVec2>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z PROC		; ImVector<ImVec2>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 3
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 3
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ENDP		; ImVector<ImVec2>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z PROC	; ImVector<ImVec2>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z ENDP	; ImVector<ImVec2>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??BImColor@@QEBAIXZ
_TEXT	SEGMENT
this$ = 48
??BImColor@@QEBAIXZ PROC				; ImColor::operator unsigned int, COMDAT

; 1744 : 	inline operator ImU32() const { return ImGui::ColorConvertFloat4ToU32(Value); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	add	rsp, 40					; 00000028H
	ret	0
??BImColor@@QEBAIXZ ENDP				; ImColor::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImColor@@QEAA@HHHH@Z
_TEXT	SEGMENT
sc$ = 32
this$ = 64
r$ = 72
g$ = 80
b$ = 88
a$ = 96
??0ImColor@@QEAA@HHHH@Z PROC				; ImColor::ImColor, COMDAT

; 1739 : 	ImColor(int r, int g, int b, int a = 255) { float sc = 1.0f / 255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0ImVec4@@QEAA@XZ			; ImVec4::ImVec4
	movss	xmm0, DWORD PTR __real@3b808081
	movss	DWORD PTR sc$[rsp], xmm0
	cvtsi2ss xmm0, DWORD PTR r$[rsp]
	mulss	xmm0, DWORD PTR sc$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0
	cvtsi2ss xmm0, DWORD PTR g$[rsp]
	mulss	xmm0, DWORD PTR sc$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	cvtsi2ss xmm0, DWORD PTR b$[rsp]
	mulss	xmm0, DWORD PTR sc$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	cvtsi2ss xmm0, DWORD PTR a$[rsp]
	mulss	xmm0, DWORD PTR sc$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0ImColor@@QEAA@HHHH@Z ENDP				; ImColor::ImColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1ImGuiListClipper@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1ImGuiListClipper@@QEAA@XZ PROC			; ImGuiListClipper::~ImGuiListClipper, COMDAT

; 1703 : 	~ImGuiListClipper() { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1ImGuiListClipper@@QEAA@XZ ENDP			; ImGuiListClipper::~ImGuiListClipper
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImGuiListClipper@@QEAA@HM@Z
_TEXT	SEGMENT
this$ = 48
items_count$ = 56
items_height$ = 64
??0ImGuiListClipper@@QEAA@HM@Z PROC			; ImGuiListClipper::ImGuiListClipper, COMDAT

; 1702 : 	ImGuiListClipper(int items_count = -1, float items_height = -1.0f) { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).

$LN3:
	movss	DWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	movss	xmm2, DWORD PTR items_height$[rsp]
	mov	edx, DWORD PTR items_count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Begin@ImGuiListClipper@@QEAAXHM@Z	; ImGuiListClipper::Begin
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiListClipper@@QEAA@HM@Z ENDP			; ImGuiListClipper::ImGuiListClipper
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImGuiTextBuffer@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImGuiTextBuffer@@QEAA@XZ PROC			; ImGuiTextBuffer::~ImGuiTextBuffer, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ImGuiTextBuffer@@QEAA@XZ ENDP			; ImGuiTextBuffer::~ImGuiTextBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA PROC		; `ImGuiTextBuffer::~ImGuiTextBuffer'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ImGuiTextBuffer@@QEAA@XZ@4HA ENDP		; `ImGuiTextBuffer::~ImGuiTextBuffer'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?size@ImGuiTextBuffer@@QEBAHXZ
_TEXT	SEGMENT
tv70 = 0
this$ = 32
?size@ImGuiTextBuffer@@QEBAHXZ PROC			; ImGuiTextBuffer::size, COMDAT

; 1619 : 	int                 size() const { return Buf.Size ? Buf.Size - 1 : 0; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN3@size
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@size
$LN3@size:
	mov	DWORD PTR tv70[rsp], 0
$LN4@size:
	mov	eax, DWORD PTR tv70[rsp]
	add	rsp, 24
	ret	0
?size@ImGuiTextBuffer@@QEBAHXZ ENDP			; ImGuiTextBuffer::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImGuiTextBuffer@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0ImGuiTextBuffer@@QEAA@XZ PROC			; ImGuiTextBuffer::ImGuiTextBuffer, COMDAT

; 1617 : 	ImGuiTextBuffer() { }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$ImVector@D@@QEAA@XZ		; ImVector<char>::ImVector<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiTextBuffer@@QEAA@XZ ENDP			; ImGuiTextBuffer::ImGuiTextBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0ImGuiTextBuffer@@QEAA@XZ@4HA PROC		; `ImGuiTextBuffer::ImGuiTextBuffer'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ImGuiTextBuffer@@QEAA@XZ@4HA ENDP		; `ImGuiTextBuffer::ImGuiTextBuffer'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@D@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@D@@QEAAXH@Z PROC			; ImVector<char>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@D@@QEAAXH@Z ENDP			; ImVector<char>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@D@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@D@@QEAAXH@Z PROC			; ImVector<char>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@D@@QEBAHH@Z	; ImVector<char>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@D@@QEAAXH@Z ENDP			; ImVector<char>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@D@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@D@@QEBAHH@Z PROC		; ImVector<char>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@D@@QEBAHH@Z ENDP		; ImVector<char>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??1?$ImVector@D@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@D@@QEAA@XZ PROC				; ImVector<char>::~ImVector<char>, COMDAT

; 1222 : 	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@ImVector
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN2@ImVector:
	add	rsp, 40					; 00000028H
	ret	0
??1?$ImVector@D@@QEAA@XZ ENDP				; ImVector<char>::~ImVector<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0?$ImVector@D@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@D@@QEAA@XZ PROC				; ImVector<char>::ImVector<char>, COMDAT

; 1219 : 	inline ImVector() { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ImVector@D@@QEAA@XZ ENDP				; ImVector<char>::ImVector<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??3@YAXPEAXUImNewDummy@@0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
__formal$ = 24
??3@YAXPEAXUImNewDummy@@0@Z PROC			; operator delete, COMDAT

; 1563 : inline void  operator delete(void*, ImNewDummy, void*) {} // This is only required so we can use the symetrical new()

	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	ret	0
??3@YAXPEAXUImNewDummy@@0@Z ENDP			; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??2@YAPEAX_KUImNewDummy@@PEAX@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
ptr$ = 24
??2@YAPEAX_KUImNewDummy@@PEAX@Z PROC			; operator new, COMDAT

; 1562 : inline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }

	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR ptr$[rsp]
	ret	0
??2@YAPEAX_KUImNewDummy@@PEAX@Z ENDP			; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
format$ = 64
__$ArrayPad$ = 80
label$ = 128
v$ = 136
decimal_precision$ = 144
flags$ = 152
?InputFloat4@ImGui@@YA_NPEBDQEAMHH@Z PROC		; ImGui::InputFloat4

; 3187 : {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3188 : 	char format[16] = "%f";

	lea	rax, QWORD PTR format$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 3
	rep movsb
	lea	rax, QWORD PTR format$[rsp+3]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 13
	rep stosb

; 3189 : 	if (decimal_precision >= 0)

	cmp	DWORD PTR decimal_precision$[rsp], 0
	jl	SHORT $LN2@InputFloat

; 3190 : 		ImFormatString(format, IM_ARRAYSIZE(format), ("%%.%df"), decimal_precision);

	mov	r9d, DWORD PTR decimal_precision$[rsp]
	lea	r8, OFFSET FLAT:??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@
	mov	edx, 16
	lea	rcx, QWORD PTR format$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
$LN2@InputFloat:

; 3191 : 	return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	lea	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 4
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z ; ImGui::InputScalarN

; 3192 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?InputFloat4@ImGui@@YA_NPEBDQEAMHH@Z ENDP		; ImGui::InputFloat4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
format$ = 64
__$ArrayPad$ = 80
label$ = 128
v$ = 136
decimal_precision$ = 144
flags$ = 152
?InputFloat3@ImGui@@YA_NPEBDQEAMHH@Z PROC		; ImGui::InputFloat3

; 3179 : {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3180 : 	char format[16] = "%f";

	lea	rax, QWORD PTR format$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 3
	rep movsb
	lea	rax, QWORD PTR format$[rsp+3]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 13
	rep stosb

; 3181 : 	if (decimal_precision >= 0)

	cmp	DWORD PTR decimal_precision$[rsp], 0
	jl	SHORT $LN2@InputFloat

; 3182 : 		ImFormatString(format, IM_ARRAYSIZE(format), ("%%.%df"), decimal_precision);

	mov	r9d, DWORD PTR decimal_precision$[rsp]
	lea	r8, OFFSET FLAT:??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@
	mov	edx, 16
	lea	rcx, QWORD PTR format$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
$LN2@InputFloat:

; 3183 : 	return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	lea	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 3
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z ; ImGui::InputScalarN

; 3184 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?InputFloat3@ImGui@@YA_NPEBDQEAMHH@Z ENDP		; ImGui::InputFloat3
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
format$ = 64
__$ArrayPad$ = 80
label$ = 128
v$ = 136
decimal_precision$ = 144
flags$ = 152
?InputFloat2@ImGui@@YA_NPEBDQEAMHH@Z PROC		; ImGui::InputFloat2

; 3171 : {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3172 : 	char format[16] = "%f";

	lea	rax, QWORD PTR format$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 3
	rep movsb
	lea	rax, QWORD PTR format$[rsp+3]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 13
	rep stosb

; 3173 : 	if (decimal_precision >= 0)

	cmp	DWORD PTR decimal_precision$[rsp], 0
	jl	SHORT $LN2@InputFloat

; 3174 : 		ImFormatString(format, IM_ARRAYSIZE(format), ("%%.%df"), decimal_precision);

	mov	r9d, DWORD PTR decimal_precision$[rsp]
	lea	r8, OFFSET FLAT:??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@
	mov	edx, 16
	lea	rcx, QWORD PTR format$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
$LN2@InputFloat:

; 3175 : 	return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	lea	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 2
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z ; ImGui::InputScalarN

; 3176 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?InputFloat2@ImGui@@YA_NPEBDQEAMHH@Z ENDP		; ImGui::InputFloat2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
format$ = 48
__$ArrayPad$ = 64
label$ = 112
v$ = 120
step$ = 128
step_fast$ = 136
decimal_precision$ = 144
flags$ = 152
?InputFloat@ImGui@@YA_NPEBDPEAMMMHH@Z PROC		; ImGui::InputFloat

; 3163 : {

$LN4:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3164 : 	char format[16] = "%f";

	lea	rax, QWORD PTR format$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 3
	rep movsb
	lea	rax, QWORD PTR format$[rsp+3]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 13
	rep stosb

; 3165 : 	if (decimal_precision >= 0)

	cmp	DWORD PTR decimal_precision$[rsp], 0
	jl	SHORT $LN2@InputFloat

; 3166 : 		ImFormatString(format, IM_ARRAYSIZE(format), ("%%.%df"), decimal_precision);

	mov	r9d, DWORD PTR decimal_precision$[rsp]
	lea	r8, OFFSET FLAT:??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@
	mov	edx, 16
	lea	rcx, QWORD PTR format$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
$LN2@InputFloat:

; 3167 : 	return InputFloat(label, v, step, step_fast, format, flags);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+40], eax
	lea	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movss	xmm3, DWORD PTR step_fast$[rsp]
	movss	xmm2, DWORD PTR step$[rsp]
	mov	rdx, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z	; ImGui::InputFloat

; 3168 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?InputFloat@ImGui@@YA_NPEBDPEAMMMHH@Z ENDP		; ImGui::InputFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
c$1 = 0
tv74 = 1
dst$ = 8
src$ = 16
this$ = 48
pos$ = 56
bytes_count$ = 64
?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z PROC	; ImGuiInputTextCallbackData::DeleteChars

; 3464 : {

$LN8:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3465 : 	IM_ASSERT(pos + bytes_count <= BufTextLen);
; 3466 : 	char* dst = Buf + pos;

	movsxd	rax, DWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR dst$[rsp], rax

; 3467 : 	const char* src = Buf + pos + bytes_count;

	movsxd	rax, DWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR bytes_count$[rsp]
	add	rax, rcx
	mov	QWORD PTR src$[rsp], rax
$LN2@DeleteChar:

; 3468 : 	while (char c = *src++)

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv74[rsp], al
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR c$1[rsp], al
	movsx	eax, BYTE PTR c$1[rsp]
	test	eax, eax
	je	SHORT $LN3@DeleteChar

; 3469 : 		*dst++ = c;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$1[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	jmp	SHORT $LN2@DeleteChar
$LN3@DeleteChar:

; 3470 : 	*dst = '\0';

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0

; 3471 : 
; 3472 : 	if (CursorPos + bytes_count >= pos)

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	add	eax, DWORD PTR bytes_count$[rsp]
	cmp	eax, DWORD PTR pos$[rsp]
	jl	SHORT $LN4@DeleteChar

; 3473 : 		CursorPos -= bytes_count;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR bytes_count$[rsp]
	mov	eax, DWORD PTR [rax+48]
	sub	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+48], eax
	jmp	SHORT $LN5@DeleteChar
$LN4@DeleteChar:

; 3474 : 	else if (CursorPos >= pos)

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR pos$[rsp]
	cmp	DWORD PTR [rax+48], ecx
	jl	SHORT $LN6@DeleteChar

; 3475 : 		CursorPos = pos;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR pos$[rsp]
	mov	DWORD PTR [rax+48], ecx
$LN6@DeleteChar:
$LN5@DeleteChar:

; 3476 : 	SelectionStart = SelectionEnd = CursorPos;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+48]
	mov	DWORD PTR [rax+52], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+52]
	mov	DWORD PTR [rax+40], ecx

; 3477 : 	BufDirty = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+32], 1

; 3478 : 	BufTextLen -= bytes_count;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR bytes_count$[rsp]
	mov	eax, DWORD PTR [rax+36]
	sub	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 3479 : }

	add	rsp, 40					; 00000028H
	ret	0
?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z ENDP	; ImGuiInputTextCallbackData::DeleteChars
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
this$ = 48
??0ImGuiInputTextCallbackData@@QEAA@XZ PROC		; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData

; 3456 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3457 : 	memset(this, 0, sizeof(*this));

	mov	r8d, 56					; 00000038H
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	memset
	npad	1

; 3458 : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ImGuiInputTextCallbackData@@QEAA@XZ ENDP		; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv67 = 32
new_text_len$ = 36
is_resizable$ = 40
new_buf_size$1 = 44
tv74 = 48
edit_state$2 = 56
g$3 = 64
tv130 = 72
tv151 = 80
this$ = 112
pos$ = 120
new_text$ = 128
new_text_end$ = 136
?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z PROC ; ImGuiInputTextCallbackData::InsertChars

; 3482 : {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 3483 : 	const bool is_resizable = (Flags & ImGuiInputTextFlags_CallbackResize) != 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN7@InsertChar
	mov	BYTE PTR tv67[rsp], 1
	jmp	SHORT $LN8@InsertChar
$LN7@InsertChar:
	mov	BYTE PTR tv67[rsp], 0
$LN8@InsertChar:
	movzx	eax, BYTE PTR tv67[rsp]
	mov	BYTE PTR is_resizable$[rsp], al

; 3484 : 	const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);

	cmp	QWORD PTR new_text_end$[rsp], 0
	je	SHORT $LN9@InsertChar
	mov	rax, QWORD PTR new_text$[rsp]
	mov	rcx, QWORD PTR new_text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR tv74[rsp], eax
	jmp	SHORT $LN10@InsertChar
$LN9@InsertChar:
	mov	rcx, QWORD PTR new_text$[rsp]
	call	strlen
	mov	DWORD PTR tv74[rsp], eax
$LN10@InsertChar:
	mov	eax, DWORD PTR tv74[rsp]
	mov	DWORD PTR new_text_len$[rsp], eax

; 3485 : 	if (new_text_len + BufTextLen >= BufSize)

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	ecx, DWORD PTR new_text_len$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	cmp	eax, DWORD PTR [rcx+44]
	jl	$LN2@InsertChar

; 3486 : 	{
; 3487 : 		if (!is_resizable)

	movzx	eax, BYTE PTR is_resizable$[rsp]
	test	eax, eax
	jne	SHORT $LN3@InsertChar

; 3488 : 			return;

	jmp	$LN1@InsertChar
$LN3@InsertChar:

; 3489 : 
; 3490 : 		// Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the midly similar code (until we remove the U16 buffer alltogether!)
; 3491 : 		ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$3[rsp], rax

; 3492 : 		ImGuiInputTextState* edit_state = &g.InputTextState;

	mov	rax, QWORD PTR g$3[rsp]
	add	rax, 7936				; 00001f00H
	mov	QWORD PTR edit_state$2[rsp], rax

; 3493 : 		IM_ASSERT(edit_state->ID != 0 && g.ActiveId == edit_state->ID);
; 3494 : 		IM_ASSERT(Buf == edit_state->TempBuffer.Data);
; 3495 : 		int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;

	mov	edx, DWORD PTR new_text_len$[rsp]
	mov	ecx, 256				; 00000100H
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	ecx, DWORD PTR new_text_len$[rsp]
	shl	ecx, 2
	mov	r8d, eax
	mov	edx, 32					; 00000020H
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	DWORD PTR new_buf_size$1[rsp], eax

; 3496 : 		edit_state->TempBuffer.reserve(new_buf_size + 1);

	mov	rax, QWORD PTR edit_state$2[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv130[rsp], rax
	mov	eax, DWORD PTR new_buf_size$1[rsp]
	inc	eax
	mov	edx, eax
	mov	rcx, QWORD PTR tv130[rsp]
	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve

; 3497 : 		Buf = edit_state->TempBuffer.Data;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR edit_state$2[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rax+24], rcx

; 3498 : 		BufSize = edit_state->BufCapacityA = new_buf_size;

	mov	rax, QWORD PTR edit_state$2[rsp]
	mov	ecx, DWORD PTR new_buf_size$1[rsp]
	mov	DWORD PTR [rax+76], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_buf_size$1[rsp]
	mov	DWORD PTR [rax+44], ecx
$LN2@InsertChar:

; 3499 : 	}
; 3500 : 
; 3501 : 	if (BufTextLen != pos)

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR pos$[rsp]
	cmp	DWORD PTR [rax+36], ecx
	je	SHORT $LN4@InsertChar

; 3502 : 		memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR pos$[rsp]
	mov	eax, DWORD PTR [rax+36]
	sub	eax, ecx
	cdqe
	movsxd	rcx, DWORD PTR pos$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	add	rcx, QWORD PTR [rdx+24]
	movsxd	rdx, DWORD PTR pos$[rsp]
	mov	r8, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [r8+24]
	add	r8, rdx
	mov	rdx, r8
	movsxd	r8, DWORD PTR new_text_len$[rsp]
	add	rdx, r8
	mov	QWORD PTR tv151[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv151[rsp]
	mov	rcx, rax
	call	memmove
	npad	1
$LN4@InsertChar:

; 3503 : 	memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));

	movsxd	rax, DWORD PTR new_text_len$[rsp]
	movsxd	rcx, DWORD PTR pos$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	add	rcx, QWORD PTR [rdx+24]
	mov	r8, rax
	mov	rdx, QWORD PTR new_text$[rsp]
	call	memcpy

; 3504 : 	Buf[BufTextLen + new_text_len] = '\0';

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+36]
	add	eax, DWORD PTR new_text_len$[rsp]
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	BYTE PTR [rcx+rax], 0

; 3505 : 
; 3506 : 	if (CursorPos >= pos)

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR pos$[rsp]
	cmp	DWORD PTR [rax+48], ecx
	jl	SHORT $LN5@InsertChar

; 3507 : 		CursorPos += new_text_len;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	add	eax, DWORD PTR new_text_len$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+48], eax
$LN5@InsertChar:

; 3508 : 	SelectionStart = SelectionEnd = CursorPos;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+48]
	mov	DWORD PTR [rax+52], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+52]
	mov	DWORD PTR [rax+40], ecx

; 3509 : 	BufDirty = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+32], 1

; 3510 : 	BufTextLen += new_text_len;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+36]
	add	eax, DWORD PTR new_text_len$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+36], eax
$LN1@InsertChar:

; 3511 : }

	add	rsp, 104				; 00000068H
	ret	0
?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z ENDP ; ImGuiInputTextCallbackData::InsertChars
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@G@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@G@@QEAAXH@Z PROC			; ImVector<unsigned short>::reserve, COMDAT

; 1245 : 	inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jg	SHORT $LN2@reserve
	jmp	SHORT $LN1@reserve
$LN2@reserve:
	movsxd	rax, DWORD PTR new_capacity$[rsp]
	shl	rax, 1
	mov	rcx, rax
	call	?MemAlloc@ImGui@@YAPEAX_K@Z		; ImGui::MemAlloc
	mov	QWORD PTR new_data$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@reserve
	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	shl	rax, 1
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR new_data$[rsp]
	call	memcpy
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?MemFree@ImGui@@YAXPEAX@Z		; ImGui::MemFree
	npad	1
$LN3@reserve:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR new_data$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR [rax+4], ecx
$LN1@reserve:
	add	rsp, 56					; 00000038H
	ret	0
?reserve@?$ImVector@G@@QEAAXH@Z ENDP			; ImVector<unsigned short>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@G@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@G@@QEAAXH@Z PROC			; ImVector<unsigned short>::resize, COMDAT

; 1243 : 	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR new_size$[rsp], eax
	jle	SHORT $LN2@resize
	mov	edx, DWORD PTR new_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow_capacity@?$ImVector@G@@QEBAHH@Z	; ImVector<unsigned short>::_grow_capacity
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
	npad	1
$LN2@resize:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR new_size$[rsp]
	mov	DWORD PTR [rax], ecx
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$ImVector@G@@QEAAXH@Z ENDP			; ImVector<unsigned short>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@G@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@G@@QEBAHH@Z PROC		; ImVector<unsigned short>::_grow_capacity, COMDAT

; 1242 : 	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN3@grow_capac
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN4@grow_capac
$LN3@grow_capac:
	mov	DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR new_capacity$[rsp], eax
	mov	eax, DWORD PTR sz$[rsp]
	cmp	DWORD PTR new_capacity$[rsp], eax
	jle	SHORT $LN5@grow_capac
	mov	eax, DWORD PTR new_capacity$[rsp]
	mov	DWORD PTR tv72[rsp], eax
	jmp	SHORT $LN6@grow_capac
$LN5@grow_capac:
	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
	mov	eax, DWORD PTR tv72[rsp]
	add	rsp, 24
	ret	0
?_grow_capacity@?$ImVector@G@@QEBAHH@Z ENDP		; ImVector<unsigned short>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@G@@QEBAAEBGH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@G@@QEBAAEBGH@Z PROC			; ImVector<unsigned short>::operator[], COMDAT

; 1229 : 	inline const T& operator[](int i) const { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*2]
	ret	0
??A?$ImVector@G@@QEBAAEBGH@Z ENDP			; ImVector<unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??A?$ImVector@G@@QEAAAEAGH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@G@@QEAAAEAGH@Z PROC			; ImVector<unsigned short>::operator[], COMDAT

; 1228 : 	inline T& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+rax*2]
	ret	0
??A?$ImVector@G@@QEAAAEAGH@Z ENDP			; ImVector<unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
is_within_manual_tab_bar$ = 32
tv73 = 36
tab_id$1 = 40
g$ = 48
tab_bar$2 = 56
label$ = 80
?SetTabItemClosed@ImGui@@YAXPEBD@Z PROC			; ImGui::SetTabItemClosed

; 7117 : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 7118 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 7119 : 	bool is_within_manual_tab_bar = (g.CurrentTabBar.Size > 0) && !(g.CurrentTabBar.back()->Flags & ImGuiTabBarFlags_DockNode);

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7800], 0
	jle	SHORT $LN4@SetTabItem
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7800				; 00001e78H
	mov	rcx, rax
	call	?back@?$ImVector@PEAUImGuiTabBar@@@@QEAAAEAPEAUImGuiTabBar@@XZ ; ImVector<ImGuiTabBar *>::back
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	jne	SHORT $LN4@SetTabItem
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN5@SetTabItem
$LN4@SetTabItem:
	mov	DWORD PTR tv73[rsp], 0
$LN5@SetTabItem:
	movzx	eax, BYTE PTR tv73[rsp]
	mov	BYTE PTR is_within_manual_tab_bar$[rsp], al

; 7120 : 	if (is_within_manual_tab_bar)

	movzx	eax, BYTE PTR is_within_manual_tab_bar$[rsp]
	test	eax, eax
	je	SHORT $LN2@SetTabItem

; 7121 : 	{
; 7122 : 		ImGuiTabBar* tab_bar = g.CurrentTabBar.back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7800				; 00001e78H
	mov	rcx, rax
	call	?back@?$ImVector@PEAUImGuiTabBar@@@@QEAAAEAPEAUImGuiTabBar@@XZ ; ImVector<ImGuiTabBar *>::back
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tab_bar$2[rsp], rax

; 7123 : 		IM_ASSERT(tab_bar->WantLayout);         // Needs to be called AFTER BeginTabBar() and BEFORE the first call to BeginTabItem()
; 7124 : 		ImGuiID tab_id = TabBarCalcTabID(tab_bar, label);

	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR tab_bar$2[rsp]
	call	?TabBarCalcTabID@ImGui@@YAIPEAUImGuiTabBar@@PEBD@Z ; ImGui::TabBarCalcTabID
	mov	DWORD PTR tab_id$1[rsp], eax

; 7125 : 		TabBarRemoveTab(tab_bar, tab_id);

	mov	edx, DWORD PTR tab_id$1[rsp]
	mov	rcx, QWORD PTR tab_bar$2[rsp]
	call	?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z ; ImGui::TabBarRemoveTab
	npad	1
$LN2@SetTabItem:

; 7126 : 	}
; 7127 : }

	add	rsp, 72					; 00000048H
	ret	0
?SetTabItemClosed@ImGui@@YAXPEBD@Z ENDP			; ImGui::SetTabItemClosed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 32
tab_bar$ = 40
tv78 = 48
tab$ = 56
?EndTabItem@ImGui@@YAXXZ PROC				; ImGui::EndTabItem

; 6912 : {

$LN5:
	sub	rsp, 72					; 00000048H

; 6913 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6914 : 	if (g.CurrentWindow->SkipItems)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@EndTabItem

; 6915 : 		return;

	jmp	SHORT $LN1@EndTabItem
$LN2@EndTabItem:

; 6916 : 
; 6917 : 	IM_ASSERT(g.CurrentTabBar.Size > 0 && "Needs to be called between BeginTabBar() and EndTabBar()!");
; 6918 : 	ImGuiTabBar* tab_bar = g.CurrentTabBar.back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7800				; 00001e78H
	mov	rcx, rax
	call	?back@?$ImVector@PEAUImGuiTabBar@@@@QEAAAEAPEAUImGuiTabBar@@XZ ; ImVector<ImGuiTabBar *>::back
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tab_bar$[rsp], rax

; 6919 : 	IM_ASSERT(tab_bar->LastTabItemIdx >= 0 && "Needs to be called between BeginTabItem() and EndTabItem()");
; 6920 : 	ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR tab_bar$[rsp]
	movsx	eax, WORD PTR [rax+122]
	mov	edx, eax
	mov	rcx, QWORD PTR tv78[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	mov	QWORD PTR tab$[rsp], rax

; 6921 : 	if (!(tab->Flags & ImGuiTabItemFlags_NoPushId))

	mov	rax, QWORD PTR tab$[rsp]
	mov	eax, DWORD PTR [rax+12]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN3@EndTabItem

; 6922 : 		g.CurrentWindow->IDStack.pop_back();

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	?pop_back@?$ImVector@I@@QEAAXXZ		; ImVector<unsigned int>::pop_back
	npad	1
$LN3@EndTabItem:
$LN1@EndTabItem:

; 6923 : }

	add	rsp, 72					; 00000048H
	ret	0
?EndTabItem@ImGui@@YAXXZ ENDP				; ImGui::EndTabItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
ret$ = 32
tab_bar$ = 40
g$ = 48
tv87 = 56
tab$1 = 64
tv94 = 72
label$ = 96
p_open$ = 104
flags$ = 112
?BeginTabItem@ImGui@@YA_NPEBDPEA_NH@Z PROC		; ImGui::BeginTabItem

; 6895 : {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 6896 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6897 : 	if (g.CurrentWindow->SkipItems)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@BeginTabIt

; 6898 : 		return false;

	xor	al, al
	jmp	$LN1@BeginTabIt
$LN2@BeginTabIt:

; 6899 : 
; 6900 : 	IM_ASSERT(g.CurrentTabBar.Size > 0 && "Needs to be called between BeginTabBar() and EndTabBar()!");
; 6901 : 	ImGuiTabBar* tab_bar = g.CurrentTabBar.back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7800				; 00001e78H
	mov	rcx, rax
	call	?back@?$ImVector@PEAUImGuiTabBar@@@@QEAAAEAPEAUImGuiTabBar@@XZ ; ImVector<ImGuiTabBar *>::back
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tab_bar$[rsp], rax

; 6902 : 	bool ret = TabItemEx(tab_bar, label, p_open, flags);

	mov	r9d, DWORD PTR flags$[rsp]
	mov	r8, QWORD PTR p_open$[rsp]
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NH@Z ; ImGui::TabItemEx
	mov	BYTE PTR ret$[rsp], al

; 6903 : 	if (ret && !(flags & ImGuiTabItemFlags_NoPushId))

	movzx	eax, BYTE PTR ret$[rsp]
	test	eax, eax
	je	SHORT $LN3@BeginTabIt
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN3@BeginTabIt

; 6904 : 	{
; 6905 : 		ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];

	mov	rax, QWORD PTR tab_bar$[rsp]
	add	rax, 16
	mov	QWORD PTR tv87[rsp], rax
	mov	rax, QWORD PTR tab_bar$[rsp]
	movsx	eax, WORD PTR [rax+122]
	mov	edx, eax
	mov	rcx, QWORD PTR tv87[rsp]
	call	??A?$ImVector@UImGuiTabItem@@@@QEAAAEAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
	mov	QWORD PTR tab$1[rsp], rax

; 6906 : 		g.CurrentWindow->IDStack.push_back(tab->ID);    // We already hashed 'label' so push into the ID stack directly instead of doing another hash through PushID(label)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	add	rax, 232				; 000000e8H
	mov	QWORD PTR tv94[rsp], rax
	mov	rax, QWORD PTR tab$1[rsp]
	add	rax, 8
	mov	rdx, rax
	mov	rcx, QWORD PTR tv94[rsp]
	call	?push_back@?$ImVector@I@@QEAAXAEBI@Z	; ImVector<unsigned int>::push_back
	npad	1
$LN3@BeginTabIt:

; 6907 : 	}
; 6908 : 	return ret;

	movzx	eax, BYTE PTR ret$[rsp]
$LN1@BeginTabIt:

; 6909 : }

	add	rsp, 88					; 00000058H
	ret	0
?BeginTabItem@ImGui@@YA_NPEBDPEA_NH@Z ENDP		; ImGui::BeginTabItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv79 = 32
tab_bar_appearing$ = 33
tab_bar$ = 40
g$ = 48
window$ = 56
?EndTabBar@ImGui@@YAXXZ PROC				; ImGui::EndTabBar

; 6513 : {

$LN11:
	sub	rsp, 72					; 00000048H

; 6514 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6515 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 6516 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@EndTabBar

; 6517 : 		return;

	jmp	$LN1@EndTabBar
$LN2@EndTabBar:

; 6518 : 
; 6519 : 	IM_ASSERT(!g.CurrentTabBar.empty());      // Mismatched BeginTabBar/EndTabBar
; 6520 : 	ImGuiTabBar* tab_bar = g.CurrentTabBar.back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7800				; 00001e78H
	mov	rcx, rax
	call	?back@?$ImVector@PEAUImGuiTabBar@@@@QEAAAEAPEAUImGuiTabBar@@XZ ; ImVector<ImGuiTabBar *>::back
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tab_bar$[rsp], rax

; 6521 : 	if (tab_bar->WantLayout)

	mov	rax, QWORD PTR tab_bar$[rsp]
	movzx	eax, BYTE PTR [rax+88]
	test	eax, eax
	je	SHORT $LN3@EndTabBar

; 6522 : 		TabBarLayout(tab_bar);

	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z ; ImGui::TabBarLayout
	npad	1
$LN3@EndTabBar:

; 6523 : 
; 6524 : 	// Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().
; 6525 : 	const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+12]
	inc	eax
	mov	rcx, QWORD PTR g$[rsp]
	cmp	eax, DWORD PTR [rcx+6552]
	jge	SHORT $LN9@EndTabBar
	mov	BYTE PTR tv79[rsp], 1
	jmp	SHORT $LN10@EndTabBar
$LN9@EndTabBar:
	mov	BYTE PTR tv79[rsp], 0
$LN10@EndTabBar:
	movzx	eax, BYTE PTR tv79[rsp]
	mov	BYTE PTR tab_bar_appearing$[rsp], al

; 6526 : 	if (tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 || tab_bar_appearing)

	mov	rax, QWORD PTR tab_bar$[rsp]
	movzx	eax, BYTE PTR [rax+120]
	test	eax, eax
	jne	SHORT $LN6@EndTabBar
	mov	rax, QWORD PTR tab_bar$[rsp]
	cmp	DWORD PTR [rax+4], 0
	je	SHORT $LN6@EndTabBar
	movzx	eax, BYTE PTR tab_bar_appearing$[rsp]
	test	eax, eax
	je	SHORT $LN4@EndTabBar
$LN6@EndTabBar:

; 6527 : 		tab_bar->ContentsHeight = ImMax(window->DC.CursorPos.y - tab_bar->BarRect.Max.y, 0.0f);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	subss	xmm0, DWORD PTR [rcx+48]
	xorps	xmm1, xmm1
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR tab_bar$[rsp]
	movss	DWORD PTR [rax+56], xmm0
	jmp	SHORT $LN5@EndTabBar
$LN4@EndTabBar:

; 6528 : 	else
; 6529 : 		window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->ContentsHeight;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx+56]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+344], xmm0
$LN5@EndTabBar:

; 6530 : 
; 6531 : 	if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	eax, DWORD PTR [rax+72]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	jne	SHORT $LN7@EndTabBar

; 6532 : 		PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	npad	1
$LN7@EndTabBar:

; 6533 : 	g.CurrentTabBar.pop_back();

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7800				; 00001e78H
	mov	rcx, rax
	call	?pop_back@?$ImVector@PEAUImGuiTabBar@@@@QEAAXXZ ; ImVector<ImGuiTabBar *>::pop_back
	npad	1
$LN1@EndTabBar:

; 6534 : }

	add	rsp, 72					; 00000048H
	ret	0
?EndTabBar@ImGui@@YAXXZ ENDP				; ImGui::EndTabBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
id$ = 48
window$ = 56
g$ = 64
tab_bar$ = 72
tv77 = 80
tab_bar_bb$ = 88
str_id$ = 128
flags$ = 136
?BeginTabBar@ImGui@@YA_NPEBDH@Z PROC			; ImGui::BeginTabBar

; 6450 : {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 6451 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6452 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 6453 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@BeginTabBa

; 6454 : 		return false;

	xor	al, al
	jmp	$LN1@BeginTabBa
$LN2@BeginTabBa:

; 6455 : 
; 6456 : 	ImGuiID id = window->GetID(str_id);

	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 6457 : 	ImGuiTabBar* tab_bar = g.TabBars.GetOrAddByKey(id);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 7744				; 00001e40H
	mov	QWORD PTR tv77[rsp], rax
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QEAAPEAUImGuiTabBar@@I@Z ; ImPool<ImGuiTabBar>::GetOrAddByKey
	mov	QWORD PTR tab_bar$[rsp], rax

; 6458 : 	ImRect tab_bar_bb = ImRect(window->DC.CursorPos.x, window->DC.CursorPos.y, window->InnerClipRect.Max.x, window->DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	addss	xmm0, DWORD PTR [rcx+6408]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5528]
	mulss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	movss	DWORD PTR [rsp+32], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm3, DWORD PTR [rax+608]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm2, DWORD PTR [rax+344]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+340]
	lea	rcx, QWORD PTR tab_bar_bb$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect

; 6459 : 	tab_bar->ID = id;

	mov	rax, QWORD PTR tab_bar$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 6460 : 	return BeginTabBarEx(tab_bar, tab_bar_bb, flags | ImGuiTabBarFlags_IsFocused);

	mov	eax, DWORD PTR flags$[rsp]
	bts	eax, 21
	mov	r8d, eax
	lea	rdx, QWORD PTR tab_bar_bb$[rsp]
	mov	rcx, QWORD PTR tab_bar$[rsp]
	call	?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@H@Z ; ImGui::BeginTabBarEx
$LN1@BeginTabBa:

; 6461 : }

	add	rsp, 120				; 00000078H
	ret	0
?BeginTabBar@ImGui@@YA_NPEBDH@Z ENDP			; ImGui::BeginTabBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv67 = 32
tv72 = 33
tv78 = 36
label$ = 64
shortcut$ = 72
p_selected$ = 80
enabled$ = 88
?MenuItem@ImGui@@YA_NPEBD0PEA_N_N@Z PROC		; ImGui::MenuItem

; 6375 : {

$LN9:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6376 : 	if (MenuItem(label, shortcut, p_selected ? *p_selected : false, enabled))

	movzx	eax, BYTE PTR enabled$[rsp]
	mov	BYTE PTR tv72[rsp], al
	cmp	QWORD PTR p_selected$[rsp], 0
	je	SHORT $LN5@MenuItem
	mov	rax, QWORD PTR p_selected$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv67[rsp], al
	jmp	SHORT $LN6@MenuItem
$LN5@MenuItem:
	mov	BYTE PTR tv67[rsp], 0
$LN6@MenuItem:
	movzx	r9d, BYTE PTR tv72[rsp]
	movzx	r8d, BYTE PTR tv67[rsp]
	mov	rdx, QWORD PTR shortcut$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?MenuItem@ImGui@@YA_NPEBD0_N1@Z		; ImGui::MenuItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@MenuItem

; 6377 : 	{
; 6378 : 		if (p_selected)

	cmp	QWORD PTR p_selected$[rsp], 0
	je	SHORT $LN3@MenuItem

; 6379 : 			*p_selected = !*p_selected;

	mov	rax, QWORD PTR p_selected$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN7@MenuItem
	mov	DWORD PTR tv78[rsp], 1
	jmp	SHORT $LN8@MenuItem
$LN7@MenuItem:
	mov	DWORD PTR tv78[rsp], 0
$LN8@MenuItem:
	mov	rax, QWORD PTR p_selected$[rsp]
	movzx	ecx, BYTE PTR tv78[rsp]
	mov	BYTE PTR [rax], cl
$LN3@MenuItem:

; 6380 : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@MenuItem
$LN2@MenuItem:

; 6381 : 	}
; 6382 : 	return false;

	xor	al, al
$LN1@MenuItem:

; 6383 : }

	add	rsp, 56					; 00000038H
	ret	0
?MenuItem@ImGui@@YA_NPEBD0PEA_N_N@Z ENDP		; ImGui::MenuItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
pressed$ = 48
window$ = 56
g$ = 64
tv79 = 72
w$1 = 76
flags$ = 80
tv236 = 84
extra_w$2 = 88
w$3 = 92
tv264 = 96
tv261 = 100
style$ = 104
tv170 = 112
label_size$ = 120
shortcut_size$4 = 128
pos$ = 136
$T5 = 144
tv184 = 152
$T6 = 160
$T7 = 168
$T8 = 176
$T9 = 184
$T10 = 192
$T11 = 200
$T12 = 208
$T13 = 216
$T14 = 224
$T15 = 232
$T16 = 240
$T17 = 248
label$ = 272
shortcut$ = 280
selected$ = 288
enabled$ = 296
?MenuItem@ImGui@@YA_NPEBD0_N1@Z PROC			; ImGui::MenuItem

; 6331 : {

$LN17:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 264				; 00000108H

; 6332 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 6333 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN5@MenuItem

; 6334 : 		return false;

	xor	al, al
	jmp	$LN1@MenuItem
$LN5@MenuItem:

; 6335 : 
; 6336 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6337 : 	ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 6338 : 	ImVec2 pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR pos$[rsp], rax

; 6339 : 	ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 6340 : 
; 6341 : 	ImGuiSelectableFlags flags = ImGuiSelectableFlags_PressedOnRelease | (enabled ? 0 : ImGuiSelectableFlags_Disabled);

	movzx	eax, BYTE PTR enabled$[rsp]
	test	eax, eax
	je	SHORT $LN11@MenuItem
	mov	DWORD PTR tv79[rsp], 0
	jmp	SHORT $LN12@MenuItem
$LN11@MenuItem:
	mov	DWORD PTR tv79[rsp], 8
$LN12@MenuItem:
	mov	eax, DWORD PTR tv79[rsp]
	bts	eax, 12
	mov	DWORD PTR flags$[rsp], eax

; 6342 : 	bool pressed;
; 6343 : 	if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+468], 0
	jne	$LN6@MenuItem

; 6344 : 	{
; 6345 : 		// Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful
; 6346 : 		// Note that in this situation we render neither the shortcut neither the selected tick mark
; 6347 : 		float w = label_size.x;

	movss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR w$3[rsp], xmm0

; 6348 : 		window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+68]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+340]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 6349 : 		PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);

	mov	rax, QWORD PTR style$[rsp]
	add	rax, 68					; 00000044H
	movss	xmm2, DWORD PTR __real@40000000
	mov	rdx, rax
	lea	rcx, QWORD PTR $T8[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rdx, rax
	mov	ecx, 13
	call	?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z	; ImGui::PushStyleVar
	npad	1

; 6350 : 		pressed = Selectable(label, false, flags, ImVec2(w, 0.0f));

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR w$3[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9, rax
	mov	r8d, DWORD PTR flags$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	mov	BYTE PTR pressed$[rsp], al

; 6351 : 		PopStyleVar();

	mov	ecx, 1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 6352 : 		window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+68]
	mulss	xmm0, DWORD PTR __real@bf000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+340]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 6353 : 	}

	jmp	$LN7@MenuItem
$LN6@MenuItem:

; 6354 : 	else
; 6355 : 	{
; 6356 : 		ImVec2 shortcut_size = shortcut ? CalcTextSize(shortcut, NULL) : ImVec2(0.0f, 0.0f);

	cmp	QWORD PTR shortcut$[rsp], 0
	je	SHORT $LN13@MenuItem
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR shortcut$[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	mov	QWORD PTR tv170[rsp], rax
	jmp	SHORT $LN14@MenuItem
$LN13@MenuItem:
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv170[rsp], rax
$LN14@MenuItem:
	mov	rax, QWORD PTR tv170[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rax, QWORD PTR $T5[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR shortcut_size$4[rsp], rax

; 6357 : 		float w = window->MenuColumns.DeclColumns(label_size.x, shortcut_size.x, (float)(int)(g.FontSize * 1.20f)); // Feedback for next frame

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 616				; 00000268H
	mov	QWORD PTR tv184[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f99999a
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movaps	xmm3, xmm0
	movss	xmm2, DWORD PTR shortcut_size$4[rsp]
	movss	xmm1, DWORD PTR label_size$[rsp]
	mov	rcx, QWORD PTR tv184[rsp]
	call	?DeclColumns@ImGuiMenuColumns@@QEAAMMMM@Z ; ImGuiMenuColumns::DeclColumns
	movss	DWORD PTR w$1[rsp], xmm0

; 6358 : 		float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);

	lea	rcx, QWORD PTR $T12[rsp]
	call	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR w$1[rsp]
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR extra_w$2[rsp], xmm0

; 6359 : 		pressed = Selectable(label, false, flags | ImGuiSelectableFlags_DrawFillAvailWidth, ImVec2(w, 0.0f));

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR w$1[rsp]
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	ecx, DWORD PTR flags$[rsp]
	bts	ecx, 13
	mov	r9, rax
	mov	r8d, ecx
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	mov	BYTE PTR pressed$[rsp], al

; 6360 : 		if (shortcut_size.x > 0.0f)

	movss	xmm0, DWORD PTR shortcut_size$4[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN8@MenuItem

; 6361 : 		{
; 6362 : 			PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax+5640]
	mov	rdx, rax
	xor	ecx, ecx
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor
	npad	1

; 6363 : 			RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+632]
	addss	xmm0, DWORD PTR extra_w$2[rsp]
	xorps	xmm2, xmm2
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T15[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR shortcut$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1

; 6364 : 			PopStyleColor();

	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	npad	1
$LN8@MenuItem:

; 6365 : 		}
; 6366 : 		if (selected)

	movzx	eax, BYTE PTR selected$[rsp]
	test	eax, eax
	je	$LN9@MenuItem

; 6367 : 			RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled), g.FontSize * 0.866f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f5db22d
	movss	DWORD PTR tv264[rsp], xmm0
	movzx	eax, BYTE PTR enabled$[rsp]
	test	eax, eax
	je	SHORT $LN15@MenuItem
	mov	DWORD PTR tv236[rsp], 0
	jmp	SHORT $LN16@MenuItem
$LN15@MenuItem:
	mov	DWORD PTR tv236[rsp], 1
$LN16@MenuItem:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv236[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv261[rsp], eax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3e09374c
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rcx+rax+632]
	addss	xmm1, DWORD PTR extra_w$2[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR [rax+6408]
	mulss	xmm2, DWORD PTR __real@3ecccccd
	addss	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T17[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T6[rsp], rax
	mov	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR $T7[rsp], rax
	movss	xmm2, DWORD PTR tv264[rsp]
	mov	edx, DWORD PTR tv261[rsp]
	mov	rcx, QWORD PTR $T7[rsp]
	call	?RenderCheckMark@ImGui@@YAXUImVec2@@IM@Z ; ImGui::RenderCheckMark
	npad	1
$LN9@MenuItem:
$LN7@MenuItem:
$LN4@MenuItem:

; 6368 : 	}
; 6369 : 
; 6370 : 	IMGUI_TEST_ENGINE_ITEM_INFO(window->DC.LastItemId, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | (selected ? ImGuiItemStatusFlags_Checked : 0));

	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@MenuItem

; 6371 : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@MenuItem:

; 6372 : }

	add	rsp, 264				; 00000108H
	ret	0
?MenuItem@ImGui@@YA_NPEBD0_N1@Z ENDP			; ImGui::MenuItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 32
window$ = 40
?EndMenu@ImGui@@YAXXZ PROC				; ImGui::EndMenu

; 6315 : {

$LN4:
	sub	rsp, 56					; 00000038H

; 6316 : 	// Nav: When a left move request _within our child menu_ failed, close ourselves (the _parent_ menu).
; 6317 : 	// A menu doesn't close itself because EndMenuBar() wants the catch the last Left<>Right inputs.
; 6318 : 	// However, it means that with the current code, a BeginMenu() from outside another menu or a menu-bar won't be closable with the Left direction.
; 6319 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6320 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 6321 : 	if (g.NavWindow && g.NavWindow->ParentWindow == window && g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet() && window->DC.LayoutType == ImGuiLayoutType_Vertical)

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+7024], 0
	je	SHORT $LN2@EndMenu
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+880], rcx
	jne	SHORT $LN2@EndMenu
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 0
	jne	SHORT $LN2@EndMenu
	call	?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ ; ImGui::NavMoveRequestButNoResultYet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@EndMenu
	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+468], 1
	jne	SHORT $LN2@EndMenu

; 6322 : 	{
; 6323 : 		ClosePopupToLevel(g.BeginPopupStack.Size, true);

	mov	dl, 1
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+6888]
	call	?ClosePopupToLevel@ImGui@@YAXH_N@Z	; ImGui::ClosePopupToLevel

; 6324 : 		NavMoveRequestCancel();

	call	?NavMoveRequestCancel@ImGui@@YAXXZ	; ImGui::NavMoveRequestCancel
	npad	1
$LN2@EndMenu:

; 6325 : 	}
; 6326 : 
; 6327 : 	EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	npad	1

; 6328 : }

	add	rsp, 56					; 00000038H
	ret	0
?EndMenu@ImGui@@YAXXZ ENDP				; ImGui::EndMenu
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
menu_is_open$ = 48
want_open$ = 49
want_close$ = 50
pressed$ = 51
hovered$ = 52
menuset_is_open$ = 53
g$ = 56
moving_within_opened_triangle$1 = 64
window$ = 72
tv300 = 80
id$ = 84
ta$2 = 88
flags$3 = 96
style$ = 104
tv133 = 112
tv197 = 116
w$4 = 120
tv254 = 124
tv417 = 128
extra$5 = 132
tv450 = 136
tv464 = 140
tv470 = 144
pos$ = 152
next_window$6 = 160
tb$7 = 168
tv150 = 176
tv167 = 180
tv165 = 184
w$8 = 188
extra_w$9 = 192
tc$10 = 200
popup_pos$ = 208
label_size$ = 216
tv389 = 224
tv402 = 232
next_window_rect$11 = 240
tv95 = 256
tv90 = 264
tv203 = 272
tv238 = 280
tv260 = 288
backed_nav_window$ = 296
tv353 = 304
tv366 = 312
$T12 = 320
$T13 = 328
$T14 = 336
$T15 = 344
$T16 = 352
$T17 = 360
$T18 = 368
$T19 = 376
$T20 = 384
$T21 = 392
$T22 = 400
$T23 = 408
$T24 = 416
$T25 = 424
$T26 = 432
label$ = 464
enabled$ = 472
?BeginMenu@ImGui@@YA_NPEBD_N@Z PROC			; ImGui::BeginMenu

; 6176 : {

$LN53:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 456				; 000001c8H

; 6177 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 6178 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN5@BeginMenu

; 6179 : 		return false;

	xor	al, al
	jmp	$LN1@BeginMenu
$LN5@BeginMenu:

; 6180 : 
; 6181 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6182 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 6183 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 6184 : 
; 6185 : 	ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 6186 : 
; 6187 : 	bool pressed;
; 6188 : 	bool menu_is_open = IsPopupOpen(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?IsPopupOpen@ImGui@@YA_NI@Z		; ImGui::IsPopupOpen
	mov	BYTE PTR menu_is_open$[rsp], al

; 6189 : 	bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].OpenParentId == window->IDStack.back());

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	jne	SHORT $LN31@BeginMenu
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6888]
	cmp	DWORD PTR [rax+6872], ecx
	jle	SHORT $LN31@BeginMenu
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv95[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+6888]
	mov	rcx, QWORD PTR tv95[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	QWORD PTR tv90[rsp], rax
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 232				; 000000e8H
	call	?back@?$ImVector@I@@QEAAAEAIXZ		; ImVector<unsigned int>::back
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR tv90[rsp]
	cmp	DWORD PTR [rcx+4], eax
	jne	SHORT $LN31@BeginMenu
	mov	DWORD PTR tv133[rsp], 1
	jmp	SHORT $LN32@BeginMenu
$LN31@BeginMenu:
	mov	DWORD PTR tv133[rsp], 0
$LN32@BeginMenu:
	movzx	eax, BYTE PTR tv133[rsp]
	mov	BYTE PTR menuset_is_open$[rsp], al

; 6190 : 	ImGuiWindow* backed_nav_window = g.NavWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	QWORD PTR backed_nav_window$[rsp], rax

; 6191 : 	if (menuset_is_open)

	movzx	eax, BYTE PTR menuset_is_open$[rsp]
	test	eax, eax
	je	SHORT $LN6@BeginMenu

; 6192 : 		g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rax+7024], rcx
$LN6@BeginMenu:

; 6193 : 
; 6194 : 	// The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu,
; 6195 : 	// However the final position is going to be different! It is choosen by FindBestWindowPosForPopup().
; 6196 : 	// e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.
; 6197 : 	ImVec2 popup_pos, pos = window->DC.CursorPos;

	lea	rcx, QWORD PTR popup_pos$[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR pos$[rsp], rax

; 6198 : 	if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+468], 0
	jne	$LN7@BeginMenu

; 6199 : 	{
; 6200 : 		// Menu inside an horizontal menu bar
; 6201 : 		// Selectable extend their highlight by half ItemSpacing in each direction.
; 6202 : 		// For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()
; 6203 : 		popup_pos = ImVec2(pos.x - 1.0f - (float)(int)(style.ItemSpacing.x * 0.5f), pos.y - style.FramePadding.y + window->MenuBarHeight());

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR pos$[rsp+4]
	subss	xmm0, DWORD PTR [rax+56]
	movss	DWORD PTR tv150[rsp], xmm0
	mov	rcx, QWORD PTR window$[rsp]
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	movss	xmm1, DWORD PTR tv150[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv167[rsp], xmm0
	movss	xmm0, DWORD PTR pos$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+68]
	mulss	xmm1, DWORD PTR __real@3f000000
	cvttss2si eax, xmm1
	cvtsi2ss xmm1, eax
	subss	xmm0, xmm1
	movss	DWORD PTR tv165[rsp], xmm0
	movss	xmm2, DWORD PTR tv167[rsp]
	movss	xmm1, DWORD PTR tv165[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR popup_pos$[rsp], rax

; 6204 : 		window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+68]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+340]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 6205 : 		PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);

	mov	rax, QWORD PTR style$[rsp]
	add	rax, 68					; 00000044H
	movss	xmm2, DWORD PTR __real@40000000
	mov	rdx, rax
	lea	rcx, QWORD PTR $T15[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	rdx, rax
	mov	ecx, 13
	call	?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z	; ImGui::PushStyleVar
	npad	1

; 6206 : 		float w = label_size.x;

	movss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR w$8[rsp], xmm0

; 6207 : 		pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR w$8[rsp]
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv203[rsp], rax
	movzx	eax, BYTE PTR enabled$[rsp]
	test	eax, eax
	jne	SHORT $LN33@BeginMenu
	mov	DWORD PTR tv197[rsp], 8
	jmp	SHORT $LN34@BeginMenu
$LN33@BeginMenu:
	mov	DWORD PTR tv197[rsp], 0
$LN34@BeginMenu:
	mov	eax, DWORD PTR tv197[rsp]
	or	eax, 3073				; 00000c01H
	mov	r9, QWORD PTR tv203[rsp]
	mov	r8d, eax
	movzx	edx, BYTE PTR menu_is_open$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	mov	BYTE PTR pressed$[rsp], al

; 6208 : 		PopStyleVar();

	mov	ecx, 1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 6209 : 		window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+68]
	mulss	xmm0, DWORD PTR __real@bf000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+340]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+340], xmm0

; 6210 : 	}

	jmp	$LN8@BeginMenu
$LN7@BeginMenu:

; 6211 : 	else
; 6212 : 	{
; 6213 : 		// Menu inside a menu
; 6214 : 		popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR pos$[rsp+4]
	subss	xmm0, DWORD PTR [rax+8]
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR popup_pos$[rsp], rax

; 6215 : 		float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, (float)(int)(g.FontSize * 1.20f)); // Feedback to next frame

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 616				; 00000268H
	mov	QWORD PTR tv238[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f99999a
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movaps	xmm3, xmm0
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR label_size$[rsp]
	mov	rcx, QWORD PTR tv238[rsp]
	call	?DeclColumns@ImGuiMenuColumns@@QEAAMMMM@Z ; ImGuiMenuColumns::DeclColumns
	movss	DWORD PTR w$4[rsp], xmm0

; 6216 : 		float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);

	lea	rcx, QWORD PTR $T18[rsp]
	call	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR w$4[rsp]
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR extra_w$9[rsp], xmm0

; 6217 : 		pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_DrawFillAvailWidth | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR w$4[rsp]
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv260[rsp], rax
	movzx	eax, BYTE PTR enabled$[rsp]
	test	eax, eax
	jne	SHORT $LN35@BeginMenu
	mov	DWORD PTR tv254[rsp], 8
	jmp	SHORT $LN36@BeginMenu
$LN35@BeginMenu:
	mov	DWORD PTR tv254[rsp], 0
$LN36@BeginMenu:
	mov	eax, DWORD PTR tv254[rsp]
	or	eax, 11265				; 00002c01H
	mov	r9, QWORD PTR tv260[rsp]
	mov	r8d, eax
	movzx	edx, BYTE PTR menu_is_open$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	mov	BYTE PTR pressed$[rsp], al

; 6218 : 		if (!enabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);

	movzx	eax, BYTE PTR enabled$[rsp]
	test	eax, eax
	jne	SHORT $LN9@BeginMenu
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax+5640]
	mov	rdx, rax
	xor	ecx, ecx
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor
	npad	1
$LN9@BeginMenu:

; 6219 : 		RenderArrow(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.30f, 0.0f), ImGuiDir_Right);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax+632]
	addss	xmm0, DWORD PTR extra_w$9[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	mulss	xmm1, DWORD PTR __real@3e99999a
	addss	xmm0, xmm1
	xorps	xmm2, xmm2
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T20[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	movss	xmm2, DWORD PTR __real@3f800000
	mov	edx, 1
	mov	rcx, QWORD PTR [rax]
	call	?RenderArrow@ImGui@@YAXUImVec2@@HM@Z	; ImGui::RenderArrow
	npad	1

; 6220 : 		if (!enabled) PopStyleColor();

	movzx	eax, BYTE PTR enabled$[rsp]
	test	eax, eax
	jne	SHORT $LN10@BeginMenu
	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	npad	1
$LN10@BeginMenu:
$LN8@BeginMenu:

; 6221 : 	}
; 6222 : 
; 6223 : 	const bool hovered = enabled && ItemHoverable(window->DC.LastItemRect, id);

	movzx	eax, BYTE PTR enabled$[rsp]
	test	eax, eax
	je	SHORT $LN37@BeginMenu
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 368				; 00000170H
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, rax
	call	?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z ; ImGui::ItemHoverable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN37@BeginMenu
	mov	BYTE PTR tv300[rsp], 1
	jmp	SHORT $LN38@BeginMenu
$LN37@BeginMenu:
	mov	BYTE PTR tv300[rsp], 0
$LN38@BeginMenu:
	movzx	eax, BYTE PTR tv300[rsp]
	mov	BYTE PTR hovered$[rsp], al

; 6224 : 	if (menuset_is_open)

	movzx	eax, BYTE PTR menuset_is_open$[rsp]
	test	eax, eax
	je	SHORT $LN11@BeginMenu

; 6225 : 		g.NavWindow = backed_nav_window;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR backed_nav_window$[rsp]
	mov	QWORD PTR [rax+7024], rcx
$LN11@BeginMenu:

; 6226 : 
; 6227 : 	bool want_open = false, want_close = false;

	mov	BYTE PTR want_open$[rsp], 0
	mov	BYTE PTR want_close$[rsp], 0

; 6228 : 	if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+468], 1
	jne	$LN12@BeginMenu

; 6229 : 	{
; 6230 : 		// Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
; 6231 : 		bool moving_within_opened_triangle = false;

	mov	BYTE PTR moving_within_opened_triangle$1[rsp], 0

; 6232 : 		if (g.HoveredWindow == window && g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].ParentWindow == window && !(window->Flags & ImGuiWindowFlags_MenuBar))

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+6560], rcx
	jne	$LN14@BeginMenu
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6888]
	cmp	DWORD PTR [rax+6872], ecx
	jle	$LN14@BeginMenu
	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv353[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+6888]
	mov	rcx, QWORD PTR tv353[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+40], rcx
	jne	$LN14@BeginMenu
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1024				; 00000400H
	test	eax, eax
	jne	$LN14@BeginMenu

; 6233 : 		{
; 6234 : 			if (ImGuiWindow* next_window = g.OpenPopupStack[g.BeginPopupStack.Size].Window)

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 6872				; 00001ad8H
	mov	QWORD PTR tv366[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+6888]
	mov	rcx, QWORD PTR tv366[rsp]
	call	??A?$ImVector@UImGuiPopupRef@@@@QEAAAEAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR next_window$6[rsp], rax
	cmp	QWORD PTR next_window$6[rsp], 0
	je	$LN15@BeginMenu

; 6235 : 			{
; 6236 : 				// FIXME-DPI: Values should be derived from a master "scale" factor.
; 6237 : 				ImRect next_window_rect = next_window->Rect();

	lea	rdx, QWORD PTR next_window_rect$11[rsp]
	mov	rcx, QWORD PTR next_window$6[rsp]
	call	?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ	; ImGuiWindow::Rect

; 6238 : 				ImVec2 ta = g.IO.MousePos - g.IO.MouseDelta;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 968				; 000003c8H
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 316				; 0000013cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR ta$2[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	npad	1

; 6239 : 				ImVec2 tb = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();

	mov	rax, QWORD PTR next_window$6[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	comiss	xmm0, DWORD PTR [rcx+48]
	jbe	SHORT $LN39@BeginMenu
	lea	rdx, QWORD PTR $T21[rsp]
	lea	rcx, QWORD PTR next_window_rect$11[rsp]
	call	?GetTL@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetTL
	mov	QWORD PTR tv389[rsp], rax
	jmp	SHORT $LN40@BeginMenu
$LN39@BeginMenu:
	lea	rdx, QWORD PTR $T22[rsp]
	lea	rcx, QWORD PTR next_window_rect$11[rsp]
	call	?GetTR@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetTR
	mov	QWORD PTR tv389[rsp], rax
$LN40@BeginMenu:
	mov	rax, QWORD PTR tv389[rsp]
	mov	QWORD PTR $T12[rsp], rax
	mov	rax, QWORD PTR $T12[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tb$7[rsp], rax

; 6240 : 				ImVec2 tc = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();

	mov	rax, QWORD PTR next_window$6[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	comiss	xmm0, DWORD PTR [rcx+48]
	jbe	SHORT $LN41@BeginMenu
	lea	rdx, QWORD PTR $T23[rsp]
	lea	rcx, QWORD PTR next_window_rect$11[rsp]
	call	?GetBL@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetBL
	mov	QWORD PTR tv402[rsp], rax
	jmp	SHORT $LN42@BeginMenu
$LN41@BeginMenu:
	lea	rdx, QWORD PTR $T24[rsp]
	lea	rcx, QWORD PTR next_window_rect$11[rsp]
	call	?GetBR@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetBR
	mov	QWORD PTR tv402[rsp], rax
$LN42@BeginMenu:
	mov	rax, QWORD PTR tv402[rsp]
	mov	QWORD PTR $T13[rsp], rax
	mov	rax, QWORD PTR $T13[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tc$10[rsp], rax

; 6241 : 				float extra = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, 5.0f, 30.0f); // add a bit of extra slack.

	movss	xmm0, DWORD PTR ta$2[rsp]
	subss	xmm0, DWORD PTR tb$7[rsp]
	call	?ImFabs@@YAMM@Z				; ImFabs
	mulss	xmm0, DWORD PTR __real@3e99999a
	movss	xmm2, DWORD PTR __real@41f00000
	movss	xmm1, DWORD PTR __real@40a00000
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR extra$5[rsp], xmm0

; 6242 : 				ta.x += (window->Pos.x < next_window->Pos.x) ? -0.5f : +0.5f;    // to avoid numerical issues

	mov	rax, QWORD PTR next_window$6[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	comiss	xmm0, DWORD PTR [rcx+48]
	jbe	SHORT $LN43@BeginMenu
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR tv417[rsp], xmm0
	jmp	SHORT $LN44@BeginMenu
$LN43@BeginMenu:
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv417[rsp], xmm0
$LN44@BeginMenu:
	movss	xmm0, DWORD PTR ta$2[rsp]
	addss	xmm0, DWORD PTR tv417[rsp]
	movss	DWORD PTR ta$2[rsp], xmm0

; 6243 : 				tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -100.0f);             // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?

	movss	xmm0, DWORD PTR tb$7[rsp+4]
	subss	xmm0, DWORD PTR extra$5[rsp]
	subss	xmm0, DWORD PTR ta$2[rsp+4]
	movss	xmm1, DWORD PTR __real@c2c80000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	xmm1, DWORD PTR ta$2[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tb$7[rsp+4], xmm0

; 6244 : 				tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +100.0f);

	movss	xmm0, DWORD PTR tc$10[rsp+4]
	addss	xmm0, DWORD PTR extra$5[rsp]
	subss	xmm0, DWORD PTR ta$2[rsp+4]
	movss	xmm1, DWORD PTR __real@42c80000
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	xmm1, DWORD PTR ta$2[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tc$10[rsp+4], xmm0

; 6245 : 				moving_within_opened_triangle = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	mov	r9, rax
	lea	r8, QWORD PTR tc$10[rsp]
	lea	rdx, QWORD PTR tb$7[rsp]
	lea	rcx, QWORD PTR ta$2[rsp]
	call	?ImTriangleContainsPoint@@YA_NAEBUImVec2@@000@Z ; ImTriangleContainsPoint
	mov	BYTE PTR moving_within_opened_triangle$1[rsp], al
$LN15@BeginMenu:
$LN14@BeginMenu:

; 6246 : 				//window->DrawList->PushClipRectFullScreen(); window->DrawList->AddTriangleFilled(ta, tb, tc, moving_within_opened_triangle ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); window->DrawList->PopClipRect(); // Debug
; 6247 : 			}
; 6248 : 		}
; 6249 : 
; 6250 : 		want_close = (menu_is_open && !hovered && g.HoveredWindow == window && g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id && !moving_within_opened_triangle);

	movzx	eax, BYTE PTR menu_is_open$[rsp]
	test	eax, eax
	je	SHORT $LN45@BeginMenu
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	jne	SHORT $LN45@BeginMenu
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+6560], rcx
	jne	SHORT $LN45@BeginMenu
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6724], 0
	je	SHORT $LN45@BeginMenu
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6724], ecx
	je	SHORT $LN45@BeginMenu
	movzx	eax, BYTE PTR moving_within_opened_triangle$1[rsp]
	test	eax, eax
	jne	SHORT $LN45@BeginMenu
	mov	DWORD PTR tv450[rsp], 1
	jmp	SHORT $LN46@BeginMenu
$LN45@BeginMenu:
	mov	DWORD PTR tv450[rsp], 0
$LN46@BeginMenu:
	movzx	eax, BYTE PTR tv450[rsp]
	mov	BYTE PTR want_close$[rsp], al

; 6251 : 		want_open = (!menu_is_open && hovered && !moving_within_opened_triangle) || (!menu_is_open && hovered && pressed);

	movzx	eax, BYTE PTR menu_is_open$[rsp]
	test	eax, eax
	jne	SHORT $LN47@BeginMenu
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN47@BeginMenu
	movzx	eax, BYTE PTR moving_within_opened_triangle$1[rsp]
	test	eax, eax
	je	SHORT $LN49@BeginMenu
$LN47@BeginMenu:
	movzx	eax, BYTE PTR menu_is_open$[rsp]
	test	eax, eax
	jne	SHORT $LN48@BeginMenu
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN48@BeginMenu
	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	jne	SHORT $LN49@BeginMenu
$LN48@BeginMenu:
	mov	DWORD PTR tv464[rsp], 0
	jmp	SHORT $LN50@BeginMenu
$LN49@BeginMenu:
	mov	DWORD PTR tv464[rsp], 1
$LN50@BeginMenu:
	movzx	eax, BYTE PTR tv464[rsp]
	mov	BYTE PTR want_open$[rsp], al

; 6252 : 
; 6253 : 		if (g.NavActivateId == id)

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7044], ecx
	jne	SHORT $LN16@BeginMenu

; 6254 : 		{
; 6255 : 			want_close = menu_is_open;

	movzx	eax, BYTE PTR menu_is_open$[rsp]
	mov	BYTE PTR want_close$[rsp], al

; 6256 : 			want_open = !menu_is_open;

	movzx	eax, BYTE PTR menu_is_open$[rsp]
	test	eax, eax
	jne	SHORT $LN51@BeginMenu
	mov	DWORD PTR tv470[rsp], 1
	jmp	SHORT $LN52@BeginMenu
$LN51@BeginMenu:
	mov	DWORD PTR tv470[rsp], 0
$LN52@BeginMenu:
	movzx	eax, BYTE PTR tv470[rsp]
	mov	BYTE PTR want_open$[rsp], al
$LN16@BeginMenu:

; 6257 : 		}
; 6258 : 		if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7040], ecx
	jne	SHORT $LN17@BeginMenu
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	SHORT $LN17@BeginMenu
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 1
	jne	SHORT $LN17@BeginMenu

; 6259 : 		{
; 6260 : 			want_open = true;

	mov	BYTE PTR want_open$[rsp], 1

; 6261 : 			NavMoveRequestCancel();

	call	?NavMoveRequestCancel@ImGui@@YAXXZ	; ImGui::NavMoveRequestCancel
	npad	1
$LN17@BeginMenu:

; 6262 : 		}
; 6263 : 	}

	jmp	$LN13@BeginMenu
$LN12@BeginMenu:

; 6264 : 	else
; 6265 : 	{
; 6266 : 		// Menu bar
; 6267 : 		if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it

	movzx	eax, BYTE PTR menu_is_open$[rsp]
	test	eax, eax
	je	SHORT $LN18@BeginMenu
	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN18@BeginMenu
	movzx	eax, BYTE PTR menuset_is_open$[rsp]
	test	eax, eax
	je	SHORT $LN18@BeginMenu

; 6268 : 		{
; 6269 : 			want_close = true;

	mov	BYTE PTR want_close$[rsp], 1

; 6270 : 			want_open = menu_is_open = false;

	mov	BYTE PTR menu_is_open$[rsp], 0
	movzx	eax, BYTE PTR menu_is_open$[rsp]
	mov	BYTE PTR want_open$[rsp], al

; 6271 : 		}

	jmp	SHORT $LN19@BeginMenu
$LN18@BeginMenu:

; 6272 : 		else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	jne	SHORT $LN22@BeginMenu
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN20@BeginMenu
	movzx	eax, BYTE PTR menuset_is_open$[rsp]
	test	eax, eax
	je	SHORT $LN20@BeginMenu
	movzx	eax, BYTE PTR menu_is_open$[rsp]
	test	eax, eax
	jne	SHORT $LN20@BeginMenu
$LN22@BeginMenu:

; 6273 : 		{
; 6274 : 			want_open = true;

	mov	BYTE PTR want_open$[rsp], 1

; 6275 : 		}

	jmp	SHORT $LN21@BeginMenu
$LN20@BeginMenu:

; 6276 : 		else if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7040], ecx
	jne	SHORT $LN23@BeginMenu
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7171]
	test	eax, eax
	je	SHORT $LN23@BeginMenu
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 3
	jne	SHORT $LN23@BeginMenu

; 6277 : 		{
; 6278 : 			want_open = true;

	mov	BYTE PTR want_open$[rsp], 1

; 6279 : 			NavMoveRequestCancel();

	call	?NavMoveRequestCancel@ImGui@@YAXXZ	; ImGui::NavMoveRequestCancel
	npad	1
$LN23@BeginMenu:
$LN21@BeginMenu:
$LN19@BeginMenu:
$LN13@BeginMenu:

; 6280 : 		}
; 6281 : 	}
; 6282 : 
; 6283 : 	if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'

	movzx	eax, BYTE PTR enabled$[rsp]
	test	eax, eax
	jne	SHORT $LN24@BeginMenu

; 6284 : 		want_close = true;

	mov	BYTE PTR want_close$[rsp], 1
$LN24@BeginMenu:

; 6285 : 	if (want_close && IsPopupOpen(id))

	movzx	eax, BYTE PTR want_close$[rsp]
	test	eax, eax
	je	SHORT $LN25@BeginMenu
	mov	ecx, DWORD PTR id$[rsp]
	call	?IsPopupOpen@ImGui@@YA_NI@Z		; ImGui::IsPopupOpen
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@BeginMenu

; 6286 : 		ClosePopupToLevel(g.BeginPopupStack.Size, true);

	mov	dl, 1
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rax+6888]
	call	?ClosePopupToLevel@ImGui@@YAXH_N@Z	; ImGui::ClosePopupToLevel
	npad	1
$LN25@BeginMenu:
$LN4@BeginMenu:

; 6287 : 
; 6288 : 	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Openable | (menu_is_open ? ImGuiItemStatusFlags_Opened : 0));

	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@BeginMenu

; 6289 : 
; 6290 : 	if (!menu_is_open && want_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size)

	movzx	eax, BYTE PTR menu_is_open$[rsp]
	test	eax, eax
	jne	SHORT $LN26@BeginMenu
	movzx	eax, BYTE PTR want_open$[rsp]
	test	eax, eax
	je	SHORT $LN26@BeginMenu
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6888]
	cmp	DWORD PTR [rax+6872], ecx
	jle	SHORT $LN26@BeginMenu

; 6291 : 	{
; 6292 : 		// Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.
; 6293 : 		OpenPopup(label);

	mov	rcx, QWORD PTR label$[rsp]
	call	?OpenPopup@ImGui@@YAXPEBD@Z		; ImGui::OpenPopup

; 6294 : 		return false;

	xor	al, al
	jmp	$LN1@BeginMenu
$LN26@BeginMenu:

; 6295 : 	}
; 6296 : 
; 6297 : 	menu_is_open |= want_open;

	movzx	eax, BYTE PTR menu_is_open$[rsp]
	movzx	ecx, BYTE PTR want_open$[rsp]
	or	eax, ecx
	mov	BYTE PTR menu_is_open$[rsp], al

; 6298 : 	if (want_open)

	movzx	eax, BYTE PTR want_open$[rsp]
	test	eax, eax
	je	SHORT $LN27@BeginMenu

; 6299 : 		OpenPopup(label);

	mov	rcx, QWORD PTR label$[rsp]
	call	?OpenPopup@ImGui@@YAXPEBD@Z		; ImGui::OpenPopup
	npad	1
$LN27@BeginMenu:

; 6300 : 
; 6301 : 	if (menu_is_open)

	movzx	eax, BYTE PTR menu_is_open$[rsp]
	test	eax, eax
	je	SHORT $LN28@BeginMenu

; 6302 : 	{
; 6303 : 		// Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)
; 6304 : 		SetNextWindowPos(popup_pos, ImGuiCond_Always);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T25[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	mov	edx, 1
	lea	rcx, QWORD PTR popup_pos$[rsp]
	call	?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z ; ImGui::SetNextWindowPos
	npad	1

; 6305 : 		ImGuiWindowFlags flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar /*| ImGuiWindowFlags_NoSavedSettings */ | ImGuiWindowFlags_NoNavFocus;

	mov	DWORD PTR flags$3[rsp], 268959813	; 10080045H

; 6306 : 		if (window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu))

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 335544320				; 14000000H
	test	eax, eax
	je	SHORT $LN29@BeginMenu

; 6307 : 			flags |= ImGuiWindowFlags_ChildWindow;

	mov	eax, DWORD PTR flags$3[rsp]
	bts	eax, 24
	mov	DWORD PTR flags$3[rsp], eax
$LN29@BeginMenu:

; 6308 : 		menu_is_open = BeginPopupEx(id, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)

	mov	edx, DWORD PTR flags$3[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?BeginPopupEx@ImGui@@YA_NIH@Z		; ImGui::BeginPopupEx
	mov	BYTE PTR menu_is_open$[rsp], al
$LN28@BeginMenu:

; 6309 : 	}
; 6310 : 
; 6311 : 	return menu_is_open;

	movzx	eax, BYTE PTR menu_is_open$[rsp]
$LN1@BeginMenu:

; 6312 : }

	add	rsp, 456				; 000001c8H
	ret	0
?BeginMenu@ImGui@@YA_NPEBD_N@Z ENDP			; ImGui::BeginMenu
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 32
g$ = 40
nav_earliest_child$1 = 48
$T2 = 56
?EndMenuBar@ImGui@@YAXXZ PROC				; ImGui::EndMenuBar

; 6136 : {

$LN9:
	sub	rsp, 88					; 00000058H

; 6137 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 6138 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN4@EndMenuBar

; 6139 : 		return;

	jmp	$LN1@EndMenuBar
$LN4@EndMenuBar:

; 6140 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6141 : 
; 6142 : 	// Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.
; 6143 : 	if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))

	call	?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ ; ImGui::NavMoveRequestButNoResultYet
	movzx	eax, al
	test	eax, eax
	je	$LN5@EndMenuBar
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 0
	je	SHORT $LN6@EndMenuBar
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 1
	jne	$LN5@EndMenuBar
$LN6@EndMenuBar:
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	$LN5@EndMenuBar

; 6144 : 	{
; 6145 : 		ImGuiWindow* nav_earliest_child = g.NavWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+7024]
	mov	QWORD PTR nav_earliest_child$1[rsp], rax
$LN2@EndMenuBar:

; 6146 : 		while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))

	mov	rax, QWORD PTR nav_earliest_child$1[rsp]
	cmp	QWORD PTR [rax+880], 0
	je	SHORT $LN3@EndMenuBar
	mov	rax, QWORD PTR nav_earliest_child$1[rsp]
	mov	rax, QWORD PTR [rax+880]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $LN3@EndMenuBar

; 6147 : 			nav_earliest_child = nav_earliest_child->ParentWindow;

	mov	rax, QWORD PTR nav_earliest_child$1[rsp]
	mov	rax, QWORD PTR [rax+880]
	mov	QWORD PTR nav_earliest_child$1[rsp], rax
	jmp	SHORT $LN2@EndMenuBar
$LN3@EndMenuBar:

; 6148 : 		if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && g.NavMoveRequestForward == ImGuiNavForward_None)

	mov	rax, QWORD PTR nav_earliest_child$1[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+880], rcx
	jne	$LN7@EndMenuBar
	mov	rax, QWORD PTR nav_earliest_child$1[rsp]
	cmp	DWORD PTR [rax+472], 0
	jne	$LN7@EndMenuBar
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7272], 0
	jne	SHORT $LN7@EndMenuBar

; 6149 : 		{
; 6150 : 			// To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
; 6151 : 			// This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth the hassle/cost)
; 6152 : 			IM_ASSERT(window->DC.NavLayerActiveMaskNext & 0x02); // Sanity check
; 6153 : 			FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 6154 : 			SetNavIDWithRectRel(window->NavLastIds[1], 1, window->NavRectRel[1]);

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR window$[rsp]
	lea	rax, QWORD PTR [rcx+rax+912]
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	edx, 1
	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rax+rcx+904]
	call	?SetNavIDWithRectRel@ImGui@@YAXIHAEBUImRect@@@Z ; ImGui::SetNavIDWithRectRel

; 6155 : 			g.NavLayer = ImGuiNavLayer_Menu;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7132], 1

; 6156 : 			g.NavDisableHighlight = true; // Hide highlight for the current frame so we don't see the intermediary selection.

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 1

; 6157 : 			g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+7272], 1

; 6158 : 			NavMoveRequestCancel();

	call	?NavMoveRequestCancel@ImGui@@YAXXZ	; ImGui::NavMoveRequestCancel
	npad	1
$LN7@EndMenuBar:
$LN5@EndMenuBar:

; 6159 : 		}
; 6160 : 	}
; 6161 : 
; 6162 : 	IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);
; 6163 : 	IM_ASSERT(window->DC.MenuBarAppending);
; 6164 : 	PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect

; 6165 : 	PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	npad	1

; 6166 : 	window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->MenuBarRect().Min.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ ; ImGuiWindow::MenuBarRect
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+340]
	subss	xmm0, DWORD PTR [rax]
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+460], xmm0

; 6167 : 	window->DC.GroupStack.back().AdvanceCursor = false;

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 536				; 00000218H
	mov	rcx, rax
	call	?back@?$ImVector@UImGuiGroupData@@@@QEAAAEAUImGuiGroupData@@XZ ; ImVector<ImGuiGroupData>::back
	mov	BYTE PTR [rax+45], 0

; 6168 : 	EndGroup(); // Restore position on layer 0

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 6169 : 	window->DC.LayoutType = ImGuiLayoutType_Vertical;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+468], 1

; 6170 : 	window->DC.NavLayerCurrent = ImGuiNavLayer_Main;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+400], 0

; 6171 : 	window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+404], 1

; 6172 : 	window->DC.MenuBarAppending = false;

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+457], 0
$LN1@EndMenuBar:

; 6173 : }

	add	rsp, 88					; 00000058H
	ret	0
?EndMenuBar@ImGui@@YAXXZ ENDP				; ImGui::EndMenuBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv138 = 48
tv136 = 52
tv134 = 56
tv132 = 60
window$ = 64
$T1 = 72
bar_rect$ = 80
clip_rect$ = 96
?BeginMenuBar@ImGui@@YA_NXZ PROC			; ImGui::BeginMenuBar

; 6108 : {

$LN5:
	sub	rsp, 120				; 00000078H

; 6109 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 6110 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@BeginMenuB

; 6111 : 		return false;

	xor	al, al
	jmp	$LN1@BeginMenuB
$LN2@BeginMenuB:

; 6112 : 	if (!(window->Flags & ImGuiWindowFlags_MenuBar))

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 1024				; 00000400H
	test	eax, eax
	jne	SHORT $LN3@BeginMenuB

; 6113 : 		return false;

	xor	al, al
	jmp	$LN1@BeginMenuB
$LN3@BeginMenuB:

; 6114 : 
; 6115 : 	IM_ASSERT(!window->DC.MenuBarAppending);
; 6116 : 	BeginGroup(); // Backup position on layer 0

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 6117 : 	PushID(("##+-menubar"));

	lea	rcx, OFFSET FLAT:??_C@_0M@GEGHBGML@?$CD?$CD?$CL?9menubar@
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 6118 : 
; 6119 : 	// We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.
; 6120 : 	// We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.
; 6121 : 	ImRect bar_rect = window->MenuBarRect();

	lea	rdx, QWORD PTR bar_rect$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ ; ImGuiWindow::MenuBarRect

; 6122 : 	ImRect clip_rect(ImFloor(bar_rect.Min.x + 0.5f), ImFloor(bar_rect.Min.y + window->WindowBorderSize + 0.5f), ImFloor(ImMax(bar_rect.Min.x, bar_rect.Max.x - window->WindowRounding) + 0.5f), ImFloor(bar_rect.Max.y + 0.5f));

	movss	xmm0, DWORD PTR bar_rect$[rsp+12]
	addss	xmm0, DWORD PTR __real@3f000000
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR tv138[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR bar_rect$[rsp+8]
	subss	xmm0, DWORD PTR [rax+88]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR bar_rect$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	addss	xmm0, DWORD PTR __real@3f000000
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR tv136[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR bar_rect$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	addss	xmm0, DWORD PTR __real@3f000000
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR tv134[rsp], xmm0
	movss	xmm0, DWORD PTR bar_rect$[rsp]
	addss	xmm0, DWORD PTR __real@3f000000
	call	?ImFloor@@YAMM@Z			; ImFloor
	movss	DWORD PTR tv132[rsp], xmm0
	movss	xmm0, DWORD PTR tv138[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR tv136[rsp]
	movss	xmm2, DWORD PTR tv134[rsp]
	movss	xmm1, DWORD PTR tv132[rsp]
	lea	rcx, QWORD PTR clip_rect$[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect

; 6123 : 	clip_rect.ClipWith(window->OuterRectClipped);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 264				; 00000108H
	mov	rdx, rax
	lea	rcx, QWORD PTR clip_rect$[rsp]
	call	?ClipWith@ImRect@@QEAAXAEBU1@@Z		; ImRect::ClipWith

; 6124 : 	PushClipRect(clip_rect.Min, clip_rect.Max, false);

	xor	r8d, r8d
	lea	rdx, QWORD PTR clip_rect$[rsp+8]
	lea	rcx, QWORD PTR clip_rect$[rsp]
	call	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z ; ImGui::PushClipRect
	npad	1

; 6125 : 
; 6126 : 	window->DC.CursorPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR bar_rect$[rsp+4]
	addss	xmm0, DWORD PTR [rax+464]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR bar_rect$[rsp]
	addss	xmm1, DWORD PTR [rax+460]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR window$[rsp]
	mov	QWORD PTR [rcx+340], rax

; 6127 : 	window->DC.LayoutType = ImGuiLayoutType_Horizontal;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+468], 0

; 6128 : 	window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+400], 1

; 6129 : 	window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+404], 2

; 6130 : 	window->DC.MenuBarAppending = true;

	mov	rax, QWORD PTR window$[rsp]
	mov	BYTE PTR [rax+457], 1

; 6131 : 	AlignTextToFramePadding();

	call	?AlignTextToFramePadding@ImGui@@YAXXZ	; ImGui::AlignTextToFramePadding

; 6132 : 	return true;

	mov	al, 1
$LN1@BeginMenuB:

; 6133 : }

	add	rsp, 120				; 00000078H
	ret	0
?BeginMenuBar@ImGui@@YA_NXZ ENDP			; ImGui::BeginMenuBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 32
?EndMainMenuBar@ImGui@@YAXXZ PROC			; ImGui::EndMainMenuBar

; 6096 : {

$LN4:
	sub	rsp, 56					; 00000038H

; 6097 : 	EndMenuBar();

	call	?EndMenuBar@ImGui@@YAXXZ		; ImGui::EndMenuBar

; 6098 : 
; 6099 : 	// When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
; 6100 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6101 : 	if (g.CurrentWindow == g.NavWindow && g.NavLayer == 0)

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+7024]
	cmp	QWORD PTR [rax+6584], rcx
	jne	SHORT $LN2@EndMainMen
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7132], 0
	jne	SHORT $LN2@EndMainMen

; 6102 : 		FocusPreviousWindowIgnoringOne(g.NavWindow);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+7024]
	call	?FocusPreviousWindowIgnoringOne@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusPreviousWindowIgnoringOne
	npad	1
$LN2@EndMainMen:

; 6103 : 
; 6104 : 	End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	npad	1

; 6105 : }

	add	rsp, 56					; 00000038H
	ret	0
?EndMainMenuBar@ImGui@@YAXXZ ENDP			; ImGui::EndMainMenuBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
is_open$ = 32
g$ = 40
tv170 = 48
tv86 = 52
tv84 = 56
window_flags$ = 60
tv134 = 64
tv132 = 72
$T1 = 80
$T2 = 88
$T3 = 96
$T4 = 104
$T5 = 112
$T6 = 120
?BeginMainMenuBar@ImGui@@YA_NXZ PROC			; ImGui::BeginMainMenuBar

; 6076 : {

$LN6:
	sub	rsp, 136				; 00000088H

; 6077 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 6078 : 	g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5624]
	subss	xmm0, DWORD PTR [rcx+5528]
	xorps	xmm1, xmm1
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR tv86[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5620]
	movss	DWORD PTR tv84[rsp], xmm0
	movss	xmm2, DWORD PTR tv86[rsp]
	movss	xmm1, DWORD PTR tv84[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+7000], rax

; 6079 : 	SetNextWindowPos(ImVec2(0.0f, 0.0f));

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv134[rsp], rax
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv132[rsp], rax
	mov	r8, QWORD PTR tv134[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR tv132[rsp]
	call	?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z ; ImGui::SetNextWindowPos
	npad	1

; 6080 : 	SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.NextWindowData.MenuBarOffsetMinVal.y + g.FontBaseSize + g.Style.FramePadding.y));

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7004]
	addss	xmm0, DWORD PTR [rcx+6412]
	mov	rax, QWORD PTR g$[rsp]
	addss	xmm0, DWORD PTR [rax+5528]
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+20]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xor	edx, edx
	mov	rcx, rax
	call	?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z ; ImGui::SetNextWindowSize
	npad	1

; 6081 : 	PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);

	xorps	xmm1, xmm1
	mov	ecx, 2
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar
	npad	1

; 6082 : 	PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0, 0));

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	ecx, 4
	call	?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z	; ImGui::PushStyleVar
	npad	1

; 6083 : 	ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar /*| ImGuiWindowFlags_NoSavedSettings */ | ImGuiWindowFlags_MenuBar;

	mov	DWORD PTR window_flags$[rsp], 1039	; 0000040fH

; 6084 : 	bool is_open = Begin(("##Main+-Menu+-Bar"), NULL, window_flags) && BeginMenuBar();

	mov	r8d, DWORD PTR window_flags$[rsp]
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_0BC@ELGDDMPM@?$CD?$CDMain?$CL?9Menu?$CL?9Bar@
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@BeginMainM
	call	?BeginMenuBar@ImGui@@YA_NXZ		; ImGui::BeginMenuBar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@BeginMainM
	mov	DWORD PTR tv170[rsp], 1
	jmp	SHORT $LN5@BeginMainM
$LN4@BeginMainM:
	mov	DWORD PTR tv170[rsp], 0
$LN5@BeginMainM:
	movzx	eax, BYTE PTR tv170[rsp]
	mov	BYTE PTR is_open$[rsp], al

; 6085 : 	PopStyleVar(2);

	mov	ecx, 2
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	npad	1

; 6086 : 	g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+7000], rax

; 6087 : 	if (!is_open)

	movzx	eax, BYTE PTR is_open$[rsp]
	test	eax, eax
	jne	SHORT $LN2@BeginMainM

; 6088 : 	{
; 6089 : 		End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 6090 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@BeginMainM
$LN2@BeginMainM:

; 6091 : 	}
; 6092 : 	return true; //-V1020

	mov	al, 1
$LN1@BeginMainM:

; 6093 : }

	add	rsp, 136				; 00000088H
	ret	0
?BeginMainMenuBar@ImGui@@YA_NXZ ENDP			; ImGui::BeginMainMenuBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
fmt$1 = 32
__$ArrayPad$ = 96
prefix$ = 128
v$ = 136
float_format$ = 144
?Value@ImGui@@YAXPEBDM0@Z PROC				; ImGui::Value

; 6006 : {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 6007 : 	if (float_format)

	cmp	QWORD PTR float_format$[rsp], 0
	je	SHORT $LN2@Value

; 6008 : 	{
; 6009 : 		char fmt[64];
; 6010 : 		ImFormatString(fmt, IM_ARRAYSIZE(fmt), ("%%s: %s"), float_format);

	mov	r9, QWORD PTR float_format$[rsp]
	lea	r8, OFFSET FLAT:??_C@_07EKEPIENH@?$CF?$CFs?3?5?$CFs@
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR fmt$1[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 6011 : 		Text(fmt, prefix, v);

	cvtss2sd xmm0, DWORD PTR v$[rsp]
	movaps	xmm2, xmm0
	movq	r8, xmm2
	mov	rdx, QWORD PTR prefix$[rsp]
	lea	rcx, QWORD PTR fmt$1[rsp]
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1

; 6012 : 	}

	jmp	SHORT $LN3@Value
$LN2@Value:

; 6013 : 	else
; 6014 : 	{
; 6015 : 		Text(("%s: %.3f"), prefix, v);

	cvtss2sd xmm0, DWORD PTR v$[rsp]
	movaps	xmm2, xmm0
	movq	r8, xmm2
	mov	rdx, QWORD PTR prefix$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1
$LN3@Value:

; 6016 : 	}
; 6017 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?Value@ImGui@@YAXPEBDM0@Z ENDP				; ImGui::Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
prefix$ = 48
v$ = 56
?Value@ImGui@@YAXPEBDI@Z PROC				; ImGui::Value

; 6001 : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 6002 : 	Text(("%s: %d"), prefix, v);

	mov	r8d, DWORD PTR v$[rsp]
	mov	rdx, QWORD PTR prefix$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_06GBEGMGE@?$CFs?3?5?$CFd@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1

; 6003 : }

	add	rsp, 40					; 00000028H
	ret	0
?Value@ImGui@@YAXPEBDI@Z ENDP				; ImGui::Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
prefix$ = 48
v$ = 56
?Value@ImGui@@YAXPEBDH@Z PROC				; ImGui::Value

; 5996 : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5997 : 	Text(("%s: %d"), prefix, v);

	mov	r8d, DWORD PTR v$[rsp]
	mov	rdx, QWORD PTR prefix$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_06GBEGMGE@?$CFs?3?5?$CFd@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1

; 5998 : }

	add	rsp, 40					; 00000028H
	ret	0
?Value@ImGui@@YAXPEBDH@Z ENDP				; ImGui::Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv66 = 32
prefix$ = 64
b$ = 72
?Value@ImGui@@YAXPEBD_N@Z PROC				; ImGui::Value

; 5991 : {

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5992 : 	Text(("%s: %s"), prefix, (b ? "true" : "false"));

	movzx	eax, BYTE PTR b$[rsp]
	test	eax, eax
	je	SHORT $LN3@Value
	lea	rax, OFFSET FLAT:??_C@_04LOAJBDKD@true@
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@Value
$LN3@Value:
	lea	rax, OFFSET FLAT:??_C@_05LAPONLG@false@
	mov	QWORD PTR tv66[rsp], rax
$LN4@Value:
	mov	r8, QWORD PTR tv66[rsp]
	mov	rdx, QWORD PTR prefix$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_06DJHOIPC@?$CFs?3?5?$CFs@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1

; 5993 : }

	add	rsp, 56					; 00000038H
	ret	0
?Value@ImGui@@YAXPEBD_N@Z ENDP				; ImGui::Value
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 96
values_getter$ = 104
data$ = 112
values_count$ = 120
values_offset$ = 128
overlay_text$ = 136
scale_min$ = 144
scale_max$ = 152
graph_size$ = 160
?PlotHistogram@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z PROC ; ImGui::PlotHistogram

; 5979 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 5980 : 	PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

	mov	rax, QWORD PTR graph_size$[rsp]
	mov	QWORD PTR [rsp+72], rax
	movss	xmm0, DWORD PTR scale_max$[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	movss	xmm0, DWORD PTR scale_min$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR overlay_text$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR values_offset$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR values_count$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR data$[rsp]
	mov	r8, QWORD PTR values_getter$[rsp]
	mov	rdx, QWORD PTR label$[rsp]
	mov	ecx, 1
	call	?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PEBDP6AMPEAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
	npad	1

; 5981 : }

	add	rsp, 88					; 00000058H
	ret	0
?PlotHistogram@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z ENDP ; ImGui::PlotHistogram
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
data$ = 80
label$ = 112
values$ = 120
values_count$ = 128
values_offset$ = 136
overlay_text$ = 144
scale_min$ = 152
scale_max$ = 160
graph_size$ = 168
stride$ = 176
?PlotHistogram@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z PROC	; ImGui::PlotHistogram

; 5973 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 5974 : 	ImGuiPlotArrayGetterData data(values, stride);

	mov	r8d, DWORD PTR stride$[rsp]
	mov	rdx, QWORD PTR values$[rsp]
	lea	rcx, QWORD PTR data$[rsp]
	call	??0ImGuiPlotArrayGetterData@@QEAA@PEBMH@Z ; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData

; 5975 : 	PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

	mov	rax, QWORD PTR graph_size$[rsp]
	mov	QWORD PTR [rsp+72], rax
	movss	xmm0, DWORD PTR scale_max$[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	movss	xmm0, DWORD PTR scale_min$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR overlay_text$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR values_offset$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR values_count$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR data$[rsp]
	lea	r8, OFFSET FLAT:?Plot_ArrayGetter@@YAMPEAXH@Z ; Plot_ArrayGetter
	mov	rdx, QWORD PTR label$[rsp]
	mov	ecx, 1
	call	?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PEBDP6AMPEAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
	npad	1

; 5976 : }

	add	rsp, 104				; 00000068H
	ret	0
?PlotHistogram@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z ENDP	; ImGui::PlotHistogram
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 96
values_getter$ = 104
data$ = 112
values_count$ = 120
values_offset$ = 128
overlay_text$ = 136
scale_min$ = 144
scale_max$ = 152
graph_size$ = 160
?PlotLines@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z PROC ; ImGui::PlotLines

; 5968 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 5969 : 	PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

	mov	rax, QWORD PTR graph_size$[rsp]
	mov	QWORD PTR [rsp+72], rax
	movss	xmm0, DWORD PTR scale_max$[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	movss	xmm0, DWORD PTR scale_min$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR overlay_text$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR values_offset$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR values_count$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR data$[rsp]
	mov	r8, QWORD PTR values_getter$[rsp]
	mov	rdx, QWORD PTR label$[rsp]
	xor	ecx, ecx
	call	?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PEBDP6AMPEAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
	npad	1

; 5970 : }

	add	rsp, 88					; 00000058H
	ret	0
?PlotLines@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z ENDP ; ImGui::PlotLines
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
data$ = 80
label$ = 112
values$ = 120
values_count$ = 128
values_offset$ = 136
overlay_text$ = 144
scale_min$ = 152
scale_max$ = 160
graph_size$ = 168
stride$ = 176
?PlotLines@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z PROC	; ImGui::PlotLines

; 5962 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 5963 : 	ImGuiPlotArrayGetterData data(values, stride);

	mov	r8d, DWORD PTR stride$[rsp]
	mov	rdx, QWORD PTR values$[rsp]
	lea	rcx, QWORD PTR data$[rsp]
	call	??0ImGuiPlotArrayGetterData@@QEAA@PEBMH@Z ; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData

; 5964 : 	PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

	mov	rax, QWORD PTR graph_size$[rsp]
	mov	QWORD PTR [rsp+72], rax
	movss	xmm0, DWORD PTR scale_max$[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	movss	xmm0, DWORD PTR scale_min$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR overlay_text$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR values_offset$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR values_count$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR data$[rsp]
	lea	r8, OFFSET FLAT:?Plot_ArrayGetter@@YAMPEAXH@Z ; Plot_ArrayGetter
	mov	rdx, QWORD PTR label$[rsp]
	xor	ecx, ecx
	call	?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PEBDP6AMPEAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
	npad	1

; 5965 : }

	add	rsp, 104				; 00000068H
	ret	0
?PlotLines@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z ENDP	; ImGui::PlotLines
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
parent_window$ = 32
style$ = 40
bb$ = 48
?ListBoxFooter@ImGui@@YAXXZ PROC			; ImGui::ListBoxFooter

; 5772 : {

$LN3:
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 5773 : 	ImGuiWindow* parent_window = GetCurrentWindow()->ParentWindow;

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	rax, QWORD PTR [rax+880]
	mov	QWORD PTR parent_window$[rsp], rax

; 5774 : 	const ImRect bb = parent_window->DC.LastItemRect;

	lea	rax, QWORD PTR bb$[rsp]
	mov	rcx, QWORD PTR parent_window$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+368]
	mov	ecx, 16
	rep movsb

; 5775 : 	const ImGuiStyle& style = GetStyle();

	call	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ	; ImGui::GetStyle
	mov	QWORD PTR style$[rsp], rax

; 5776 : 
; 5777 : 	EndChildFrame();

	call	?EndChildFrame@ImGui@@YAXXZ		; ImGui::EndChildFrame

; 5778 : 
; 5779 : 	// Redeclare item size so that it includes the label (we have stored the full size in LastItemRect)
; 5780 : 	// We call SameLine() to restore DC.CurrentLine* data
; 5781 : 	SameLine();

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@bf800000
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 5782 : 	parent_window->DC.CursorPos = bb.Min;

	mov	rax, QWORD PTR parent_window$[rsp]
	mov	rcx, QWORD PTR bb$[rsp]
	mov	QWORD PTR [rax+340], rcx

; 5783 : 	ItemSize(bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize

; 5784 : 	EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	npad	1

; 5785 : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?ListBoxFooter@ImGui@@YAXXZ ENDP			; ImGui::ListBoxFooter
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv74 = 32
height_in_items_f$ = 36
size$ = 40
style$ = 48
label$ = 80
items_count$ = 88
height_in_items$ = 96
?ListBoxHeader@ImGui@@YA_NPEBDHH@Z PROC			; ImGui::ListBoxHeader

; 5753 : {

$LN6:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 5754 : 	// Size default to hold ~7.25 items.
; 5755 : 	// We add +25% worth of item height to allow the user to see at a glance if there are more items up/down, without looking at the scrollbar.
; 5756 : 	// We don't add this extra bit if items_count <= height_in_items. It is slightly dodgy, because it means a dynamic list of items will make the widget resize occasionally when it crosses that size.
; 5757 : 	// I am expecting that someone will come and complain about this behavior in a remote future, then we can advise on a better solution.
; 5758 : 	if (height_in_items < 0)

	cmp	DWORD PTR height_in_items$[rsp], 0
	jge	SHORT $LN2@ListBoxHea

; 5759 : 		height_in_items = ImMin(items_count, 7);

	mov	edx, 7
	mov	ecx, DWORD PTR items_count$[rsp]
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	mov	DWORD PTR height_in_items$[rsp], eax
$LN2@ListBoxHea:

; 5760 : 	const ImGuiStyle& style = GetStyle();

	call	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ	; ImGui::GetStyle
	mov	QWORD PTR style$[rsp], rax

; 5761 : 	float height_in_items_f = (height_in_items < items_count) ? (height_in_items + 0.25f) : (height_in_items + 0.00f);

	mov	eax, DWORD PTR items_count$[rsp]
	cmp	DWORD PTR height_in_items$[rsp], eax
	jge	SHORT $LN4@ListBoxHea
	cvtsi2ss xmm0, DWORD PTR height_in_items$[rsp]
	addss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR tv74[rsp], xmm0
	jmp	SHORT $LN5@ListBoxHea
$LN4@ListBoxHea:
	cvtsi2ss xmm0, DWORD PTR height_in_items$[rsp]
	addss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv74[rsp], xmm0
$LN5@ListBoxHea:
	movss	xmm0, DWORD PTR tv74[rsp]
	movss	DWORD PTR height_in_items_f$[rsp], xmm0

; 5762 : 
; 5763 : 	// We include ItemSpacing.y so that a list sized for the exact number of items doesn't make a scrollbar appears. We could also enforce that by passing a flag to BeginChild().
; 5764 : 	ImVec2 size;

	lea	rcx, QWORD PTR size$[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2

; 5765 : 	size.x = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR size$[rsp], xmm0

; 5766 : 	size.y = GetTextLineHeightWithSpacing() * height_in_items_f + style.FramePadding.y * 2.0f;

	call	?GetTextLineHeightWithSpacing@ImGui@@YAMXZ ; ImGui::GetTextLineHeightWithSpacing
	mulss	xmm0, DWORD PTR height_in_items_f$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	mulss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	movss	DWORD PTR size$[rsp+4], xmm0

; 5767 : 	return ListBoxHeader(label, size);

	lea	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?ListBoxHeader@ImGui@@YA_NPEBDAEBUImVec2@@@Z ; ImGui::ListBoxHeader

; 5768 : }

	add	rsp, 72					; 00000048H
	ret	0
?ListBoxHeader@ImGui@@YA_NPEBDHH@Z ENDP			; ImGui::ListBoxHeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv151 = 48
style$ = 56
window$ = 64
label_size$ = 72
tv92 = 80
tv89 = 84
tv174 = 88
id$ = 92
frame_bb$ = 96
size$ = 112
bb$ = 120
$T1 = 136
$T2 = 144
frame_size$ = 152
tv172 = 160
$T3 = 168
$T4 = 176
$T5 = 184
$T6 = 192
$T7 = 200
$T8 = 208
label$ = 256
size_arg$ = 264
?ListBoxHeader@ImGui@@YA_NPEBDAEBUImVec2@@@Z PROC	; ImGui::ListBoxHeader

; 5720 : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 232				; 000000e8H

; 5721 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5722 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@ListBoxHea

; 5723 : 		return false;

	xor	al, al
	jmp	$LN1@ListBoxHea
$LN2@ListBoxHea:

; 5724 : 
; 5725 : 	const ImGuiStyle& style = GetStyle();

	call	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ	; ImGui::GetStyle
	mov	QWORD PTR style$[rsp], rax

; 5726 : 	const ImGuiID id = GetID(label);

	mov	rcx, QWORD PTR label$[rsp]
	call	?GetID@ImGui@@YAIPEBD@Z			; ImGui::GetID
	mov	DWORD PTR id$[rsp], eax

; 5727 : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	npad	1

; 5728 : 
; 5729 : 	// Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
; 5730 : 	ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y);

	call	?GetTextLineHeightWithSpacing@ImGui@@YAMXZ ; ImGui::GetTextLineHeightWithSpacing
	mulss	xmm0, DWORD PTR __real@40eccccd
	mov	rax, QWORD PTR style$[rsp]
	addss	xmm0, DWORD PTR [rax+72]
	movss	DWORD PTR tv92[rsp], xmm0
	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movss	DWORD PTR tv89[rsp], xmm0
	mov	rax, QWORD PTR size_arg$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T2[rsp], rax
	movss	xmm3, DWORD PTR tv92[rsp]
	movss	xmm2, DWORD PTR tv89[rsp]
	mov	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR size$[rsp]
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
	npad	1

; 5731 : 	ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));

	movss	xmm1, DWORD PTR label_size$[rsp+4]
	movss	xmm0, DWORD PTR size$[rsp+4]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR size$[rsp]
	lea	rcx, QWORD PTR frame_size$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 5732 : 	ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	lea	r8, QWORD PTR frame_size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 5733 : 	ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@ListBoxHea
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	addss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR tv151[rsp], xmm0
	jmp	SHORT $LN7@ListBoxHea
$LN6@ListBoxHea:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv151[rsp], xmm0
$LN7@ListBoxHea:
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR tv151[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 5734 : 	window->DC.LastItemRect = bb; // Forward storage for ListBoxFooter.. dodgy.

	mov	rax, QWORD PTR window$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	lea	rdi, QWORD PTR [rax+368]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 5735 : 
; 5736 : 	if (!IsRectVisible(bb.Min, bb.Max))

	lea	rdx, QWORD PTR bb$[rsp+8]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?IsRectVisible@ImGui@@YA_NAEBUImVec2@@0@Z ; ImGui::IsRectVisible
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@ListBoxHea

; 5737 : 	{
; 5738 : 		ItemSize(bb.GetSize(), style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	movss	DWORD PTR tv174[rsp], xmm0
	lea	rdx, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?GetSize@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetSize
	mov	QWORD PTR tv172[rsp], rax
	movss	xmm1, DWORD PTR tv174[rsp]
	mov	rcx, QWORD PTR tv172[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 5739 : 		ItemAdd(bb, 0, &frame_bb);

	lea	r8, QWORD PTR frame_bb$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd

; 5740 : 		return false;

	xor	al, al
	jmp	$LN1@ListBoxHea
$LN3@ListBoxHea:

; 5741 : 	}
; 5742 : 
; 5743 : 	BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup
	npad	1

; 5744 : 	if (label_size.x > 0)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@ListBoxHea

; 5745 : 		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR frame_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR frame_bb$[rsp+8]
	addss	xmm1, DWORD PTR [rax+76]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN4@ListBoxHea:

; 5746 : 
; 5747 : 	BeginChildFrame(id, frame_bb.GetSize());

	lea	rdx, QWORD PTR $T8[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?GetSize@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetSize
	xor	r8d, r8d
	mov	rdx, rax
	mov	ecx, DWORD PTR id$[rsp]
	call	?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z ; ImGui::BeginChildFrame
	npad	1

; 5748 : 	return true;

	mov	al, 1
$LN1@ListBoxHea:

; 5749 : }

	add	rsp, 232				; 000000e8H
	pop	rdi
	pop	rsi
	ret	0
?ListBoxHeader@ImGui@@YA_NPEBDAEBUImVec2@@@Z ENDP	; ImGui::ListBoxHeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 32
tv83 = 33
item_selected$1 = 34
$T2 = 35
i$3 = 36
item_text$4 = 40
tv89 = 48
tv137 = 56
tv135 = 64
g$ = 72
clipper$ = 80
$T5 = 104
label$ = 128
current_item$ = 136
items_getter$ = 144
data$ = 152
items_count$ = 160
height_in_items$ = 168
?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z PROC ; ImGui::ListBox

; 5794 : {

$LN16:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 5795 : 	if (!ListBoxHeader(label, items_count, height_in_items))

	mov	r8d, DWORD PTR height_in_items$[rsp]
	mov	edx, DWORD PTR items_count$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?ListBoxHeader@ImGui@@YA_NPEBDHH@Z	; ImGui::ListBoxHeader
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@ListBox

; 5796 : 		return false;

	xor	al, al
	jmp	$LN1@ListBox
$LN7@ListBox:

; 5797 : 
; 5798 : 	// Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.
; 5799 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5800 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 5801 : 	ImGuiListClipper clipper(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.

	call	?GetTextLineHeightWithSpacing@ImGui@@YAMXZ ; ImGui::GetTextLineHeightWithSpacing
	movaps	xmm2, xmm0
	mov	edx, DWORD PTR items_count$[rsp]
	lea	rcx, QWORD PTR clipper$[rsp]
	call	??0ImGuiListClipper@@QEAA@HM@Z		; ImGuiListClipper::ImGuiListClipper
	npad	1
$LN2@ListBox:

; 5802 : 	while (clipper.Step())

	lea	rcx, QWORD PTR clipper$[rsp]
	call	?Step@ImGuiListClipper@@QEAA_NXZ	; ImGuiListClipper::Step
	movzx	eax, al
	test	eax, eax
	je	$LN3@ListBox

; 5803 : 		for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)

	mov	eax, DWORD PTR clipper$[rsp+16]
	mov	DWORD PTR i$3[rsp], eax
	jmp	SHORT $LN6@ListBox
$LN4@ListBox:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN6@ListBox:
	mov	eax, DWORD PTR clipper$[rsp+20]
	cmp	DWORD PTR i$3[rsp], eax
	jge	$LN5@ListBox

; 5804 : 		{
; 5805 : 			const bool item_selected = (i == *current_item);

	mov	rax, QWORD PTR current_item$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$3[rsp], eax
	jne	SHORT $LN13@ListBox
	mov	BYTE PTR tv83[rsp], 1
	jmp	SHORT $LN14@ListBox
$LN13@ListBox:
	mov	BYTE PTR tv83[rsp], 0
$LN14@ListBox:
	movzx	eax, BYTE PTR tv83[rsp]
	mov	BYTE PTR item_selected$1[rsp], al

; 5806 : 			const char* item_text;
; 5807 : 			if (!items_getter(data, i, &item_text))

	mov	rax, QWORD PTR items_getter$[rsp]
	mov	QWORD PTR tv89[rsp], rax
	lea	r8, QWORD PTR item_text$4[rsp]
	mov	edx, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	QWORD PTR tv89[rsp]
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@ListBox

; 5808 : 				item_text = ("*Unknown item*");

	lea	rax, OFFSET FLAT:??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@
	mov	QWORD PTR item_text$4[rsp], rax
$LN8@ListBox:

; 5809 : 
; 5810 : 			PushID(i);

	mov	ecx, DWORD PTR i$3[rsp]
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID
	npad	1

; 5811 : 			if (Selectable(item_text, item_selected))

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR item_text$4[rsp]
	mov	QWORD PTR tv135[rsp], rax
	mov	r9, QWORD PTR tv137[rsp]
	xor	r8d, r8d
	movzx	edx, BYTE PTR item_selected$1[rsp]
	mov	rcx, QWORD PTR tv135[rsp]
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@ListBox

; 5812 : 			{
; 5813 : 				*current_item = i;

	mov	rax, QWORD PTR current_item$[rsp]
	mov	ecx, DWORD PTR i$3[rsp]
	mov	DWORD PTR [rax], ecx

; 5814 : 				value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN9@ListBox:

; 5815 : 			}
; 5816 : 			if (item_selected)

	movzx	eax, BYTE PTR item_selected$1[rsp]
	test	eax, eax
	je	SHORT $LN10@ListBox

; 5817 : 				SetItemDefaultFocus();

	call	?SetItemDefaultFocus@ImGui@@YAXXZ	; ImGui::SetItemDefaultFocus
	npad	1
$LN10@ListBox:

; 5818 : 			PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	npad	1

; 5819 : 		}

	jmp	$LN4@ListBox
$LN5@ListBox:
	jmp	$LN2@ListBox
$LN3@ListBox:

; 5820 : 	ListBoxFooter();

	call	?ListBoxFooter@ImGui@@YAXXZ		; ImGui::ListBoxFooter
	npad	1

; 5821 : 	if (value_changed)

	movzx	eax, BYTE PTR value_changed$[rsp]
	test	eax, eax
	je	SHORT $LN11@ListBox

; 5822 : 		MarkItemEdited(g.CurrentWindow->DC.LastItemId);

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	ecx, DWORD PTR [rax+412]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN11@ListBox:

; 5823 : 
; 5824 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
	mov	BYTE PTR $T2[rsp], al
	lea	rcx, QWORD PTR clipper$[rsp]
	call	??1ImGuiListClipper@@QEAA@XZ		; ImGuiListClipper::~ImGuiListClipper
	movzx	eax, BYTE PTR $T2[rsp]
$LN1@ListBox:

; 5825 : }

	add	rsp, 120				; 00000078H
	ret	0
?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z ENDP ; ImGui::ListBox
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 32
tv83 = 33
item_selected$1 = 34
$T2 = 35
i$3 = 36
item_text$4 = 40
tv89 = 48
tv137 = 56
tv135 = 64
g$ = 72
clipper$ = 80
$T5 = 104
label$ = 128
current_item$ = 136
items_getter$ = 144
data$ = 152
items_count$ = 160
height_in_items$ = 168
?dtor$0@?0??ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z@4HA PROC ; `ImGui::ListBox'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR clipper$[rbp]
	call	??1ImGuiListClipper@@QEAA@XZ		; ImGuiListClipper::~ImGuiListClipper
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z@4HA ENDP ; `ImGui::ListBox'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 48
label$ = 80
current_item$ = 88
items$ = 96
items_count$ = 104
height_items$ = 112
?ListBox@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z PROC		; ImGui::ListBox

; 5788 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 5789 : 	const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);

	mov	eax, DWORD PTR height_items$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR items_count$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR items$[rsp]
	lea	r8, OFFSET FLAT:?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z ; Items_ArrayGetter
	mov	rdx, QWORD PTR current_item$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z ; ImGui::ListBox
	mov	BYTE PTR value_changed$[rsp], al

; 5790 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]

; 5791 : }

	add	rsp, 72					; 00000048H
	ret	0
?ListBox@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z ENDP		; ImGui::ListBox
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv73 = 32
label$ = 64
p_selected$ = 72
flags$ = 80
size_arg$ = 88
?Selectable@ImGui@@YA_NPEBDPEA_NHAEBUImVec2@@@Z PROC	; ImGui::Selectable

; 5699 : {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5700 : 	if (Selectable(label, *p_selected, flags, size_arg))

	mov	r9, QWORD PTR size_arg$[rsp]
	mov	r8d, DWORD PTR flags$[rsp]
	mov	rax, QWORD PTR p_selected$[rsp]
	movzx	edx, BYTE PTR [rax]
	mov	rcx, QWORD PTR label$[rsp]
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Selectable

; 5701 : 	{
; 5702 : 		*p_selected = !*p_selected;

	mov	rax, QWORD PTR p_selected$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN4@Selectable
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN5@Selectable
$LN4@Selectable:
	mov	DWORD PTR tv73[rsp], 0
$LN5@Selectable:
	mov	rax, QWORD PTR p_selected$[rsp]
	movzx	ecx, BYTE PTR tv73[rsp]
	mov	BYTE PTR [rax], cl

; 5703 : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@Selectable
$LN2@Selectable:

; 5704 : 	}
; 5705 : 	return false;

	xor	al, al
$LN1@Selectable:

; 5706 : }

	add	rsp, 56					; 00000038H
	ret	0
?Selectable@ImGui@@YA_NPEBDPEA_NHAEBUImVec2@@@Z ENDP	; ImGui::Selectable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
hovered$ = 64
pressed$ = 65
button_flags$ = 68
held$ = 72
window$ = 80
id$ = 88
bb$ = 96
pos$ = 112
g$ = 120
tv88 = 128
tv93 = 132
tv151 = 136
tv165 = 140
tv172 = 144
spacing_L$ = 148
spacing_U$ = 152
tv309 = 156
tv310 = 160
max_x$ = 164
style$ = 168
label_size$ = 176
spacing_D$ = 184
col$1 = 188
w_draw$ = 192
spacing_R$ = 196
window_padding$ = 200
size$ = 208
size_draw$ = 216
bb_inner$ = 224
$T2 = 240
$T3 = 248
$T4 = 256
$T5 = 264
$T6 = 272
label$ = 304
selected$ = 312
flags$ = 320
size_arg$ = 328
?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z PROC	; ImGui::Selectable

; 5608 : {

$LN45:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 296				; 00000128H

; 5609 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5610 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@Selectable

; 5611 : 		return false;

	xor	al, al
	jmp	$LN1@Selectable
$LN2@Selectable:

; 5612 : 
; 5613 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5614 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 5615 : 
; 5616 : 	if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet) // FIXME-OPT: Avoid if vertically clipped.

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN3@Selectable
	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN3@Selectable

; 5617 : 		PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect
	npad	1
$LN3@Selectable:

; 5618 : 
; 5619 : 	ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 5620 : 	ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 5621 : 	ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);

	mov	rax, QWORD PTR size_arg$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN44@Selectable
	je	SHORT $LN25@Selectable
$LN44@Selectable:
	mov	rax, QWORD PTR size_arg$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv88[rsp], xmm0
	jmp	SHORT $LN26@Selectable
$LN25@Selectable:
	movss	xmm0, DWORD PTR label_size$[rsp+4]
	movss	DWORD PTR tv88[rsp], xmm0
$LN26@Selectable:
	mov	rax, QWORD PTR size_arg$[rsp]
	movss	xmm0, DWORD PTR [rax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN43@Selectable
	je	SHORT $LN27@Selectable
$LN43@Selectable:
	mov	rax, QWORD PTR size_arg$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv93[rsp], xmm0
	jmp	SHORT $LN28@Selectable
$LN27@Selectable:
	movss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR tv93[rsp], xmm0
$LN28@Selectable:
	movss	xmm2, DWORD PTR tv88[rsp]
	movss	xmm1, DWORD PTR tv93[rsp]
	lea	rcx, QWORD PTR size$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 5622 : 	ImVec2 pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR pos$[rsp], rax

; 5623 : 	pos.y += window->DC.CurrentLineTextBaseOffset;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR [rax+328]
	movss	DWORD PTR pos$[rsp+4], xmm0

; 5624 : 	ImRect bb_inner(pos, pos + size);

	lea	r8, QWORD PTR size$[rsp]
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR bb_inner$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 5625 : 	ItemSize(bb_inner);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR bb_inner$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize

; 5626 : 
; 5627 : 	// Fill horizontal space.
; 5628 : 	ImVec2 window_padding = window->WindowPadding;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR window_padding$[rsp], rax

; 5629 : 	float max_x = (flags & ImGuiSelectableFlags_SpanAllColumns) ? GetWindowContentRegionMax().x : GetContentRegionMax().x;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN29@Selectable
	lea	rcx, QWORD PTR $T3[rsp]
	call	?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetWindowContentRegionMax
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv151[rsp], xmm0
	jmp	SHORT $LN30@Selectable
$LN29@Selectable:
	lea	rcx, QWORD PTR $T4[rsp]
	call	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv151[rsp], xmm0
$LN30@Selectable:
	movss	xmm0, DWORD PTR tv151[rsp]
	movss	DWORD PTR max_x$[rsp], xmm0

; 5630 : 	float w_draw = ImMax(label_size.x, window->Pos.x + max_x - window_padding.x - pos.x);

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR max_x$[rsp]
	subss	xmm0, DWORD PTR window_padding$[rsp]
	subss	xmm0, DWORD PTR pos$[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR label_size$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR w_draw$[rsp], xmm0

; 5631 : 	ImVec2 size_draw((size_arg.x != 0 && !(flags & ImGuiSelectableFlags_DrawFillAvailWidth)) ? size_arg.x : w_draw, size_arg.y != 0.0f ? size_arg.y : size.y);

	mov	rax, QWORD PTR size_arg$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN42@Selectable
	je	SHORT $LN31@Selectable
$LN42@Selectable:
	mov	rax, QWORD PTR size_arg$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv165[rsp], xmm0
	jmp	SHORT $LN32@Selectable
$LN31@Selectable:
	movss	xmm0, DWORD PTR size$[rsp+4]
	movss	DWORD PTR tv165[rsp], xmm0
$LN32@Selectable:
	mov	rax, QWORD PTR size_arg$[rsp]
	movss	xmm0, DWORD PTR [rax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN41@Selectable
	je	SHORT $LN33@Selectable
$LN41@Selectable:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8192				; 00002000H
	test	eax, eax
	jne	SHORT $LN33@Selectable
	mov	rax, QWORD PTR size_arg$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv172[rsp], xmm0
	jmp	SHORT $LN34@Selectable
$LN33@Selectable:
	movss	xmm0, DWORD PTR w_draw$[rsp]
	movss	DWORD PTR tv172[rsp], xmm0
$LN34@Selectable:
	movss	xmm2, DWORD PTR tv165[rsp]
	movss	xmm1, DWORD PTR tv172[rsp]
	lea	rcx, QWORD PTR size_draw$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 5632 : 	ImRect bb(pos, pos + size_draw);

	lea	r8, QWORD PTR size_draw$[rsp]
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 5633 : 	if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_DrawFillAvailWidth))

	mov	rax, QWORD PTR size_arg$[rsp]
	movss	xmm0, DWORD PTR [rax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN40@Selectable
	je	SHORT $LN5@Selectable
$LN40@Selectable:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8192				; 00002000H
	test	eax, eax
	je	SHORT $LN4@Selectable
$LN5@Selectable:

; 5634 : 		bb.Max.x += window_padding.x;

	movss	xmm0, DWORD PTR bb$[rsp+8]
	addss	xmm0, DWORD PTR window_padding$[rsp]
	movss	DWORD PTR bb$[rsp+8], xmm0
$LN4@Selectable:

; 5635 : 
; 5636 : 	// Selectables are tightly packed together, we extend the box to cover spacing between selectable.
; 5637 : 	float spacing_L = (float)(int)(style.ItemSpacing.x * 0.5f);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+68]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR spacing_L$[rsp], xmm0

; 5638 : 	float spacing_U = (float)(int)(style.ItemSpacing.y * 0.5f);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+72]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR spacing_U$[rsp], xmm0

; 5639 : 	float spacing_R = style.ItemSpacing.x - spacing_L;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+68]
	subss	xmm0, DWORD PTR spacing_L$[rsp]
	movss	DWORD PTR spacing_R$[rsp], xmm0

; 5640 : 	float spacing_D = style.ItemSpacing.y - spacing_U;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+72]
	subss	xmm0, DWORD PTR spacing_U$[rsp]
	movss	DWORD PTR spacing_D$[rsp], xmm0

; 5641 : 	bb.Min.x -= spacing_L;

	movss	xmm0, DWORD PTR bb$[rsp]
	subss	xmm0, DWORD PTR spacing_L$[rsp]
	movss	DWORD PTR bb$[rsp], xmm0

; 5642 : 	bb.Min.y -= spacing_U;

	movss	xmm0, DWORD PTR bb$[rsp+4]
	subss	xmm0, DWORD PTR spacing_U$[rsp]
	movss	DWORD PTR bb$[rsp+4], xmm0

; 5643 : 	bb.Max.x += spacing_R;

	movss	xmm0, DWORD PTR bb$[rsp+8]
	addss	xmm0, DWORD PTR spacing_R$[rsp]
	movss	DWORD PTR bb$[rsp+8], xmm0

; 5644 : 	bb.Max.y += spacing_D;

	movss	xmm0, DWORD PTR bb$[rsp+12]
	addss	xmm0, DWORD PTR spacing_D$[rsp]
	movss	DWORD PTR bb$[rsp+12], xmm0

; 5645 : 	if (!ItemAdd(bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Selectable

; 5646 : 	{
; 5647 : 		if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN7@Selectable
	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN7@Selectable

; 5648 : 			PushColumnClipRect();

	mov	ecx, -1
	call	?PushColumnClipRect@ImGui@@YAXH@Z	; ImGui::PushColumnClipRect
	npad	1
$LN7@Selectable:

; 5649 : 		return false;

	xor	al, al
	jmp	$LN1@Selectable
$LN6@Selectable:

; 5650 : 	}
; 5651 : 
; 5652 : 	// We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
; 5653 : 	ImGuiButtonFlags button_flags = 0;

	mov	DWORD PTR button_flags$[rsp], 0

; 5654 : 	if (flags & ImGuiSelectableFlags_NoHoldingActiveID) button_flags |= ImGuiButtonFlags_NoHoldingActiveID;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $LN8@Selectable
	mov	eax, DWORD PTR button_flags$[rsp]
	bts	eax, 11
	mov	DWORD PTR button_flags$[rsp], eax
$LN8@Selectable:

; 5655 : 	if (flags & ImGuiSelectableFlags_PressedOnClick) button_flags |= ImGuiButtonFlags_PressedOnClick;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $LN9@Selectable
	mov	eax, DWORD PTR button_flags$[rsp]
	or	eax, 4
	mov	DWORD PTR button_flags$[rsp], eax
$LN9@Selectable:

; 5656 : 	if (flags & ImGuiSelectableFlags_PressedOnRelease) button_flags |= ImGuiButtonFlags_PressedOnRelease;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $LN10@Selectable
	mov	eax, DWORD PTR button_flags$[rsp]
	or	eax, 8
	mov	DWORD PTR button_flags$[rsp], eax
$LN10@Selectable:

; 5657 : 	if (flags & ImGuiSelectableFlags_Disabled) button_flags |= ImGuiButtonFlags_Disabled;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN11@Selectable
	mov	eax, DWORD PTR button_flags$[rsp]
	bts	eax, 8
	mov	DWORD PTR button_flags$[rsp], eax
$LN11@Selectable:

; 5658 : 	if (flags & ImGuiSelectableFlags_AllowDoubleClick) button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN12@Selectable
	mov	eax, DWORD PTR button_flags$[rsp]
	or	eax, 18
	mov	DWORD PTR button_flags$[rsp], eax
$LN12@Selectable:

; 5659 : 	if (flags & ImGuiSelectableFlags_Disabled)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN13@Selectable

; 5660 : 		selected = false;

	mov	BYTE PTR selected$[rsp], 0
$LN13@Selectable:

; 5661 : 
; 5662 : 	bool hovered, held;
; 5663 : 	bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);

	mov	eax, DWORD PTR button_flags$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 5664 : 	// Hovering selectable with mouse updates NavId accordingly so navigation can be resumed with gamepad/keyboard (this doesn't happen on most widgets)
; 5665 : 	if (pressed || hovered)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	jne	SHORT $LN15@Selectable
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN14@Selectable
$LN15@Selectable:

; 5666 : 		if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7143]
	test	eax, eax
	jne	SHORT $LN16@Selectable
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+7024], rcx
	jne	SHORT $LN16@Selectable
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+400]
	cmp	DWORD PTR [rax+7132], ecx
	jne	SHORT $LN16@Selectable

; 5667 : 		{
; 5668 : 			g.NavDisableHighlight = true;

	mov	rax, QWORD PTR g$[rsp]
	mov	BYTE PTR [rax+7140], 1

; 5669 : 			SetNavID(id, window->DC.NavLayerCurrent);

	mov	rax, QWORD PTR window$[rsp]
	mov	edx, DWORD PTR [rax+400]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetNavID@ImGui@@YAXIH@Z		; ImGui::SetNavID
	npad	1
$LN16@Selectable:
$LN14@Selectable:

; 5670 : 		}
; 5671 : 	if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN17@Selectable

; 5672 : 		MarkItemEdited(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN17@Selectable:

; 5673 : 
; 5674 : 	// Render
; 5675 : 	if (hovered || selected)

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	jne	SHORT $LN19@Selectable
	movzx	eax, BYTE PTR selected$[rsp]
	test	eax, eax
	je	$LN18@Selectable
$LN19@Selectable:

; 5676 : 	{
; 5677 : 		const ImU32 col = GetColorU32(((held && hovered) || selected) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN35@Selectable
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	jne	SHORT $LN36@Selectable
$LN35@Selectable:
	movzx	eax, BYTE PTR selected$[rsp]
	test	eax, eax
	jne	SHORT $LN36@Selectable
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN37@Selectable
	mov	DWORD PTR tv309[rsp], 25
	jmp	SHORT $LN38@Selectable
$LN37@Selectable:
	mov	DWORD PTR tv309[rsp], 24
$LN38@Selectable:
	mov	eax, DWORD PTR tv309[rsp]
	mov	DWORD PTR tv310[rsp], eax
	jmp	SHORT $LN39@Selectable
$LN36@Selectable:
	mov	DWORD PTR tv310[rsp], 26
$LN39@Selectable:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv310[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR col$1[rsp], eax

; 5678 : 		RenderFrame(bb.Min, bb.Max, col, false, 0.0f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	mov	r8d, DWORD PTR col$1[rsp]
	mov	rdx, QWORD PTR bb$[rsp+8]
	mov	rcx, QWORD PTR bb$[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 5679 : 		RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);

	mov	r8d, 10
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
	npad	1
$LN18@Selectable:

; 5680 : 	}
; 5681 : 
; 5682 : 	if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN20@Selectable
	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN20@Selectable

; 5683 : 	{
; 5684 : 		PushColumnClipRect();

	mov	ecx, -1
	call	?PushColumnClipRect@ImGui@@YAXH@Z	; ImGui::PushColumnClipRect
	npad	1

; 5685 : 		bb.Max.x -= (GetContentRegionMax().x - max_x);

	lea	rcx, QWORD PTR $T6[rsp]
	call	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR max_x$[rsp]
	movss	xmm1, DWORD PTR bb$[rsp+8]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR bb$[rsp+8], xmm0
$LN20@Selectable:

; 5686 : 	}
; 5687 : 
; 5688 : 	if (flags & ImGuiSelectableFlags_Disabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN21@Selectable
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax+5640]
	mov	rdx, rax
	xor	ecx, ecx
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor
	npad	1
$LN21@Selectable:

; 5689 : 	RenderTextClipped(bb_inner.Min, bb_inner.Max, label, NULL, &label_size, style.SelectableTextAlign, &bb);

	mov	rax, QWORD PTR style$[rsp]
	add	rax, 132				; 00000084H
	lea	rcx, QWORD PTR bb$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR label_size$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR label$[rsp]
	lea	rdx, QWORD PTR bb_inner$[rsp+8]
	lea	rcx, QWORD PTR bb_inner$[rsp]
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
	npad	1

; 5690 : 	if (flags & ImGuiSelectableFlags_Disabled) PopStyleColor();

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN22@Selectable
	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	npad	1
$LN22@Selectable:

; 5691 : 
; 5692 : 	// Automatically close popups
; 5693 : 	if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(window->DC.ItemFlags & ImGuiItemFlags_SelectableDontClosePopup))

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN23@Selectable
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+28]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN23@Selectable
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN23@Selectable
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+476]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN23@Selectable

; 5694 : 		CloseCurrentPopup();

	call	?CloseCurrentPopup@ImGui@@YAXXZ		; ImGui::CloseCurrentPopup
	npad	1
$LN23@Selectable:

; 5695 : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@Selectable:

; 5696 : }

	add	rsp, 296				; 00000128H
	ret	0
?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ENDP	; ImGui::Selectable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
is_open$ = 32
window$ = 40
tv80 = 48
id$ = 52
button_radius$1 = 56
tv82 = 60
tv154 = 64
tv152 = 68
g$2 = 72
tv87 = 80
tv132 = 88
button_center$3 = 96
$T4 = 104
last_item_backup$5 = 112
label$ = 176
p_open$ = 184
flags$ = 192
?CollapsingHeader@ImGui@@YA_NPEBDPEA_NH@Z PROC		; ImGui::CollapsingHeader

; 5574 : {

$LN9:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 5575 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5576 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@Collapsing

; 5577 : 		return false;

	xor	al, al
	jmp	$LN1@Collapsing
$LN2@Collapsing:

; 5578 : 
; 5579 : 	if (p_open && !*p_open)

	cmp	QWORD PTR p_open$[rsp], 0
	je	SHORT $LN3@Collapsing
	mov	rax, QWORD PTR p_open$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN3@Collapsing

; 5580 : 		return false;

	xor	al, al
	jmp	$LN1@Collapsing
$LN3@Collapsing:

; 5581 : 
; 5582 : 	ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 5583 : 	bool is_open = TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader | (p_open ? ImGuiTreeNodeFlags_AllowItemOverlap : 0), label);

	mov	rax, QWORD PTR label$[rsp]
	mov	QWORD PTR tv87[rsp], rax
	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 26
	mov	DWORD PTR tv82[rsp], eax
	cmp	QWORD PTR p_open$[rsp], 0
	je	SHORT $LN7@Collapsing
	mov	DWORD PTR tv80[rsp], 4
	jmp	SHORT $LN8@Collapsing
$LN7@Collapsing:
	mov	DWORD PTR tv80[rsp], 0
$LN8@Collapsing:
	mov	eax, DWORD PTR tv80[rsp]
	mov	ecx, DWORD PTR tv82[rsp]
	or	ecx, eax
	mov	eax, ecx
	xor	r9d, r9d
	mov	r8, QWORD PTR tv87[rsp]
	mov	edx, eax
	mov	ecx, DWORD PTR id$[rsp]
	call	?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z	; ImGui::TreeNodeBehavior
	mov	BYTE PTR is_open$[rsp], al

; 5584 : 	if (p_open)

	cmp	QWORD PTR p_open$[rsp], 0
	je	$LN4@Collapsing

; 5585 : 	{
; 5586 : 		// Create a small overlapping close button // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
; 5587 : 		ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$2[rsp], rax

; 5588 : 		ImGuiItemHoveredDataBackup last_item_backup;

	lea	rcx, QWORD PTR last_item_backup$5[rsp]
	call	??0ImGuiItemHoveredDataBackup@@QEAA@XZ	; ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup

; 5589 : 		float button_radius = g.FontSize * 0.5f;

	mov	rax, QWORD PTR g$2[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR button_radius$1[rsp], xmm0

; 5590 : 		ImVec2 button_center = ImVec2(ImMin(window->DC.LastItemRect.Max.x, window->ClipRect.Max.x) - g.Style.FramePadding.x - button_radius, window->DC.LastItemRect.GetCenter().y);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 368				; 00000170H
	mov	QWORD PTR tv132[rsp], rax
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR tv132[rsp]
	call	?GetCenter@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetCenter
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR tv154[rsp], xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+256]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+376]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	mov	rax, QWORD PTR g$2[rsp]
	subss	xmm0, DWORD PTR [rax+5524]
	subss	xmm0, DWORD PTR button_radius$1[rsp]
	movss	DWORD PTR tv152[rsp], xmm0
	movss	xmm2, DWORD PTR tv154[rsp]
	movss	xmm1, DWORD PTR tv152[rsp]
	lea	rcx, QWORD PTR button_center$3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 5591 : 		if (CloseButton(window->GetID((void*)((intptr_t)id + 1)), button_center, button_radius))

	mov	eax, DWORD PTR id$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBX@Z		; ImGuiWindow::GetID
	movss	xmm2, DWORD PTR button_radius$1[rsp]
	lea	rdx, QWORD PTR button_center$3[rsp]
	mov	ecx, eax
	call	?CloseButton@ImGui@@YA_NIAEBUImVec2@@M@Z ; ImGui::CloseButton
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Collapsing

; 5592 : 			*p_open = false;

	mov	rax, QWORD PTR p_open$[rsp]
	mov	BYTE PTR [rax], 0
$LN5@Collapsing:

; 5593 : 		last_item_backup.Restore();

	lea	rcx, QWORD PTR last_item_backup$5[rsp]
	call	?Restore@ImGuiItemHoveredDataBackup@@QEBAXXZ ; ImGuiItemHoveredDataBackup::Restore
	npad	1
$LN4@Collapsing:

; 5594 : 	}
; 5595 : 
; 5596 : 	return is_open;

	movzx	eax, BYTE PTR is_open$[rsp]
$LN1@Collapsing:

; 5597 : }

	add	rsp, 168				; 000000a8H
	ret	0
?CollapsingHeader@ImGui@@YA_NPEBDPEA_NH@Z ENDP		; ImGui::CollapsingHeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv71 = 32
window$ = 40
label$ = 64
flags$ = 72
?CollapsingHeader@ImGui@@YA_NPEBDH@Z PROC		; ImGui::CollapsingHeader

; 5565 : {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5566 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5567 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@Collapsing

; 5568 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@Collapsing
$LN2@Collapsing:

; 5569 : 
; 5570 : 	return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader, label);

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 26
	mov	DWORD PTR tv71[rsp], eax
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	xor	r9d, r9d
	mov	r8, QWORD PTR label$[rsp]
	mov	ecx, DWORD PTR tv71[rsp]
	mov	edx, ecx
	mov	ecx, eax
	call	?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z	; ImGui::TreeNodeBehavior
$LN1@Collapsing:

; 5571 : }

	add	rsp, 56					; 00000038H
	ret	0
?CollapsingHeader@ImGui@@YA_NPEBDH@Z ENDP		; ImGui::CollapsingHeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv71 = 0
g$ = 8
is_open$ = 32
cond$ = 40
?SetNextTreeNodeOpen@ImGui@@YAX_NH@Z PROC		; ImGui::SetNextTreeNodeOpen

; 5554 : {

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24

; 5555 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5556 : 	if (g.CurrentWindow->SkipItems)

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@SetNextTre

; 5557 : 		return;

	jmp	SHORT $LN1@SetNextTre
$LN2@SetNextTre:

; 5558 : 	g.NextTreeNodeOpenVal = is_open;

	mov	rax, QWORD PTR g$[rsp]
	movzx	ecx, BYTE PTR is_open$[rsp]
	mov	BYTE PTR [rax+6904], cl

; 5559 : 	g.NextTreeNodeOpenCond = cond ? cond : ImGuiCond_Always;

	cmp	DWORD PTR cond$[rsp], 0
	je	SHORT $LN4@SetNextTre
	mov	eax, DWORD PTR cond$[rsp]
	mov	DWORD PTR tv71[rsp], eax
	jmp	SHORT $LN5@SetNextTre
$LN4@SetNextTre:
	mov	DWORD PTR tv71[rsp], 1
$LN5@SetNextTre:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR tv71[rsp]
	mov	DWORD PTR [rax+6908], ecx
$LN1@SetNextTre:

; 5560 : }

	add	rsp, 24
	ret	0
?SetNextTreeNodeOpen@ImGui@@YAX_NH@Z ENDP		; ImGui::SetNextTreeNodeOpen
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 0
?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ PROC		; ImGui::GetTreeNodeToLabelSpacing

; 5548 : {

$LN3:
	sub	rsp, 24

; 5549 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5550 : 	return g.FontSize + (g.Style.FramePadding.x * 2.0f);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5524]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1

; 5551 : }

	add	rsp, 24
	ret	0
?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ ENDP		; ImGui::GetTreeNodeToLabelSpacing
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv74 = 32
tv76 = 36
g$ = 40
?TreeAdvanceToLabelPos@ImGui@@YAXXZ PROC		; ImGui::TreeAdvanceToLabelPos

; 5541 : {

$LN3:
	sub	rsp, 56					; 00000038H

; 5542 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5543 : 	g.CurrentWindow->DC.CursorPos.x += GetTreeNodeToLabelSpacing();

	call	?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ	; ImGui::GetTreeNodeToLabelSpacing
	movss	DWORD PTR tv76[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	movss	xmm0, DWORD PTR [rax+340]
	movss	DWORD PTR tv74[rsp], xmm0
	movss	xmm0, DWORD PTR tv74[rsp]
	addss	xmm0, DWORD PTR tv76[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	movss	DWORD PTR [rax+340], xmm0

; 5544 : }

	add	rsp, 56					; 00000038H
	ret	0
?TreeAdvanceToLabelPos@ImGui@@YAXXZ ENDP		; ImGui::TreeAdvanceToLabelPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv160 = 32
tv131 = 36
tv129 = 40
tv170 = 44
window$ = 48
g$ = 56
?TreePop@ImGui@@YAXXZ PROC				; ImGui::TreePop

; 5522 : {

$LN5:
	sub	rsp, 72					; 00000048H

; 5523 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5524 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 5525 : 	Unindent();

	xorps	xmm0, xmm0
	call	?Unindent@ImGui@@YAXM@Z			; ImGui::Unindent

; 5526 : 
; 5527 : 	window->DC.TreeDepth--;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+364]
	dec	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+364], eax

; 5528 : 	if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+7276], 0
	jne	$LN2@TreePop
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+7024], rcx
	jne	$LN2@TreePop
	call	?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ ; ImGui::NavMoveRequestButNoResultYet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@TreePop

; 5529 : 		if (g.NavIdIsAlive && (window->DC.TreeDepthMayJumpToParentOnPop & (1 << window->DC.TreeDepth)))

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+7141]
	test	eax, eax
	je	SHORT $LN3@TreePop
	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+364]
	mov	ecx, 1
	mov	DWORD PTR tv160[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv160[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+408]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN3@TreePop

; 5530 : 		{
; 5531 : 			SetNavID(window->IDStack.back(), g.NavLayer);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+7132]
	mov	DWORD PTR tv131[rsp], eax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 232				; 000000e8H
	mov	rcx, rax
	call	?back@?$ImVector@I@@QEAAAEAIXZ		; ImVector<unsigned int>::back
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv129[rsp], eax
	mov	edx, DWORD PTR tv131[rsp]
	mov	ecx, DWORD PTR tv129[rsp]
	call	?SetNavID@ImGui@@YAXIH@Z		; ImGui::SetNavID

; 5532 : 			NavMoveRequestCancel();

	call	?NavMoveRequestCancel@ImGui@@YAXXZ	; ImGui::NavMoveRequestCancel
	npad	1
$LN3@TreePop:
$LN2@TreePop:

; 5533 : 		}
; 5534 : 	window->DC.TreeDepthMayJumpToParentOnPop &= (1 << window->DC.TreeDepth) - 1;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+364]
	mov	ecx, 1
	mov	DWORD PTR tv170[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv170[rsp]
	shl	eax, cl
	dec	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rcx+408]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+408], eax

; 5535 : 
; 5536 : 	IM_ASSERT(window->IDStack.Size > 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.
; 5537 : 	PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	npad	1

; 5538 : }

	add	rsp, 72					; 00000048H
	ret	0
?TreePop@ImGui@@YAXXZ ENDP				; ImGui::TreePop
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 32
tv74 = 40
ptr_id$ = 64
?TreePush@ImGui@@YAXPEBX@Z PROC				; ImGui::TreePush

; 5506 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5507 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5508 : 	Indent();

	xorps	xmm0, xmm0
	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent

; 5509 : 	window->DC.TreeDepth++;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+364]
	inc	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+364], eax

; 5510 : 	PushID(ptr_id ? ptr_id : (const void*)("#TreePush"));

	cmp	QWORD PTR ptr_id$[rsp], 0
	je	SHORT $LN3@TreePush
	mov	rax, QWORD PTR ptr_id$[rsp]
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN4@TreePush
$LN3@TreePush:
	lea	rax, OFFSET FLAT:??_C@_09GHACPMKF@?$CDTreePush@
	mov	QWORD PTR tv74[rsp], rax
$LN4@TreePush:
	mov	rcx, QWORD PTR tv74[rsp]
	call	?PushID@ImGui@@YAXPEBX@Z		; ImGui::PushID
	npad	1

; 5511 : }

	add	rsp, 56					; 00000038H
	ret	0
?TreePush@ImGui@@YAXPEBX@Z ENDP				; ImGui::TreePush
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 32
tv74 = 40
str_id$ = 64
?TreePush@ImGui@@YAXPEBD@Z PROC				; ImGui::TreePush

; 5498 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5499 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5500 : 	Indent();

	xorps	xmm0, xmm0
	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent

; 5501 : 	window->DC.TreeDepth++;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+364]
	inc	eax
	mov	rcx, QWORD PTR window$[rsp]
	mov	DWORD PTR [rcx+364], eax

; 5502 : 	PushID(str_id ? str_id : ("#TreePush"));

	cmp	QWORD PTR str_id$[rsp], 0
	je	SHORT $LN3@TreePush
	mov	rax, QWORD PTR str_id$[rsp]
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN4@TreePush
$LN3@TreePush:
	lea	rax, OFFSET FLAT:??_C@_09GHACPMKF@?$CDTreePush@
	mov	QWORD PTR tv74[rsp], rax
$LN4@TreePush:
	mov	rcx, QWORD PTR tv74[rsp]
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID
	npad	1

; 5503 : }

	add	rsp, 56					; 00000038H
	ret	0
?TreePush@ImGui@@YAXPEBD@Z ENDP				; ImGui::TreePush
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 32
window$ = 40
label_end$ = 48
tv79 = 56
ptr_id$ = 80
flags$ = 88
fmt$ = 96
args$ = 104
?TreeNodeExV@ImGui@@YA_NPEBXHPEBDPEAD@Z PROC		; ImGui::TreeNodeExV

; 5288 : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 5289 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5290 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@TreeNodeEx

; 5291 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@TreeNodeEx
$LN2@TreeNodeEx:

; 5292 : 
; 5293 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5294 : 	const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 12240				; 00002fd0H
	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	edx, 3073				; 00000c01H
	mov	rcx, rax
	call	?ImFormatStringV@@YAHPEAD_KPEBD0@Z	; ImFormatStringV
	cdqe
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax+12240]
	mov	QWORD PTR label_end$[rsp], rax

; 5295 : 	return TreeNodeBehavior(window->GetID(ptr_id), flags, g.TempBuffer, label_end);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 12240				; 00002fd0H
	mov	QWORD PTR tv79[rsp], rax
	mov	rdx, QWORD PTR ptr_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBX@Z		; ImGuiWindow::GetID
	mov	r9, QWORD PTR label_end$[rsp]
	mov	rcx, QWORD PTR tv79[rsp]
	mov	r8, rcx
	mov	edx, DWORD PTR flags$[rsp]
	mov	ecx, eax
	call	?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z	; ImGui::TreeNodeBehavior
$LN1@TreeNodeEx:

; 5296 : }

	add	rsp, 72					; 00000048H
	ret	0
?TreeNodeExV@ImGui@@YA_NPEBXHPEBDPEAD@Z ENDP		; ImGui::TreeNodeExV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 32
window$ = 40
label_end$ = 48
tv79 = 56
str_id$ = 80
flags$ = 88
fmt$ = 96
args$ = 104
?TreeNodeExV@ImGui@@YA_NPEBDH0PEAD@Z PROC		; ImGui::TreeNodeExV

; 5277 : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 5278 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5279 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@TreeNodeEx

; 5280 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@TreeNodeEx
$LN2@TreeNodeEx:

; 5281 : 
; 5282 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5283 : 	const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 12240				; 00002fd0H
	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	edx, 3073				; 00000c01H
	mov	rcx, rax
	call	?ImFormatStringV@@YAHPEAD_KPEBD0@Z	; ImFormatStringV
	cdqe
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax+12240]
	mov	QWORD PTR label_end$[rsp], rax

; 5284 : 	return TreeNodeBehavior(window->GetID(str_id), flags, g.TempBuffer, label_end);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 12240				; 00002fd0H
	mov	QWORD PTR tv79[rsp], rax
	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	r9, QWORD PTR label_end$[rsp]
	mov	rcx, QWORD PTR tv79[rsp]
	mov	r8, rcx
	mov	edx, DWORD PTR flags$[rsp]
	mov	ecx, eax
	call	?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z	; ImGui::TreeNodeBehavior
$LN1@TreeNodeEx:

; 5285 : }

	add	rsp, 72					; 00000048H
	ret	0
?TreeNodeExV@ImGui@@YA_NPEBDH0PEAD@Z ENDP		; ImGui::TreeNodeExV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
is_open$ = 32
args$ = 40
ptr_id$ = 64
flags$ = 72
fmt$ = 80
?TreeNodeEx@ImGui@@YA_NPEBXHPEBDZZ PROC			; ImGui::TreeNodeEx

; 5268 : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 5269 : 	va_list args;
; 5270 : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 5271 : 	bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);

	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	edx, DWORD PTR flags$[rsp]
	mov	rcx, QWORD PTR ptr_id$[rsp]
	call	?TreeNodeExV@ImGui@@YA_NPEBXHPEBDPEAD@Z	; ImGui::TreeNodeExV
	mov	BYTE PTR is_open$[rsp], al

; 5272 : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 5273 : 	return is_open;

	movzx	eax, BYTE PTR is_open$[rsp]

; 5274 : }

	add	rsp, 56					; 00000038H
	ret	0
?TreeNodeEx@ImGui@@YA_NPEBXHPEBDZZ ENDP			; ImGui::TreeNodeEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
is_open$ = 32
args$ = 40
str_id$ = 64
flags$ = 72
fmt$ = 80
?TreeNodeEx@ImGui@@YA_NPEBDH0ZZ PROC			; ImGui::TreeNodeEx

; 5259 : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 5260 : 	va_list args;
; 5261 : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 5262 : 	bool is_open = TreeNodeExV(str_id, flags, fmt, args);

	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	edx, DWORD PTR flags$[rsp]
	mov	rcx, QWORD PTR str_id$[rsp]
	call	?TreeNodeExV@ImGui@@YA_NPEBDH0PEAD@Z	; ImGui::TreeNodeExV
	mov	BYTE PTR is_open$[rsp], al

; 5263 : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 5264 : 	return is_open;

	movzx	eax, BYTE PTR is_open$[rsp]

; 5265 : }

	add	rsp, 56					; 00000038H
	ret	0
?TreeNodeEx@ImGui@@YA_NPEBDH0ZZ ENDP			; ImGui::TreeNodeEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 32
label$ = 64
flags$ = 72
?TreeNodeEx@ImGui@@YA_NPEBDH@Z PROC			; ImGui::TreeNodeEx

; 5250 : {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5251 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5252 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@TreeNodeEx

; 5253 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@TreeNodeEx
$LN2@TreeNodeEx:

; 5254 : 
; 5255 : 	return TreeNodeBehavior(window->GetID(label), flags, label, NULL);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	xor	r9d, r9d
	mov	r8, QWORD PTR label$[rsp]
	mov	edx, DWORD PTR flags$[rsp]
	mov	ecx, eax
	call	?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z	; ImGui::TreeNodeBehavior
$LN1@TreeNodeEx:

; 5256 : }

	add	rsp, 56					; 00000038H
	ret	0
?TreeNodeEx@ImGui@@YA_NPEBDH@Z ENDP			; ImGui::TreeNodeEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
ptr_id$ = 48
fmt$ = 56
args$ = 64
?TreeNodeV@ImGui@@YA_NPEBXPEBDPEAD@Z PROC		; ImGui::TreeNodeV

; 5245 : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5246 : 	return TreeNodeExV(ptr_id, 0, fmt, args);

	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR ptr_id$[rsp]
	call	?TreeNodeExV@ImGui@@YA_NPEBXHPEBDPEAD@Z	; ImGui::TreeNodeExV

; 5247 : }

	add	rsp, 40					; 00000028H
	ret	0
?TreeNodeV@ImGui@@YA_NPEBXPEBDPEAD@Z ENDP		; ImGui::TreeNodeV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
str_id$ = 48
fmt$ = 56
args$ = 64
?TreeNodeV@ImGui@@YA_NPEBD0PEAD@Z PROC			; ImGui::TreeNodeV

; 5240 : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5241 : 	return TreeNodeExV(str_id, 0, fmt, args);

	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR str_id$[rsp]
	call	?TreeNodeExV@ImGui@@YA_NPEBDH0PEAD@Z	; ImGui::TreeNodeExV

; 5242 : }

	add	rsp, 40					; 00000028H
	ret	0
?TreeNodeV@ImGui@@YA_NPEBD0PEAD@Z ENDP			; ImGui::TreeNodeV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
is_open$ = 32
args$ = 40
ptr_id$ = 64
fmt$ = 72
?TreeNode@ImGui@@YA_NPEBXPEBDZZ PROC			; ImGui::TreeNode

; 5223 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 5224 : 	va_list args;
; 5225 : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 5226 : 	bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);

	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR ptr_id$[rsp]
	call	?TreeNodeExV@ImGui@@YA_NPEBXHPEBDPEAD@Z	; ImGui::TreeNodeExV
	mov	BYTE PTR is_open$[rsp], al

; 5227 : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 5228 : 	return is_open;

	movzx	eax, BYTE PTR is_open$[rsp]

; 5229 : }

	add	rsp, 56					; 00000038H
	ret	0
?TreeNode@ImGui@@YA_NPEBXPEBDZZ ENDP			; ImGui::TreeNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
is_open$ = 32
args$ = 40
str_id$ = 64
fmt$ = 72
?TreeNode@ImGui@@YA_NPEBD0ZZ PROC			; ImGui::TreeNode

; 5214 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 5215 : 	va_list args;
; 5216 : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 5217 : 	bool is_open = TreeNodeExV(str_id, 0, fmt, args);

	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR str_id$[rsp]
	call	?TreeNodeExV@ImGui@@YA_NPEBDH0PEAD@Z	; ImGui::TreeNodeExV
	mov	BYTE PTR is_open$[rsp], al

; 5218 : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 5219 : 	return is_open;

	movzx	eax, BYTE PTR is_open$[rsp]

; 5220 : }

	add	rsp, 56					; 00000038H
	ret	0
?TreeNode@ImGui@@YA_NPEBD0ZZ ENDP			; ImGui::TreeNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 32
label$ = 64
?TreeNode@ImGui@@YA_NPEBD@Z PROC			; ImGui::TreeNode

; 5232 : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5233 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5234 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@TreeNode

; 5235 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@TreeNode
$LN2@TreeNode:

; 5236 : 	return TreeNodeBehavior(window->GetID(label), 0, label, NULL);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	xor	r9d, r9d
	mov	r8, QWORD PTR label$[rsp]
	xor	edx, edx
	mov	ecx, eax
	call	?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z	; ImGui::TreeNodeBehavior
$LN1@TreeNode:

; 5237 : }

	add	rsp, 56					; 00000038H
	ret	0
?TreeNode@ImGui@@YA_NPEBD@Z ENDP			; ImGui::TreeNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
num_segments$ = 32
i$1 = 36
window$ = 40
a_min$ = 48
a$2 = 52
pos$ = 56
g$ = 64
id$ = 72
start$ = 76
a_max$ = 80
tv200 = 84
tv198 = 88
style$ = 96
size$ = 104
centre$ = 112
tv203 = 120
tv205 = 128
tv213 = 136
bb$ = 144
$T3 = 160
$T4 = 168
label$ = 192
radius$ = 200
thickness$ = 208
color$ = 216
?Spinner@ImGui@@YA_NPEBDMHAEBI@Z PROC			; ImGui::Spinner

; 5048 : bool ImGui::Spinner(const char* label, float radius, int thickness, const ImU32& color) {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 5049 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 5050 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN5@Spinner

; 5051 : 		return false;

	xor	al, al
	jmp	$LN1@Spinner
$LN5@Spinner:

; 5052 : 
; 5053 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 5054 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 5055 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 5056 : 
; 5057 : 	ImVec2 pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR pos$[rsp], rax

; 5058 : 	ImVec2 size((radius) * 2, (radius + style.FramePadding.y) * 2);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR radius$[rsp]
	addss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR radius$[rsp]
	mulss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR size$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 5059 : 
; 5060 : 	const ImRect bb(pos, ImVec2(pos.x + size.x, pos.y + size.y));

	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR size$[rsp+4]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, DWORD PTR size$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 5061 : 	ItemSize(bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 5062 : 	if (!ItemAdd(bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Spinner

; 5063 : 		return false;

	xor	al, al
	jmp	$LN1@Spinner
$LN6@Spinner:

; 5064 : 
; 5065 : 	// Render
; 5066 : 	window->DrawList->PathClear();

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR [rax+696]
	call	?PathClear@ImDrawList@@QEAAXXZ		; ImDrawList::PathClear

; 5067 : 
; 5068 : 	int num_segments = 30;

	mov	DWORD PTR num_segments$[rsp], 30

; 5069 : 	int start = abs(ImSin(g.Time * 1.8f) * (num_segments - 5));

	mov	rax, QWORD PTR g$[rsp]
	movsd	xmm0, QWORD PTR [rax+6576]
	mulsd	xmm0, QWORD PTR __real@3ffcccccc0000000
	cvtsd2ss xmm0, xmm0
	call	?ImSin@@YAMM@Z				; ImSin
	mov	eax, DWORD PTR num_segments$[rsp]
	sub	eax, 5
	cvtsi2ss xmm1, eax
	mulss	xmm0, xmm1
	call	?abs@@YAMM@Z				; abs
	cvttss2si eax, xmm0
	mov	DWORD PTR start$[rsp], eax

; 5070 : 
; 5071 : 	const float a_min = IM_PI * 2.0f * ((float)start) / (float)num_segments;

	cvtsi2ss xmm0, DWORD PTR start$[rsp]
	movss	xmm1, DWORD PTR __real@40c90fdb
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR num_segments$[rsp]
	divss	xmm0, xmm1
	movss	DWORD PTR a_min$[rsp], xmm0

; 5072 : 	const float a_max = IM_PI * 2.0f * ((float)num_segments - 3) / (float)num_segments;

	cvtsi2ss xmm0, DWORD PTR num_segments$[rsp]
	subss	xmm0, DWORD PTR __real@40400000
	movss	xmm1, DWORD PTR __real@40c90fdb
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR num_segments$[rsp]
	divss	xmm0, xmm1
	movss	DWORD PTR a_max$[rsp], xmm0

; 5073 : 
; 5074 : 	const ImVec2 centre = ImVec2(pos.x + radius, pos.y + radius + style.FramePadding.y);

	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR radius$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	addss	xmm0, DWORD PTR [rax+56]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, DWORD PTR radius$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR centre$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 5075 : 
; 5076 : 	for (int i = 0; i < num_segments; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@Spinner
$LN2@Spinner:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@Spinner:
	mov	eax, DWORD PTR num_segments$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN3@Spinner

; 5077 : 		const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);

	cvtsi2ss xmm0, DWORD PTR i$1[rsp]
	cvtsi2ss xmm1, DWORD PTR num_segments$[rsp]
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR a_max$[rsp]
	subss	xmm1, DWORD PTR a_min$[rsp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR a_min$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR a$2[rsp], xmm0

; 5078 : 		window->DrawList->PathLineTo(ImVec2(centre.x + ImCos(a + g.Time * 8) * radius,

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv205[rsp], rax
	cvtss2sd xmm0, DWORD PTR a$2[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movsd	xmm1, QWORD PTR [rax+6576]
	mulsd	xmm1, QWORD PTR __real@4020000000000000
	addsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	call	?ImSin@@YAMM@Z				; ImSin
	mulss	xmm0, DWORD PTR radius$[rsp]
	movss	xmm1, DWORD PTR centre$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv200[rsp], xmm0
	cvtss2sd xmm0, DWORD PTR a$2[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movsd	xmm1, QWORD PTR [rax+6576]
	mulsd	xmm1, QWORD PTR __real@4020000000000000
	addsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	call	?ImCos@@YAMM@Z				; ImCos
	mulss	xmm0, DWORD PTR radius$[rsp]
	movss	xmm1, DWORD PTR centre$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv198[rsp], xmm0
	movss	xmm2, DWORD PTR tv200[rsp]
	movss	xmm1, DWORD PTR tv198[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv203[rsp], rax
	mov	rdx, QWORD PTR tv203[rsp]
	mov	rcx, QWORD PTR tv205[rsp]
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
	npad	1

; 5079 : 			centre.y + ImSin(a + g.Time * 8) * radius));
; 5080 : 	}

	jmp	$LN2@Spinner
$LN3@Spinner:

; 5081 : 
; 5082 : 	window->DrawList->PathStroke(color, false, thickness);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv213[rsp], rax
	cvtsi2ss xmm0, DWORD PTR thickness$[rsp]
	movaps	xmm3, xmm0
	xor	r8d, r8d
	mov	rax, QWORD PTR color$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR tv213[rsp]
	call	?PathStroke@ImDrawList@@QEAAXI_NM@Z	; ImDrawList::PathStroke

; 5083 : 	return false;

	xor	al, al
$LN1@Spinner:

; 5084 : }

	add	rsp, 184				; 000000b8H
	ret	0
?Spinner@ImGui@@YA_NPEBDMHAEBI@Z ENDP			; ImGui::Spinner
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
r$ = 48
t$ = 52
window$ = 56
pos$ = 64
rectWidth$ = 72
circleWidth$ = 76
size$ = 80
bb$ = 88
id$ = 104
tv151 = 108
tv170 = 112
o1$ = 116
o2$ = 120
o3$ = 124
style$ = 128
g$ = 136
speed$ = 144
a$ = 148
b$ = 152
c$ = 156
tv149 = 160
tv153 = 168
tv168 = 176
tv172 = 184
tv255 = 192
tv257 = 200
tv272 = 208
tv274 = 216
tv289 = 224
tv291 = 232
$T1 = 240
$T2 = 248
$T3 = 256
$T4 = 264
$T5 = 272
$T6 = 280
label$ = 304
value$ = 312
size_arg$ = 320
bg_col$ = 328
fg_col$ = 336
?BufferingBar@ImGui@@YA_NPEBDMAEBUImVec2@@AEBI2@Z PROC	; ImGui::BufferingBar

; 4963 : bool ImGui::BufferingBar(const char* label, float value, const ImVec2& size_arg, const ImU32& bg_col, const ImU32& fg_col) {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 296				; 00000128H

; 4964 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 4965 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@BufferingB

; 4966 : 		return false;

	xor	al, al
	jmp	$LN1@BufferingB
$LN2@BufferingB:

; 4967 : 
; 4968 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4969 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 4970 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 4971 : 
; 4972 : 	ImVec2 pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR pos$[rsp], rax

; 4973 : 	ImVec2 size = size_arg;

	mov	rax, QWORD PTR size_arg$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR size$[rsp], rax

; 4974 : 	size.x -= style.FramePadding.x * 2;

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR size$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR size$[rsp], xmm0

; 4975 : 
; 4976 : 	const ImRect bb(pos, ImVec2(pos.x + size.x, pos.y + size.y));

	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR size$[rsp+4]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, DWORD PTR size$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 4977 : 	ItemSize(bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 4978 : 	if (!ItemAdd(bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@BufferingB

; 4979 : 		return false;

	xor	al, al
	jmp	$LN1@BufferingB
$LN3@BufferingB:

; 4980 : 
; 4981 : 	// Render
; 4982 : 	const float rectWidth = size.x;

	movss	xmm0, DWORD PTR size$[rsp]
	movss	DWORD PTR rectWidth$[rsp], xmm0

; 4983 : 	const float circleWidth = rectWidth * value;

	movss	xmm0, DWORD PTR rectWidth$[rsp]
	mulss	xmm0, DWORD PTR value$[rsp]
	movss	DWORD PTR circleWidth$[rsp], xmm0

; 4984 : 
; 4985 : 	const float t = g.Time;

	mov	rax, QWORD PTR g$[rsp]
	cvtsd2ss xmm0, QWORD PTR [rax+6576]
	movss	DWORD PTR t$[rsp], xmm0

; 4986 : 	const float r = size.y / 2;

	movss	xmm0, DWORD PTR size$[rsp+4]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR r$[rsp], xmm0

; 4987 : 	const float speed = 1.5;

	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR speed$[rsp], xmm0

; 4988 : 
; 4989 : 	window->DrawList->AddRectFilled(bb.Min, ImVec2(pos.x + rectWidth, bb.Max.y), bg_col, r);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv153[rsp], rax
	mov	rax, QWORD PTR bg_col$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv151[rsp], eax
	movss	xmm0, DWORD PTR pos$[rsp]
	addss	xmm0, DWORD PTR rectWidth$[rsp]
	movss	xmm2, DWORD PTR bb$[rsp+12]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv149[rsp], rax
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR r$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv151[rsp]
	mov	r8, QWORD PTR tv149[rsp]
	lea	rdx, QWORD PTR bb$[rsp]
	mov	rcx, QWORD PTR tv153[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1

; 4990 : 	window->DrawList->AddRectFilled(bb.Min, ImVec2(pos.x + rectWidth * value, bb.Max.y), fg_col, r);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv172[rsp], rax
	mov	rax, QWORD PTR fg_col$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv170[rsp], eax
	movss	xmm0, DWORD PTR rectWidth$[rsp]
	mulss	xmm0, DWORD PTR value$[rsp]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR bb$[rsp+12]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv168[rsp], rax
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR r$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv170[rsp]
	mov	r8, QWORD PTR tv168[rsp]
	lea	rdx, QWORD PTR bb$[rsp]
	mov	rcx, QWORD PTR tv172[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1

; 4991 : 
; 4992 : 
; 4993 : 	const float a = speed * 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR a$[rsp], xmm0

; 4994 : 	const float b = speed * 0.333f;

	movss	xmm0, DWORD PTR __real@3effbe77
	movss	DWORD PTR b$[rsp], xmm0

; 4995 : 	const float c = speed * 0.666f;

	movss	xmm0, DWORD PTR __real@3f7fbe77
	movss	DWORD PTR c$[rsp], xmm0

; 4996 : 
; 4997 : 	const float o1 = (circleWidth - r - 2) * (t + a - speed * (int)((t + a) / speed)) / speed;

	movss	xmm0, DWORD PTR circleWidth$[rsp]
	subss	xmm0, DWORD PTR r$[rsp]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR t$[rsp]
	addss	xmm1, DWORD PTR __real@00000000
	movss	xmm2, DWORD PTR t$[rsp]
	addss	xmm2, DWORD PTR __real@00000000
	divss	xmm2, DWORD PTR __real@3fc00000
	cvttss2si eax, xmm2
	cvtsi2ss xmm2, eax
	movss	xmm3, DWORD PTR __real@3fc00000
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	subss	xmm1, xmm2
	mulss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR o1$[rsp], xmm0

; 4998 : 	const float o2 = (circleWidth - r - 2) * (t + b - speed * (int)((t + b) / speed)) / speed;

	movss	xmm0, DWORD PTR circleWidth$[rsp]
	subss	xmm0, DWORD PTR r$[rsp]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR t$[rsp]
	addss	xmm1, DWORD PTR __real@3effbe77
	movss	xmm2, DWORD PTR t$[rsp]
	addss	xmm2, DWORD PTR __real@3effbe77
	divss	xmm2, DWORD PTR __real@3fc00000
	cvttss2si eax, xmm2
	cvtsi2ss xmm2, eax
	movss	xmm3, DWORD PTR __real@3fc00000
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	subss	xmm1, xmm2
	mulss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR o2$[rsp], xmm0

; 4999 : 	const float o3 = (circleWidth - r - 2) * (t + c - speed * (int)((t + c) / speed)) / speed;

	movss	xmm0, DWORD PTR circleWidth$[rsp]
	subss	xmm0, DWORD PTR r$[rsp]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR t$[rsp]
	addss	xmm1, DWORD PTR __real@3f7fbe77
	movss	xmm2, DWORD PTR t$[rsp]
	addss	xmm2, DWORD PTR __real@3f7fbe77
	divss	xmm2, DWORD PTR __real@3fc00000
	cvttss2si eax, xmm2
	cvtsi2ss xmm2, eax
	movss	xmm3, DWORD PTR __real@3fc00000
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	subss	xmm1, xmm2
	mulss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR o3$[rsp], xmm0

; 5000 : 
; 5001 : 	window->DrawList->AddCircleFilled(ImVec2(pos.x + r + o1, bb.Min.y + r), r, IM_COL32(255, 255, 255, 255));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv257[rsp], rax
	movss	xmm0, DWORD PTR bb$[rsp+4]
	addss	xmm0, DWORD PTR r$[rsp]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, DWORD PTR r$[rsp]
	addss	xmm1, DWORD PTR o1$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv255[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, -1					; ffffffffH
	movss	xmm2, DWORD PTR r$[rsp]
	mov	rdx, QWORD PTR tv255[rsp]
	mov	rcx, QWORD PTR tv257[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 5002 : 	window->DrawList->AddCircleFilled(ImVec2(pos.x + r + o2, bb.Min.y + r), r, IM_COL32(255, 255, 255, 255));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv274[rsp], rax
	movss	xmm0, DWORD PTR bb$[rsp+4]
	addss	xmm0, DWORD PTR r$[rsp]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, DWORD PTR r$[rsp]
	addss	xmm1, DWORD PTR o2$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv272[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, -1					; ffffffffH
	movss	xmm2, DWORD PTR r$[rsp]
	mov	rdx, QWORD PTR tv272[rsp]
	mov	rcx, QWORD PTR tv274[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 5003 : 	window->DrawList->AddCircleFilled(ImVec2(pos.x + r + o3, bb.Min.y + r), r, IM_COL32(255, 255, 255, 255));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv291[rsp], rax
	movss	xmm0, DWORD PTR bb$[rsp+4]
	addss	xmm0, DWORD PTR r$[rsp]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, DWORD PTR r$[rsp]
	addss	xmm1, DWORD PTR o3$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv289[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, -1					; ffffffffH
	movss	xmm2, DWORD PTR r$[rsp]
	mov	rdx, QWORD PTR tv289[rsp]
	mov	rcx, QWORD PTR tv291[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 5004 : 
; 5005 : 	//ImGuiWindow* window = GetCurrentWindow();
; 5006 : 	//if (window->SkipItems)
; 5007 : 	//	return false;
; 5008 : 
; 5009 : 	//ImGuiContext& g = *GImGui;
; 5010 : 	//const ImGuiStyle& style = g.Style;
; 5011 : 	//const ImGuiID id = window->GetID(label);
; 5012 : 
; 5013 : 	//ImVec2 pos = window->DC.CursorPos;
; 5014 : 	//ImVec2 size = size_arg;
; 5015 : 	//size.x -= style.FramePadding.x * 2;
; 5016 : 
; 5017 : 	//const ImRect bb(pos, ImVec2(pos.x + size.x, pos.y + size.y));
; 5018 : 	//ItemSize(bb, style.FramePadding.y);
; 5019 : 	//if (!ItemAdd(bb, id))
; 5020 : 	//	return false;
; 5021 : 
; 5022 : 	//// Render
; 5023 : 	//const float circleStart = size.x * 0.7f;
; 5024 : 	//const float circleEnd = size.x;
; 5025 : 	//const float circleWidth = circleEnd - circleStart;
; 5026 : 
; 5027 : 	//window->DrawList->AddRectFilled(bb.Min, ImVec2(pos.x + circleStart, bb.Max.y), bg_col);
; 5028 : 	//window->DrawList->AddRectFilled(bb.Min, ImVec2(pos.x + circleStart * value, bb.Max.y), fg_col);
; 5029 : 
; 5030 : 	//const float t = g.Time;
; 5031 : 	//const float r = size.y / 2;
; 5032 : 	//const float speed = 1.5f;
; 5033 : 
; 5034 : 	//const float a = speed * 0;
; 5035 : 	//const float b = speed * 0.333f;
; 5036 : 	//const float c = speed * 0.666f;
; 5037 : 
; 5038 : 	//const float o1 = (circleWidth + r) * (t + a - speed * (int)((t + a) / speed)) / speed;
; 5039 : 	//const float o2 = (circleWidth + r) * (t + b - speed * (int)((t + b) / speed)) / speed;
; 5040 : 	//const float o3 = (circleWidth + r) * (t + c - speed * (int)((t + c) / speed)) / speed;
; 5041 : 
; 5042 : 	//window->DrawList->AddCircleFilled(ImVec2(pos.x + circleEnd - o1, bb.Min.y + r), r, bg_col);
; 5043 : 	//window->DrawList->AddCircleFilled(ImVec2(pos.x + circleEnd - o2, bb.Min.y + r), r, bg_col);
; 5044 : 	//window->DrawList->AddCircleFilled(ImVec2(pos.x + circleEnd - o3, bb.Min.y + r), r, bg_col);
; 5045 : 	return false;

	xor	al, al
$LN1@BufferingB:

; 5046 : }

	add	rsp, 296				; 00000128H
	ret	0
?BufferingBar@ImGui@@YA_NPEBDMAEBUImVec2@@AEBI2@Z ENDP	; ImGui::BufferingBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 0
flags$ = 32
?SetColorEditOptions@ImGui@@YAXH@Z PROC			; ImGui::SetColorEditOptions

; 4949 : {

$LN6:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 4950 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4951 : 	if ((flags & ImGuiColorEditFlags__InputsMask) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 7340032				; 00700000H
	test	eax, eax
	jne	SHORT $LN2@SetColorEd

; 4952 : 		flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__InputsMask;

	mov	eax, DWORD PTR flags$[rsp]
	bts	eax, 20
	mov	DWORD PTR flags$[rsp], eax
$LN2@SetColorEd:

; 4953 : 	if ((flags & ImGuiColorEditFlags__DataTypeMask) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 25165824				; 01800000H
	test	eax, eax
	jne	SHORT $LN3@SetColorEd

; 4954 : 		flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DataTypeMask;

	mov	eax, DWORD PTR flags$[rsp]
	bts	eax, 23
	mov	DWORD PTR flags$[rsp], eax
$LN3@SetColorEd:

; 4955 : 	if ((flags & ImGuiColorEditFlags__PickerMask) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 100663296				; 06000000H
	test	eax, eax
	jne	SHORT $LN4@SetColorEd

; 4956 : 		flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__PickerMask;

	mov	eax, DWORD PTR flags$[rsp]
	bts	eax, 25
	mov	DWORD PTR flags$[rsp], eax
$LN4@SetColorEd:

; 4957 : 	IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__InputsMask)));   // Check only 1 option is selected
; 4958 : 	IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__DataTypeMask))); // Check only 1 option is selected
; 4959 : 	IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask)));   // Check only 1 option is selected
; 4960 : 	g.ColorEditOptions = flags;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rax+11676], ecx

; 4961 : }

	add	rsp, 24
	ret	0
?SetColorEditOptions@ImGui@@YAXH@Z ENDP			; ImGui::SetColorEditOptions
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
pressed$ = 64
hovered$ = 65
off$ = 68
grid_step$ = 72
id$ = 76
bb_inner$ = 80
rounding$ = 96
held$ = 100
default_size$ = 104
window$ = 112
tv146 = 120
tv216 = 124
mid_x$1 = 128
tv268 = 132
tv303 = 136
tv336 = 140
g$ = 144
tv273 = 152
bb$ = 160
tv142 = 176
tv140 = 184
$T2 = 192
$T3 = 200
$T4 = 208
$T5 = 216
tv266 = 224
tv270 = 232
$T6 = 240
$T7 = 248
$T8 = 256
$T9 = 264
$T10 = 272
$T11 = 280
$T12 = 288
$T13 = 296
$T14 = 304
$T15 = 312
tv334 = 320
tv332 = 328
tv338 = 336
tv362 = 344
tv360 = 352
tv364 = 360
tv94 = 368
tv92 = 376
col_source$16 = 384
col_without_alpha$ = 400
$T17 = 416
$T18 = 424
$T19 = 432
$T20 = 440
$T21 = 448
$T22 = 456
$T23 = 464
$T24 = 472
$T25 = 480
$T26 = 488
$T27 = 496
$T28 = 504
$T29 = 512
$T30 = 520
$T31 = 528
$T32 = 536
desc_id$ = 576
col$ = 584
flags$ = 592
size$ = 600
?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z PROC ; ImGui::ColorButton

; 4867 : {

$LN21:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 552				; 00000228H

; 4868 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 4869 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@ColorButto

; 4870 : 		return false;

	xor	al, al
	jmp	$LN1@ColorButto
$LN2@ColorButto:

; 4871 : 
; 4872 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4873 : 	const ImGuiID id = window->GetID(desc_id);

	xor	r8d, r8d
	mov	rdx, QWORD PTR desc_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 4874 : 	float default_size = GetFrameHeight();

	call	?GetFrameHeight@ImGui@@YAMXZ		; ImGui::GetFrameHeight
	movss	DWORD PTR default_size$[rsp], xmm0

; 4875 : 	if (size.x == 0.0f)

	movss	xmm0, DWORD PTR size$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN3@ColorButto
	jne	SHORT $LN3@ColorButto

; 4876 : 		size.x = default_size;

	movss	xmm0, DWORD PTR default_size$[rsp]
	movss	DWORD PTR size$[rsp], xmm0
$LN3@ColorButto:

; 4877 : 	if (size.y == 0.0f)

	movss	xmm0, DWORD PTR size$[rsp+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN4@ColorButto
	jne	SHORT $LN4@ColorButto

; 4878 : 		size.y = default_size;

	movss	xmm0, DWORD PTR default_size$[rsp]
	movss	DWORD PTR size$[rsp+4], xmm0
$LN4@ColorButto:

; 4879 : 	const ImRect bb(window->DC.CursorPos + ImVec2(30.f, 0), window->DC.CursorPos + size + ImVec2(30.f, 0));

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@41f00000
	lea	rcx, QWORD PTR $T29[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv94[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	lea	r8, QWORD PTR size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T30[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv92[rsp], rax
	mov	r8, QWORD PTR tv94[rsp]
	mov	rdx, QWORD PTR tv92[rsp]
	lea	rcx, QWORD PTR $T31[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv142[rsp], rax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@41f00000
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T18[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv140[rsp], rax
	mov	r8, QWORD PTR tv142[rsp]
	mov	rdx, QWORD PTR tv140[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 4880 : 	ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);

	movss	xmm0, DWORD PTR size$[rsp+4]
	comiss	xmm0, DWORD PTR default_size$[rsp]
	jb	SHORT $LN17@ColorButto
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5528]
	movss	DWORD PTR tv146[rsp], xmm0
	jmp	SHORT $LN18@ColorButto
$LN17@ColorButto:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv146[rsp], xmm0
$LN18@ColorButto:
	movss	xmm1, DWORD PTR tv146[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 4881 : 	if (!ItemAdd(bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@ColorButto

; 4882 : 		return false;

	xor	al, al
	jmp	$LN1@ColorButto
$LN5@ColorButto:

; 4883 : 
; 4884 : 	bool hovered, held;
; 4885 : 	bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 4886 : 
; 4887 : 	if (flags & ImGuiColorEditFlags_NoAlpha)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN6@ColorButto

; 4888 : 		flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, -393217				; fffffffffff9ffffH
	mov	DWORD PTR flags$[rsp], eax
$LN6@ColorButto:

; 4889 : 
; 4890 : 	ImVec4 col_without_alpha(col.x, col.y, col.z, 1.0f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm3, DWORD PTR [rax+8]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR col_without_alpha$[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4

; 4891 : 	float grid_step = ImMin(size.x, size.y) / 2.99f;

	movss	xmm1, DWORD PTR size$[rsp+4]
	movss	xmm0, DWORD PTR size$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	divss	xmm0, DWORD PTR __real@403f5c29
	movss	DWORD PTR grid_step$[rsp], xmm0

; 4892 : 	float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);

	movss	xmm0, DWORD PTR grid_step$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movaps	xmm1, xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5532]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR rounding$[rsp], xmm0

; 4893 : 	ImRect bb_inner = bb;

	lea	rax, QWORD PTR bb_inner$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 4894 : 	float off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.

	movss	xmm0, DWORD PTR __real@bf400000
	movss	DWORD PTR off$[rsp], xmm0

; 4895 : 	bb_inner.Expand(off);

	movss	xmm1, DWORD PTR off$[rsp]
	lea	rcx, QWORD PTR bb_inner$[rsp]
	call	?Expand@ImRect@@QEAAXM@Z		; ImRect::Expand
	npad	1

; 4896 : 	if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col.w < 1.0f)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	$LN7@ColorButto
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [rax+12]
	jbe	$LN7@ColorButto

; 4897 : 	{
; 4898 : 		float mid_x = (float)(int)((bb_inner.Min.x + bb_inner.Max.x) * 0.5f + 0.5f);

	movss	xmm0, DWORD PTR bb_inner$[rsp]
	addss	xmm0, DWORD PTR bb_inner$[rsp+8]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR mid_x$1[rsp], xmm0

; 4899 : 		RenderColorRectWithAlphaCheckerboard(ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight);

	movss	xmm0, DWORD PTR grid_step$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR off$[rsp]
	movss	xmm2, DWORD PTR off$[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T25[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	rcx, QWORD PTR col$[rsp]
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv216[rsp], eax
	movss	xmm0, DWORD PTR bb_inner$[rsp]
	addss	xmm0, DWORD PTR grid_step$[rsp]
	movss	xmm2, DWORD PTR bb_inner$[rsp+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	DWORD PTR [rsp+48], 10
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	mov	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR [rsp+32], rax
	movss	xmm3, DWORD PTR grid_step$[rsp]
	mov	r8d, DWORD PTR tv216[rsp]
	mov	rdx, QWORD PTR bb_inner$[rsp+8]
	mov	rcx, QWORD PTR $T5[rsp]
	call	?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z ; ImGui::RenderColorRectWithAlphaCheckerboard
	npad	1

; 4900 : 		window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_without_alpha), rounding, ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv270[rsp], rax
	lea	rcx, QWORD PTR col_without_alpha$[rsp]
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv268[rsp], eax
	movss	xmm2, DWORD PTR bb_inner$[rsp+12]
	movss	xmm1, DWORD PTR mid_x$1[rsp]
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv266[rsp], rax
	mov	DWORD PTR [rsp+40], 5
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv268[rsp]
	mov	r8, QWORD PTR tv266[rsp]
	lea	rdx, QWORD PTR bb_inner$[rsp]
	mov	rcx, QWORD PTR tv270[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1

; 4901 : 	}

	jmp	$LN8@ColorButto
$LN7@ColorButto:

; 4902 : 	else
; 4903 : 	{
; 4904 : 		// Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
; 4905 : 		ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col : col_without_alpha;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $LN19@ColorButto
	mov	rax, QWORD PTR col$[rsp]
	mov	QWORD PTR tv273[rsp], rax
	jmp	SHORT $LN20@ColorButto
$LN19@ColorButto:
	lea	rax, QWORD PTR col_without_alpha$[rsp]
	mov	QWORD PTR tv273[rsp], rax
$LN20@ColorButto:
	mov	rax, QWORD PTR tv273[rsp]
	mov	QWORD PTR $T6[rsp], rax
	lea	rax, QWORD PTR col_source$16[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR $T6[rsp]
	mov	ecx, 16
	rep movsb

; 4906 : 		if (col_source.w < 1.0f)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR col_source$16[rsp+12]
	jbe	$LN9@ColorButto

; 4907 : 			RenderColorRectWithAlphaCheckerboard(ImVec2(bb_inner.Min.x, bb_inner.Min.y + 6), ImVec2(bb_inner.Max.x, bb_inner.Max.y - 6), GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);

	movss	xmm2, DWORD PTR off$[rsp]
	movss	xmm1, DWORD PTR off$[rsp]
	lea	rcx, QWORD PTR $T21[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T7[rsp], rax
	mov	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR $T8[rsp], rax
	mov	rax, QWORD PTR $T8[rsp]
	mov	QWORD PTR $T13[rsp], rax
	lea	rcx, QWORD PTR col_source$16[rsp]
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv303[rsp], eax
	movss	xmm0, DWORD PTR bb_inner$[rsp+12]
	subss	xmm0, DWORD PTR __real@40c00000
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR bb_inner$[rsp+8]
	lea	rcx, QWORD PTR $T22[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T9[rsp], rax
	mov	rax, QWORD PTR $T9[rsp]
	mov	QWORD PTR $T10[rsp], rax
	mov	rax, QWORD PTR $T10[rsp]
	mov	QWORD PTR $T14[rsp], rax
	movss	xmm0, DWORD PTR bb_inner$[rsp+4]
	addss	xmm0, DWORD PTR __real@40c00000
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR bb_inner$[rsp]
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T11[rsp], rax
	mov	rax, QWORD PTR $T11[rsp]
	mov	QWORD PTR $T12[rsp], rax
	mov	rax, QWORD PTR $T12[rsp]
	mov	QWORD PTR $T15[rsp], rax
	mov	DWORD PTR [rsp+48], -1
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	mov	rax, QWORD PTR $T13[rsp]
	mov	QWORD PTR [rsp+32], rax
	movss	xmm3, DWORD PTR grid_step$[rsp]
	mov	r8d, DWORD PTR tv303[rsp]
	mov	rdx, QWORD PTR $T14[rsp]
	mov	rcx, QWORD PTR $T15[rsp]
	call	?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z ; ImGui::RenderColorRectWithAlphaCheckerboard
	npad	1
	jmp	$LN10@ColorButto
$LN9@ColorButto:

; 4908 : 		else
; 4909 : 		{
; 4910 : 			window->DrawList->AddRectFilled(ImVec2(bb_inner.Min.x + 4, bb_inner.Min.y + 4), ImVec2(bb_inner.Max.x - 4, bb_inner.Max.y - 4), GetColorU32(col_source), rounding, ImDrawCornerFlags_All);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv338[rsp], rax
	lea	rcx, QWORD PTR col_source$16[rsp]
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv336[rsp], eax
	movss	xmm0, DWORD PTR bb_inner$[rsp+12]
	subss	xmm0, DWORD PTR __real@40800000
	movss	xmm1, DWORD PTR bb_inner$[rsp+8]
	subss	xmm1, DWORD PTR __real@40800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv334[rsp], rax
	movss	xmm0, DWORD PTR bb_inner$[rsp+4]
	addss	xmm0, DWORD PTR __real@40800000
	movss	xmm1, DWORD PTR bb_inner$[rsp]
	addss	xmm1, DWORD PTR __real@40800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T32[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv332[rsp], rax
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR rounding$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv336[rsp]
	mov	r8, QWORD PTR tv334[rsp]
	mov	rdx, QWORD PTR tv332[rsp]
	mov	rcx, QWORD PTR tv338[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1

; 4911 : 			window->DrawList->AddRect(ImVec2(bb_inner.Min.x + 2, bb_inner.Min.y + 2), ImVec2(bb_inner.Max.x - 2, bb_inner.Max.y - 2), 0xFFFFFFFF, 2.f, ImDrawCornerFlags_All, 1);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv364[rsp], rax
	movss	xmm0, DWORD PTR bb_inner$[rsp+12]
	subss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR bb_inner$[rsp+8]
	subss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv362[rsp], rax
	movss	xmm0, DWORD PTR bb_inner$[rsp+4]
	addss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR bb_inner$[rsp]
	addss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T27[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv360[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, -1					; ffffffffH
	mov	r8, QWORD PTR tv362[rsp]
	mov	rdx, QWORD PTR tv360[rsp]
	mov	rcx, QWORD PTR tv364[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1
$LN10@ColorButto:
$LN8@ColorButto:

; 4912 : 		}
; 4913 : 	}
; 4914 : 	RenderNavHighlight(bb, id);

	mov	r8d, 1
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
	npad	1

; 4915 : 	//   if (g.Style.FrameBorderSize > 0.0f)
; 4916 : 	//       RenderFrameBorder(bb.Min, bb.Max, rounding);
; 4917 : 	//   else
; 4918 : 	   //{
; 4919 : 	   //	//window->DrawList->AddRect(ImVec2(bb.Min.x, bb.Min.y + 6), ImVec2(bb.Max.x, bb.Max.y - 6), GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border
; 4920 : 	   //	window->DrawList->AddRect(ImVec2(bb.Min.x, bb.Min.y + 6), ImVec2(bb.Max.x, bb.Max.y - 6), IM_COL32(80, 120, 228, 255), rounding); // Color button are often in need of some sort of border
; 4921 : 
; 4922 : 	   //}
; 4923 : 
; 4924 : 	   // Drag and Drop Source
; 4925 : 	   // NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
; 4926 : 	if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource())

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	$LN11@ColorButto
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 512				; 00000200H
	test	eax, eax
	jne	$LN11@ColorButto
	xor	ecx, ecx
	call	?BeginDragDropSource@ImGui@@YA_NH@Z	; ImGui::BeginDragDropSource
	movzx	eax, al
	test	eax, eax
	je	$LN11@ColorButto

; 4927 : 	{
; 4928 : 		if (flags & ImGuiColorEditFlags_NoAlpha)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN12@ColorButto

; 4929 : 			SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col, sizeof(float) * 3, ImGuiCond_Once);

	mov	r9d, 2
	mov	r8d, 12
	mov	rdx, QWORD PTR col$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_06LFKNFKEK@_COL3F@
	call	?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z ; ImGui::SetDragDropPayload
	npad	1
	jmp	SHORT $LN13@ColorButto
$LN12@ColorButto:

; 4930 : 		else
; 4931 : 			SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col, sizeof(float) * 4, ImGuiCond_Once);

	mov	r9d, 2
	mov	r8d, 16
	mov	rdx, QWORD PTR col$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_06LAOCEMMP@_COL4F@
	call	?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z ; ImGui::SetDragDropPayload
	npad	1
$LN13@ColorButto:

; 4932 : 		ColorButton(desc_id, col, flags);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T28[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9, QWORD PTR [rax]
	mov	r8d, DWORD PTR flags$[rsp]
	mov	rdx, QWORD PTR col$[rsp]
	mov	rcx, QWORD PTR desc_id$[rsp]
	call	?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z ; ImGui::ColorButton
	npad	1

; 4933 : 		SameLine();

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@bf800000
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 4934 : 		TextUnformatted(("Color"));

	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_05PDOBBJNA@Color@
	call	?TextUnformatted@ImGui@@YAXPEBD0@Z	; ImGui::TextUnformatted

; 4935 : 		EndDragDropSource();

	call	?EndDragDropSource@ImGui@@YAXXZ		; ImGui::EndDragDropSource
	npad	1
$LN11@ColorButto:

; 4936 : 	}
; 4937 : 
; 4938 : 	// Tooltip
; 4939 : 	if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN14@ColorButto
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN14@ColorButto

; 4940 : 		ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 393218				; 00060002H
	mov	rcx, QWORD PTR col$[rsp]
	mov	r8d, eax
	mov	rdx, rcx
	mov	rcx, QWORD PTR desc_id$[rsp]
	call	?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z	; ImGui::ColorTooltip
	npad	1
$LN14@ColorButto:

; 4941 : 
; 4942 : 	if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN15@ColorButto

; 4943 : 		MarkItemEdited(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN15@ColorButto:

; 4944 : 
; 4945 : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@ColorButto:

; 4946 : }

	add	rsp, 552				; 00000228H
	pop	rdi
	pop	rsi
	ret	0
?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z ENDP ; ImGui::ColorButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 64
sv_picker_size$ = 68
value_changed_h$ = 72
value_changed_sv$ = 73
alpha_bar$ = 74
H$ = 76
picker_pos$ = 80
bars_width$ = 88
draw_list$ = 96
value_changed_fix_hue_wrap$ = 104
wheel_r_inner$ = 108
V$ = 112
i$1 = 116
wheel_r_outer$ = 120
S$ = 124
bar0_pos_x$ = 128
n$2 = 132
wheel_center$ = 136
hue_color32$ = 144
col32_no_alpha$ = 148
bar1_pos_x$ = 152
triangle_r$ = 156
square_sz$ = 160
new_V$3 = 164
cos_hue_angle$4 = 168
bars_triangles_half_sz$ = 172
wheel_thickness$ = 176
hue_cursor_rad$5 = 180
sin_hue_angle$6 = 184
g$ = 192
sub_flags$7 = 200
new_S$8 = 204
a0$9 = 208
a1$10 = 212
hue_cursor_segments$11 = 216
sv_cursor_rad$ = 220
components$ = 224
sv_cursor_pos$ = 232
style$ = 240
uv_white$12 = 248
tv455 = 256
tv487 = 260
tv530 = 264
tv533 = 268
tv537 = 272
tv549 = 276
tv571 = 280
tv660 = 284
tv683 = 288
aeps$13 = 292
tv858 = 296
tv1163 = 300
tv82 = 304
tv92 = 308
tv129 = 312
tv139 = 316
initial_dist2$14 = 320
sin_hue_angle$15 = 324
cos_hue_angle$16 = 328
triangle_pa$ = 336
triangle_pb$ = 344
triangle_pc$ = 352
current_off_unrotated$17 = 360
io$ = 368
tra$18 = 376
trc$19 = 384
trb$20 = 392
tv960 = 400
tv1009 = 404
tv1011 = 408
tv1024 = 412
tv1026 = 416
tv1122 = 420
tv1120 = 424
tv147 = 428
tv1084 = 432
bar0_line_y$21 = 436
tv1210 = 440
alpha$22 = 444
bar1_line_y$23 = 448
vv$24 = 452
uu$25 = 456
sub_flags_to_forward$26 = 460
tv609 = 464
tv622 = 468
new_H$27 = 472
tv1086 = 476
tv687 = 480
segment_per_arc$28 = 484
tv806 = 488
tv804 = 492
tv821 = 496
tv819 = 500
vert_end_idx$29 = 504
vert_start_idx$30 = 508
current_off$31 = 512
hue_cursor_pos$32 = 520
window$ = 528
bar1_bb$33 = 536
initial_off$34 = 552
label_display_end$35 = 560
hue_color_f$ = 568
tv542 = 584
tv544 = 592
tv540 = 600
tv667 = 608
tv669 = 616
tv665 = 624
tv689 = 632
tv691 = 640
tv693 = 648
gradient_p1$36 = 656
gradient_p0$37 = 664
tv958 = 672
$T38 = 680
$T39 = 688
tv1082 = 696
tv1080 = 704
$T40 = 712
$T41 = 720
$T42 = 728
$T43 = 736
$T44 = 744
$T45 = 752
$T46 = 760
ww$47 = 768
$T48 = 772
$T49 = 780
$T50 = 788
$T51 = 796
$T52 = 804
$T53 = 812
$T54 = 820
$T55 = 828
$T56 = 836
$T57 = 844
$T58 = 852
$T59 = 860
$T60 = 868
$T61 = 876
$T62 = 884
$T63 = 892
$T64 = 900
$T65 = 908
$T66 = 916
$T67 = 924
$T68 = 932
$T69 = 940
$T70 = 948
$T71 = 956
$T72 = 964
$T73 = 972
$T74 = 980
$T75 = 988
$T76 = 996
$T77 = 1004
col_v4$78 = 1016
ref_col_v4$79 = 1032
$T80 = 1048
hue_colors$ = 1064
backup_initial_col$ = 1096
__$ArrayPad$ = 1112
label$ = 1136
col$ = 1144
flags$ = 1152
ref_col$ = 1160
?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z PROC		; ImGui::ColorPicker4

; 4559 : {

$LN87:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1128				; 00000468H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 4560 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4561 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 4562 : 	ImDrawList* draw_list = window->DrawList;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR draw_list$[rsp], rax

; 4563 : 
; 4564 : 	ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 4565 : 	ImGuiIO& io = g.IO;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 16
	mov	QWORD PTR io$[rsp], rax

; 4566 : 
; 4567 : 	PushID(label);

	mov	rcx, QWORD PTR label$[rsp]
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 4568 : 	BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup
	npad	1

; 4569 : 
; 4570 : 	if (!(flags & ImGuiColorEditFlags_NoSidePreview))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	jne	SHORT $LN8@ColorPicke

; 4571 : 		flags |= ImGuiColorEditFlags_NoSmallPreview;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 16
	mov	DWORD PTR flags$[rsp], eax
$LN8@ColorPicke:

; 4572 : 
; 4573 : 	// Context menu: display and store options.
; 4574 : 	if (!(flags & ImGuiColorEditFlags_NoOptions))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN9@ColorPicke

; 4575 : 		ColorPickerOptionsPopup(col, flags);

	mov	edx, DWORD PTR flags$[rsp]
	mov	rcx, QWORD PTR col$[rsp]
	call	?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z ; ImGui::ColorPickerOptionsPopup
	npad	1
$LN9@ColorPicke:

; 4576 : 
; 4577 : 	// Read stored options
; 4578 : 	if (!(flags & ImGuiColorEditFlags__PickerMask))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 100663296				; 06000000H
	test	eax, eax
	jne	SHORT $LN10@ColorPicke

; 4579 : 		flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__PickerMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__PickerMask;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+11676]
	and	eax, 100663296				; 06000000H
	test	eax, eax
	je	SHORT $LN56@ColorPicke
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+11676]
	mov	DWORD PTR tv82[rsp], eax
	jmp	SHORT $LN57@ColorPicke
$LN56@ColorPicke:
	mov	DWORD PTR tv82[rsp], 42991616		; 02900000H
$LN57@ColorPicke:
	mov	eax, DWORD PTR tv82[rsp]
	and	eax, 100663296				; 06000000H
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax
$LN10@ColorPicke:

; 4580 : 	IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask))); // Check that only 1 is selected
; 4581 : 	if (!(flags & ImGuiColorEditFlags_NoOptions))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN11@ColorPicke

; 4582 : 		flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+11676]
	and	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax
$LN11@ColorPicke:

; 4583 : 
; 4584 : 	// Setup
; 4585 : 	int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN58@ColorPicke
	mov	DWORD PTR tv92[rsp], 3
	jmp	SHORT $LN59@ColorPicke
$LN58@ColorPicke:
	mov	DWORD PTR tv92[rsp], 4
$LN59@ColorPicke:
	mov	eax, DWORD PTR tv92[rsp]
	mov	DWORD PTR components$[rsp], eax

; 4586 : 	bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	SHORT $LN60@ColorPicke
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN60@ColorPicke
	mov	DWORD PTR tv129[rsp], 1
	jmp	SHORT $LN61@ColorPicke
$LN60@ColorPicke:
	mov	DWORD PTR tv129[rsp], 0
$LN61@ColorPicke:
	movzx	eax, BYTE PTR tv129[rsp]
	mov	BYTE PTR alpha_bar$[rsp], al

; 4587 : 	ImVec2 picker_pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR picker_pos$[rsp], rax

; 4588 : 	float square_sz = GetFrameHeight();

	call	?GetFrameHeight@ImGui@@YAMXZ		; ImGui::GetFrameHeight
	movss	DWORD PTR square_sz$[rsp], xmm0

; 4589 : 	float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars

	movss	xmm0, DWORD PTR square_sz$[rsp]
	movss	DWORD PTR bars_width$[rsp], xmm0

; 4590 : 	float sv_picker_size = ImMax(bars_width * 1, CalcItemWidth() - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box

	movzx	eax, BYTE PTR alpha_bar$[rsp]
	test	eax, eax
	je	SHORT $LN62@ColorPicke
	mov	DWORD PTR tv139[rsp], 2
	jmp	SHORT $LN63@ColorPicke
$LN62@ColorPicke:
	mov	DWORD PTR tv139[rsp], 1
$LN63@ColorPicke:
	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	cvtsi2ss xmm1, DWORD PTR tv139[rsp]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR bars_width$[rsp]
	addss	xmm2, DWORD PTR [rax+76]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR bars_width$[rsp]
	mulss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR tv147[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv147[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR sv_picker_size$[rsp], xmm0

; 4591 : 	float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;

	movss	xmm0, DWORD PTR picker_pos$[rsp]
	addss	xmm0, DWORD PTR sv_picker_size$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	addss	xmm0, DWORD PTR [rax+76]
	movss	DWORD PTR bar0_pos_x$[rsp], xmm0

; 4592 : 	float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;

	movss	xmm0, DWORD PTR bar0_pos_x$[rsp]
	addss	xmm0, DWORD PTR bars_width$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	addss	xmm0, DWORD PTR [rax+76]
	movss	DWORD PTR bar1_pos_x$[rsp], xmm0

; 4593 : 	float bars_triangles_half_sz = (float)(int)(bars_width * 0.20f);

	movss	xmm0, DWORD PTR bars_width$[rsp]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR bars_triangles_half_sz$[rsp], xmm0

; 4594 : 
; 4595 : 	float backup_initial_col[4];
; 4596 : 	memcpy(backup_initial_col, col, components * sizeof(float));

	movsxd	rax, DWORD PTR components$[rsp]
	shl	rax, 2
	mov	r8, rax
	mov	rdx, QWORD PTR col$[rsp]
	lea	rcx, QWORD PTR backup_initial_col$[rsp]
	call	memcpy

; 4597 : 
; 4598 : 	float wheel_thickness = sv_picker_size * 0.08f;

	movss	xmm0, DWORD PTR sv_picker_size$[rsp]
	mulss	xmm0, DWORD PTR __real@3da3d70a
	movss	DWORD PTR wheel_thickness$[rsp], xmm0

; 4599 : 	float wheel_r_outer = sv_picker_size * 0.50f;

	movss	xmm0, DWORD PTR sv_picker_size$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR wheel_r_outer$[rsp], xmm0

; 4600 : 	float wheel_r_inner = wheel_r_outer - wheel_thickness;

	movss	xmm0, DWORD PTR wheel_r_outer$[rsp]
	subss	xmm0, DWORD PTR wheel_thickness$[rsp]
	movss	DWORD PTR wheel_r_inner$[rsp], xmm0

; 4601 : 	ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width) * 0.5f, picker_pos.y + sv_picker_size * 0.5f);

	movss	xmm0, DWORD PTR sv_picker_size$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR picker_pos$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR sv_picker_size$[rsp]
	addss	xmm1, DWORD PTR bars_width$[rsp]
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR picker_pos$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR wheel_center$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 4602 : 
; 4603 : 	// Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.
; 4604 : 	float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);

	movss	xmm0, DWORD PTR sv_picker_size$[rsp]
	mulss	xmm0, DWORD PTR __real@3cdd2f1b
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR wheel_r_inner$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR triangle_r$[rsp], xmm0

; 4605 : 	ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR triangle_r$[rsp]
	lea	rcx, QWORD PTR triangle_pa$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 4606 : 	ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.

	movss	xmm0, DWORD PTR triangle_r$[rsp]
	mulss	xmm0, DWORD PTR __real@bf5db3d0
	movss	xmm1, DWORD PTR triangle_r$[rsp]
	mulss	xmm1, DWORD PTR __real@bf000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR triangle_pb$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 4607 : 	ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.

	movss	xmm0, DWORD PTR triangle_r$[rsp]
	mulss	xmm0, DWORD PTR __real@3f5db3d0
	movss	xmm1, DWORD PTR triangle_r$[rsp]
	mulss	xmm1, DWORD PTR __real@bf000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR triangle_pc$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 4608 : 
; 4609 : 	float H, S, V;
; 4610 : 	ColorConvertRGBtoHSV(col[0], col[1], col[2], H, S, V);

	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 0
	lea	r8, QWORD PTR V$[rsp]
	mov	QWORD PTR [rsp+40], r8
	lea	r8, QWORD PTR S$[rsp]
	mov	QWORD PTR [rsp+32], r8
	lea	r9, QWORD PTR H$[rsp]
	mov	r8, QWORD PTR col$[rsp]
	movss	xmm2, DWORD PTR [r8+rax]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm1, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rax+rdx]
	call	?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertRGBtoHSV

; 4611 : 
; 4612 : 	bool value_changed = false, value_changed_h = false, value_changed_sv = false;

	mov	BYTE PTR value_changed$[rsp], 0
	mov	BYTE PTR value_changed_h$[rsp], 0
	mov	BYTE PTR value_changed_sv$[rsp], 0

; 4613 : 
; 4614 : 	PushItemFlag(ImGuiItemFlags_NoNav, true);

	mov	dl, 1
	mov	ecx, 8
	call	?PushItemFlag@ImGui@@YAXH_N@Z		; ImGui::PushItemFlag
	npad	1

; 4615 : 	if (flags & ImGuiColorEditFlags_PickerHueWheel)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	$LN12@ColorPicke

; 4616 : 	{
; 4617 : 		// Hue wheel + SV triangle logic
; 4618 : 		InvisibleButton(("hsv"), ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR sv_picker_size$[rsp]
	addss	xmm0, DWORD PTR [rax+76]
	addss	xmm0, DWORD PTR bars_width$[rsp]
	movss	xmm2, DWORD PTR sv_picker_size$[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T76[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_03PPLPHHG@hsv@
	call	?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@@Z ; ImGui::InvisibleButton
	npad	1

; 4619 : 		if (IsItemActive())

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	movzx	eax, al
	test	eax, eax
	je	$LN14@ColorPicke

; 4620 : 		{
; 4621 : 			ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1036]
	lea	r8, QWORD PTR wheel_center$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR initial_off$34[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-

; 4622 : 			ImVec2 current_off = g.IO.MousePos - wheel_center;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 316				; 0000013cH
	lea	r8, QWORD PTR wheel_center$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR current_off$31[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-

; 4623 : 			float initial_dist2 = ImLengthSqr(initial_off);

	lea	rcx, QWORD PTR initial_off$34[rsp]
	call	?ImLengthSqr@@YAMAEBUImVec2@@@Z		; ImLengthSqr
	movss	DWORD PTR initial_dist2$14[rsp], xmm0

; 4624 : 			if (initial_dist2 >= (wheel_r_inner - 1) * (wheel_r_inner - 1) && initial_dist2 <= (wheel_r_outer + 1) * (wheel_r_outer + 1))

	movss	xmm0, DWORD PTR wheel_r_inner$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR wheel_r_inner$[rsp]
	subss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR initial_dist2$14[rsp]
	comiss	xmm1, xmm0
	jb	$LN15@ColorPicke
	movss	xmm0, DWORD PTR wheel_r_outer$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR wheel_r_outer$[rsp]
	addss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm0, xmm1
	comiss	xmm0, DWORD PTR initial_dist2$14[rsp]
	jb	SHORT $LN15@ColorPicke

; 4625 : 			{
; 4626 : 				// Interactive with Hue wheel
; 4627 : 				H = ImAtan2(current_off.y, current_off.x) / IM_PI * 0.5f;

	movss	xmm1, DWORD PTR current_off$31[rsp]
	movss	xmm0, DWORD PTR current_off$31[rsp+4]
	call	?ImAtan2@@YAMMM@Z			; ImAtan2
	divss	xmm0, DWORD PTR __real@40490fdb
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR H$[rsp], xmm0

; 4628 : 				if (H < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR H$[rsp]
	jbe	SHORT $LN16@ColorPicke

; 4629 : 					H += 1.0f;

	movss	xmm0, DWORD PTR H$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR H$[rsp], xmm0
$LN16@ColorPicke:

; 4630 : 				value_changed = value_changed_h = true;

	mov	BYTE PTR value_changed_h$[rsp], 1
	movzx	eax, BYTE PTR value_changed_h$[rsp]
	mov	BYTE PTR value_changed$[rsp], al
$LN15@ColorPicke:

; 4631 : 			}
; 4632 : 			float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);

	movss	xmm0, DWORD PTR H$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@40490fdb
	call	?ImCos@@YAMM@Z				; ImCos
	movss	DWORD PTR cos_hue_angle$16[rsp], xmm0

; 4633 : 			float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);

	movss	xmm0, DWORD PTR H$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@40490fdb
	call	?ImSin@@YAMM@Z				; ImSin
	movss	DWORD PTR sin_hue_angle$15[rsp], xmm0

; 4634 : 			if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))

	movss	xmm3, DWORD PTR sin_hue_angle$15[rsp]
	movss	xmm2, DWORD PTR cos_hue_angle$16[rsp]
	lea	rdx, QWORD PTR initial_off$34[rsp]
	lea	rcx, QWORD PTR $T77[rsp]
	call	?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z	; ImRotate
	mov	r9, rax
	lea	r8, QWORD PTR triangle_pc$[rsp]
	lea	rdx, QWORD PTR triangle_pb$[rsp]
	lea	rcx, QWORD PTR triangle_pa$[rsp]
	call	?ImTriangleContainsPoint@@YA_NAEBUImVec2@@000@Z ; ImTriangleContainsPoint
	movzx	eax, al
	test	eax, eax
	je	$LN17@ColorPicke

; 4635 : 			{
; 4636 : 				// Interacting with SV triangle
; 4637 : 				ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);

	movss	xmm3, DWORD PTR sin_hue_angle$15[rsp]
	movss	xmm2, DWORD PTR cos_hue_angle$16[rsp]
	lea	rdx, QWORD PTR current_off$31[rsp]
	lea	rcx, QWORD PTR current_off_unrotated$17[rsp]
	call	?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z	; ImRotate
	npad	1

; 4638 : 				if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))

	lea	r9, QWORD PTR current_off_unrotated$17[rsp]
	lea	r8, QWORD PTR triangle_pc$[rsp]
	lea	rdx, QWORD PTR triangle_pb$[rsp]
	lea	rcx, QWORD PTR triangle_pa$[rsp]
	call	?ImTriangleContainsPoint@@YA_NAEBUImVec2@@000@Z ; ImTriangleContainsPoint
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@ColorPicke

; 4639 : 					current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);

	lea	rax, QWORD PTR current_off_unrotated$17[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR triangle_pc$[rsp]
	lea	r8, QWORD PTR triangle_pb$[rsp]
	lea	rdx, QWORD PTR triangle_pa$[rsp]
	lea	rcx, QWORD PTR $T48[rsp]
	call	?ImTriangleClosestPoint@@YA?AUImVec2@@AEBU1@000@Z ; ImTriangleClosestPoint
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR current_off_unrotated$17[rsp], rax
$LN18@ColorPicke:

; 4640 : 				float uu, vv, ww;
; 4641 : 				ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);

	lea	rax, QWORD PTR ww$47[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR vv$24[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR uu$25[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR current_off_unrotated$17[rsp]
	lea	r8, QWORD PTR triangle_pc$[rsp]
	lea	rdx, QWORD PTR triangle_pb$[rsp]
	lea	rcx, QWORD PTR triangle_pa$[rsp]
	call	?ImTriangleBarycentricCoords@@YAXAEBUImVec2@@000AEAM11@Z ; ImTriangleBarycentricCoords

; 4642 : 				V = ImClamp(1.0f - vv, 0.0001f, 1.0f);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR vv$24[rsp]
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@38d1b717
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR V$[rsp], xmm0

; 4643 : 				S = ImClamp(uu / V, 0.0001f, 1.0f);

	movss	xmm0, DWORD PTR uu$25[rsp]
	divss	xmm0, DWORD PTR V$[rsp]
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@38d1b717
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR S$[rsp], xmm0

; 4644 : 				value_changed = value_changed_sv = true;

	mov	BYTE PTR value_changed_sv$[rsp], 1
	movzx	eax, BYTE PTR value_changed_sv$[rsp]
	mov	BYTE PTR value_changed$[rsp], al
$LN17@ColorPicke:
$LN14@ColorPicke:

; 4645 : 			}
; 4646 : 		}
; 4647 : 		if (!(flags & ImGuiColorEditFlags_NoOptions))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN19@ColorPicke

; 4648 : 			OpenPopupOnItemClick(("context"));

	mov	edx, 1
	lea	rcx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	call	?OpenPopupOnItemClick@ImGui@@YA_NPEBDH@Z ; ImGui::OpenPopupOnItemClick
	npad	1
$LN19@ColorPicke:

; 4649 : 	}

	jmp	$LN13@ColorPicke
$LN12@ColorPicke:

; 4650 : 	else if (flags & ImGuiColorEditFlags_PickerHueBar)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	$LN20@ColorPicke

; 4651 : 	{
; 4652 : 		// SV rectangle logic
; 4653 : 		InvisibleButton(("sv"), ImVec2(sv_picker_size, sv_picker_size));

	movss	xmm2, DWORD PTR sv_picker_size$[rsp]
	movss	xmm1, DWORD PTR sv_picker_size$[rsp]
	lea	rcx, QWORD PTR $T49[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_02CPGMCOJE@sv@
	call	?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@@Z ; ImGui::InvisibleButton
	npad	1

; 4654 : 		if (IsItemActive())

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	movzx	eax, al
	test	eax, eax
	je	$LN21@ColorPicke

; 4655 : 		{
; 4656 : 			S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size - 1));

	mov	rax, QWORD PTR io$[rsp]
	movss	xmm0, DWORD PTR [rax+300]
	subss	xmm0, DWORD PTR picker_pos$[rsp]
	movss	xmm1, DWORD PTR sv_picker_size$[rsp]
	subss	xmm1, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR S$[rsp], xmm0

; 4657 : 			V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));

	mov	rax, QWORD PTR io$[rsp]
	movss	xmm0, DWORD PTR [rax+304]
	subss	xmm0, DWORD PTR picker_pos$[rsp+4]
	movss	xmm1, DWORD PTR sv_picker_size$[rsp]
	subss	xmm1, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR V$[rsp], xmm0

; 4658 : 			value_changed = value_changed_sv = true;

	mov	BYTE PTR value_changed_sv$[rsp], 1
	movzx	eax, BYTE PTR value_changed_sv$[rsp]
	mov	BYTE PTR value_changed$[rsp], al
$LN21@ColorPicke:

; 4659 : 		}
; 4660 : 		if (!(flags & ImGuiColorEditFlags_NoOptions))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN22@ColorPicke

; 4661 : 			OpenPopupOnItemClick(("context"));

	mov	edx, 1
	lea	rcx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	call	?OpenPopupOnItemClick@ImGui@@YA_NPEBDH@Z ; ImGui::OpenPopupOnItemClick
	npad	1
$LN22@ColorPicke:

; 4662 : 
; 4663 : 		// Hue bar logic
; 4664 : 		SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));

	movss	xmm2, DWORD PTR picker_pos$[rsp+4]
	movss	xmm1, DWORD PTR bar0_pos_x$[rsp]
	lea	rcx, QWORD PTR $T50[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, rax
	call	?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z ; ImGui::SetCursorScreenPos
	npad	1

; 4665 : 		InvisibleButton(("hue"), ImVec2(bars_width, sv_picker_size));

	movss	xmm2, DWORD PTR sv_picker_size$[rsp]
	movss	xmm1, DWORD PTR bars_width$[rsp]
	lea	rcx, QWORD PTR $T51[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_03GKJJMKFG@hue@
	call	?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@@Z ; ImGui::InvisibleButton
	npad	1

; 4666 : 		if (IsItemActive())

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@ColorPicke

; 4667 : 		{
; 4668 : 			H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));

	mov	rax, QWORD PTR io$[rsp]
	movss	xmm0, DWORD PTR [rax+304]
	subss	xmm0, DWORD PTR picker_pos$[rsp+4]
	movss	xmm1, DWORD PTR sv_picker_size$[rsp]
	subss	xmm1, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR H$[rsp], xmm0

; 4669 : 			value_changed = value_changed_h = true;

	mov	BYTE PTR value_changed_h$[rsp], 1
	movzx	eax, BYTE PTR value_changed_h$[rsp]
	mov	BYTE PTR value_changed$[rsp], al
$LN23@ColorPicke:
$LN20@ColorPicke:
$LN13@ColorPicke:

; 4670 : 		}
; 4671 : 	}
; 4672 : 
; 4673 : 	// Alpha bar logic
; 4674 : 	if (alpha_bar)

	movzx	eax, BYTE PTR alpha_bar$[rsp]
	test	eax, eax
	je	$LN24@ColorPicke

; 4675 : 	{
; 4676 : 		SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));

	movss	xmm2, DWORD PTR picker_pos$[rsp+4]
	movss	xmm1, DWORD PTR bar1_pos_x$[rsp]
	lea	rcx, QWORD PTR $T52[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, rax
	call	?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z ; ImGui::SetCursorScreenPos
	npad	1

; 4677 : 		InvisibleButton(("alpha"), ImVec2(bars_width, sv_picker_size));

	movss	xmm2, DWORD PTR sv_picker_size$[rsp]
	movss	xmm1, DWORD PTR bars_width$[rsp]
	lea	rcx, QWORD PTR $T53[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_05IAEKHIAN@alpha@
	call	?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@@Z ; ImGui::InvisibleButton
	npad	1

; 4678 : 		if (IsItemActive())

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@ColorPicke

; 4679 : 		{
; 4680 : 			col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));

	mov	rax, QWORD PTR io$[rsp]
	movss	xmm0, DWORD PTR [rax+304]
	subss	xmm0, DWORD PTR picker_pos$[rsp+4]
	movss	xmm1, DWORD PTR sv_picker_size$[rsp]
	subss	xmm1, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR col$[rsp]
	movss	DWORD PTR [rcx+rax], xmm0

; 4681 : 			value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN25@ColorPicke:
$LN24@ColorPicke:

; 4682 : 		}
; 4683 : 	}
; 4684 : 	PopItemFlag(); // ImGuiItemFlags_NoNav

	call	?PopItemFlag@ImGui@@YAXXZ		; ImGui::PopItemFlag
	npad	1

; 4685 : 
; 4686 : 	if (!(flags & ImGuiColorEditFlags_NoSidePreview))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	jne	SHORT $LN26@ColorPicke

; 4687 : 	{
; 4688 : 		SameLine(0, style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 4689 : 		BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup
	npad	1
$LN26@ColorPicke:

; 4690 : 	}
; 4691 : 
; 4692 : 	if (!(flags & ImGuiColorEditFlags_NoLabel))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN27@ColorPicke

; 4693 : 	{
; 4694 : 		const char* label_display_end = FindRenderedTextEnd(label);

	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	QWORD PTR label_display_end$35[rsp], rax

; 4695 : 		if (label != label_display_end)

	mov	rax, QWORD PTR label_display_end$35[rsp]
	cmp	QWORD PTR label$[rsp], rax
	je	SHORT $LN28@ColorPicke

; 4696 : 		{
; 4697 : 			if ((flags & ImGuiColorEditFlags_NoSidePreview))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN29@ColorPicke

; 4698 : 				SameLine(0, style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1
$LN29@ColorPicke:

; 4699 : 			TextUnformatted(label, label_display_end);

	mov	rdx, QWORD PTR label_display_end$35[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?TextUnformatted@ImGui@@YAXPEBD0@Z	; ImGui::TextUnformatted
	npad	1
$LN28@ColorPicke:
$LN27@ColorPicke:

; 4700 : 		}
; 4701 : 	}
; 4702 : 
; 4703 : 	if (!(flags & ImGuiColorEditFlags_NoSidePreview))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	jne	$LN30@ColorPicke

; 4704 : 	{
; 4705 : 		PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);

	mov	dl, 1
	mov	ecx, 16
	call	?PushItemFlag@ImGui@@YAXH_N@Z		; ImGui::PushItemFlag

; 4706 : 		ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN64@ColorPicke
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv455[rsp], xmm0
	jmp	SHORT $LN65@ColorPicke
$LN64@ColorPicke:
	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR tv455[rsp], xmm0
$LN65@ColorPicke:
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 0
	movss	xmm0, DWORD PTR tv455[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r8, QWORD PTR col$[rsp]
	movss	xmm3, DWORD PTR [r8+rax]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm2, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm1, DWORD PTR [rax+rdx]
	lea	rcx, QWORD PTR col_v4$78[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	npad	1

; 4707 : 		if ((flags & ImGuiColorEditFlags_NoLabel))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN31@ColorPicke

; 4708 : 			Text(("###Current###"));

	lea	rcx, OFFSET FLAT:??_C@_0O@EALHHNOL@?$CD?$CD?$CDCurrent?$CD?$CD?$CD@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1
$LN31@ColorPicke:

; 4709 : 		ColorButton(("##+-current"), col_v4, (flags & (ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 2, square_sz * 2));

	movss	xmm0, DWORD PTR square_sz$[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR square_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T54[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	ecx, DWORD PTR flags$[rsp]
	and	ecx, 917568				; 000e0040H
	mov	r9, QWORD PTR [rax]
	mov	r8d, ecx
	lea	rdx, QWORD PTR col_v4$78[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0M@BANGFOMF@?$CD?$CD?$CL?9current@
	call	?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z ; ImGui::ColorButton
	npad	1

; 4710 : 		if (ref_col != NULL)

	cmp	QWORD PTR ref_col$[rsp], 0
	je	$LN32@ColorPicke

; 4711 : 		{
; 4712 : 			Text(("###Original###"));

	lea	rcx, OFFSET FLAT:??_C@_0P@ECAOJHDA@?$CD?$CD?$CDOriginal?$CD?$CD?$CD@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 4713 : 			ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN66@ColorPicke
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv487[rsp], xmm0
	jmp	SHORT $LN67@ColorPicke
$LN66@ColorPicke:
	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR ref_col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR tv487[rsp], xmm0
$LN67@ColorPicke:
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 0
	movss	xmm0, DWORD PTR tv487[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r8, QWORD PTR ref_col$[rsp]
	movss	xmm3, DWORD PTR [r8+rax]
	mov	rax, QWORD PTR ref_col$[rsp]
	movss	xmm2, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR ref_col$[rsp]
	movss	xmm1, DWORD PTR [rax+rdx]
	lea	rcx, QWORD PTR ref_col_v4$79[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	npad	1

; 4714 : 			if (ColorButton(("##+-original"), ref_col_v4, (flags & (ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 2, square_sz * 2)))

	movss	xmm0, DWORD PTR square_sz$[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR square_sz$[rsp]
	mulss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T55[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	ecx, DWORD PTR flags$[rsp]
	and	ecx, 917568				; 000e0040H
	mov	r9, QWORD PTR [rax]
	mov	r8d, ecx
	lea	rdx, QWORD PTR ref_col_v4$79[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0N@CHHIOJEB@?$CD?$CD?$CL?9original@
	call	?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z ; ImGui::ColorButton
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@ColorPicke

; 4715 : 			{
; 4716 : 				memcpy(col, ref_col, components * sizeof(float));

	movsxd	rax, DWORD PTR components$[rsp]
	shl	rax, 2
	mov	r8, rax
	mov	rdx, QWORD PTR ref_col$[rsp]
	mov	rcx, QWORD PTR col$[rsp]
	call	memcpy

; 4717 : 				value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN33@ColorPicke:
$LN32@ColorPicke:

; 4718 : 			}
; 4719 : 		}
; 4720 : 		PopItemFlag();

	call	?PopItemFlag@ImGui@@YAXXZ		; ImGui::PopItemFlag

; 4721 : 		EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	npad	1
$LN30@ColorPicke:

; 4722 : 	}
; 4723 : 
; 4724 : 	// Convert back color to RGB
; 4725 : 	if (value_changed_h || value_changed_sv)

	movzx	eax, BYTE PTR value_changed_h$[rsp]
	test	eax, eax
	jne	SHORT $LN35@ColorPicke
	movzx	eax, BYTE PTR value_changed_sv$[rsp]
	test	eax, eax
	je	$LN34@ColorPicke
$LN35@ColorPicke:

; 4726 : 		ColorConvertHSVtoRGB(H >= 1.0f ? H - 10 * 1e-6f : H, S > 0.0f ? S : 10 * 1e-6f, V > 0.0f ? V : 1e-6f, col[0], col[1], col[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR col$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv542[rsp], rax
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR col$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv544[rsp], rax
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR col$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv540[rsp], rax
	movss	xmm0, DWORD PTR V$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN68@ColorPicke
	movss	xmm0, DWORD PTR V$[rsp]
	movss	DWORD PTR tv530[rsp], xmm0
	jmp	SHORT $LN69@ColorPicke
$LN68@ColorPicke:
	movss	xmm0, DWORD PTR __real@358637bd
	movss	DWORD PTR tv530[rsp], xmm0
$LN69@ColorPicke:
	movss	xmm0, DWORD PTR S$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN70@ColorPicke
	movss	xmm0, DWORD PTR S$[rsp]
	movss	DWORD PTR tv533[rsp], xmm0
	jmp	SHORT $LN71@ColorPicke
$LN70@ColorPicke:
	movss	xmm0, DWORD PTR __real@3727c5ac
	movss	DWORD PTR tv533[rsp], xmm0
$LN71@ColorPicke:
	movss	xmm0, DWORD PTR H$[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN72@ColorPicke
	movss	xmm0, DWORD PTR H$[rsp]
	subss	xmm0, DWORD PTR __real@3727c5ac
	movss	DWORD PTR tv537[rsp], xmm0
	jmp	SHORT $LN73@ColorPicke
$LN72@ColorPicke:
	movss	xmm0, DWORD PTR H$[rsp]
	movss	DWORD PTR tv537[rsp], xmm0
$LN73@ColorPicke:
	mov	rax, QWORD PTR tv542[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv544[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv540[rsp]
	movss	xmm2, DWORD PTR tv530[rsp]
	movss	xmm1, DWORD PTR tv533[rsp]
	movss	xmm0, DWORD PTR tv537[rsp]
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB
	npad	1
$LN34@ColorPicke:

; 4727 : 
; 4728 : 	// R,G,B and H,S,V slider color editor
; 4729 : 	bool value_changed_fix_hue_wrap = false;

	mov	BYTE PTR value_changed_fix_hue_wrap$[rsp], 0

; 4730 : 	if ((flags & ImGuiColorEditFlags_NoInputs) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	$LN36@ColorPicke

; 4731 : 	{
; 4732 : 		PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);

	movzx	eax, BYTE PTR alpha_bar$[rsp]
	test	eax, eax
	je	SHORT $LN74@ColorPicke
	movss	xmm0, DWORD PTR bar1_pos_x$[rsp]
	movss	DWORD PTR tv549[rsp], xmm0
	jmp	SHORT $LN75@ColorPicke
$LN74@ColorPicke:
	movss	xmm0, DWORD PTR bar0_pos_x$[rsp]
	movss	DWORD PTR tv549[rsp], xmm0
$LN75@ColorPicke:
	movss	xmm0, DWORD PTR tv549[rsp]
	addss	xmm0, DWORD PTR bars_width$[rsp]
	subss	xmm0, DWORD PTR picker_pos$[rsp]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 4733 : 		ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;

	mov	DWORD PTR sub_flags_to_forward$26[rsp], 26083354 ; 018e001aH

; 4734 : 		ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;

	mov	eax, DWORD PTR sub_flags_to_forward$26[rsp]
	mov	ecx, DWORD PTR flags$[rsp]
	and	ecx, eax
	mov	eax, ecx
	or	eax, 4
	mov	DWORD PTR sub_flags$7[rsp], eax

; 4735 : 		if (flags & ImGuiColorEditFlags_RGB || (flags & ImGuiColorEditFlags__InputsMask) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	jne	SHORT $LN38@ColorPicke
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 7340032				; 00700000H
	test	eax, eax
	jne	SHORT $LN37@ColorPicke
$LN38@ColorPicke:

; 4736 : 			if (ColorEdit4(("##+-rgb"), col, sub_flags | ImGuiColorEditFlags_RGB))

	mov	eax, DWORD PTR sub_flags$7[rsp]
	bts	eax, 20
	mov	r8d, eax
	mov	rdx, QWORD PTR col$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_07JMCOMEPF@?$CD?$CD?$CL?9rgb@
	call	?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z	; ImGui::ColorEdit4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN39@ColorPicke

; 4737 : 			{
; 4738 : 				// FIXME: Hackily differenciating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.
; 4739 : 				// For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)
; 4740 : 				value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN76@ColorPicke
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+6753]
	test	eax, eax
	jne	SHORT $LN76@ColorPicke
	mov	DWORD PTR tv571[rsp], 1
	jmp	SHORT $LN77@ColorPicke
$LN76@ColorPicke:
	mov	DWORD PTR tv571[rsp], 0
$LN77@ColorPicke:
	movzx	eax, BYTE PTR tv571[rsp]
	mov	BYTE PTR value_changed_fix_hue_wrap$[rsp], al

; 4741 : 				value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN39@ColorPicke:
$LN37@ColorPicke:

; 4742 : 			}
; 4743 : 		if (flags & ImGuiColorEditFlags_HSV || (flags & ImGuiColorEditFlags__InputsMask) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2097152				; 00200000H
	test	eax, eax
	jne	SHORT $LN41@ColorPicke
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 7340032				; 00700000H
	test	eax, eax
	jne	SHORT $LN40@ColorPicke
$LN41@ColorPicke:

; 4744 : 			value_changed |= ColorEdit4(("##+-hsv"), col, sub_flags | ImGuiColorEditFlags_HSV);

	movzx	eax, BYTE PTR value_changed$[rsp]
	mov	DWORD PTR tv609[rsp], eax
	mov	ecx, DWORD PTR sub_flags$7[rsp]
	bts	ecx, 21
	mov	r8d, ecx
	mov	rdx, QWORD PTR col$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_07JGALKPPH@?$CD?$CD?$CL?9hsv@
	call	?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z	; ImGui::ColorEdit4
	movzx	eax, al
	mov	ecx, DWORD PTR tv609[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR value_changed$[rsp], al
$LN40@ColorPicke:

; 4745 : 		if (flags & ImGuiColorEditFlags_HEX || (flags & ImGuiColorEditFlags__InputsMask) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4194304				; 00400000H
	test	eax, eax
	jne	SHORT $LN43@ColorPicke
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 7340032				; 00700000H
	test	eax, eax
	jne	SHORT $LN42@ColorPicke
$LN43@ColorPicke:

; 4746 : 			value_changed |= ColorEdit4(("##+-hex"), col, sub_flags | ImGuiColorEditFlags_HEX);

	movzx	eax, BYTE PTR value_changed$[rsp]
	mov	DWORD PTR tv622[rsp], eax
	mov	ecx, DWORD PTR sub_flags$7[rsp]
	bts	ecx, 22
	mov	r8d, ecx
	mov	rdx, QWORD PTR col$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_07BACDFNLL@?$CD?$CD?$CL?9hex@
	call	?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z	; ImGui::ColorEdit4
	movzx	eax, al
	mov	ecx, DWORD PTR tv622[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR value_changed$[rsp], al
$LN42@ColorPicke:

; 4747 : 		PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	npad	1
$LN36@ColorPicke:

; 4748 : 	}
; 4749 : 
; 4750 : 	// Try to cancel hue wrap (after ColorEdit4 call), if any
; 4751 : 	if (value_changed_fix_hue_wrap)

	movzx	eax, BYTE PTR value_changed_fix_hue_wrap$[rsp]
	test	eax, eax
	je	$LN44@ColorPicke

; 4752 : 	{
; 4753 : 		float new_H, new_S, new_V;
; 4754 : 		ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);

	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 0
	lea	r8, QWORD PTR new_V$3[rsp]
	mov	QWORD PTR [rsp+40], r8
	lea	r8, QWORD PTR new_S$8[rsp]
	mov	QWORD PTR [rsp+32], r8
	lea	r9, QWORD PTR new_H$27[rsp]
	mov	r8, QWORD PTR col$[rsp]
	movss	xmm2, DWORD PTR [r8+rax]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm1, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rax+rdx]
	call	?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertRGBtoHSV
	npad	1

; 4755 : 		if (new_H <= 0 && H > 0)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR new_H$27[rsp]
	jb	$LN45@ColorPicke
	movss	xmm0, DWORD PTR H$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN45@ColorPicke

; 4756 : 		{
; 4757 : 			if (new_V <= 0 && V != new_V)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR new_V$3[rsp]
	jb	$LN46@ColorPicke
	movss	xmm0, DWORD PTR V$[rsp]
	ucomiss	xmm0, DWORD PTR new_V$3[rsp]
	jp	SHORT $LN86@ColorPicke
	je	$LN46@ColorPicke
$LN86@ColorPicke:

; 4758 : 				ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR col$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv667[rsp], rax
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR col$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv669[rsp], rax
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR col$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv665[rsp], rax
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR new_V$3[rsp]
	jb	SHORT $LN78@ColorPicke
	movss	xmm0, DWORD PTR V$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv660[rsp], xmm0
	jmp	SHORT $LN79@ColorPicke
$LN78@ColorPicke:
	movss	xmm0, DWORD PTR new_V$3[rsp]
	movss	DWORD PTR tv660[rsp], xmm0
$LN79@ColorPicke:
	mov	rax, QWORD PTR tv667[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv669[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv665[rsp]
	movss	xmm2, DWORD PTR tv660[rsp]
	movss	xmm1, DWORD PTR S$[rsp]
	movss	xmm0, DWORD PTR H$[rsp]
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB
	npad	1
	jmp	$LN47@ColorPicke
$LN46@ColorPicke:

; 4759 : 			else if (new_S <= 0)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR new_S$8[rsp]
	jb	$LN48@ColorPicke

; 4760 : 				ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR col$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv689[rsp], rax
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR col$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv691[rsp], rax
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR col$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv693[rsp], rax
	movss	xmm0, DWORD PTR new_V$3[rsp]
	movss	DWORD PTR tv687[rsp], xmm0
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR new_S$8[rsp]
	jb	SHORT $LN80@ColorPicke
	movss	xmm0, DWORD PTR S$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv683[rsp], xmm0
	jmp	SHORT $LN81@ColorPicke
$LN80@ColorPicke:
	movss	xmm0, DWORD PTR new_S$8[rsp]
	movss	DWORD PTR tv683[rsp], xmm0
$LN81@ColorPicke:
	mov	rax, QWORD PTR tv689[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv691[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv693[rsp]
	movss	xmm2, DWORD PTR tv687[rsp]
	movss	xmm1, DWORD PTR tv683[rsp]
	movss	xmm0, DWORD PTR H$[rsp]
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB
	npad	1
$LN48@ColorPicke:
$LN47@ColorPicke:
$LN45@ColorPicke:
$LN44@ColorPicke:

; 4761 : 		}
; 4762 : 	}
; 4763 : 
; 4764 : 	ImVec4 hue_color_f(1, 1, 1, 1); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR hue_color_f$[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	lea	rax, QWORD PTR hue_color_f$[rsp+8]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR hue_color_f$[rsp+4]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR hue_color_f$[rsp]
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	movss	xmm0, DWORD PTR H$[rsp]
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 4765 : 	ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);

	lea	rcx, QWORD PTR hue_color_f$[rsp]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR hue_color32$[rsp], eax

; 4766 : 	ImU32 col32_no_alpha = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 1.0f));

	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r8, QWORD PTR col$[rsp]
	movss	xmm3, DWORD PTR [r8+rax]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm2, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm1, DWORD PTR [rax+rdx]
	lea	rcx, QWORD PTR $T80[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR col32_no_alpha$[rsp], eax

; 4767 : 
; 4768 : 	const ImU32 hue_colors[6 + 1] = { IM_COL32(255,0,0,255), IM_COL32(255,255,0,255), IM_COL32(0,255,0,255), IM_COL32(0,255,255,255), IM_COL32(0,0,255,255), IM_COL32(255,0,255,255), IM_COL32(255,0,0,255) };

	mov	DWORD PTR hue_colors$[rsp], -16776961	; ff0000ffH
	mov	DWORD PTR hue_colors$[rsp+4], -16711681	; ff00ffffH
	mov	DWORD PTR hue_colors$[rsp+8], -16711936	; ff00ff00H
	mov	DWORD PTR hue_colors$[rsp+12], -256	; ffffff00H
	mov	DWORD PTR hue_colors$[rsp+16], -65536	; ffff0000H
	mov	DWORD PTR hue_colors$[rsp+20], -65281	; ffff00ffH
	mov	DWORD PTR hue_colors$[rsp+24], -16776961 ; ff0000ffH

; 4769 : 	ImVec2 sv_cursor_pos;

	lea	rcx, QWORD PTR sv_cursor_pos$[rsp]
	call	??0ImVec2@@QEAA@XZ			; ImVec2::ImVec2
	npad	1

; 4770 : 
; 4771 : 	if (flags & ImGuiColorEditFlags_PickerHueWheel)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	$LN49@ColorPicke

; 4772 : 	{
; 4773 : 		// Render Hue Wheel
; 4774 : 		const float aeps = 1.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).

	movss	xmm0, DWORD PTR __real@3fc00000
	divss	xmm0, DWORD PTR wheel_r_outer$[rsp]
	movss	DWORD PTR aeps$13[rsp], xmm0

; 4775 : 		const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);

	cvttss2si eax, DWORD PTR wheel_r_outer$[rsp]
	cdq
	mov	ecx, 12
	idiv	ecx
	mov	edx, eax
	mov	ecx, 4
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	DWORD PTR segment_per_arc$28[rsp], eax

; 4776 : 		for (int n = 0; n < 6; n++)

	mov	DWORD PTR n$2[rsp], 0
	jmp	SHORT $LN4@ColorPicke
$LN2@ColorPicke:
	mov	eax, DWORD PTR n$2[rsp]
	inc	eax
	mov	DWORD PTR n$2[rsp], eax
$LN4@ColorPicke:
	cmp	DWORD PTR n$2[rsp], 6
	jge	$LN3@ColorPicke

; 4777 : 		{
; 4778 : 			const float a0 = (n) / 6.0f * 2.0f * IM_PI - aeps;

	cvtsi2ss xmm0, DWORD PTR n$2[rsp]
	divss	xmm0, DWORD PTR __real@40c00000
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@40490fdb
	subss	xmm0, DWORD PTR aeps$13[rsp]
	movss	DWORD PTR a0$9[rsp], xmm0

; 4779 : 			const float a1 = (n + 1.0f) / 6.0f * 2.0f * IM_PI + aeps;

	cvtsi2ss xmm0, DWORD PTR n$2[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR __real@40c00000
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@40490fdb
	addss	xmm0, DWORD PTR aeps$13[rsp]
	movss	DWORD PTR a1$10[rsp], xmm0

; 4780 : 			const int vert_start_idx = draw_list->VtxBuffer.Size;

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR vert_start_idx$30[rsp], eax

; 4781 : 			draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer) * 0.5f, a0, a1, segment_per_arc);

	movss	xmm0, DWORD PTR wheel_r_inner$[rsp]
	addss	xmm0, DWORD PTR wheel_r_outer$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR segment_per_arc$28[rsp]
	mov	DWORD PTR [rsp+40], eax
	movss	xmm1, DWORD PTR a1$10[rsp]
	movss	DWORD PTR [rsp+32], xmm1
	movss	xmm3, DWORD PTR a0$9[rsp]
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR wheel_center$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo

; 4782 : 			draw_list->PathStroke(IM_COL32_WHITE, false, wheel_thickness);

	movss	xmm3, DWORD PTR wheel_thickness$[rsp]
	xor	r8d, r8d
	mov	edx, -1					; ffffffffH
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PathStroke@ImDrawList@@QEAAXI_NM@Z	; ImDrawList::PathStroke

; 4783 : 			const int vert_end_idx = draw_list->VtxBuffer.Size;

	mov	rax, QWORD PTR draw_list$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR vert_end_idx$29[rsp], eax

; 4784 : 
; 4785 : 			// Paint colors over existing vertices
; 4786 : 			ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);

	movss	xmm0, DWORD PTR a0$9[rsp]
	call	?ImSin@@YAMM@Z				; ImSin
	mulss	xmm0, DWORD PTR wheel_r_inner$[rsp]
	movss	xmm1, DWORD PTR wheel_center$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv806[rsp], xmm0
	movss	xmm0, DWORD PTR a0$9[rsp]
	call	?ImCos@@YAMM@Z				; ImCos
	mulss	xmm0, DWORD PTR wheel_r_inner$[rsp]
	movss	xmm1, DWORD PTR wheel_center$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv804[rsp], xmm0
	movss	xmm2, DWORD PTR tv806[rsp]
	movss	xmm1, DWORD PTR tv804[rsp]
	lea	rcx, QWORD PTR gradient_p0$37[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 4787 : 			ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);

	movss	xmm0, DWORD PTR a1$10[rsp]
	call	?ImSin@@YAMM@Z				; ImSin
	mulss	xmm0, DWORD PTR wheel_r_inner$[rsp]
	movss	xmm1, DWORD PTR wheel_center$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv821[rsp], xmm0
	movss	xmm0, DWORD PTR a1$10[rsp]
	call	?ImCos@@YAMM@Z				; ImCos
	mulss	xmm0, DWORD PTR wheel_r_inner$[rsp]
	movss	xmm1, DWORD PTR wheel_center$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv819[rsp], xmm0
	movss	xmm2, DWORD PTR tv821[rsp]
	movss	xmm1, DWORD PTR tv819[rsp]
	lea	rcx, QWORD PTR gradient_p1$36[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 4788 : 			ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, hue_colors[n], hue_colors[n + 1]);

	mov	eax, DWORD PTR n$2[rsp]
	inc	eax
	cdqe
	movsxd	rcx, DWORD PTR n$2[rsp]
	mov	eax, DWORD PTR hue_colors$[rsp+rax*4]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR hue_colors$[rsp+rcx*4]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR gradient_p1$36[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR gradient_p0$37[rsp]
	mov	r8d, DWORD PTR vert_end_idx$29[rsp]
	mov	edx, DWORD PTR vert_start_idx$30[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z ; ImGui::ShadeVertsLinearColorGradientKeepAlpha
	npad	1

; 4789 : 		}

	jmp	$LN2@ColorPicke
$LN3@ColorPicke:

; 4790 : 
; 4791 : 		// Render Cursor + preview on Hue Wheel
; 4792 : 		float cos_hue_angle = ImCos(H * 2.0f * IM_PI);

	movss	xmm0, DWORD PTR H$[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@40490fdb
	call	?ImCos@@YAMM@Z				; ImCos
	movss	DWORD PTR cos_hue_angle$4[rsp], xmm0

; 4793 : 		float sin_hue_angle = ImSin(H * 2.0f * IM_PI);

	movss	xmm0, DWORD PTR H$[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@40490fdb
	call	?ImSin@@YAMM@Z				; ImSin
	movss	DWORD PTR sin_hue_angle$6[rsp], xmm0

; 4794 : 		ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f);

	movss	xmm0, DWORD PTR wheel_r_inner$[rsp]
	addss	xmm0, DWORD PTR wheel_r_outer$[rsp]
	movss	xmm1, DWORD PTR sin_hue_angle$6[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR wheel_center$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR wheel_r_inner$[rsp]
	addss	xmm1, DWORD PTR wheel_r_outer$[rsp]
	movss	xmm2, DWORD PTR cos_hue_angle$4[rsp]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR wheel_center$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR hue_cursor_pos$32[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 4795 : 		float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;

	movzx	eax, BYTE PTR value_changed_h$[rsp]
	test	eax, eax
	je	SHORT $LN82@ColorPicke
	movss	xmm0, DWORD PTR wheel_thickness$[rsp]
	mulss	xmm0, DWORD PTR __real@3f266666
	movss	DWORD PTR tv858[rsp], xmm0
	jmp	SHORT $LN83@ColorPicke
$LN82@ColorPicke:
	movss	xmm0, DWORD PTR wheel_thickness$[rsp]
	mulss	xmm0, DWORD PTR __real@3f0ccccd
	movss	DWORD PTR tv858[rsp], xmm0
$LN83@ColorPicke:
	movss	xmm0, DWORD PTR tv858[rsp]
	movss	DWORD PTR hue_cursor_rad$5[rsp], xmm0

; 4796 : 		int hue_cursor_segments = ImClamp((int)(hue_cursor_rad / 1.4f), 9, 32);

	movss	xmm0, DWORD PTR hue_cursor_rad$5[rsp]
	divss	xmm0, DWORD PTR __real@3fb33333
	cvttss2si eax, xmm0
	mov	r8d, 32					; 00000020H
	mov	edx, 9
	mov	ecx, eax
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	DWORD PTR hue_cursor_segments$11[rsp], eax

; 4797 : 		draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);

	mov	eax, DWORD PTR hue_cursor_segments$11[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR hue_color32$[rsp]
	movss	xmm2, DWORD PTR hue_cursor_rad$5[rsp]
	lea	rdx, QWORD PTR hue_cursor_pos$32[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled

; 4798 : 		draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad + 1, IM_COL32(128, 128, 128, 255), hue_cursor_segments);

	movss	xmm0, DWORD PTR hue_cursor_rad$5[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+40], xmm1
	mov	eax, DWORD PTR hue_cursor_segments$11[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, -8355712				; ff808080H
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR hue_cursor_pos$32[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle

; 4799 : 		draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, IM_COL32_WHITE, hue_cursor_segments);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+40], xmm0
	mov	eax, DWORD PTR hue_cursor_segments$11[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, -1					; ffffffffH
	movss	xmm2, DWORD PTR hue_cursor_rad$5[rsp]
	lea	rdx, QWORD PTR hue_cursor_pos$32[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
	npad	1

; 4800 : 
; 4801 : 		// Render SV triangle (rotated according to hue)
; 4802 : 		ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);

	movss	xmm3, DWORD PTR sin_hue_angle$6[rsp]
	movss	xmm2, DWORD PTR cos_hue_angle$4[rsp]
	lea	rdx, QWORD PTR triangle_pa$[rsp]
	lea	rcx, QWORD PTR $T56[rsp]
	call	?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z	; ImRotate
	mov	r8, rax
	lea	rdx, QWORD PTR wheel_center$[rsp]
	lea	rcx, QWORD PTR tra$18[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1

; 4803 : 		ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);

	movss	xmm3, DWORD PTR sin_hue_angle$6[rsp]
	movss	xmm2, DWORD PTR cos_hue_angle$4[rsp]
	lea	rdx, QWORD PTR triangle_pb$[rsp]
	lea	rcx, QWORD PTR $T57[rsp]
	call	?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z	; ImRotate
	mov	r8, rax
	lea	rdx, QWORD PTR wheel_center$[rsp]
	lea	rcx, QWORD PTR trb$20[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1

; 4804 : 		ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);

	movss	xmm3, DWORD PTR sin_hue_angle$6[rsp]
	movss	xmm2, DWORD PTR cos_hue_angle$4[rsp]
	lea	rdx, QWORD PTR triangle_pc$[rsp]
	lea	rcx, QWORD PTR $T58[rsp]
	call	?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z	; ImRotate
	mov	r8, rax
	lea	rdx, QWORD PTR wheel_center$[rsp]
	lea	rcx, QWORD PTR trc$19[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1

; 4805 : 		ImVec2 uv_white = GetFontTexUvWhitePixel();

	lea	rcx, QWORD PTR uv_white$12[rsp]
	call	?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetFontTexUvWhitePixel

; 4806 : 		draw_list->PrimReserve(6, 6);

	mov	r8d, 6
	mov	edx, 6
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 4807 : 		draw_list->PrimVtx(tra, uv_white, hue_color32);

	mov	r9d, DWORD PTR hue_color32$[rsp]
	lea	r8, QWORD PTR uv_white$12[rsp]
	lea	rdx, QWORD PTR tra$18[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ; ImDrawList::PrimVtx

; 4808 : 		draw_list->PrimVtx(trb, uv_white, hue_color32);

	mov	r9d, DWORD PTR hue_color32$[rsp]
	lea	r8, QWORD PTR uv_white$12[rsp]
	lea	rdx, QWORD PTR trb$20[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ; ImDrawList::PrimVtx

; 4809 : 		draw_list->PrimVtx(trc, uv_white, IM_COL32_WHITE);

	mov	r9d, -1					; ffffffffH
	lea	r8, QWORD PTR uv_white$12[rsp]
	lea	rdx, QWORD PTR trc$19[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ; ImDrawList::PrimVtx

; 4810 : 		draw_list->PrimVtx(tra, uv_white, IM_COL32_BLACK_TRANS);

	xor	r9d, r9d
	lea	r8, QWORD PTR uv_white$12[rsp]
	lea	rdx, QWORD PTR tra$18[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ; ImDrawList::PrimVtx

; 4811 : 		draw_list->PrimVtx(trb, uv_white, IM_COL32_BLACK);

	mov	r9d, -16777216				; ff000000H
	lea	r8, QWORD PTR uv_white$12[rsp]
	lea	rdx, QWORD PTR trb$20[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ; ImDrawList::PrimVtx

; 4812 : 		draw_list->PrimVtx(trc, uv_white, IM_COL32_BLACK_TRANS);

	xor	r9d, r9d
	lea	r8, QWORD PTR uv_white$12[rsp]
	lea	rdx, QWORD PTR trc$19[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ; ImDrawList::PrimVtx

; 4813 : 		draw_list->AddTriangle(tra, trb, trc, IM_COL32(128, 128, 128, 255), 1.5f);

	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], -8355712		; ff808080H
	lea	r9, QWORD PTR trc$19[rsp]
	lea	r8, QWORD PTR trb$20[rsp]
	lea	rdx, QWORD PTR tra$18[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z ; ImDrawList::AddTriangle
	npad	1

; 4814 : 		sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR V$[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR tv960[rsp], xmm0
	movss	xmm0, DWORD PTR S$[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movaps	xmm3, xmm0
	lea	r8, QWORD PTR tra$18[rsp]
	lea	rdx, QWORD PTR trc$19[rsp]
	lea	rcx, QWORD PTR $T59[rsp]
	call	?ImLerp@@YA?AUImVec2@@AEBU1@0M@Z	; ImLerp
	mov	QWORD PTR tv958[rsp], rax
	movss	xmm3, DWORD PTR tv960[rsp]
	lea	r8, QWORD PTR trb$20[rsp]
	mov	rdx, QWORD PTR tv958[rsp]
	lea	rcx, QWORD PTR $T60[rsp]
	call	?ImLerp@@YA?AUImVec2@@AEBU1@0M@Z	; ImLerp
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sv_cursor_pos$[rsp], rax

; 4815 : 	}

	jmp	$LN50@ColorPicke
$LN49@ColorPicke:

; 4816 : 	else if (flags & ImGuiColorEditFlags_PickerHueBar)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	$LN51@ColorPicke

; 4817 : 	{
; 4818 : 		// Render SV Square
; 4819 : 		draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), IM_COL32_WHITE, hue_color32, hue_color32, IM_COL32_WHITE);

	movss	xmm2, DWORD PTR sv_picker_size$[rsp]
	movss	xmm1, DWORD PTR sv_picker_size$[rsp]
	lea	rcx, QWORD PTR $T61[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR picker_pos$[rsp]
	lea	rcx, QWORD PTR $T62[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	DWORD PTR [rsp+48], -1			; ffffffffH
	mov	ecx, DWORD PTR hue_color32$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	ecx, DWORD PTR hue_color32$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, -1					; ffffffffH
	mov	r8, rax
	lea	rdx, QWORD PTR picker_pos$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
	npad	1

; 4820 : 		draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), IM_COL32_BLACK_TRANS, IM_COL32_BLACK_TRANS, IM_COL32_BLACK, IM_COL32_BLACK);

	movss	xmm2, DWORD PTR sv_picker_size$[rsp]
	movss	xmm1, DWORD PTR sv_picker_size$[rsp]
	lea	rcx, QWORD PTR $T63[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR picker_pos$[rsp]
	lea	rcx, QWORD PTR $T64[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	DWORD PTR [rsp+48], -16777216		; ff000000H
	mov	DWORD PTR [rsp+40], -16777216		; ff000000H
	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, rax
	lea	rdx, QWORD PTR picker_pos$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
	npad	1

; 4821 : 		RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0.0f);

	movss	xmm2, DWORD PTR sv_picker_size$[rsp]
	movss	xmm1, DWORD PTR sv_picker_size$[rsp]
	lea	rcx, QWORD PTR $T65[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR picker_pos$[rsp]
	lea	rcx, QWORD PTR $T66[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T38[rsp], rax
	mov	rax, QWORD PTR picker_pos$[rsp]
	mov	QWORD PTR $T39[rsp], rax
	xorps	xmm2, xmm2
	mov	rdx, QWORD PTR $T38[rsp]
	mov	rcx, QWORD PTR $T39[rsp]
	call	?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder
	npad	1

; 4822 : 		sv_cursor_pos.x = ImClamp((float)(int)(picker_pos.x + ImSaturate(S) * sv_picker_size + 0.5f), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much

	movss	xmm0, DWORD PTR picker_pos$[rsp]
	addss	xmm0, DWORD PTR sv_picker_size$[rsp]
	subss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv1009[rsp], xmm0
	movss	xmm1, DWORD PTR picker_pos$[rsp]
	addss	xmm1, DWORD PTR __real@40000000
	movss	DWORD PTR tv1011[rsp], xmm1
	movss	xmm0, DWORD PTR S$[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR sv_picker_size$[rsp]
	movss	xmm1, DWORD PTR picker_pos$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR tv1009[rsp]
	movaps	xmm2, xmm1
	movss	xmm1, DWORD PTR tv1011[rsp]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR sv_cursor_pos$[rsp], xmm0

; 4823 : 		sv_cursor_pos.y = ImClamp((float)(int)(picker_pos.y + ImSaturate(1 - V) * sv_picker_size + 0.5f), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);

	movss	xmm0, DWORD PTR picker_pos$[rsp+4]
	addss	xmm0, DWORD PTR sv_picker_size$[rsp]
	subss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv1024[rsp], xmm0
	movss	xmm1, DWORD PTR picker_pos$[rsp+4]
	addss	xmm1, DWORD PTR __real@40000000
	movss	DWORD PTR tv1026[rsp], xmm1
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, DWORD PTR V$[rsp]
	movaps	xmm0, xmm2
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	mulss	xmm0, DWORD PTR sv_picker_size$[rsp]
	movss	xmm1, DWORD PTR picker_pos$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR tv1024[rsp]
	movaps	xmm2, xmm1
	movss	xmm1, DWORD PTR tv1026[rsp]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR sv_cursor_pos$[rsp+4], xmm0

; 4824 : 
; 4825 : 		// Render Hue Bar
; 4826 : 		for (int i = 0; i < 6; ++i)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN7@ColorPicke
$LN5@ColorPicke:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN7@ColorPicke:
	cmp	DWORD PTR i$1[rsp], 6
	jge	$LN6@ColorPicke

; 4827 : 			draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), hue_colors[i], hue_colors[i], hue_colors[i + 1], hue_colors[i + 1]);

	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	cdqe
	mov	eax, DWORD PTR hue_colors$[rsp+rax*4]
	mov	DWORD PTR tv1122[rsp], eax
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	cdqe
	mov	eax, DWORD PTR hue_colors$[rsp+rax*4]
	mov	DWORD PTR tv1120[rsp], eax
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	eax, DWORD PTR hue_colors$[rsp+rax*4]
	mov	DWORD PTR tv1086[rsp], eax
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	eax, DWORD PTR hue_colors$[rsp+rax*4]
	mov	DWORD PTR tv1084[rsp], eax
	movss	xmm0, DWORD PTR sv_picker_size$[rsp]
	divss	xmm0, DWORD PTR __real@40c00000
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	cvtsi2ss xmm1, eax
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR picker_pos$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR bar0_pos_x$[rsp]
	addss	xmm1, DWORD PTR bars_width$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T67[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1082[rsp], rax
	movss	xmm0, DWORD PTR sv_picker_size$[rsp]
	divss	xmm0, DWORD PTR __real@40c00000
	cvtsi2ss xmm1, DWORD PTR i$1[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR picker_pos$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR bar0_pos_x$[rsp]
	lea	rcx, QWORD PTR $T68[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1080[rsp], rax
	mov	eax, DWORD PTR tv1122[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR tv1120[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR tv1086[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR tv1084[rsp]
	mov	r8, QWORD PTR tv1082[rsp]
	mov	rdx, QWORD PTR tv1080[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
	npad	1
	jmp	$LN5@ColorPicke
$LN6@ColorPicke:

; 4828 : 		float bar0_line_y = (float)(int)(picker_pos.y + H * sv_picker_size + 0.5f);

	movss	xmm0, DWORD PTR H$[rsp]
	mulss	xmm0, DWORD PTR sv_picker_size$[rsp]
	movss	xmm1, DWORD PTR picker_pos$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR bar0_line_y$21[rsp], xmm0

; 4829 : 		RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);

	movss	xmm0, DWORD PTR picker_pos$[rsp+4]
	addss	xmm0, DWORD PTR sv_picker_size$[rsp]
	movss	xmm1, DWORD PTR bar0_pos_x$[rsp]
	addss	xmm1, DWORD PTR bars_width$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T69[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T40[rsp], rax
	movss	xmm2, DWORD PTR picker_pos$[rsp+4]
	movss	xmm1, DWORD PTR bar0_pos_x$[rsp]
	lea	rcx, QWORD PTR $T70[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T41[rsp], rax
	xorps	xmm2, xmm2
	mov	rdx, QWORD PTR $T40[rsp]
	mov	rcx, QWORD PTR $T41[rsp]
	call	?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder
	npad	1

; 4830 : 		RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);

	movss	xmm0, DWORD PTR bars_triangles_half_sz$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR bars_triangles_half_sz$[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T71[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T42[rsp], rax
	movss	xmm0, DWORD PTR bar0_pos_x$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR bar0_line_y$21[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T72[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T43[rsp], rax
	movss	xmm0, DWORD PTR bars_width$[rsp]
	addss	xmm0, DWORD PTR __real@40000000
	movaps	xmm3, xmm0
	mov	r8, QWORD PTR $T42[rsp]
	mov	rdx, QWORD PTR $T43[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1M@Z ; RenderArrowsForVerticalBar
	npad	1
$LN51@ColorPicke:
$LN50@ColorPicke:

; 4831 : 	}
; 4832 : 
; 4833 : 	// Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
; 4834 : 	float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;

	movzx	eax, BYTE PTR value_changed_sv$[rsp]
	test	eax, eax
	je	SHORT $LN84@ColorPicke
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR tv1163[rsp], xmm0
	jmp	SHORT $LN85@ColorPicke
$LN84@ColorPicke:
	movss	xmm0, DWORD PTR __real@40c00000
	movss	DWORD PTR tv1163[rsp], xmm0
$LN85@ColorPicke:
	movss	xmm0, DWORD PTR tv1163[rsp]
	movss	DWORD PTR sv_cursor_rad$[rsp], xmm0

; 4835 : 	draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, col32_no_alpha, 12);

	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR col32_no_alpha$[rsp]
	movss	xmm2, DWORD PTR sv_cursor_rad$[rsp]
	lea	rdx, QWORD PTR sv_cursor_pos$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled

; 4836 : 	draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad + 1, IM_COL32(128, 128, 128, 255), 12);

	movss	xmm0, DWORD PTR sv_cursor_rad$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+40], xmm1
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, -8355712				; ff808080H
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR sv_cursor_pos$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle

; 4837 : 	draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, IM_COL32_WHITE, 12);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, -1					; ffffffffH
	movss	xmm2, DWORD PTR sv_cursor_rad$[rsp]
	lea	rdx, QWORD PTR sv_cursor_pos$[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
	npad	1

; 4838 : 
; 4839 : 	// Render alpha bar
; 4840 : 	if (alpha_bar)

	movzx	eax, BYTE PTR alpha_bar$[rsp]
	test	eax, eax
	je	$LN52@ColorPicke

; 4841 : 	{
; 4842 : 		float alpha = ImSaturate(col[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR alpha$22[rsp], xmm0

; 4843 : 		ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);

	movss	xmm0, DWORD PTR picker_pos$[rsp+4]
	addss	xmm0, DWORD PTR sv_picker_size$[rsp]
	movss	xmm1, DWORD PTR bar1_pos_x$[rsp]
	addss	xmm1, DWORD PTR bars_width$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm2, DWORD PTR picker_pos$[rsp+4]
	movss	xmm1, DWORD PTR bar1_pos_x$[rsp]
	lea	rcx, QWORD PTR bar1_bb$33[rsp]
	call	??0ImRect@@QEAA@MMMM@Z			; ImRect::ImRect
	npad	1

; 4844 : 		RenderColorRectWithAlphaCheckerboard(bar1_bb.Min, bar1_bb.Max, IM_COL32(0, 0, 0, 0), bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T73[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T44[rsp], rax
	lea	rcx, QWORD PTR bar1_bb$33[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv1210[rsp], xmm0
	mov	DWORD PTR [rsp+48], -1
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+40], xmm0
	mov	rax, QWORD PTR $T44[rsp]
	mov	QWORD PTR [rsp+32], rax
	movss	xmm3, DWORD PTR tv1210[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR bar1_bb$33[rsp+8]
	mov	rcx, QWORD PTR bar1_bb$33[rsp]
	call	?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z ; ImGui::RenderColorRectWithAlphaCheckerboard
	npad	1

; 4845 : 		draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, col32_no_alpha, col32_no_alpha, col32_no_alpha & ~IM_COL32_A_MASK, col32_no_alpha & ~IM_COL32_A_MASK);

	mov	eax, DWORD PTR col32_no_alpha$[rsp]
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR col32_no_alpha$[rsp]
	and	ecx, 16777215				; 00ffffffH
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], ecx
	mov	eax, DWORD PTR col32_no_alpha$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR col32_no_alpha$[rsp]
	lea	r8, QWORD PTR bar1_bb$33[rsp+8]
	lea	rdx, QWORD PTR bar1_bb$33[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor

; 4846 : 		float bar1_line_y = (float)(int)(picker_pos.y + (1.0f - alpha) * sv_picker_size + 0.5f);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR alpha$22[rsp]
	mulss	xmm0, DWORD PTR sv_picker_size$[rsp]
	movss	xmm1, DWORD PTR picker_pos$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR bar1_line_y$23[rsp], xmm0

; 4847 : 		RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);

	xorps	xmm2, xmm2
	mov	rdx, QWORD PTR bar1_bb$33[rsp+8]
	mov	rcx, QWORD PTR bar1_bb$33[rsp]
	call	?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder
	npad	1

; 4848 : 		RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);

	movss	xmm0, DWORD PTR bars_triangles_half_sz$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR bars_triangles_half_sz$[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T74[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T45[rsp], rax
	movss	xmm0, DWORD PTR bar1_pos_x$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR bar1_line_y$23[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T75[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T46[rsp], rax
	movss	xmm0, DWORD PTR bars_width$[rsp]
	addss	xmm0, DWORD PTR __real@40000000
	movaps	xmm3, xmm0
	mov	r8, QWORD PTR $T45[rsp]
	mov	rdx, QWORD PTR $T46[rsp]
	mov	rcx, QWORD PTR draw_list$[rsp]
	call	?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1M@Z ; RenderArrowsForVerticalBar
	npad	1
$LN52@ColorPicke:

; 4849 : 	}
; 4850 : 
; 4851 : 	EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	npad	1

; 4852 : 
; 4853 : 	if (value_changed && memcmp(backup_initial_col, col, components * sizeof(float)) == 0)

	movzx	eax, BYTE PTR value_changed$[rsp]
	test	eax, eax
	je	SHORT $LN53@ColorPicke
	movsxd	rax, DWORD PTR components$[rsp]
	shl	rax, 2
	mov	r8, rax
	mov	rdx, QWORD PTR col$[rsp]
	lea	rcx, QWORD PTR backup_initial_col$[rsp]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN53@ColorPicke

; 4854 : 		value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0
$LN53@ColorPicke:

; 4855 : 	if (value_changed)

	movzx	eax, BYTE PTR value_changed$[rsp]
	test	eax, eax
	je	SHORT $LN54@ColorPicke

; 4856 : 		MarkItemEdited(window->DC.LastItemId);

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rax+412]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN54@ColorPicke:

; 4857 : 
; 4858 : 	PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 4859 : 
; 4860 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]

; 4861 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1128				; 00000468H
	ret	0
?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z ENDP		; ImGui::ColorPicker4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
col4$ = 32
__$ArrayPad$ = 48
label$ = 80
col$ = 88
flags$ = 96
?ColorPicker3@ImGui@@YA_NPEBDQEAMH@Z PROC		; ImGui::ColorPicker3

; 4493 : {

$LN4:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 4494 : 	float col4[4] = { col[0], col[1], col[2], 1.0f };

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR col4$[rsp], xmm0
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR col4$[rsp+4], xmm0
	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR col4$[rsp+8], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR col4$[rsp+12], xmm0

; 4495 : 	if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 2
	xor	r9d, r9d
	mov	r8d, eax
	lea	rdx, QWORD PTR col4$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z ; ImGui::ColorPicker4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@ColorPicke

; 4496 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@ColorPicke
$LN2@ColorPicke:

; 4497 : 	col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR col4$[rsp+rax]
	movss	DWORD PTR [rdx+rcx], xmm0
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR col4$[rsp+rax]
	movss	DWORD PTR [rdx+rcx], xmm0
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR col4$[rsp+rax]
	movss	DWORD PTR [rdx+rcx], xmm0

; 4498 : 	return true;

	mov	al, 1
$LN1@ColorPicke:

; 4499 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 72					; 00000048H
	ret	0
?ColorPicker3@ImGui@@YA_NPEBDQEAMH@Z ENDP		; ImGui::ColorPicker3
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z PROC			; ImGui::ColorEdit4

; 4285 : {

$LN117:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 552				; 00000228H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 4286 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 4287 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN13@ColorEdit4

; 4288 : 		return false;

	xor	al, al
	jmp	$LN1@ColorEdit4
$LN13@ColorEdit4:

; 4289 : 
; 4290 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 4291 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 4292 : 	const float square_sz = GetFrameHeight();

	call	?GetFrameHeight@ImGui@@YAMXZ		; ImGui::GetFrameHeight
	movss	DWORD PTR square_sz$[rsp], xmm0

; 4293 : 	const float w_extra = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN54@ColorEdit4
	xorps	xmm0, xmm0
	movss	DWORD PTR tv75[rsp], xmm0
	jmp	SHORT $LN55@ColorEdit4
$LN54@ColorEdit4:
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR square_sz$[rsp]
	addss	xmm0, DWORD PTR [rax+76]
	movss	DWORD PTR tv75[rsp], xmm0
$LN55@ColorEdit4:
	movss	xmm0, DWORD PTR tv75[rsp]
	movss	DWORD PTR w_extra$[rsp], xmm0

; 4294 : 	const float w_items_all = CalcItemWidth() - w_extra;

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	subss	xmm0, DWORD PTR w_extra$[rsp]
	movss	DWORD PTR w_items_all$[rsp], xmm0

; 4295 : 	const char* label_display_end = FindRenderedTextEnd(label);

	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	QWORD PTR label_display_end$[rsp], rax

; 4296 : 
; 4297 : 	BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 4298 : 	PushID(label);

	mov	rcx, QWORD PTR label$[rsp]
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 4299 : 
; 4300 : 	// If we're not showing any slider there's no point in doing any HSV conversions
; 4301 : 	const ImGuiColorEditFlags flags_untouched = flags;

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR flags_untouched$[rsp], eax

; 4302 : 	if (flags & ImGuiColorEditFlags_NoInputs)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN14@ColorEdit4

; 4303 : 		flags = (flags & (~ImGuiColorEditFlags__InputsMask)) | ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_NoOptions;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, -7340033				; ffffffffff8fffffH
	bts	eax, 20
	or	eax, 8
	mov	DWORD PTR flags$[rsp], eax
$LN14@ColorEdit4:

; 4304 : 
; 4305 : 	// Context menu: display and modify options (before defaults are applied)
; 4306 : 	if (!(flags & ImGuiColorEditFlags_NoOptions))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN15@ColorEdit4

; 4307 : 		ColorEditOptionsPopup(col, flags);

	mov	edx, DWORD PTR flags$[rsp]
	mov	rcx, QWORD PTR col$[rsp]
	call	?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z ; ImGui::ColorEditOptionsPopup
	npad	1
$LN15@ColorEdit4:

; 4308 : 
; 4309 : 	// Read stored options
; 4310 : 	if (!(flags & ImGuiColorEditFlags__InputsMask))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 7340032				; 00700000H
	test	eax, eax
	jne	SHORT $LN16@ColorEdit4

; 4311 : 		flags |= (g.ColorEditOptions & ImGuiColorEditFlags__InputsMask);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+11676]
	and	eax, 7340032				; 00700000H
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax
$LN16@ColorEdit4:

; 4312 : 	if (!(flags & ImGuiColorEditFlags__DataTypeMask))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 25165824				; 01800000H
	test	eax, eax
	jne	SHORT $LN17@ColorEdit4

; 4313 : 		flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DataTypeMask);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+11676]
	and	eax, 25165824				; 01800000H
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax
$LN17@ColorEdit4:

; 4314 : 	if (!(flags & ImGuiColorEditFlags__PickerMask))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 100663296				; 06000000H
	test	eax, eax
	jne	SHORT $LN18@ColorEdit4

; 4315 : 		flags |= (g.ColorEditOptions & ImGuiColorEditFlags__PickerMask);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+11676]
	and	eax, 100663296				; 06000000H
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax
$LN18@ColorEdit4:

; 4316 : 	flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask));

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+11676]
	and	eax, -133169153				; fffffffff80fffffH
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax

; 4317 : 
; 4318 : 	const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN56@ColorEdit4
	mov	BYTE PTR tv143[rsp], 1
	jmp	SHORT $LN57@ColorEdit4
$LN56@ColorEdit4:
	mov	BYTE PTR tv143[rsp], 0
$LN57@ColorEdit4:
	movzx	eax, BYTE PTR tv143[rsp]
	mov	BYTE PTR alpha$[rsp], al

; 4319 : 	const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 524288				; 00080000H
	test	eax, eax
	je	SHORT $LN58@ColorEdit4
	mov	BYTE PTR tv146[rsp], 1
	jmp	SHORT $LN59@ColorEdit4
$LN58@ColorEdit4:
	mov	BYTE PTR tv146[rsp], 0
$LN59@ColorEdit4:
	movzx	eax, BYTE PTR tv146[rsp]
	mov	BYTE PTR hdr$[rsp], al

; 4320 : 	const int components = alpha ? 4 : 3;

	movzx	eax, BYTE PTR alpha$[rsp]
	test	eax, eax
	je	SHORT $LN60@ColorEdit4
	mov	DWORD PTR tv149[rsp], 4
	jmp	SHORT $LN61@ColorEdit4
$LN60@ColorEdit4:
	mov	DWORD PTR tv149[rsp], 3
$LN61@ColorEdit4:
	mov	eax, DWORD PTR tv149[rsp]
	mov	DWORD PTR components$[rsp], eax

; 4321 : 
; 4322 : 	// Convert to the formats we need
; 4323 : 	float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR f$[rsp], xmm0
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR f$[rsp+4], xmm0
	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR f$[rsp+8], xmm0
	movzx	eax, BYTE PTR alpha$[rsp]
	test	eax, eax
	je	SHORT $LN62@ColorEdit4
	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR tv160[rsp], xmm0
	jmp	SHORT $LN63@ColorEdit4
$LN62@ColorEdit4:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv160[rsp], xmm0
$LN63@ColorEdit4:
	movss	xmm0, DWORD PTR tv160[rsp]
	movss	DWORD PTR f$[rsp+12], xmm0

; 4324 : 	if (flags & ImGuiColorEditFlags_HSV)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2097152				; 00200000H
	test	eax, eax
	je	$LN19@ColorEdit4

; 4325 : 		ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);

	mov	eax, 4
	imul	rax, rax, 2
	lea	rax, QWORD PTR f$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	lea	rcx, QWORD PTR f$[rsp+rcx]
	mov	edx, 4
	imul	rdx, rdx, 0
	lea	rdx, QWORD PTR f$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 4
	imul	r9, r9, 1
	mov	QWORD PTR tv175[rsp], r9
	mov	r10d, 4
	imul	r10, r10, 0
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rdx
	movss	xmm2, DWORD PTR f$[rsp+r8]
	mov	rax, QWORD PTR tv175[rsp]
	movss	xmm1, DWORD PTR f$[rsp+rax]
	movss	xmm0, DWORD PTR f$[rsp+r10]
	call	?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertRGBtoHSV
	npad	1
$LN19@ColorEdit4:

; 4326 : 	int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };

	mov	eax, 4
	imul	rax, rax, 0
	movss	xmm0, DWORD PTR f$[rsp+rax]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN64@ColorEdit4
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv187[rsp], xmm0
	jmp	SHORT $LN65@ColorEdit4
$LN64@ColorEdit4:
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR tv187[rsp], xmm0
$LN65@ColorEdit4:
	mov	eax, 4
	imul	rax, rax, 0
	movss	xmm0, DWORD PTR f$[rsp+rax]
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR tv187[rsp]
	cvttss2si eax, xmm0
	mov	DWORD PTR i$[rsp], eax
	mov	eax, 4
	imul	rax, rax, 1
	movss	xmm0, DWORD PTR f$[rsp+rax]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN66@ColorEdit4
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv197[rsp], xmm0
	jmp	SHORT $LN67@ColorEdit4
$LN66@ColorEdit4:
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR tv197[rsp], xmm0
$LN67@ColorEdit4:
	mov	eax, 4
	imul	rax, rax, 1
	movss	xmm0, DWORD PTR f$[rsp+rax]
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR tv197[rsp]
	cvttss2si eax, xmm0
	mov	DWORD PTR i$[rsp+4], eax
	mov	eax, 4
	imul	rax, rax, 2
	movss	xmm0, DWORD PTR f$[rsp+rax]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN68@ColorEdit4
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv207[rsp], xmm0
	jmp	SHORT $LN69@ColorEdit4
$LN68@ColorEdit4:
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR tv207[rsp], xmm0
$LN69@ColorEdit4:
	mov	eax, 4
	imul	rax, rax, 2
	movss	xmm0, DWORD PTR f$[rsp+rax]
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR tv207[rsp]
	cvttss2si eax, xmm0
	mov	DWORD PTR i$[rsp+8], eax
	mov	eax, 4
	imul	rax, rax, 3
	movss	xmm0, DWORD PTR f$[rsp+rax]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN70@ColorEdit4
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv217[rsp], xmm0
	jmp	SHORT $LN71@ColorEdit4
$LN70@ColorEdit4:
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR tv217[rsp], xmm0
$LN71@ColorEdit4:
	mov	eax, 4
	imul	rax, rax, 3
	movss	xmm0, DWORD PTR f$[rsp+rax]
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR tv217[rsp]
	cvttss2si eax, xmm0
	mov	DWORD PTR i$[rsp+12], eax

; 4327 : 
; 4328 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 4329 : 	bool value_changed_as_float = false;

	mov	BYTE PTR value_changed_as_float$[rsp], 0

; 4330 : 
; 4331 : 	if ((flags & (ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_HSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 3145728				; 00300000H
	test	eax, eax
	je	$LN20@ColorEdit4
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	$LN20@ColorEdit4

; 4332 : 	{
; 4333 : 		// RGB/HSV 0..255 Sliders
; 4334 : 		const float w_item_one = ImMax(1.0f, (float)(int)((w_items_all - (style.ItemInnerSpacing.x) * (components - 1)) / (float)components));

	mov	eax, DWORD PTR components$[rsp]
	dec	eax
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR w_items_all$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR components$[rsp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR w_item_one$4[rsp], xmm0

; 4335 : 		const float w_item_last = ImMax(1.0f, (float)(int)(w_items_all - (w_item_one + style.ItemInnerSpacing.x) * (components - 1)));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR w_item_one$4[rsp]
	addss	xmm0, DWORD PTR [rax+76]
	mov	eax, DWORD PTR components$[rsp]
	dec	eax
	cvtsi2ss xmm1, eax
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR w_items_all$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR w_item_last$9[rsp], xmm0

; 4336 : 
; 4337 : 		const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? ("M:0.000") : ("M:000")).x);

	movss	xmm0, DWORD PTR w_item_one$4[rsp]
	movss	DWORD PTR tv295[rsp], xmm0
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN72@ColorEdit4
	lea	rax, OFFSET FLAT:??_C@_07FFNLLALM@M?30?4000@
	mov	QWORD PTR tv290[rsp], rax
	jmp	SHORT $LN73@ColorEdit4
$LN72@ColorEdit4:
	lea	rax, OFFSET FLAT:??_C@_05BNGMMMAL@M?3000@
	mov	QWORD PTR tv290[rsp], rax
$LN73@ColorEdit4:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv290[rsp]
	lea	rcx, QWORD PTR $T13[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR tv295[rsp]
	jb	SHORT $LN74@ColorEdit4
	mov	BYTE PTR tv297[rsp], 1
	jmp	SHORT $LN75@ColorEdit4
$LN74@ColorEdit4:
	mov	BYTE PTR tv297[rsp], 0
$LN75@ColorEdit4:
	movzx	eax, BYTE PTR tv297[rsp]
	mov	BYTE PTR hide_prefix$2[rsp], al

; 4338 : 		static std::string ids[4] = { ("##X"), ("##Y"), ("##Z"), ("##W") };

	mov	eax, OFFSET FLAT:_Init_thread_epoch
	mov	eax, eax
	mov	ecx, DWORD PTR _tls_index
	mov	rdx, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rdx+rcx*8]
	mov	eax, DWORD PTR [rax+rcx]
	cmp	DWORD PTR ?$TSS0@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA, eax
	jle	SHORT $LN2@ColorEdit4
	lea	rcx, OFFSET FLAT:?$TSS0@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS0@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA, -1
	jne	SHORT $LN2@ColorEdit4
	lea	rdx, OFFSET FLAT:??_C@_03CEFFAPNG@?$CD?$CDX@
	lea	rcx, OFFSET FLAT:?ids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_03DNEODOJH@?$CD?$CDY@
	lea	rcx, OFFSET FLAT:?ids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+32
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_03BGGDGNFE@?$CD?$CDZ@
	lea	rcx, OFFSET FLAT:?ids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+64
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_03KDMNBDBJ@?$CD?$CDW@
	lea	rcx, OFFSET FLAT:?ids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+96
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, OFFSET FLAT:??__Fids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ ; `ImGui::ColorEdit4'::`19'::`dynamic atexit destructor for 'ids''
	call	atexit
	npad	1
	lea	rcx, OFFSET FLAT:?$TSS0@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	call	_Init_thread_footer
	npad	1
$LN2@ColorEdit4:

; 4339 : 		static std::string fmt_table_int[3][4] =

	mov	eax, OFFSET FLAT:_Init_thread_epoch
	mov	eax, eax
	mov	ecx, DWORD PTR _tls_index
	mov	rdx, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rdx+rcx*8]
	mov	eax, DWORD PTR [rax+rcx]
	cmp	DWORD PTR ?$TSS1@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA, eax
	jle	$LN3@ColorEdit4
	lea	rcx, OFFSET FLAT:?$TSS1@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS1@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA, -1
	jne	$LN3@ColorEdit4

; 4340 : 		{
; 4341 : 			{   ("%3d"),   ("%3d"),   ("%3d"),   ("%3d")}, // Short display

	lea	rdx, OFFSET FLAT:??_C@_03GOOLIKIF@?$CF3d@
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_03GOOLIKIF@?$CF3d@
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+32
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_03GOOLIKIF@?$CF3d@
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+64
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_03GOOLIKIF@?$CF3d@
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+96
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 4342 : 			{ ("R:%3d"), ("G:%3d"), ("B:%3d"), ("A:%3d")}, // Long display for RGBA

	lea	rdx, OFFSET FLAT:??_C@_05FELKPNOB@R?3?$CF3d@
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+128
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_05HKBGOMJ@G?3?$CF3d@
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+160
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_05FHGMPPHK@B?3?$CF3d@
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+192
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_05NBPIINNE@A?3?$CF3d@
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+224
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 4343 : 			{ ("H:%3d"), ("S:%3d"), ("V:%3d"), ("A:%3d")}  // Long display for HSVA

	lea	rdx, OFFSET FLAT:??_C@_05PGPHNMBM@H?3?$CF3d@
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+256
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_05JPOGCOEE@S?3?$CF3d@
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+288
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_05MPCLLPPH@V?3?$CF3d@
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+320
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_05NBPIINNE@A?3?$CF3d@
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+352
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 4339 : 		static std::string fmt_table_int[3][4] =

	lea	rcx, OFFSET FLAT:??__Ffmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ ; `ImGui::ColorEdit4'::`19'::`dynamic atexit destructor for 'fmt_table_int''
	call	atexit
	npad	1
	lea	rcx, OFFSET FLAT:?$TSS1@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	call	_Init_thread_footer
	npad	1
$LN3@ColorEdit4:

; 4344 : 		};
; 4345 : 		static std::string fmt_table_float[3][4] =

	mov	eax, OFFSET FLAT:_Init_thread_epoch
	mov	eax, eax
	mov	ecx, DWORD PTR _tls_index
	mov	rdx, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rdx+rcx*8]
	mov	eax, DWORD PTR [rax+rcx]
	cmp	DWORD PTR ?$TSS2@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA, eax
	jle	$LN4@ColorEdit4
	lea	rcx, OFFSET FLAT:?$TSS2@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS2@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA, -1
	jne	$LN4@ColorEdit4

; 4346 : 		{
; 4347 : 			{  ("%0.3f"),   ("%0.3f"),   ("%0.3f"),   ("%0.3f") }, // Short display

	lea	rdx, OFFSET FLAT:??_C@_05ONBKDNLK@?$CF0?43f@
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_05ONBKDNLK@?$CF0?43f@
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+32
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_05ONBKDNLK@?$CF0?43f@
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+64
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_05ONBKDNLK@?$CF0?43f@
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+96
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 4348 : 			{ ("R:%0.3f"), ("G:%0.3f"), ("B:%0.3f"), ("A:%0.3f") }, // Long display for RGBA

	lea	rdx, OFFSET FLAT:??_C@_07CCOKENNH@R?3?$CF0?43f@
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+128
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_07BGLBHCJI@G?3?$CF0?43f@
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+160
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_07FOFBHMPM@B?3?$CF0?43f@
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+192
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_07NANOHLBP@A?3?$CF0?43f@
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+224
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 4349 : 			{ ("H:%0.3f"), ("S:%0.3f"), ("V:%0.3f"), ("A:%0.3f") }  // Long display for HSVA

	lea	rdx, OFFSET FLAT:??_C@_07MPJBGADE@H?3?$CF0?43f@
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+256
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_07OOEAENEJ@S?3?$CF0?43f@
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+288
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_07KGKAEDCN@V?3?$CF0?43f@
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+320
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_07NANOHLBP@A?3?$CF0?43f@
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+352
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 4344 : 		};
; 4345 : 		static std::string fmt_table_float[3][4] =

	lea	rcx, OFFSET FLAT:??__Ffmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@YAXXZ ; `ImGui::ColorEdit4'::`19'::`dynamic atexit destructor for 'fmt_table_float''
	call	atexit
	npad	1
	lea	rcx, OFFSET FLAT:?$TSS2@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	call	_Init_thread_footer
	npad	1
$LN4@ColorEdit4:

; 4350 : 		};
; 4351 : 		const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_HSV) ? 2 : 1;

	movzx	eax, BYTE PTR hide_prefix$2[rsp]
	test	eax, eax
	je	SHORT $LN78@ColorEdit4
	mov	DWORD PTR tv483[rsp], 0
	jmp	SHORT $LN79@ColorEdit4
$LN78@ColorEdit4:
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2097152				; 00200000H
	test	eax, eax
	je	SHORT $LN76@ColorEdit4
	mov	DWORD PTR tv480[rsp], 2
	jmp	SHORT $LN77@ColorEdit4
$LN76@ColorEdit4:
	mov	DWORD PTR tv480[rsp], 1
$LN77@ColorEdit4:
	mov	eax, DWORD PTR tv480[rsp]
	mov	DWORD PTR tv483[rsp], eax
$LN79@ColorEdit4:
	mov	eax, DWORD PTR tv483[rsp]
	mov	DWORD PTR fmt_idx$6[rsp], eax

; 4352 : 
; 4353 : 		PushItemWidth(w_item_one);

	movss	xmm0, DWORD PTR w_item_one$4[rsp]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	npad	1

; 4354 : 		for (int n = 0; n < components; n++)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN7@ColorEdit4
$LN5@ColorEdit4:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN7@ColorEdit4:
	mov	eax, DWORD PTR components$[rsp]
	cmp	DWORD PTR n$1[rsp], eax
	jge	$LN6@ColorEdit4

; 4355 : 		{
; 4356 : 			if (n > 0)

	cmp	DWORD PTR n$1[rsp], 0
	jle	SHORT $LN22@ColorEdit4

; 4357 : 				SameLine(0, style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1
$LN22@ColorEdit4:

; 4358 : 			if (n + 1 == components)

	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	cmp	eax, DWORD PTR components$[rsp]
	jne	SHORT $LN23@ColorEdit4

; 4359 : 				PushItemWidth(w_item_last);

	movss	xmm0, DWORD PTR w_item_last$9[rsp]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	npad	1
$LN23@ColorEdit4:

; 4360 : 			if (flags & ImGuiColorEditFlags_Float)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	$LN24@ColorEdit4

; 4361 : 			{
; 4362 : 				value_changed |= DragFloat(ids[n].c_str(), &f[n], 1.0f / 255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n].c_str());

	movzx	eax, BYTE PTR value_changed$[rsp]
	mov	DWORD PTR tv532[rsp], eax
	movsxd	rax, DWORD PTR fmt_idx$6[rsp]
	imul	rax, rax, 128				; 00000080H
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR n$1[rsp]
	imul	rcx, rcx, 32				; 00000020H
	add	rax, rcx
	mov	rcx, rax
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv529[rsp], rax
	movzx	eax, BYTE PTR hdr$[rsp]
	test	eax, eax
	je	SHORT $LN80@ColorEdit4
	xorps	xmm0, xmm0
	movss	DWORD PTR tv512[rsp], xmm0
	jmp	SHORT $LN81@ColorEdit4
$LN80@ColorEdit4:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv512[rsp], xmm0
$LN81@ColorEdit4:
	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:?ids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv527[rsp], rax
	movsxd	rax, DWORD PTR n$1[rsp]
	lea	rax, QWORD PTR f$[rsp+rax*4]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+48], xmm0
	mov	rcx, QWORD PTR tv529[rsp]
	mov	QWORD PTR [rsp+40], rcx
	movss	xmm0, DWORD PTR tv512[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3b808081
	mov	rdx, rax
	mov	rcx, QWORD PTR tv527[rsp]
	call	?DragFloat@ImGui@@YA_NPEBDPEAMMMM0M@Z	; ImGui::DragFloat
	movzx	eax, al
	mov	ecx, DWORD PTR tv532[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR value_changed$[rsp], al

; 4363 : 				value_changed_as_float |= value_changed;

	movzx	eax, BYTE PTR value_changed_as_float$[rsp]
	movzx	ecx, BYTE PTR value_changed$[rsp]
	or	eax, ecx
	mov	BYTE PTR value_changed_as_float$[rsp], al

; 4364 : 			}

	jmp	$LN25@ColorEdit4
$LN24@ColorEdit4:

; 4365 : 			else
; 4366 : 			{
; 4367 : 				value_changed |= DragInt(ids[n].c_str(), &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n].c_str());

	movzx	eax, BYTE PTR value_changed$[rsp]
	mov	DWORD PTR tv572[rsp], eax
	movsxd	rax, DWORD PTR fmt_idx$6[rsp]
	imul	rax, rax, 128				; 00000080H
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR n$1[rsp]
	imul	rcx, rcx, 32				; 00000020H
	add	rax, rcx
	mov	rcx, rax
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv569[rsp], rax
	movzx	eax, BYTE PTR hdr$[rsp]
	test	eax, eax
	je	SHORT $LN82@ColorEdit4
	mov	DWORD PTR tv552[rsp], 0
	jmp	SHORT $LN83@ColorEdit4
$LN82@ColorEdit4:
	mov	DWORD PTR tv552[rsp], 255		; 000000ffH
$LN83@ColorEdit4:
	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 32				; 00000020H
	lea	rcx, OFFSET FLAT:?ids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv567[rsp], rax
	movsxd	rax, DWORD PTR n$1[rsp]
	lea	rax, QWORD PTR i$[rsp+rax*4]
	mov	rcx, QWORD PTR tv569[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	ecx, DWORD PTR tv552[rsp]
	mov	DWORD PTR [rsp+32], ecx
	xor	r9d, r9d
	movss	xmm2, DWORD PTR __real@3f800000
	mov	rdx, rax
	mov	rcx, QWORD PTR tv567[rsp]
	call	?DragInt@ImGui@@YA_NPEBDPEAHMHH0@Z	; ImGui::DragInt
	movzx	eax, al
	mov	ecx, DWORD PTR tv572[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR value_changed$[rsp], al
$LN25@ColorEdit4:

; 4368 : 			}
; 4369 : 			if (!(flags & ImGuiColorEditFlags_NoOptions))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN26@ColorEdit4

; 4370 : 				OpenPopupOnItemClick(("context"));

	mov	edx, 1
	lea	rcx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	call	?OpenPopupOnItemClick@ImGui@@YA_NPEBDH@Z ; ImGui::OpenPopupOnItemClick
	npad	1
$LN26@ColorEdit4:

; 4371 : 		}

	jmp	$LN5@ColorEdit4
$LN6@ColorEdit4:

; 4372 : 		PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 4373 : 		PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	npad	1

; 4374 : 	}

	jmp	$LN21@ColorEdit4
$LN20@ColorEdit4:

; 4375 : 	else if ((flags & ImGuiColorEditFlags_HEX) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4194304				; 00400000H
	test	eax, eax
	je	$LN21@ColorEdit4
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	$LN21@ColorEdit4

; 4376 : 	{
; 4377 : 		// RGB Hexadecimal Input
; 4378 : 		char buf[64];
; 4379 : 		if (alpha)

	movzx	eax, BYTE PTR alpha$[rsp]
	test	eax, eax
	je	$LN28@ColorEdit4

; 4380 : 			ImFormatString(buf, IM_ARRAYSIZE(buf), ("#%02X%02X%02X%02X"), ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255), ImClamp(i[3], 0, 255));

	mov	eax, 4
	imul	rax, rax, 3
	mov	r8d, 255				; 000000ffH
	xor	edx, edx
	mov	ecx, DWORD PTR i$[rsp+rax]
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	DWORD PTR tv624[rsp], eax
	mov	eax, 4
	imul	rax, rax, 2
	mov	r8d, 255				; 000000ffH
	xor	edx, edx
	mov	ecx, DWORD PTR i$[rsp+rax]
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	DWORD PTR tv622[rsp], eax
	mov	eax, 4
	imul	rax, rax, 1
	mov	r8d, 255				; 000000ffH
	xor	edx, edx
	mov	ecx, DWORD PTR i$[rsp+rax]
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	DWORD PTR tv620[rsp], eax
	mov	eax, 4
	imul	rax, rax, 0
	mov	r8d, 255				; 000000ffH
	xor	edx, edx
	mov	ecx, DWORD PTR i$[rsp+rax]
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	DWORD PTR tv618[rsp], eax
	mov	eax, DWORD PTR tv624[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR tv622[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR tv620[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR tv618[rsp]
	lea	r8, OFFSET FLAT:??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR buf$19[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
	jmp	$LN29@ColorEdit4
$LN28@ColorEdit4:

; 4381 : 		else
; 4382 : 			ImFormatString(buf, IM_ARRAYSIZE(buf), ("#%02X%02X%02X"), ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255));

	mov	eax, 4
	imul	rax, rax, 2
	mov	r8d, 255				; 000000ffH
	xor	edx, edx
	mov	ecx, DWORD PTR i$[rsp+rax]
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	DWORD PTR tv654[rsp], eax
	mov	eax, 4
	imul	rax, rax, 1
	mov	r8d, 255				; 000000ffH
	xor	edx, edx
	mov	ecx, DWORD PTR i$[rsp+rax]
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	DWORD PTR tv652[rsp], eax
	mov	eax, 4
	imul	rax, rax, 0
	mov	r8d, 255				; 000000ffH
	xor	edx, edx
	mov	ecx, DWORD PTR i$[rsp+rax]
	call	??$ImClamp@H@@YAHHHH@Z			; ImClamp<int>
	mov	DWORD PTR tv650[rsp], eax
	mov	eax, DWORD PTR tv654[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR tv652[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR tv650[rsp]
	lea	r8, OFFSET FLAT:??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR buf$19[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1
$LN29@ColorEdit4:

; 4383 : 		PushItemWidth(w_items_all);

	movss	xmm0, DWORD PTR w_items_all$[rsp]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	npad	1

; 4384 : 		if (InputText(("##+-Text"), buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))

	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 6
	mov	r8d, 64					; 00000040H
	lea	rdx, QWORD PTR buf$19[rsp]
	lea	rcx, OFFSET FLAT:??_C@_08HDCBKACM@?$CD?$CD?$CL?9Text@
	call	?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputText
	movzx	eax, al
	test	eax, eax
	je	$LN30@ColorEdit4

; 4385 : 		{
; 4386 : 			value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1

; 4387 : 			char* p = buf;

	lea	rax, QWORD PTR buf$19[rsp]
	mov	QWORD PTR p$5[rsp], rax
$LN8@ColorEdit4:

; 4388 : 			while (*p == '#' || ImCharIsBlankA(*p))

	mov	rax, QWORD PTR p$5[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 35					; 00000023H
	je	SHORT $LN31@ColorEdit4
	mov	rax, QWORD PTR p$5[rsp]
	movzx	ecx, BYTE PTR [rax]
	call	?ImCharIsBlankA@@YA_ND@Z		; ImCharIsBlankA
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@ColorEdit4
$LN31@ColorEdit4:

; 4389 : 				p++;

	mov	rax, QWORD PTR p$5[rsp]
	inc	rax
	mov	QWORD PTR p$5[rsp], rax
	jmp	SHORT $LN8@ColorEdit4
$LN9@ColorEdit4:

; 4390 : 			i[0] = i[1] = i[2] = i[3] = 0;

	mov	eax, 4
	imul	rax, rax, 3
	mov	DWORD PTR i$[rsp+rax], 0
	mov	eax, 4
	imul	rax, rax, 2
	mov	DWORD PTR i$[rsp+rax], 0
	mov	eax, 4
	imul	rax, rax, 1
	mov	DWORD PTR i$[rsp+rax], 0
	mov	eax, 4
	imul	rax, rax, 0
	mov	DWORD PTR i$[rsp+rax], 0

; 4391 : 			if (alpha)

	movzx	eax, BYTE PTR alpha$[rsp]
	test	eax, eax
	je	SHORT $LN32@ColorEdit4

; 4392 : 				sscanf(p, ("%02X%02X%02X%02X"), (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)

	mov	eax, 4
	imul	rax, rax, 3
	lea	rax, QWORD PTR i$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	lea	rcx, QWORD PTR i$[rsp+rcx]
	mov	edx, 4
	imul	rdx, rdx, 1
	lea	rdx, QWORD PTR i$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 0
	lea	r8, QWORD PTR i$[rsp+r8]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rdx
	lea	rdx, OFFSET FLAT:??_C@_0BB@DDMGLOLI@?$CF02X?$CF02X?$CF02X?$CF02X@
	mov	rcx, QWORD PTR p$5[rsp]
	call	sscanf
	npad	1
	jmp	SHORT $LN30@ColorEdit4
$LN32@ColorEdit4:

; 4393 : 			else
; 4394 : 				sscanf(p, ("%02X%02X%02X"), (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);

	mov	eax, 4
	imul	rax, rax, 2
	lea	rax, QWORD PTR i$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	lea	rcx, QWORD PTR i$[rsp+rcx]
	mov	edx, 4
	imul	rdx, rdx, 0
	lea	rdx, QWORD PTR i$[rsp+rdx]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, rcx
	mov	r8, rdx
	lea	rdx, OFFSET FLAT:??_C@_0N@KODLFHPJ@?$CF02X?$CF02X?$CF02X@
	mov	rcx, QWORD PTR p$5[rsp]
	call	sscanf
	npad	1
$LN30@ColorEdit4:

; 4395 : 		}
; 4396 : 		if (!(flags & ImGuiColorEditFlags_NoOptions))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN34@ColorEdit4

; 4397 : 			OpenPopupOnItemClick(("context"));

	mov	edx, 1
	lea	rcx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	call	?OpenPopupOnItemClick@ImGui@@YA_NPEBDH@Z ; ImGui::OpenPopupOnItemClick
	npad	1
$LN34@ColorEdit4:

; 4398 : 		PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	npad	1
$LN21@ColorEdit4:

; 4399 : 	}
; 4400 : 
; 4401 : 	ImGuiWindow* picker_active_window = NULL;

	mov	QWORD PTR picker_active_window$[rsp], 0

; 4402 : 	if (!(flags & ImGuiColorEditFlags_NoSmallPreview))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16
	test	eax, eax
	jne	$LN35@ColorEdit4

; 4403 : 	{
; 4404 : 		if (!(flags & ImGuiColorEditFlags_NoInputs))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN36@ColorEdit4

; 4405 : 			SameLine(0, style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1
$LN36@ColorEdit4:

; 4406 : 
; 4407 : 		const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);

	movzx	eax, BYTE PTR alpha$[rsp]
	test	eax, eax
	je	SHORT $LN84@ColorEdit4
	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR tv725[rsp], xmm0
	jmp	SHORT $LN85@ColorEdit4
$LN84@ColorEdit4:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv725[rsp], xmm0
$LN85@ColorEdit4:
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 0
	movss	xmm0, DWORD PTR tv725[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r8, QWORD PTR col$[rsp]
	movss	xmm3, DWORD PTR [r8+rax]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm2, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR col$[rsp]
	movss	xmm1, DWORD PTR [rax+rdx]
	lea	rcx, QWORD PTR col_v4$12[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	npad	1

; 4408 : 		if (ColorButton(("##+-ColorButton"), col_v4, flags, ImVec2(0, 0)))

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9, QWORD PTR [rax]
	mov	r8d, DWORD PTR flags$[rsp]
	lea	rdx, QWORD PTR col_v4$12[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BA@DICBDPDG@?$CD?$CD?$CL?9ColorButton@
	call	?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z ; ImGui::ColorButton
	movzx	eax, al
	test	eax, eax
	je	$LN37@ColorEdit4

; 4409 : 		{
; 4410 : 			if (!(flags & ImGuiColorEditFlags_NoPicker))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	jne	$LN37@ColorEdit4

; 4411 : 			{
; 4412 : 				// Store current color and open a picker
; 4413 : 				g.ColorPickerRef = col_v4;

	mov	rax, QWORD PTR g$[rsp]
	lea	rcx, QWORD PTR col_v4$12[rsp]
	lea	rdi, QWORD PTR [rax+11680]
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 4414 : 				OpenPopup(("picker"));

	lea	rcx, OFFSET FLAT:??_C@_06MAKAMBBI@picker@
	call	?OpenPopup@ImGui@@YAXPEBD@Z		; ImGui::OpenPopup
	npad	1

; 4415 : 				SetNextWindowPos(window->DC.LastItemRect.GetBL() + ImVec2(-1, style.ItemSpacing.y));

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv781[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR [rax+72]
	movss	xmm1, DWORD PTR __real@bf800000
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv776[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 368				; 00000170H
	mov	QWORD PTR tv770[rsp], rax
	lea	rdx, QWORD PTR $T17[rsp]
	mov	rcx, QWORD PTR tv770[rsp]
	call	?GetBL@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetBL
	mov	QWORD PTR tv774[rsp], rax
	mov	r8, QWORD PTR tv776[rsp]
	mov	rdx, QWORD PTR tv774[rsp]
	lea	rcx, QWORD PTR $T18[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv779[rsp], rax
	mov	r8, QWORD PTR tv781[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR tv779[rsp]
	call	?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z ; ImGui::SetNextWindowPos
	npad	1
$LN37@ColorEdit4:

; 4416 : 			}
; 4417 : 		}
; 4418 : 		if (!(flags & ImGuiColorEditFlags_NoOptions))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN39@ColorEdit4

; 4419 : 			OpenPopupOnItemClick(("context"));

	mov	edx, 1
	lea	rcx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	call	?OpenPopupOnItemClick@ImGui@@YA_NPEBDH@Z ; ImGui::OpenPopupOnItemClick
	npad	1
$LN39@ColorEdit4:

; 4420 : 
; 4421 : 		if (BeginPopup(("picker")))

	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_06MAKAMBBI@picker@
	call	?BeginPopup@ImGui@@YA_NPEBDH@Z		; ImGui::BeginPopup
	movzx	eax, al
	test	eax, eax
	je	$LN35@ColorEdit4

; 4422 : 		{
; 4423 : 			picker_active_window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR picker_active_window$[rsp], rax

; 4424 : 			if (label != label_display_end)

	mov	rax, QWORD PTR label_display_end$[rsp]
	cmp	QWORD PTR label$[rsp], rax
	je	SHORT $LN41@ColorEdit4

; 4425 : 			{
; 4426 : 				TextUnformatted(label, label_display_end);

	mov	rdx, QWORD PTR label_display_end$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?TextUnformatted@ImGui@@YAXPEBD0@Z	; ImGui::TextUnformatted

; 4427 : 				Spacing();

	call	?Spacing@ImGui@@YAXXZ			; ImGui::Spacing
	npad	1
$LN41@ColorEdit4:

; 4428 : 			}
; 4429 : 			ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;

	mov	DWORD PTR picker_flags_to_forward$7[rsp], 126418946 ; 07890002H

; 4430 : 			ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;

	mov	eax, DWORD PTR picker_flags_to_forward$7[rsp]
	mov	ecx, DWORD PTR flags_untouched$[rsp]
	and	ecx, eax
	mov	eax, ecx
	or	eax, 7340032				; 00700000H
	bts	eax, 7
	bts	eax, 18
	mov	DWORD PTR picker_flags$8[rsp], eax

; 4431 : 			PushItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?

	movss	xmm0, DWORD PTR square_sz$[rsp]
	mulss	xmm0, DWORD PTR __real@41400000
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 4432 : 			value_changed |= ColorPicker4(("##+-picker"), col, picker_flags, &g.ColorPickerRef.x);

	movzx	eax, BYTE PTR value_changed$[rsp]
	mov	DWORD PTR tv801[rsp], eax
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 11680				; 00002da0H
	mov	r9, rcx
	mov	r8d, DWORD PTR picker_flags$8[rsp]
	mov	rdx, QWORD PTR col$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0L@OPIIJFHG@?$CD?$CD?$CL?9picker@
	call	?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z ; ImGui::ColorPicker4
	movzx	eax, al
	mov	ecx, DWORD PTR tv801[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR value_changed$[rsp], al

; 4433 : 			PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 4434 : 			EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	npad	1
$LN35@ColorEdit4:

; 4435 : 		}
; 4436 : 	}
; 4437 : 
; 4438 : 	if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))

	mov	rax, QWORD PTR label_display_end$[rsp]
	cmp	QWORD PTR label$[rsp], rax
	je	SHORT $LN42@ColorEdit4
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN42@ColorEdit4

; 4439 : 	{
; 4440 : 		SameLine(0, style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 4441 : 		TextUnformatted2(label, label_display_end);

	mov	rdx, QWORD PTR label_display_end$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?TextUnformatted2@ImGui@@YAXPEBD0@Z	; ImGui::TextUnformatted2
	npad	1
$LN42@ColorEdit4:

; 4442 : 	}
; 4443 : 
; 4444 : 	// Convert back
; 4445 : 	if (picker_active_window == NULL)

	cmp	QWORD PTR picker_active_window$[rsp], 0
	jne	$LN43@ColorEdit4

; 4446 : 	{
; 4447 : 		if (!value_changed_as_float)

	movzx	eax, BYTE PTR value_changed_as_float$[rsp]
	test	eax, eax
	jne	SHORT $LN44@ColorEdit4

; 4448 : 			for (int n = 0; n < 4; n++)

	mov	DWORD PTR n$3[rsp], 0
	jmp	SHORT $LN12@ColorEdit4
$LN10@ColorEdit4:
	mov	eax, DWORD PTR n$3[rsp]
	inc	eax
	mov	DWORD PTR n$3[rsp], eax
$LN12@ColorEdit4:
	cmp	DWORD PTR n$3[rsp], 4
	jge	SHORT $LN44@ColorEdit4

; 4449 : 				f[n] = i[n] / 255.0f;

	movsxd	rax, DWORD PTR n$3[rsp]
	cvtsi2ss xmm0, DWORD PTR i$[rsp+rax*4]
	divss	xmm0, DWORD PTR __real@437f0000
	movsxd	rax, DWORD PTR n$3[rsp]
	movss	DWORD PTR f$[rsp+rax*4], xmm0
	jmp	SHORT $LN10@ColorEdit4
$LN44@ColorEdit4:

; 4450 : 		if (flags & ImGuiColorEditFlags_HSV)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2097152				; 00200000H
	test	eax, eax
	je	SHORT $LN45@ColorEdit4

; 4451 : 			ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);

	mov	eax, 4
	imul	rax, rax, 2
	lea	rax, QWORD PTR f$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	lea	rcx, QWORD PTR f$[rsp+rcx]
	mov	edx, 4
	imul	rdx, rdx, 0
	lea	rdx, QWORD PTR f$[rsp+rdx]
	mov	edi, 4
	imul	rdi, rdi, 2
	mov	esi, 4
	imul	rsi, rsi, 1
	mov	r8d, 4
	imul	r8, r8, 0
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rdx
	movss	xmm2, DWORD PTR f$[rsp+rdi]
	movss	xmm1, DWORD PTR f$[rsp+rsi]
	movss	xmm0, DWORD PTR f$[rsp+r8]
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB
	npad	1
$LN45@ColorEdit4:

; 4452 : 		if (value_changed)

	movzx	eax, BYTE PTR value_changed$[rsp]
	test	eax, eax
	je	$LN43@ColorEdit4

; 4453 : 		{
; 4454 : 			col[0] = f[0];

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR f$[rsp+rax]
	movss	DWORD PTR [rdx+rcx], xmm0

; 4455 : 			col[1] = f[1];

	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR f$[rsp+rax]
	movss	DWORD PTR [rdx+rcx], xmm0

; 4456 : 			col[2] = f[2];

	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR f$[rsp+rax]
	movss	DWORD PTR [rdx+rcx], xmm0

; 4457 : 			if (alpha)

	movzx	eax, BYTE PTR alpha$[rsp]
	test	eax, eax
	je	SHORT $LN43@ColorEdit4

; 4458 : 				col[3] = f[3];

	mov	eax, 4
	imul	rax, rax, 3
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR col$[rsp]
	movss	xmm0, DWORD PTR f$[rsp+rax]
	movss	DWORD PTR [rdx+rcx], xmm0
$LN43@ColorEdit4:

; 4459 : 		}
; 4460 : 	}
; 4461 : 
; 4462 : 	PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 4463 : 	EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	npad	1

; 4464 : 
; 4465 : 	// Drag and Drop Target
; 4466 : 	// NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
; 4467 : 	if ((window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropTarget())

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+416]
	and	eax, 1
	test	eax, eax
	je	$LN48@ColorEdit4
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 512				; 00000200H
	test	eax, eax
	jne	$LN48@ColorEdit4
	call	?BeginDragDropTarget@ImGui@@YA_NXZ	; ImGui::BeginDragDropTarget
	movzx	eax, al
	test	eax, eax
	je	$LN48@ColorEdit4

; 4468 : 	{
; 4469 : 		if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))

	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_06LFKNFKEK@_COL3F@
	call	?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z ; ImGui::AcceptDragDropPayload
	mov	QWORD PTR payload$10[rsp], rax
	cmp	QWORD PTR payload$10[rsp], 0
	je	SHORT $LN49@ColorEdit4

; 4470 : 		{
; 4471 : 			memcpy((float*)col, payload->Data, sizeof(float) * 3); // Preserve alpha if any //-V512

	mov	r8d, 12
	mov	rax, QWORD PTR payload$10[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR col$[rsp]
	call	memcpy

; 4472 : 			value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN49@ColorEdit4:

; 4473 : 		}
; 4474 : 		if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))

	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_06LAOCEMMP@_COL4F@
	call	?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z ; ImGui::AcceptDragDropPayload
	mov	QWORD PTR payload$11[rsp], rax
	cmp	QWORD PTR payload$11[rsp], 0
	je	SHORT $LN50@ColorEdit4

; 4475 : 		{
; 4476 : 			memcpy((float*)col, payload->Data, sizeof(float) * components);

	movsxd	rax, DWORD PTR components$[rsp]
	shl	rax, 2
	mov	r8, rax
	mov	rax, QWORD PTR payload$11[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR col$[rsp]
	call	memcpy

; 4477 : 			value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN50@ColorEdit4:

; 4478 : 		}
; 4479 : 		EndDragDropTarget();

	call	?EndDragDropTarget@ImGui@@YAXXZ		; ImGui::EndDragDropTarget
	npad	1
$LN48@ColorEdit4:

; 4480 : 	}
; 4481 : 
; 4482 : 	// When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().
; 4483 : 	if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)

	cmp	QWORD PTR picker_active_window$[rsp], 0
	je	SHORT $LN51@ColorEdit4
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6704], 0
	je	SHORT $LN51@ColorEdit4
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR picker_active_window$[rsp]
	cmp	QWORD PTR [rax+6744], rcx
	jne	SHORT $LN51@ColorEdit4

; 4484 : 		window->DC.LastItemId = g.ActiveId;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+6704]
	mov	DWORD PTR [rax+412], ecx
$LN51@ColorEdit4:

; 4485 : 
; 4486 : 	if (value_changed)

	movzx	eax, BYTE PTR value_changed$[rsp]
	test	eax, eax
	je	SHORT $LN52@ColorEdit4

; 4487 : 		MarkItemEdited(window->DC.LastItemId);

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR [rax+412]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN52@ColorEdit4:

; 4488 : 
; 4489 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
$LN1@ColorEdit4:

; 4490 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 552				; 00000228H
	pop	rdi
	pop	rsi
	ret	0
?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z ENDP			; ImGui::ColorEdit4
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$0@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?$TSS0@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	call	_Init_thread_abort
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$1@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?ids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$2@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?ids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+32
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$3@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?ids@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+64
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$5@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?$TSS1@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	call	_Init_thread_abort
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$6@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$7@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+32
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$8@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$8
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+64
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$8@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$9@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$9
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+96
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$9@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$10@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$10
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+128
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$10@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$11@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$11
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+160
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$11@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$12@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$12
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+192
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$12@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$13@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$13
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+224
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$13@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$14@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$14
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+256
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$14@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$15@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$15
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+288
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$15@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$16@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$16
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_int@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+320
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$16@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$18@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$18
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?$TSS2@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA
	call	_Init_thread_abort
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$18@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$19@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$19
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$19@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$20@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$20
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+32
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$20@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$21@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$21
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+64
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$21@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$22@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$22
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+96
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$22@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$23@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$23
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+128
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$23@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$23
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$24@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$24
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+160
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$24@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$24
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$25@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$25
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+192
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$25@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$26@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$26
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+224
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$26@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$27@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$27
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+256
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$27@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$28@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$28
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+288
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$28@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$28
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
value_changed$ = 64
alpha$ = 65
value_changed_as_float$ = 66
tv143 = 67
tv146 = 68
tv297 = 69
hdr$ = 70
n$1 = 72
hide_prefix$2 = 76
components$ = 80
n$3 = 84
g$ = 88
w_item_one$4 = 96
w_items_all$ = 100
style$ = 104
p$5 = 112
tv187 = 120
tv197 = 124
tv207 = 128
tv217 = 132
tv480 = 136
tv483 = 140
tv512 = 144
fmt_idx$6 = 148
tv552 = 152
tv725 = 156
square_sz$ = 160
tv75 = 164
tv149 = 168
tv160 = 172
window$ = 176
label_display_end$ = 184
picker_active_window$ = 192
tv622 = 200
tv620 = 204
tv618 = 208
w_extra$ = 212
tv652 = 216
tv650 = 220
picker_flags_to_forward$7 = 224
flags_untouched$ = 228
picker_flags$8 = 232
tv801 = 236
tv295 = 240
w_item_last$9 = 244
tv654 = 248
tv532 = 252
tv572 = 256
tv624 = 260
tv290 = 264
payload$10 = 272
payload$11 = 280
tv175 = 288
tv529 = 296
tv527 = 304
tv569 = 312
tv567 = 320
tv770 = 328
tv776 = 336
tv774 = 344
tv781 = 352
tv779 = 360
col_v4$12 = 368
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
f$ = 432
i$ = 448
buf$19 = 464
__$ArrayPad$ = 528
label$ = 576
col$ = 584
flags$ = 592
?dtor$29@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA PROC	; `ImGui::ColorEdit4'::`1'::dtor$29
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?fmt_table_float@?BD@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+320
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$29@?0??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4HA ENDP	; `ImGui::ColorEdit4'::`1'::dtor$29
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 48
col$ = 56
flags$ = 64
?ColorEdit3@ImGui@@YA_NPEBDQEAMH@Z PROC			; ImGui::ColorEdit3

; 4277 : {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4278 : 	return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 2
	mov	r8d, eax
	mov	rdx, QWORD PTR col$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z	; ImGui::ColorEdit4

; 4279 : }

	add	rsp, 40					; 00000028H
	ret	0
?ColorEdit3@ImGui@@YA_NPEBDQEAMH@Z ENDP			; ImGui::ColorEdit3
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 64
i$1 = 68
tv78 = 72
window$ = 80
g$ = 88
type_size$ = 96
label$ = 128
data_type$ = 136
v$ = 144
components$ = 152
step$ = 160
step_fast$ = 168
format$ = 176
flags$ = 184
?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z PROC	; ImGui::InputScalarN

; 3112 : {

$LN7:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 3113 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 3114 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN5@InputScala

; 3115 : 		return false;

	xor	al, al
	jmp	$LN1@InputScala
$LN5@InputScala:

; 3116 : 
; 3117 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3118 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 3119 : 	BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 3120 : 	PushID(label);

	mov	rcx, QWORD PTR label$[rsp]
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 3121 : 	PushMultiItemsWidths(components);

	xorps	xmm1, xmm1
	mov	ecx, DWORD PTR components$[rsp]
	call	?PushMultiItemsWidths@ImGui@@YAXHM@Z	; ImGui::PushMultiItemsWidths

; 3122 : 	size_t type_size = GDataTypeInfo[data_type].Size;

	movsxd	rax, DWORD PTR data_type$[rsp]
	imul	rax, rax, 72				; 00000048H
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR type_size$[rsp], rax

; 3123 : 	for (int i = 0; i < components; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@InputScala
$LN2@InputScala:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@InputScala:
	mov	eax, DWORD PTR components$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN3@InputScala

; 3124 : 	{
; 3125 : 		PushID(i);

	mov	ecx, DWORD PTR i$1[rsp]
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 3126 : 		value_changed |= InputScalar("", data_type, v, step, step_fast, format, flags);

	movzx	eax, BYTE PTR value_changed$[rsp]
	mov	DWORD PTR tv78[rsp], eax
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+48], ecx
	mov	rcx, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR step_fast$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR step$[rsp]
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar
	movzx	eax, al
	mov	ecx, DWORD PTR tv78[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR value_changed$[rsp], al

; 3127 : 		SameLine(0, g.Style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5548]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 3128 : 		PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 3129 : 		PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 3130 : 		v = (void*)((char*)v + type_size);

	mov	rax, QWORD PTR type_size$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v$[rsp], rax

; 3131 : 	}

	jmp	$LN2@InputScala
$LN3@InputScala:

; 3132 : 	PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 3133 : 
; 3134 : 	TextUnformatted(label, FindRenderedTextEnd(label));

	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	rdx, rax
	mov	rcx, QWORD PTR label$[rsp]
	call	?TextUnformatted@ImGui@@YAXPEBD0@Z	; ImGui::TextUnformatted

; 3135 : 	EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 3136 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
$LN1@InputScala:

; 3137 : }

	add	rsp, 120				; 00000078H
	ret	0
?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z ENDP	; ImGui::InputScalarN
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 48
button_size$1 = 52
button_flags$2 = 56
style$ = 64
g$ = 72
tv177 = 80
tv203 = 88
window$ = 96
backup_frame_padding$3 = 104
$T4 = 112
$T5 = 120
buf$ = 128
__$ArrayPad$ = 192
label$ = 224
data_type$ = 232
data_ptr$ = 240
step$ = 248
step_fast$ = 256
format$ = 264
flags$ = 272
?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z PROC		; ImGui::InputScalar

; 3046 : {

$LN17:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3047 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 3048 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@InputScala

; 3049 : 		return false;

	xor	al, al
	jmp	$LN1@InputScala
$LN2@InputScala:

; 3050 : 
; 3051 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 3052 : 	ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 3053 : 
; 3054 : 	IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
; 3055 : 	if (format == NULL)

	cmp	QWORD PTR format$[rsp], 0
	jne	SHORT $LN3@InputScala

; 3056 : 		format = GDataTypeInfo[data_type].PrintFmt.c_str();

	movsxd	rax, DWORD PTR data_type$[rsp]
	imul	rax, rax, 72				; 00000048H
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, rax
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR format$[rsp], rax
$LN3@InputScala:

; 3057 : 
; 3058 : 	char buf[64];
; 3059 : 	DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, data_ptr, format);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR data_ptr$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR buf$[rsp]
	call	?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z ; DataTypeFormatString

; 3060 : 
; 3061 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 3062 : 	if ((flags & (ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsScientific)) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 131074				; 00020002H
	test	eax, eax
	jne	SHORT $LN4@InputScala

; 3063 : 		flags |= ImGuiInputTextFlags_CharsDecimal;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 1
	mov	DWORD PTR flags$[rsp], eax
$LN4@InputScala:

; 3064 : 	flags |= ImGuiInputTextFlags_AutoSelectAll;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 16
	mov	DWORD PTR flags$[rsp], eax

; 3065 : 
; 3066 : 	if (step != NULL)

	cmp	QWORD PTR step$[rsp], 0
	je	$LN5@InputScala

; 3067 : 	{
; 3068 : 		const float button_size = GetFrameHeight();

	call	?GetFrameHeight@ImGui@@YAMXZ		; ImGui::GetFrameHeight
	movss	DWORD PTR button_size$1[rsp], xmm0

; 3069 : 
; 3070 : 		BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 3071 : 		PushID(label);

	mov	rcx, QWORD PTR label$[rsp]
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 3072 : 		PushItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR button_size$1[rsp]
	addss	xmm1, DWORD PTR [rax+76]
	mulss	xmm1, DWORD PTR __real@40000000
	subss	xmm0, xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	npad	1

; 3073 : 		if (InputText("", buf, IM_ARRAYSIZE(buf), flags)) // PushId(label) + "" gives us the expected ID from outside point of view

	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, DWORD PTR flags$[rsp]
	mov	r8d, 64					; 00000040H
	lea	rdx, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputText
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@InputScala

; 3074 : 			value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialText.Data, data_type, data_ptr, format);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR data_ptr$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR [rax+7984]
	lea	rcx, QWORD PTR buf$[rsp]
	call	?DataTypeApplyOpFromText@@YA_NPEBD0HPEAX0@Z ; DataTypeApplyOpFromText
	mov	BYTE PTR value_changed$[rsp], al
$LN7@InputScala:

; 3075 : 		PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 3076 : 
; 3077 : 		// Step buttons
; 3078 : 		const ImVec2 backup_frame_padding = style.FramePadding;

	mov	rax, QWORD PTR style$[rsp]
	mov	rax, QWORD PTR [rax+52]
	mov	QWORD PTR backup_frame_padding$3[rsp], rax

; 3079 : 		style.FramePadding.x = style.FramePadding.y;

	mov	rax, QWORD PTR style$[rsp]
	mov	rcx, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR [rax+52], xmm0

; 3080 : 		ImGuiButtonFlags button_flags = ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups;

	mov	DWORD PTR button_flags$2[rsp], 129	; 00000081H

; 3081 : 		if (flags & ImGuiInputTextFlags_ReadOnly)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 16384				; 00004000H
	test	eax, eax
	je	SHORT $LN8@InputScala

; 3082 : 			button_flags |= ImGuiButtonFlags_Disabled;

	mov	eax, DWORD PTR button_flags$2[rsp]
	bts	eax, 8
	mov	DWORD PTR button_flags$2[rsp], eax
$LN8@InputScala:

; 3083 : 		SameLine(0, style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1

; 3084 : 		if (ButtonEx("-", ImVec2(button_size, button_size), button_flags))

	movss	xmm2, DWORD PTR button_size$1[rsp]
	movss	xmm1, DWORD PTR button_size$1[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8d, DWORD PTR button_flags$2[rsp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_01JOAMLHOP@?9@
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@InputScala

; 3085 : 		{
; 3086 : 			DataTypeApplyOp(data_type, '-', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	je	SHORT $LN13@InputScala
	cmp	QWORD PTR step_fast$[rsp], 0
	je	SHORT $LN13@InputScala
	mov	rax, QWORD PTR step_fast$[rsp]
	mov	QWORD PTR tv177[rsp], rax
	jmp	SHORT $LN14@InputScala
$LN13@InputScala:
	mov	rax, QWORD PTR step$[rsp]
	mov	QWORD PTR tv177[rsp], rax
$LN14@InputScala:
	mov	rax, QWORD PTR tv177[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR data_ptr$[rsp]
	mov	r8, QWORD PTR data_ptr$[rsp]
	mov	edx, 45					; 0000002dH
	mov	ecx, DWORD PTR data_type$[rsp]
	call	?DataTypeApplyOp@@YAXHHPEAX0PEBX@Z	; DataTypeApplyOp

; 3087 : 			value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN9@InputScala:

; 3088 : 		}
; 3089 : 		SameLine(0, style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1

; 3090 : 		if (ButtonEx("+", ImVec2(button_size, button_size), button_flags))

	movss	xmm2, DWORD PTR button_size$1[rsp]
	movss	xmm1, DWORD PTR button_size$1[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8d, DWORD PTR button_flags$2[rsp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_01MIFGBAGJ@?$CL@
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@InputScala

; 3091 : 		{
; 3092 : 			DataTypeApplyOp(data_type, '+', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);

	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	je	SHORT $LN15@InputScala
	cmp	QWORD PTR step_fast$[rsp], 0
	je	SHORT $LN15@InputScala
	mov	rax, QWORD PTR step_fast$[rsp]
	mov	QWORD PTR tv203[rsp], rax
	jmp	SHORT $LN16@InputScala
$LN15@InputScala:
	mov	rax, QWORD PTR step$[rsp]
	mov	QWORD PTR tv203[rsp], rax
$LN16@InputScala:
	mov	rax, QWORD PTR tv203[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR data_ptr$[rsp]
	mov	r8, QWORD PTR data_ptr$[rsp]
	mov	edx, 43					; 0000002bH
	mov	ecx, DWORD PTR data_type$[rsp]
	call	?DataTypeApplyOp@@YAXHHPEAX0PEBX@Z	; DataTypeApplyOp

; 3093 : 			value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1
$LN10@InputScala:

; 3094 : 		}
; 3095 : 		SameLine(0, style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 3096 : 		TextUnformatted(label, FindRenderedTextEnd(label));

	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	rdx, rax
	mov	rcx, QWORD PTR label$[rsp]
	call	?TextUnformatted@ImGui@@YAXPEBD0@Z	; ImGui::TextUnformatted

; 3097 : 		style.FramePadding = backup_frame_padding;

	mov	rax, QWORD PTR style$[rsp]
	mov	rcx, QWORD PTR backup_frame_padding$3[rsp]
	mov	QWORD PTR [rax+52], rcx

; 3098 : 
; 3099 : 		PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 3100 : 		EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	npad	1

; 3101 : 	}

	jmp	SHORT $LN6@InputScala
$LN5@InputScala:

; 3102 : 	else
; 3103 : 	{
; 3104 : 		if (InputText(label, buf, IM_ARRAYSIZE(buf), flags))

	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, DWORD PTR flags$[rsp]
	mov	r8d, 64					; 00000040H
	lea	rdx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputText
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@InputScala

; 3105 : 			value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialText.Data, data_type, data_ptr, format);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR data_ptr$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR [rax+7984]
	lea	rcx, QWORD PTR buf$[rsp]
	call	?DataTypeApplyOpFromText@@YA_NPEBD0HPEAX0@Z ; DataTypeApplyOpFromText
	mov	BYTE PTR value_changed$[rsp], al
$LN11@InputScala:
$LN6@InputScala:

; 3106 : 	}
; 3107 : 
; 3108 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
$LN1@InputScala:

; 3109 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 216				; 000000d8H
	ret	0
?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ENDP		; ImGui::InputScalar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv69 = 64
tv72 = 72
tv78 = 80
label$ = 112
v$ = 120
step$ = 128
step_fast$ = 136
format$ = 144
flags$ = 152
?InputDouble@ImGui@@YA_NPEBDPEANNN0H@Z PROC		; ImGui::InputDouble

; 3218 : {

$LN7:
	movsd	QWORD PTR [rsp+32], xmm3
	movsd	QWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 3219 : 	flags |= ImGuiInputTextFlags_CharsScientific;

	mov	eax, DWORD PTR flags$[rsp]
	bts	eax, 17
	mov	DWORD PTR flags$[rsp], eax

; 3220 : 	return InputScalar(label, ImGuiDataType_Double, (void*)v, (void*)(step > 0.0 ? &step : NULL), (void*)(step_fast > 0.0 ? &step_fast : NULL), format, flags);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	movsd	xmm0, QWORD PTR step_fast$[rsp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN3@InputDoubl
	lea	rax, QWORD PTR step_fast$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@InputDoubl
$LN3@InputDoubl:
	mov	QWORD PTR tv69[rsp], 0
$LN4@InputDoubl:
	movsd	xmm0, QWORD PTR step$[rsp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@InputDoubl
	lea	rax, QWORD PTR step$[rsp]
	mov	QWORD PTR tv72[rsp], rax
	jmp	SHORT $LN6@InputDoubl
$LN5@InputDoubl:
	mov	QWORD PTR tv72[rsp], 0
$LN6@InputDoubl:
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR tv78[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv69[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv72[rsp]
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 5
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar

; 3221 : }

	add	rsp, 104				; 00000068H
	ret	0
?InputDouble@ImGui@@YA_NPEBDPEANNN0H@Z ENDP		; ImGui::InputDouble
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
flags$ = 96
?InputInt4@ImGui@@YA_NPEBDQEAHH@Z PROC			; ImGui::InputInt4

; 3213 : {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3214 : 	return InputScalarN(label, ImGuiDataType_S32, v, 4, NULL, NULL, "%d", flags);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	lea	rax, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 4
	mov	r8, QWORD PTR v$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z ; ImGui::InputScalarN

; 3215 : }

	add	rsp, 72					; 00000048H
	ret	0
?InputInt4@ImGui@@YA_NPEBDQEAHH@Z ENDP			; ImGui::InputInt4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
flags$ = 96
?InputInt3@ImGui@@YA_NPEBDQEAHH@Z PROC			; ImGui::InputInt3

; 3208 : {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3209 : 	return InputScalarN(label, ImGuiDataType_S32, v, 3, NULL, NULL, "%d", flags);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	lea	rax, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 3
	mov	r8, QWORD PTR v$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z ; ImGui::InputScalarN

; 3210 : }

	add	rsp, 72					; 00000048H
	ret	0
?InputInt3@ImGui@@YA_NPEBDQEAHH@Z ENDP			; ImGui::InputInt3
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
flags$ = 96
?InputInt2@ImGui@@YA_NPEBDQEAHH@Z PROC			; ImGui::InputInt2

; 3203 : {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3204 : 	return InputScalarN(label, ImGuiDataType_S32, v, 2, NULL, NULL, "%d", flags);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	lea	rax, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 2
	mov	r8, QWORD PTR v$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z ; ImGui::InputScalarN

; 3205 : }

	add	rsp, 72					; 00000048H
	ret	0
?InputInt2@ImGui@@YA_NPEBDQEAHH@Z ENDP			; ImGui::InputInt2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv66 = 64
tv71 = 72
tv74 = 80
format$ = 88
tv80 = 96
label$ = 128
v$ = 136
step$ = 144
step_fast$ = 152
flags$ = 160
?InputInt@ImGui@@YA_NPEBDPEAHHHH@Z PROC			; ImGui::InputInt

; 3196 : {

$LN9:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 3197 : 	// Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
; 3198 : 	const char* format = (flags & ImGuiInputTextFlags_CharsHexadecimal) ? ("%08X") : "%d";

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN3@InputInt
	lea	rax, OFFSET FLAT:??_C@_04JIMNDDED@?$CF08X@
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@InputInt
$LN3@InputInt:
	lea	rax, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	mov	QWORD PTR tv66[rsp], rax
$LN4@InputInt:
	mov	rax, QWORD PTR tv66[rsp]
	mov	QWORD PTR format$[rsp], rax

; 3199 : 	return InputScalar(label, ImGuiDataType_S32, (void*)v, (void*)(step > 0 ? &step : NULL), (void*)(step_fast > 0 ? &step_fast : NULL), format, flags);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv80[rsp], rax
	cmp	DWORD PTR step_fast$[rsp], 0
	jle	SHORT $LN5@InputInt
	lea	rax, QWORD PTR step_fast$[rsp]
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN6@InputInt
$LN5@InputInt:
	mov	QWORD PTR tv71[rsp], 0
$LN6@InputInt:
	cmp	DWORD PTR step$[rsp], 0
	jle	SHORT $LN7@InputInt
	lea	rax, QWORD PTR step$[rsp]
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN8@InputInt
$LN7@InputInt:
	mov	QWORD PTR tv74[rsp], 0
$LN8@InputInt:
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR tv80[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv71[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv74[rsp]
	mov	r8, QWORD PTR v$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar

; 3200 : }

	add	rsp, 120				; 00000078H
	ret	0
?InputInt@ImGui@@YA_NPEBDPEAHHHH@Z ENDP			; ImGui::InputInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
format$ = 96
flags$ = 104
?InputFloat4@ImGui@@YA_NPEBDQEAM0H@Z PROC		; ImGui::InputFloat4

; 3156 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3157 : 	return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 4
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z ; ImGui::InputScalarN

; 3158 : }

	add	rsp, 72					; 00000048H
	ret	0
?InputFloat4@ImGui@@YA_NPEBDQEAM0H@Z ENDP		; ImGui::InputFloat4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
format$ = 96
flags$ = 104
?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z PROC		; ImGui::InputFloat3

; 3151 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3152 : 	return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 3
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z ; ImGui::InputScalarN

; 3153 : }

	add	rsp, 72					; 00000048H
	ret	0
?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z ENDP		; ImGui::InputFloat3
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
format$ = 96
flags$ = 104
?InputFloat2@ImGui@@YA_NPEBDQEAM0H@Z PROC		; ImGui::InputFloat2

; 3146 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3147 : 	return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+56], eax
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 2
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z ; ImGui::InputScalarN

; 3148 : }

	add	rsp, 72					; 00000048H
	ret	0
?InputFloat2@ImGui@@YA_NPEBDQEAM0H@Z ENDP		; ImGui::InputFloat2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv69 = 64
tv72 = 72
tv78 = 80
label$ = 112
v$ = 120
step$ = 128
step_fast$ = 136
format$ = 144
flags$ = 152
?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z PROC		; ImGui::InputFloat

; 3140 : {

$LN7:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 3141 : 	flags |= ImGuiInputTextFlags_CharsScientific;

	mov	eax, DWORD PTR flags$[rsp]
	bts	eax, 17
	mov	DWORD PTR flags$[rsp], eax

; 3142 : 	return InputScalar(label, ImGuiDataType_Float, (void*)v, (void*)(step > 0.0f ? &step : NULL), (void*)(step_fast > 0.0f ? &step_fast : NULL), format, flags);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	movss	xmm0, DWORD PTR step_fast$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@InputFloat
	lea	rax, QWORD PTR step_fast$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@InputFloat
$LN3@InputFloat:
	mov	QWORD PTR tv69[rsp], 0
$LN4@InputFloat:
	movss	xmm0, DWORD PTR step$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@InputFloat
	lea	rax, QWORD PTR step$[rsp]
	mov	QWORD PTR tv72[rsp], rax
	jmp	SHORT $LN6@InputFloat
$LN5@InputFloat:
	mov	QWORD PTR tv72[rsp], 0
$LN6@InputFloat:
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR tv78[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv69[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv72[rsp]
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar

; 3143 : }

	add	rsp, 104				; 00000068H
	ret	0
?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z ENDP		; ImGui::InputFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
buf$ = 88
buf_size$ = 96
size$ = 104
flags$ = 112
callback$ = 120
user_data$ = 128
?InputTextMultiline@ImGui@@YA_NPEBDPEAD_KAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z PROC ; ImGui::InputTextMultiline

; 3283 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3284 : 	return InputTextEx(label, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);

	mov	eax, DWORD PTR flags$[rsp]
	bts	eax, 20
	mov	rcx, QWORD PTR user_data$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR callback$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR size$[rsp]
	mov	r8d, DWORD PTR buf_size$[rsp]
	mov	rdx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputTextEx@ImGui@@YA_NPEBDPEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextEx

; 3285 : }

	add	rsp, 72					; 00000048H
	ret	0
?InputTextMultiline@ImGui@@YA_NPEBDPEAD_KAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ENDP ; ImGui::InputTextMultiline
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
$T1 = 64
label$ = 96
buf$ = 104
buf_size$ = 112
flags$ = 120
callback$ = 128
user_data$ = 136
?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z PROC ; ImGui::InputText

; 3277 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 3278 : 	IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()
; 3279 : 	return InputTextEx(label, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR user_data$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR callback$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	ecx, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, rax
	mov	r8d, DWORD PTR buf_size$[rsp]
	mov	rdx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputTextEx@ImGui@@YA_NPEBDPEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextEx

; 3280 : }

	add	rsp, 88					; 00000058H
	ret	0
?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ENDP ; ImGui::InputText
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv81 = 64
tv79 = 72
cb_user_data$ = 80
label$ = 128
str$ = 136
size$ = 144
flags$ = 152
callback$ = 160
user_data$ = 168
?InputTextMultiline@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z PROC ; ImGui::InputTextMultiline

; 3265 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 3266 : 	IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);
; 3267 : 	flags |= ImGuiInputTextFlags_CallbackResize;

	mov	eax, DWORD PTR flags$[rsp]
	bts	eax, 18
	mov	DWORD PTR flags$[rsp], eax

; 3268 : 
; 3269 : 	InputTextCallback_UserData cb_user_data;
; 3270 : 	cb_user_data.Str = str;

	mov	rax, QWORD PTR str$[rsp]
	mov	QWORD PTR cb_user_data$[rsp], rax

; 3271 : 	cb_user_data.ChainCallback = callback;

	mov	rax, QWORD PTR callback$[rsp]
	mov	QWORD PTR cb_user_data$[rsp+8], rax

; 3272 : 	cb_user_data.ChainCallbackUserData = user_data;

	mov	rax, QWORD PTR user_data$[rsp]
	mov	QWORD PTR cb_user_data$[rsp+16], rax

; 3273 : 	return InputTextMultiline(label, (char*)str->c_str(), str->capacity() + 1, size, flags, InputTextCallback, &cb_user_data);

	mov	rcx, QWORD PTR str$[rsp]
	call	?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
	inc	rax
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR str$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv79[rsp], rax
	lea	rax, QWORD PTR cb_user_data$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, OFFSET FLAT:?InputTextCallback@@YAHPEAUImGuiInputTextCallbackData@@@Z ; InputTextCallback
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR size$[rsp]
	mov	r8, QWORD PTR tv81[rsp]
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputTextMultiline@ImGui@@YA_NPEBDPEAD_KAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextMultiline

; 3274 : }

	add	rsp, 120				; 00000078H
	ret	0
?InputTextMultiline@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ENDP ; ImGui::InputTextMultiline
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv80 = 48
tv73 = 56
cb_user_data$ = 64
label$ = 112
str$ = 120
lenght$ = 128
flags$ = 136
callback$ = 144
user_data$ = 152
?InputText@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z PROC ; ImGui::InputText

; 3253 : {

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 3254 : 	IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);
; 3255 : 	flags |= ImGuiInputTextFlags_CallbackResize;

	mov	eax, DWORD PTR flags$[rsp]
	bts	eax, 18
	mov	DWORD PTR flags$[rsp], eax

; 3256 : 
; 3257 : 	InputTextCallback_UserData cb_user_data;
; 3258 : 	cb_user_data.Str = str;

	mov	rax, QWORD PTR str$[rsp]
	mov	QWORD PTR cb_user_data$[rsp], rax

; 3259 : 	cb_user_data.ChainCallback = callback;

	mov	rax, QWORD PTR callback$[rsp]
	mov	QWORD PTR cb_user_data$[rsp+8], rax

; 3260 : 	cb_user_data.ChainCallbackUserData = user_data;

	mov	rax, QWORD PTR user_data$[rsp]
	mov	QWORD PTR cb_user_data$[rsp+16], rax

; 3261 : 	return InputText(label, (char*)str->c_str(), lenght == 0 ? (str->capacity() + 1) : lenght, flags, InputTextCallback, &cb_user_data);

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR tv80[rsp], eax
	cmp	QWORD PTR lenght$[rsp], 0
	jne	SHORT $LN3@InputText
	mov	rcx, QWORD PTR str$[rsp]
	call	?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
	inc	rax
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN4@InputText
$LN3@InputText:
	mov	rax, QWORD PTR lenght$[rsp]
	mov	QWORD PTR tv73[rsp], rax
$LN4@InputText:
	mov	rcx, QWORD PTR str$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	lea	rcx, QWORD PTR cb_user_data$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, OFFSET FLAT:?InputTextCallback@@YAHPEAUImGuiInputTextCallbackData@@@Z ; InputTextCallback
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR tv80[rsp]
	mov	r8, QWORD PTR tv73[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR label$[rsp]
	call	?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputText

; 3262 : }

	add	rsp, 104				; 00000068H
	ret	0
?InputText@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ENDP ; ImGui::InputText
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 80
text_display_end$ = 88
tv140 = 96
tv142 = 100
tv178 = 104
tv180 = 108
tv216 = 112
tv218 = 116
tv254 = 120
tv256 = 124
tv277 = 128
tv279 = 132
tv138 = 136
tv136 = 144
tv144 = 152
tv176 = 160
tv174 = 168
tv182 = 176
tv214 = 184
tv212 = 192
tv220 = 200
tv252 = 208
tv250 = 216
tv258 = 224
tv275 = 232
tv281 = 240
window$ = 248
$T1 = 256
$T2 = 264
$T3 = 272
$T4 = 280
$T5 = 288
$T6 = 296
$T7 = 304
$T8 = 312
$T9 = 320
$T10 = 336
$T11 = 352
$T12 = 368
pos$ = 400
text$ = 408
text_end$ = 416
hide_text_after_hash$ = 424
?RenderTextOverlay@ImGui@@YAXUImVec2@@PEBD1_N@Z PROC	; ImGui::RenderTextOverlay

; 2648 : {

$LN7:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 392				; 00000188H

; 2649 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2650 : 	ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+6584]
	mov	QWORD PTR window$[rsp], rax

; 2651 : 
; 2652 : 	// Hide anything after a '##' string
; 2653 : 	const char* text_display_end;
; 2654 : 	if (hide_text_after_hash)

	movzx	eax, BYTE PTR hide_text_after_hash$[rsp]
	test	eax, eax
	je	SHORT $LN2@RenderText

; 2655 : 	{
; 2656 : 		text_display_end = FindRenderedTextEnd(text, text_end);

	mov	rdx, QWORD PTR text_end$[rsp]
	mov	rcx, QWORD PTR text$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	QWORD PTR text_display_end$[rsp], rax

; 2657 : 	}

	jmp	SHORT $LN3@RenderText
$LN2@RenderText:

; 2658 : 	else
; 2659 : 	{
; 2660 : 		if (!text_end)

	cmp	QWORD PTR text_end$[rsp], 0
	jne	SHORT $LN4@RenderText

; 2661 : 			text_end = text + strlen(text); // FIXME-OPT

	mov	rcx, QWORD PTR text$[rsp]
	call	strlen
	mov	rcx, QWORD PTR text$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR text_end$[rsp], rax
$LN4@RenderText:

; 2662 : 		text_display_end = text_end;

	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR text_display_end$[rsp], rax
$LN3@RenderText:

; 2663 : 	}
; 2664 : 
; 2665 : 	if (text != text_display_end)

	mov	rax, QWORD PTR text_display_end$[rsp]
	cmp	QWORD PTR text$[rsp], rax
	je	$LN5@RenderText

; 2666 : 	{
; 2667 : 		ImGui::GetWindowDrawList()->AddText(g.Font, g.FontSize, pos + ImVec2(1, 0), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), text, text_display_end);

	call	?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	QWORD PTR tv144[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv140[rsp], eax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv138[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv142[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv136[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv140[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv138[rsp]
	movss	xmm2, DWORD PTR tv142[rsp]
	mov	rdx, QWORD PTR tv136[rsp]
	mov	rcx, QWORD PTR tv144[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 2668 : 		ImGui::GetWindowDrawList()->AddText(g.Font, g.FontSize, pos + ImVec2(0, 1), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), text, text_display_end);

	call	?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	QWORD PTR tv182[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv178[rsp], eax
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv176[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv180[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv174[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv178[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv176[rsp]
	movss	xmm2, DWORD PTR tv180[rsp]
	mov	rdx, QWORD PTR tv174[rsp]
	mov	rcx, QWORD PTR tv182[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 2669 : 		ImGui::GetWindowDrawList()->AddText(g.Font, g.FontSize, pos + ImVec2(-1, 0), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), text, text_display_end);

	call	?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	QWORD PTR tv220[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv216[rsp], eax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@bf800000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv214[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv218[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv212[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv216[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv214[rsp]
	movss	xmm2, DWORD PTR tv218[rsp]
	mov	rdx, QWORD PTR tv212[rsp]
	mov	rcx, QWORD PTR tv220[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 2670 : 		ImGui::GetWindowDrawList()->AddText(g.Font, g.FontSize, pos + ImVec2(0, -1), ImGui::GetColorU32(ImVec4(0, 0, 0, 1)), text, text_display_end);

	call	?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	QWORD PTR tv258[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv254[rsp], eax
	movss	xmm2, DWORD PTR __real@bf800000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv252[rsp], rax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv256[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv250[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv254[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR tv252[rsp]
	movss	xmm2, DWORD PTR tv256[rsp]
	mov	rdx, QWORD PTR tv250[rsp]
	mov	rcx, QWORD PTR tv258[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1

; 2671 : 		ImGui::GetWindowDrawList()->AddText(g.Font, g.FontSize, pos, ImGui::GetColorU32(ImGuiCol_Text), text, text_display_end);

	call	?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	QWORD PTR tv281[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	xor	ecx, ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv277[rsp], eax
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv279[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv275[rsp], rax
	mov	QWORD PTR [rsp+64], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR text_display_end$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv277[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR pos$[rsp]
	movss	xmm2, DWORD PTR tv279[rsp]
	mov	rdx, QWORD PTR tv275[rsp]
	mov	rcx, QWORD PTR tv281[rsp]
	call	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
	npad	1
$LN5@RenderText:

; 2672 : 	}
; 2673 : }

	add	rsp, 392				; 00000188H
	ret	0
?RenderTextOverlay@ImGui@@YAXUImVec2@@PEBD1_N@Z ENDP	; ImGui::RenderTextOverlay
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
id$ = 80
value_changed$ = 84
hovered$ = 85
g$ = 88
window$ = 96
style$ = 104
frame_bb$ = 112
tv131 = 128
tv188 = 132
tv189 = 136
tv225 = 140
frame_col$ = 144
tv231 = 148
tv233 = 152
label_size$ = 160
tv235 = 168
tv297 = 176
value_buf_end$ = 184
tv295 = 192
grab_bb$ = 200
$T1 = 216
$T2 = 224
$T3 = 232
$T4 = 240
$T5 = 248
$T6 = 256
bb$ = 264
value_buf$ = 288
__$ArrayPad$ = 352
label$ = 384
size$ = 392
data_type$ = 400
v$ = 408
v_min$ = 416
v_max$ = 424
format$ = 432
power$ = 440
?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30M@Z PROC ; ImGui::VSliderScalar

; 2853 : {

$LN21:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 376				; 00000178H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2854 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 2855 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@VSliderSca

; 2856 : 		return false;

	xor	al, al
	jmp	$LN1@VSliderSca
$LN2@VSliderSca:

; 2857 : 
; 2858 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2859 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 2860 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 2861 : 
; 2862 : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	npad	1

; 2863 : 	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	mov	r8, QWORD PTR size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 2864 : 	const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN13@VSliderSca
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	addss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR tv131[rsp], xmm0
	jmp	SHORT $LN14@VSliderSca
$LN13@VSliderSca:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv131[rsp], xmm0
$LN14@VSliderSca:
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR tv131[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 2865 : 
; 2866 : 	ItemSize(bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 2867 : 	if (!ItemAdd(frame_bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@VSliderSca

; 2868 : 		return false;

	xor	al, al
	jmp	$LN1@VSliderSca
$LN3@VSliderSca:

; 2869 : 
; 2870 : 	// Default format string when passing NULL
; 2871 : 	// Patch old "%.0f" format string to use "%d", read function comments for more details.
; 2872 : 	IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
; 2873 : 	if (format == NULL)

	cmp	QWORD PTR format$[rsp], 0
	jne	SHORT $LN4@VSliderSca

; 2874 : 		format = GDataTypeInfo[data_type].PrintFmt.c_str();

	movsxd	rax, DWORD PTR data_type$[rsp]
	imul	rax, rax, 72				; 00000048H
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, rax
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR format$[rsp], rax
	jmp	SHORT $LN5@VSliderSca
$LN4@VSliderSca:

; 2875 : 	else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)

	cmp	DWORD PTR data_type$[rsp], 0
	jne	SHORT $LN6@VSliderSca
	lea	rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	mov	rcx, QWORD PTR format$[rsp]
	call	strcmp
	test	eax, eax
	je	SHORT $LN6@VSliderSca

; 2876 : 		format = PatchFormatStringFloatToInt(format);

	mov	rcx, QWORD PTR format$[rsp]
	call	?PatchFormatStringFloatToInt@@YAPEBDPEBD@Z ; PatchFormatStringFloatToInt
	mov	QWORD PTR format$[rsp], rax
$LN6@VSliderSca:
$LN5@VSliderSca:

; 2877 : 
; 2878 : 	const bool hovered = ItemHoverable(frame_bb, id);

	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z ; ImGui::ItemHoverable
	mov	BYTE PTR hovered$[rsp], al

; 2879 : 	if ((hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavInputId == id)

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN9@VSliderSca
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1016]
	test	eax, eax
	jne	SHORT $LN8@VSliderSca
$LN9@VSliderSca:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7044], ecx
	je	SHORT $LN8@VSliderSca
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7048], ecx
	jne	SHORT $LN7@VSliderSca
$LN8@VSliderSca:

; 2880 : 	{
; 2881 : 		SetActiveID(id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 2882 : 		SetFocusID(id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetFocusID

; 2883 : 		FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 2884 : 		g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6804], 3
$LN7@VSliderSca:

; 2885 : 	}
; 2886 : 
; 2887 : 	// Draw frame
; 2888 : 	const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN17@VSliderSca
	mov	DWORD PTR tv189[rsp], 9
	jmp	SHORT $LN18@VSliderSca
$LN17@VSliderSca:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6696], ecx
	jne	SHORT $LN15@VSliderSca
	mov	DWORD PTR tv188[rsp], 8
	jmp	SHORT $LN16@VSliderSca
$LN15@VSliderSca:
	mov	DWORD PTR tv188[rsp], 7
$LN16@VSliderSca:
	mov	eax, DWORD PTR tv188[rsp]
	mov	DWORD PTR tv189[rsp], eax
$LN18@VSliderSca:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv189[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR frame_col$[rsp], eax

; 2889 : 	RenderNavHighlight(frame_bb, id);

	mov	r8d, 1
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 2890 : 	RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5532]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	r8d, DWORD PTR frame_col$[rsp]
	mov	rdx, QWORD PTR frame_bb$[rsp+8]
	mov	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 2891 : 
; 2892 : 	// Slider behavior
; 2893 : 	ImRect grab_bb;

	lea	rcx, QWORD PTR grab_bb$[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect

; 2894 : 	const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_Vertical, &grab_bb);

	lea	rax, QWORD PTR grab_bb$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	DWORD PTR [rsp+64], 1
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?SliderBehavior@ImGui@@YA_NAEBUImRect@@IHPEAXPEBX2PEBDMHPEAU2@@Z ; ImGui::SliderBehavior
	mov	BYTE PTR value_changed$[rsp], al

; 2895 : 	if (value_changed)

	movzx	eax, BYTE PTR value_changed$[rsp]
	test	eax, eax
	je	SHORT $LN10@VSliderSca

; 2896 : 		MarkItemEdited(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN10@VSliderSca:

; 2897 : 
; 2898 : 	// Render grab
; 2899 : 	window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv235[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+112]
	movss	DWORD PTR tv231[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN19@VSliderSca
	mov	DWORD PTR tv225[rsp], 20
	jmp	SHORT $LN20@VSliderSca
$LN19@VSliderSca:
	mov	DWORD PTR tv225[rsp], 19
$LN20@VSliderSca:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv225[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv233[rsp], eax
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR tv231[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv233[rsp]
	lea	r8, QWORD PTR grab_bb$[rsp+8]
	lea	rdx, QWORD PTR grab_bb$[rsp]
	mov	rcx, QWORD PTR tv235[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 2900 : 
; 2901 : 	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
; 2902 : 	// For the vertical slider we allow centered text to overlap the frame padding
; 2903 : 	char value_buf[64];
; 2904 : 	const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR value_buf$[rsp]
	call	?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z ; DataTypeFormatString
	cdqe
	lea	rax, QWORD PTR value_buf$[rsp+rax]
	mov	QWORD PTR value_buf_end$[rsp], rax

; 2905 : 	RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.0f));

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv297[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR frame_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv295[rsp], rax
	mov	QWORD PTR [rsp+48], 0
	mov	rax, QWORD PTR tv297[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR value_buf_end$[rsp]
	lea	r8, QWORD PTR value_buf$[rsp]
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	mov	rcx, QWORD PTR tv295[rsp]
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
	npad	1

; 2906 : 	if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN11@VSliderSca

; 2907 : 		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR frame_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR frame_bb$[rsp+8]
	addss	xmm1, DWORD PTR [rax+76]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN11@VSliderSca:

; 2908 : 
; 2909 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
$LN1@VSliderSca:

; 2910 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 376				; 00000178H
	ret	0
?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30M@Z ENDP ; ImGui::VSliderScalar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
size$ = 88
v$ = 96
v_min$ = 104
v_max$ = 112
format$ = 120
?VSliderInt@ImGui@@YA_NPEBDAEBUImVec2@@PEAHHH0@Z PROC	; ImGui::VSliderInt

; 2918 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2919 : 	return VSliderScalar(label, size, ImGuiDataType_S32, v, &v_min, &v_max, format);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30M@Z ; ImGui::VSliderScalar

; 2920 : }

	add	rsp, 72					; 00000048H
	ret	0
?VSliderInt@ImGui@@YA_NPEBDAEBUImVec2@@PEAHHH0@Z ENDP	; ImGui::VSliderInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
size$ = 88
v$ = 96
v_min$ = 104
v_max$ = 112
format$ = 120
power$ = 128
?VSliderFloat@ImGui@@YA_NPEBDAEBUImVec2@@PEAMMM0M@Z PROC ; ImGui::VSliderFloat

; 2913 : {

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2914 : 	return VSliderScalar(label, size, ImGuiDataType_Float, v, &v_min, &v_max, format, power);

	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v$[rsp]
	mov	r8d, 4
	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30M@Z ; ImGui::VSliderScalar

; 2915 : }

	add	rsp, 72					; 00000048H
	ret	0
?VSliderFloat@ImGui@@YA_NPEBDAEBUImVec2@@PEAMMM0M@Z ENDP ; ImGui::VSliderFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 64
i$1 = 68
tv78 = 72
window$ = 80
g$ = 88
type_size$ = 96
label$ = 128
data_type$ = 136
v$ = 144
components$ = 152
v_min$ = 160
v_max$ = 168
format$ = 176
power$ = 184
?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z PROC	; ImGui::SliderScalarN

; 2775 : {

$LN7:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 2776 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 2777 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN5@SliderScal

; 2778 : 		return false;

	xor	al, al
	jmp	$LN1@SliderScal
$LN5@SliderScal:

; 2779 : 
; 2780 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2781 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 2782 : 	BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 2783 : 	PushID(label);

	mov	rcx, QWORD PTR label$[rsp]
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 2784 : 	PushMultiItemsWidths(components);

	xorps	xmm1, xmm1
	mov	ecx, DWORD PTR components$[rsp]
	call	?PushMultiItemsWidths@ImGui@@YAXHM@Z	; ImGui::PushMultiItemsWidths

; 2785 : 	size_t type_size = GDataTypeInfo[data_type].Size;

	movsxd	rax, DWORD PTR data_type$[rsp]
	imul	rax, rax, 72				; 00000048H
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR type_size$[rsp], rax

; 2786 : 	for (int i = 0; i < components; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@SliderScal
$LN2@SliderScal:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@SliderScal:
	mov	eax, DWORD PTR components$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN3@SliderScal

; 2787 : 	{
; 2788 : 		PushID(i);

	mov	ecx, DWORD PTR i$1[rsp]
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 2789 : 		value_changed |= SliderScalar("", data_type, v, v_min, v_max, format, power);

	movzx	eax, BYTE PTR value_changed$[rsp]
	mov	DWORD PTR tv78[rsp], eax
	mov	BYTE PTR [rsp+56], 1
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	rcx, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR v_min$[rsp]
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20M_N@Z ; ImGui::SliderScalar
	movzx	eax, al
	mov	ecx, DWORD PTR tv78[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR value_changed$[rsp], al

; 2790 : 		SameLine(0, g.Style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5548]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 2791 : 		PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 2792 : 		PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 2793 : 		v = (void*)((char*)v + type_size);

	mov	rax, QWORD PTR type_size$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v$[rsp], rax

; 2794 : 	}

	jmp	$LN2@SliderScal
$LN3@SliderScal:

; 2795 : 	PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 2796 : 
; 2797 : 	TextUnformatted(label, FindRenderedTextEnd(label));

	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	rdx, rax
	mov	rcx, QWORD PTR label$[rsp]
	call	?TextUnformatted@ImGui@@YAXPEBD0@Z	; ImGui::TextUnformatted

; 2798 : 	EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 2799 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
$LN1@SliderScal:

; 2800 : }

	add	rsp, 120				; 00000078H
	ret	0
?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z ENDP	; ImGui::SliderScalarN
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
id$ = 80
tab_focus_requested$ = 84
start_text_input$ = 85
value_changed$ = 86
frame_bb$ = 88
hovered$ = 104
g$ = 112
window$ = 120
grab_bb$ = 128
tv140 = 144
tv230 = 148
tv231 = 152
style$ = 160
label_size$ = 168
w$ = 176
tv422 = 180
tv512 = 184
tv576 = 188
tv606 = 192
tv637 = 196
tv297 = 200
tv311 = 208
tv358 = 216
tv356 = 224
tv362 = 232
$T1 = 240
tv395 = 248
tv393 = 256
$T2 = 264
tv416 = 272
tv414 = 280
$T3 = 288
$T4 = 296
$T5 = 304
tv453 = 312
tv451 = 320
$T6 = 328
tv474 = 336
tv472 = 344
$T7 = 352
$T8 = 360
$T9 = 368
tv548 = 376
tv546 = 384
tv569 = 392
tv567 = 400
tv574 = 408
tv572 = 416
tv578 = 424
tv604 = 432
tv608 = 440
tv635 = 448
tv639 = 456
frame_col$ = 464
tv251 = 472
total_bb$ = 480
$T10 = 496
$T11 = 504
$T12 = 512
$T13 = 520
$T14 = 528
$T15 = 536
$T16 = 544
$T17 = 552
$T18 = 560
$T19 = 568
$T20 = 576
$T21 = 584
$T22 = 592
$T23 = 600
$T24 = 608
$T25 = 616
$T26 = 624
$T27 = 632
$T28 = 640
$T29 = 648
$T30 = 656
$T31 = 664
$T32 = 672
$T33 = 680
$T34 = 688
$T35 = 696
$T36 = 704
$T37 = 712
$T38 = 720
$T39 = 736
$T40 = 752
$T41 = 768
$T42 = 784
$T43 = 800
value_buf_end$ = 816
value_buf$ = 848
__$ArrayPad$ = 1040
label$ = 1072
data_type$ = 1080
v$ = 1088
v_min$ = 1096
v_max$ = 1104
format$ = 1112
power$ = 1120
decvalue$ = 1128
?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20M_N@Z PROC	; ImGui::SliderScalar

; 2676 : {

$LN26:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1064				; 00000428H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2677 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 2678 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN5@SliderScal

; 2679 : 		return false;

	xor	al, al
	jmp	$LN1@SliderScal
$LN5@SliderScal:

; 2680 : 
; 2681 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2682 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 2683 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 2684 : 	const float w = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movss	DWORD PTR w$[rsp], xmm0

; 2685 : 
; 2686 : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	npad	1

; 2687 : 	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR w$[rsp]
	lea	rcx, QWORD PTR $T35[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T36[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 2688 : 	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN20@SliderScal
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	addss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR tv140[rsp], xmm0
	jmp	SHORT $LN21@SliderScal
$LN20@SliderScal:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv140[rsp], xmm0
$LN21@SliderScal:
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR tv140[rsp]
	lea	rcx, QWORD PTR $T37[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	lea	rcx, QWORD PTR $T10[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 2689 : 
; 2690 : 	ItemSize(total_bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 2691 : 	if (!ItemAdd(total_bb, id, &frame_bb))

	lea	r8, QWORD PTR frame_bb$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@SliderScal

; 2692 : 		return false;

	xor	al, al
	jmp	$LN1@SliderScal
$LN6@SliderScal:

; 2693 : 
; 2694 : 	// Default format string when passing NULL
; 2695 : 	// Patch old "%.0f" format string to use "%d", read function comments for more details.
; 2696 : 	IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
; 2697 : 	if (format == NULL)

	cmp	QWORD PTR format$[rsp], 0
	jne	SHORT $LN7@SliderScal

; 2698 : 		format = GDataTypeInfo[data_type].PrintFmt.c_str();

	movsxd	rax, DWORD PTR data_type$[rsp]
	imul	rax, rax, 72				; 00000048H
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, rax
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR format$[rsp], rax
	jmp	SHORT $LN8@SliderScal
$LN7@SliderScal:

; 2699 : 	else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)

	cmp	DWORD PTR data_type$[rsp], 0
	jne	SHORT $LN9@SliderScal
	lea	rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	mov	rcx, QWORD PTR format$[rsp]
	call	strcmp
	test	eax, eax
	je	SHORT $LN9@SliderScal

; 2700 : 		format = PatchFormatStringFloatToInt(format);

	mov	rcx, QWORD PTR format$[rsp]
	call	?PatchFormatStringFloatToInt@@YAPEBDPEBD@Z ; PatchFormatStringFloatToInt
	mov	QWORD PTR format$[rsp], rax
$LN9@SliderScal:
$LN8@SliderScal:

; 2701 : 
; 2702 : 	// Tabbing or CTRL-clicking on Slider turns it into an input box
; 2703 : 	bool start_text_input = false;

	mov	BYTE PTR start_text_input$[rsp], 0

; 2704 : 	const bool tab_focus_requested = FocusableItemRegister(window, id);

	mov	r8b, 1
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusableItemRegister@ImGui@@YA_NPEAUImGuiWindow@@I_N@Z ; ImGui::FocusableItemRegister
	mov	BYTE PTR tab_focus_requested$[rsp], al

; 2705 : 	const bool hovered = ItemHoverable(frame_bb, id);

	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z ; ImGui::ItemHoverable
	mov	BYTE PTR hovered$[rsp], al

; 2706 : 	if (tab_focus_requested || (hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))

	movzx	eax, BYTE PTR tab_focus_requested$[rsp]
	test	eax, eax
	jne	SHORT $LN11@SliderScal
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN12@SliderScal
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1016]
	test	eax, eax
	jne	SHORT $LN11@SliderScal
$LN12@SliderScal:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7044], ecx
	je	SHORT $LN11@SliderScal
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7048], ecx
	jne	$LN10@SliderScal
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+11664], ecx
	je	SHORT $LN10@SliderScal
$LN11@SliderScal:

; 2707 : 	{
; 2708 : 		SetActiveID(id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 2709 : 		SetFocusID(id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetFocusID

; 2710 : 		FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 2711 : 		g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6804], 12

; 2712 : 		if (tab_focus_requested || g.IO.KeyCtrl || g.NavInputId == id)

	movzx	eax, BYTE PTR tab_focus_requested$[rsp]
	test	eax, eax
	jne	SHORT $LN14@SliderScal
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	jne	SHORT $LN14@SliderScal
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7048], ecx
	jne	SHORT $LN13@SliderScal
$LN14@SliderScal:

; 2713 : 		{
; 2714 : 			start_text_input = true;

	mov	BYTE PTR start_text_input$[rsp], 1

; 2715 : 			g.ScalarAsInputTextId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+11664], 0
$LN13@SliderScal:
$LN10@SliderScal:

; 2716 : 		}
; 2717 : 	}
; 2718 : 	if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))

	movzx	eax, BYTE PTR start_text_input$[rsp]
	test	eax, eax
	jne	SHORT $LN16@SliderScal
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN15@SliderScal
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+11664], ecx
	jne	SHORT $LN15@SliderScal
$LN16@SliderScal:

; 2719 : 	{
; 2720 : 		window->DC.CursorPos = frame_bb.Min;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR frame_bb$[rsp]
	mov	QWORD PTR [rax+340], rcx

; 2721 : 		FocusableItemUnregister(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusableItemUnregister@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusableItemUnregister

; 2722 : 		return InputScalarAsWidgetReplacement(frame_bb, id, label, data_type, v, format);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR v$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR data_type$[rsp]
	mov	r8, QWORD PTR label$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?InputScalarAsWidgetReplacement@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1@Z ; ImGui::InputScalarAsWidgetReplacement
	jmp	$LN1@SliderScal
$LN15@SliderScal:

; 2723 : 	}
; 2724 : 
; 2725 : 	// Draw frame
; 2726 : 	const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN24@SliderScal
	mov	DWORD PTR tv231[rsp], 9
	jmp	SHORT $LN25@SliderScal
$LN24@SliderScal:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6696], ecx
	jne	SHORT $LN22@SliderScal
	mov	DWORD PTR tv230[rsp], 8
	jmp	SHORT $LN23@SliderScal
$LN22@SliderScal:
	mov	DWORD PTR tv230[rsp], 7
$LN23@SliderScal:
	mov	eax, DWORD PTR tv230[rsp]
	mov	DWORD PTR tv231[rsp], eax
$LN25@SliderScal:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv231[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR frame_col$[rsp], eax

; 2727 : 	//RenderNavHighlight(frame_bb, id);
; 2728 : 	//RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);
; 2729 : 
; 2730 : 	// Slider behavior
; 2731 : 	ImRect grab_bb;

	lea	rcx, QWORD PTR grab_bb$[rsp]
	call	??0ImRect@@QEAA@XZ			; ImRect::ImRect

; 2732 : 	const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_None, &grab_bb);

	lea	rax, QWORD PTR grab_bb$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	DWORD PTR [rsp+64], 0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?SliderBehavior@ImGui@@YA_NAEBUImRect@@IHPEAXPEBX2PEBDMHPEAU2@@Z ; ImGui::SliderBehavior
	mov	BYTE PTR value_changed$[rsp], al

; 2733 : 	if (value_changed)

	movzx	eax, BYTE PTR value_changed$[rsp]
	test	eax, eax
	je	SHORT $LN17@SliderScal

; 2734 : 		MarkItemEdited(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN17@SliderScal:

; 2735 : 
; 2736 : 	// Render grab
; 2737 : 	//window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);
; 2738 : 
; 2739 : 	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
; 2740 : 	//char value_buf[64];
; 2741 : 	//const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
; 2742 : 	//RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));
; 2743 : 
; 2744 : 	//if (label_size.x > 0.0f)
; 2745 : 	//    RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);
; 2746 : 
; 2747 : 	//IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);
; 2748 : 	char value_buf[3][64];
; 2749 : 	const char* value_buf_end[3];
; 2750 : 	value_buf_end[0] = value_buf[0] + DataTypeFormatString(value_buf[0], IM_ARRAYSIZE(value_buf[0]), data_type, v, format);

	mov	eax, 64					; 00000040H
	imul	rax, rax, 0
	lea	rax, QWORD PTR value_buf$[rsp+rax]
	mov	QWORD PTR tv251[rsp], rax
	mov	ecx, 64					; 00000040H
	imul	rcx, rcx, 0
	lea	rcx, QWORD PTR value_buf$[rsp+rcx]
	mov	rdx, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9, QWORD PTR v$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, 64					; 00000040H
	call	?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z ; DataTypeFormatString
	cdqe
	mov	rcx, QWORD PTR tv251[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR value_buf_end$[rsp+rcx], rax

; 2751 : 	value_buf_end[1] = value_buf[1] + DataTypeFormatString(value_buf[1], IM_ARRAYSIZE(value_buf[1]), data_type, v_min, format);

	mov	eax, 64					; 00000040H
	imul	rax, rax, 1
	lea	rax, QWORD PTR value_buf$[rsp+rax]
	mov	QWORD PTR tv297[rsp], rax
	mov	ecx, 64					; 00000040H
	imul	rcx, rcx, 1
	lea	rcx, QWORD PTR value_buf$[rsp+rcx]
	mov	rdx, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9, QWORD PTR v_min$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, 64					; 00000040H
	call	?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z ; DataTypeFormatString
	cdqe
	mov	rcx, QWORD PTR tv297[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	QWORD PTR value_buf_end$[rsp+rcx], rax

; 2752 : 	value_buf_end[2] = value_buf[2] + DataTypeFormatString(value_buf[2], IM_ARRAYSIZE(value_buf[2]), data_type, v_max, format);

	mov	eax, 64					; 00000040H
	imul	rax, rax, 2
	lea	rax, QWORD PTR value_buf$[rsp+rax]
	mov	QWORD PTR tv311[rsp], rax
	mov	ecx, 64					; 00000040H
	imul	rcx, rcx, 2
	lea	rcx, QWORD PTR value_buf$[rsp+rcx]
	mov	rdx, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+32], rdx
	mov	r9, QWORD PTR v_max$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, 64					; 00000040H
	call	?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z ; DataTypeFormatString
	cdqe
	mov	rcx, QWORD PTR tv311[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	QWORD PTR value_buf_end$[rsp+rcx], rax

; 2753 : 
; 2754 : 	ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(210.f / 255.f, 200.f / 255.f, 120.f / 255.f, 1.f));

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ef0f0f1
	movss	xmm2, DWORD PTR __real@3f48c8c9
	movss	xmm1, DWORD PTR __real@3f52d2d3
	lea	rcx, QWORD PTR $T38[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rdx, rax
	xor	ecx, ecx
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor
	npad	1

; 2755 : 	RenderTextOverlay(ImVec2(frame_bb.Max.x - grab_bb.Max.x + grab_bb.Min.x - 6.f, frame_bb.Max.y - ((frame_bb.Max.y - frame_bb.Min.y) / 2.5f)) + ImVec2(16, -9), value_buf[0], value_buf_end[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rax, QWORD PTR value_buf_end$[rsp+rax]
	mov	QWORD PTR tv362[rsp], rax
	movss	xmm2, DWORD PTR __real@c1100000
	movss	xmm1, DWORD PTR __real@41800000
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv358[rsp], rax
	movss	xmm0, DWORD PTR frame_bb$[rsp+12]
	subss	xmm0, DWORD PTR frame_bb$[rsp+4]
	divss	xmm0, DWORD PTR __real@40200000
	movss	xmm1, DWORD PTR frame_bb$[rsp+12]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR frame_bb$[rsp+8]
	subss	xmm1, DWORD PTR grab_bb$[rsp+8]
	addss	xmm1, DWORD PTR grab_bb$[rsp]
	subss	xmm1, DWORD PTR __real@40c00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv356[rsp], rax
	mov	r8, QWORD PTR tv358[rsp]
	mov	rdx, QWORD PTR tv356[rsp]
	lea	rcx, QWORD PTR $T13[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T1[rsp], rax
	mov	eax, 64					; 00000040H
	imul	rax, rax, 0
	lea	rax, QWORD PTR value_buf$[rsp+rax]
	mov	r9b, 1
	mov	r8, QWORD PTR tv362[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	?RenderTextOverlay@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderTextOverlay
	npad	1

; 2756 : 	ImGui::PopStyleColor();

	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	npad	1

; 2757 : 
; 2758 : 	RenderFrame(ImVec2(frame_bb.Min.x, frame_bb.Min.y + ((frame_bb.Max.y - frame_bb.Min.y) / 2.f) + 3) - ImVec2(0, 2), ImVec2(frame_bb.Max.x - grab_bb.Max.x + grab_bb.Min.x, frame_bb.Max.y - ((frame_bb.Max.y - frame_bb.Min.y) / 2.5f)) + ImVec2(0, 2), ImColor(168, 168, 168), true, 2.f);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 168				; 000000a8H
	mov	r8d, 168				; 000000a8H
	mov	edx, 168				; 000000a8H
	lea	rcx, QWORD PTR $T39[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	rcx, rax
	call	??BImColor@@QEBAIXZ			; ImColor::operator unsigned int
	mov	DWORD PTR tv422[rsp], eax
	movss	xmm2, DWORD PTR __real@40000000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv395[rsp], rax
	movss	xmm0, DWORD PTR frame_bb$[rsp+12]
	subss	xmm0, DWORD PTR frame_bb$[rsp+4]
	divss	xmm0, DWORD PTR __real@40200000
	movss	xmm1, DWORD PTR frame_bb$[rsp+12]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR frame_bb$[rsp+8]
	subss	xmm1, DWORD PTR grab_bb$[rsp+8]
	addss	xmm1, DWORD PTR grab_bb$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv393[rsp], rax
	mov	r8, QWORD PTR tv395[rsp]
	mov	rdx, QWORD PTR tv393[rsp]
	lea	rcx, QWORD PTR $T16[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T4[rsp], rax
	movss	xmm2, DWORD PTR __real@40000000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv416[rsp], rax
	movss	xmm0, DWORD PTR frame_bb$[rsp+12]
	subss	xmm0, DWORD PTR frame_bb$[rsp+4]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR frame_bb$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@40400000
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv414[rsp], rax
	mov	r8, QWORD PTR tv416[rsp]
	mov	rdx, QWORD PTR tv414[rsp]
	lea	rcx, QWORD PTR $T19[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T5[rsp], rax
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	r8d, DWORD PTR tv422[rsp]
	mov	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR $T5[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	npad	1

; 2759 : 	RenderFrame(ImVec2(frame_bb.Min.x, frame_bb.Min.y + ((frame_bb.Max.y - frame_bb.Min.y) / 2.f) + 3) - ImVec2(0, 2), ImVec2(grab_bb.Min.x, frame_bb.Max.y - ((frame_bb.Max.y - frame_bb.Min.y) / 2.5f)) + ImVec2(0, 2), ImColor(210, 200, 120), true, 2.f);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 120				; 00000078H
	mov	r8d, 200				; 000000c8H
	mov	edx, 210				; 000000d2H
	lea	rcx, QWORD PTR $T40[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	rcx, rax
	call	??BImColor@@QEBAIXZ			; ImColor::operator unsigned int
	mov	DWORD PTR tv512[rsp], eax
	movss	xmm2, DWORD PTR __real@40000000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv453[rsp], rax
	movss	xmm0, DWORD PTR frame_bb$[rsp+12]
	subss	xmm0, DWORD PTR frame_bb$[rsp+4]
	divss	xmm0, DWORD PTR __real@40200000
	movss	xmm1, DWORD PTR frame_bb$[rsp+12]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR grab_bb$[rsp]
	lea	rcx, QWORD PTR $T21[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv451[rsp], rax
	mov	r8, QWORD PTR tv453[rsp]
	mov	rdx, QWORD PTR tv451[rsp]
	lea	rcx, QWORD PTR $T22[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T6[rsp], rax
	mov	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR $T8[rsp], rax
	movss	xmm2, DWORD PTR __real@40000000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv474[rsp], rax
	movss	xmm0, DWORD PTR frame_bb$[rsp+12]
	subss	xmm0, DWORD PTR frame_bb$[rsp+4]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR frame_bb$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@40400000
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv472[rsp], rax
	mov	r8, QWORD PTR tv474[rsp]
	mov	rdx, QWORD PTR tv472[rsp]
	lea	rcx, QWORD PTR $T25[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T7[rsp], rax
	mov	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR $T9[rsp], rax
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	r8d, DWORD PTR tv512[rsp]
	mov	rdx, QWORD PTR $T8[rsp]
	mov	rcx, QWORD PTR $T9[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	npad	1

; 2760 : 	window->DrawList->AddRect(ImVec2(frame_bb.Min.x, frame_bb.Min.y + ((frame_bb.Max.y - frame_bb.Min.y) / 2.f) + 3) - ImVec2(0, 2), ImVec2(frame_bb.Max.x - grab_bb.Max.x + grab_bb.Min.x, frame_bb.Max.y - ((frame_bb.Max.y - frame_bb.Min.y) / 2.5f)) + ImVec2(0, 2), ImColor(150, 150, 150, 255));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv578[rsp], rax
	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 150				; 00000096H
	mov	r8d, 150				; 00000096H
	mov	edx, 150				; 00000096H
	lea	rcx, QWORD PTR $T41[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	rcx, rax
	call	??BImColor@@QEBAIXZ			; ImColor::operator unsigned int
	mov	DWORD PTR tv576[rsp], eax
	movss	xmm2, DWORD PTR __real@40000000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv548[rsp], rax
	movss	xmm0, DWORD PTR frame_bb$[rsp+12]
	subss	xmm0, DWORD PTR frame_bb$[rsp+4]
	divss	xmm0, DWORD PTR __real@40200000
	movss	xmm1, DWORD PTR frame_bb$[rsp+12]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR frame_bb$[rsp+8]
	subss	xmm1, DWORD PTR grab_bb$[rsp+8]
	addss	xmm1, DWORD PTR grab_bb$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T27[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv546[rsp], rax
	mov	r8, QWORD PTR tv548[rsp]
	mov	rdx, QWORD PTR tv546[rsp]
	lea	rcx, QWORD PTR $T28[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv574[rsp], rax
	movss	xmm2, DWORD PTR __real@40000000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T29[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv569[rsp], rax
	movss	xmm0, DWORD PTR frame_bb$[rsp+12]
	subss	xmm0, DWORD PTR frame_bb$[rsp+4]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR frame_bb$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@40400000
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR $T30[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv567[rsp], rax
	mov	r8, QWORD PTR tv569[rsp]
	mov	rdx, QWORD PTR tv567[rsp]
	lea	rcx, QWORD PTR $T31[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv572[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv576[rsp]
	mov	r8, QWORD PTR tv574[rsp]
	mov	rdx, QWORD PTR tv572[rsp]
	mov	rcx, QWORD PTR tv578[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1

; 2761 : 
; 2762 : 	window->DrawList->AddCircleFilled(ImVec2(grab_bb.Min.x, grab_bb.Min.y + ((grab_bb.Max.y - grab_bb.Min.y) / 2.f) + 2.5), 5.f, ImColor(255, 255, 255, 255), 64);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv608[rsp], rax
	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 255				; 000000ffH
	mov	r8d, 255				; 000000ffH
	mov	edx, 255				; 000000ffH
	lea	rcx, QWORD PTR $T42[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	rcx, rax
	call	??BImColor@@QEBAIXZ			; ImColor::operator unsigned int
	mov	DWORD PTR tv606[rsp], eax
	movss	xmm0, DWORD PTR grab_bb$[rsp+12]
	subss	xmm0, DWORD PTR grab_bb$[rsp+4]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_bb$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@4004000000000000
	cvtsd2ss xmm0, xmm0
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR grab_bb$[rsp]
	lea	rcx, QWORD PTR $T32[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv604[rsp], rax
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	mov	r9d, DWORD PTR tv606[rsp]
	movss	xmm2, DWORD PTR __real@40a00000
	mov	rdx, QWORD PTR tv604[rsp]
	mov	rcx, QWORD PTR tv608[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 2763 : 	window->DrawList->AddCircle(ImVec2(grab_bb.Min.x, grab_bb.Min.y + ((grab_bb.Max.y - grab_bb.Min.y) / 2.f) + 2.5), 5.f, ImColor(100, 100, 100, 255), 64);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv639[rsp], rax
	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 100				; 00000064H
	mov	r8d, 100				; 00000064H
	mov	edx, 100				; 00000064H
	lea	rcx, QWORD PTR $T43[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	rcx, rax
	call	??BImColor@@QEBAIXZ			; ImColor::operator unsigned int
	mov	DWORD PTR tv637[rsp], eax
	movss	xmm0, DWORD PTR grab_bb$[rsp+12]
	subss	xmm0, DWORD PTR grab_bb$[rsp+4]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR grab_bb$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@4004000000000000
	cvtsd2ss xmm0, xmm0
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR grab_bb$[rsp]
	lea	rcx, QWORD PTR $T33[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv635[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	mov	r9d, DWORD PTR tv637[rsp]
	movss	xmm2, DWORD PTR __real@40a00000
	mov	rdx, QWORD PTR tv635[rsp]
	mov	rcx, QWORD PTR tv639[rsp]
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
	npad	1

; 2764 : 
; 2765 : 	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value. 
; 2766 : 	if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN18@SliderScal

; 2767 : 		RenderText(ImVec2(frame_bb.Max.x - grab_bb.Max.x + grab_bb.Min.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y + 3.8), label);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR frame_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@400e666666666666
	cvtsd2ss xmm0, xmm0
	movss	xmm1, DWORD PTR frame_bb$[rsp+8]
	subss	xmm1, DWORD PTR grab_bb$[rsp+8]
	addss	xmm1, DWORD PTR grab_bb$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	addss	xmm1, DWORD PTR [rax+76]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T34[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN18@SliderScal:
$LN4@SliderScal:

; 2768 : 
; 2769 : 	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);

	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@SliderScal

; 2770 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
$LN1@SliderScal:

; 2771 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1064				; 00000428H
	ret	0
?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20M_N@Z ENDP	; ImGui::SliderScalar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
v_min$ = 96
v_max$ = 104
format$ = 112
?SliderInt4@ImGui@@YA_NPEBDQEAHHH0@Z PROC		; ImGui::SliderInt4

; 2848 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2849 : 	return SliderScalarN(label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 4
	mov	r8, QWORD PTR v$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z ; ImGui::SliderScalarN

; 2850 : }

	add	rsp, 72					; 00000048H
	ret	0
?SliderInt4@ImGui@@YA_NPEBDQEAHHH0@Z ENDP		; ImGui::SliderInt4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
v_min$ = 96
v_max$ = 104
format$ = 112
?SliderInt3@ImGui@@YA_NPEBDQEAHHH0@Z PROC		; ImGui::SliderInt3

; 2843 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2844 : 	return SliderScalarN(label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 3
	mov	r8, QWORD PTR v$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z ; ImGui::SliderScalarN

; 2845 : }

	add	rsp, 72					; 00000048H
	ret	0
?SliderInt3@ImGui@@YA_NPEBDQEAHHH0@Z ENDP		; ImGui::SliderInt3
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
v_min$ = 96
v_max$ = 104
format$ = 112
?SliderInt2@ImGui@@YA_NPEBDQEAHHH0@Z PROC		; ImGui::SliderInt2

; 2838 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2839 : 	return SliderScalarN(label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 2
	mov	r8, QWORD PTR v$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z ; ImGui::SliderScalarN

; 2840 : }

	add	rsp, 72					; 00000048H
	ret	0
?SliderInt2@ImGui@@YA_NPEBDQEAHHH0@Z ENDP		; ImGui::SliderInt2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
v_min$ = 96
v_max$ = 104
format$ = 112
decvalue$ = 120
?SliderInt@ImGui@@YA_NPEBDPEAHHH0_N@Z PROC		; ImGui::SliderInt

; 2833 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2834 : 	return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format, decvalue);

	movzx	eax, BYTE PTR decvalue$[rsp]
	cvtsi2ss xmm0, eax
	mov	BYTE PTR [rsp+56], 1
	movss	DWORD PTR [rsp+48], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR v_min$[rsp]
	mov	r8, QWORD PTR v$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20M_N@Z ; ImGui::SliderScalar

; 2835 : }

	add	rsp, 72					; 00000048H
	ret	0
?SliderInt@ImGui@@YA_NPEBDPEAHHH0_N@Z ENDP		; ImGui::SliderInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 64
v_deg$ = 68
label$ = 96
v_rad$ = 104
v_degrees_min$ = 112
v_degrees_max$ = 120
format$ = 128
?SliderAngle@ImGui@@YA_NPEBDPEAMMM0@Z PROC		; ImGui::SliderAngle

; 2823 : {

$LN4:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2824 : 	if (format == NULL)

	cmp	QWORD PTR format$[rsp], 0
	jne	SHORT $LN2@SliderAngl

; 2825 : 		format = ("%.0f deg");

	lea	rax, OFFSET FLAT:??_C@_08FKIHKODH@?$CF?40f?5deg@
	mov	QWORD PTR format$[rsp], rax
$LN2@SliderAngl:

; 2826 : 	float v_deg = (*v_rad) * 360.0f / (2 * IM_PI);

	mov	rax, QWORD PTR v_rad$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR __real@43b40000
	divss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR v_deg$[rsp], xmm0

; 2827 : 	bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, 1.0f);

	mov	BYTE PTR [rsp+48], 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+40], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movss	xmm3, DWORD PTR v_degrees_max$[rsp]
	movss	xmm2, DWORD PTR v_degrees_min$[rsp]
	lea	rdx, QWORD PTR v_deg$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?SliderFloat@ImGui@@YA_NPEBDPEAMMM0M_N@Z ; ImGui::SliderFloat
	mov	BYTE PTR value_changed$[rsp], al

; 2828 : 	*v_rad = v_deg * (2 * IM_PI) / 360.0f;

	movss	xmm0, DWORD PTR v_deg$[rsp]
	mulss	xmm0, DWORD PTR __real@40c90fdb
	divss	xmm0, DWORD PTR __real@43b40000
	mov	rax, QWORD PTR v_rad$[rsp]
	movss	DWORD PTR [rax], xmm0

; 2829 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]

; 2830 : }

	add	rsp, 88					; 00000058H
	ret	0
?SliderAngle@ImGui@@YA_NPEBDPEAMMM0@Z ENDP		; ImGui::SliderAngle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
v_min$ = 96
v_max$ = 104
format$ = 112
power$ = 120
?SliderFloat4@ImGui@@YA_NPEBDQEAMMM0M@Z PROC		; ImGui::SliderFloat4

; 2818 : {

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2819 : 	return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power);

	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 4
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z ; ImGui::SliderScalarN

; 2820 : }

	add	rsp, 72					; 00000048H
	ret	0
?SliderFloat4@ImGui@@YA_NPEBDQEAMMM0M@Z ENDP		; ImGui::SliderFloat4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
v_min$ = 96
v_max$ = 104
format$ = 112
power$ = 120
?SliderFloat3@ImGui@@YA_NPEBDQEAMMM0M@Z PROC		; ImGui::SliderFloat3

; 2813 : {

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2814 : 	return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power);

	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 3
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z ; ImGui::SliderScalarN

; 2815 : }

	add	rsp, 72					; 00000048H
	ret	0
?SliderFloat3@ImGui@@YA_NPEBDQEAMMM0M@Z ENDP		; ImGui::SliderFloat3
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
v_min$ = 96
v_max$ = 104
format$ = 112
power$ = 120
?SliderFloat2@ImGui@@YA_NPEBDQEAMMM0M@Z PROC		; ImGui::SliderFloat2

; 2808 : {

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2809 : 	return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power);

	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 2
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z ; ImGui::SliderScalarN

; 2810 : }

	add	rsp, 72					; 00000048H
	ret	0
?SliderFloat2@ImGui@@YA_NPEBDQEAMMM0M@Z ENDP		; ImGui::SliderFloat2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
v_min$ = 96
v_max$ = 104
format$ = 112
power$ = 120
decvalue$ = 128
?SliderFloat@ImGui@@YA_NPEBDPEAMMM0M_N@Z PROC		; ImGui::SliderFloat

; 2803 : {

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2804 : 	return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, power, decvalue);

	movzx	eax, BYTE PTR decvalue$[rsp]
	mov	BYTE PTR [rsp+56], al
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR v_min$[rsp]
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20M_N@Z ; ImGui::SliderScalar

; 2805 : }

	add	rsp, 72					; 00000048H
	ret	0
?SliderFloat@ImGui@@YA_NPEBDPEAMMM0M_N@Z ENDP		; ImGui::SliderFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 64
i$1 = 68
tv78 = 72
window$ = 80
g$ = 88
type_size$ = 96
label$ = 128
data_type$ = 136
v$ = 144
components$ = 152
v_speed$ = 160
v_min$ = 168
v_max$ = 176
format$ = 184
power$ = 192
?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z PROC	; ImGui::DragScalarN

; 2288 : {

$LN7:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 2289 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 2290 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN5@DragScalar

; 2291 : 		return false;

	xor	al, al
	jmp	$LN1@DragScalar
$LN5@DragScalar:

; 2292 : 
; 2293 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2294 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 2295 : 	BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 2296 : 	PushID(label);

	mov	rcx, QWORD PTR label$[rsp]
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 2297 : 	PushMultiItemsWidths(components);

	xorps	xmm1, xmm1
	mov	ecx, DWORD PTR components$[rsp]
	call	?PushMultiItemsWidths@ImGui@@YAXHM@Z	; ImGui::PushMultiItemsWidths

; 2298 : 	size_t type_size = GDataTypeInfo[data_type].Size;

	movsxd	rax, DWORD PTR data_type$[rsp]
	imul	rax, rax, 72				; 00000048H
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR type_size$[rsp], rax

; 2299 : 	for (int i = 0; i < components; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@DragScalar
$LN2@DragScalar:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@DragScalar:
	mov	eax, DWORD PTR components$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN3@DragScalar

; 2300 : 	{
; 2301 : 		PushID(i);

	mov	ecx, DWORD PTR i$1[rsp]
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 2302 : 		value_changed |= DragScalar("", data_type, v, v_speed, v_min, v_max, format, power);

	movzx	eax, BYTE PTR value_changed$[rsp]
	mov	DWORD PTR tv78[rsp], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rcx, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	movss	xmm3, DWORD PTR v_speed$[rsp]
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20M@Z ; ImGui::DragScalar
	movzx	eax, al
	mov	ecx, DWORD PTR tv78[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR value_changed$[rsp], al

; 2303 : 		SameLine(0, g.Style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5548]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 2304 : 		PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 2305 : 		PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 2306 : 		v = (void*)((char*)v + type_size);

	mov	rax, QWORD PTR type_size$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v$[rsp], rax

; 2307 : 	}

	jmp	$LN2@DragScalar
$LN3@DragScalar:

; 2308 : 	PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 2309 : 
; 2310 : 	TextUnformatted(label, FindRenderedTextEnd(label));

	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	rdx, rax
	mov	rcx, QWORD PTR label$[rsp]
	call	?TextUnformatted@ImGui@@YAXPEBD0@Z	; ImGui::TextUnformatted

; 2311 : 	EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 2312 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
$LN1@DragScalar:

; 2313 : }

	add	rsp, 120				; 00000078H
	ret	0
?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z ENDP	; ImGui::DragScalarN
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
id$ = 80
tab_focus_requested$ = 84
start_text_input$ = 85
value_changed$ = 86
hovered$ = 87
g$ = 88
window$ = 96
style$ = 104
frame_bb$ = 112
tv141 = 128
tv256 = 132
tv257 = 136
label_size$ = 144
w$ = 152
frame_col$ = 156
value_buf_end$ = 160
total_bb$ = 168
$T1 = 184
$T2 = 192
$T3 = 200
$T4 = 208
$T5 = 216
$T6 = 224
value_buf$ = 240
__$ArrayPad$ = 304
label$ = 336
data_type$ = 344
v$ = 352
v_speed$ = 360
v_min$ = 368
v_max$ = 376
format$ = 384
power$ = 392
?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20M@Z PROC		; ImGui::DragScalar

; 2212 : {

$LN28:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 328				; 00000148H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2213 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 2214 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN5@DragScalar

; 2215 : 		return false;

	xor	al, al
	jmp	$LN1@DragScalar
$LN5@DragScalar:

; 2216 : 
; 2217 : 	if (power != 1.0f)

	movss	xmm0, DWORD PTR power$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000

; 2218 : 		IM_ASSERT(v_min != NULL && v_max != NULL); // When using a power curve the drag needs to have known bounds
; 2219 : 
; 2220 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2221 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 2222 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 2223 : 	const float w = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movss	DWORD PTR w$[rsp], xmm0

; 2224 : 
; 2225 : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	npad	1

; 2226 : 	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR w$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 2227 : 	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN21@DragScalar
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	addss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR tv141[rsp], xmm0
	jmp	SHORT $LN22@DragScalar
$LN21@DragScalar:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv141[rsp], xmm0
$LN22@DragScalar:
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR tv141[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 2228 : 
; 2229 : 	ItemSize(total_bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 2230 : 	if (!ItemAdd(total_bb, id, &frame_bb))

	lea	r8, QWORD PTR frame_bb$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@DragScalar

; 2231 : 		return false;

	xor	al, al
	jmp	$LN1@DragScalar
$LN7@DragScalar:

; 2232 : 
; 2233 : 	const bool hovered = ItemHoverable(frame_bb, id);

	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z ; ImGui::ItemHoverable
	mov	BYTE PTR hovered$[rsp], al

; 2234 : 
; 2235 : 	// Default format string when passing NULL
; 2236 : 	// Patch old "%.0f" format string to use "%d", read function comments for more details.
; 2237 : 	IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
; 2238 : 	if (format == NULL)

	cmp	QWORD PTR format$[rsp], 0
	jne	SHORT $LN8@DragScalar

; 2239 : 		format = GDataTypeInfo[data_type].PrintFmt.c_str();

	movsxd	rax, DWORD PTR data_type$[rsp]
	imul	rax, rax, 72				; 00000048H
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	rcx, rax
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR format$[rsp], rax
	jmp	SHORT $LN9@DragScalar
$LN8@DragScalar:

; 2240 : 	else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)

	cmp	DWORD PTR data_type$[rsp], 0
	jne	SHORT $LN10@DragScalar
	lea	rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	mov	rcx, QWORD PTR format$[rsp]
	call	strcmp
	test	eax, eax
	je	SHORT $LN10@DragScalar

; 2241 : 		format = PatchFormatStringFloatToInt(format);

	mov	rcx, QWORD PTR format$[rsp]
	call	?PatchFormatStringFloatToInt@@YAPEBDPEBD@Z ; PatchFormatStringFloatToInt
	mov	QWORD PTR format$[rsp], rax
$LN10@DragScalar:
$LN9@DragScalar:

; 2242 : 
; 2243 : 	// Tabbing or CTRL-clicking on Drag turns it into an input box
; 2244 : 	bool start_text_input = false;

	mov	BYTE PTR start_text_input$[rsp], 0

; 2245 : 	const bool tab_focus_requested = FocusableItemRegister(window, id);

	mov	r8b, 1
	mov	edx, DWORD PTR id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusableItemRegister@ImGui@@YA_NPEAUImGuiWindow@@I_N@Z ; ImGui::FocusableItemRegister
	mov	BYTE PTR tab_focus_requested$[rsp], al

; 2246 : 	if (tab_focus_requested || (hovered && (g.IO.MouseClicked[0] || g.IO.MouseDoubleClicked[0])) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))

	movzx	eax, BYTE PTR tab_focus_requested$[rsp]
	test	eax, eax
	jne	SHORT $LN12@DragScalar
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN13@DragScalar
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1016]
	test	eax, eax
	jne	SHORT $LN12@DragScalar
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1021]
	test	eax, eax
	jne	SHORT $LN12@DragScalar
$LN13@DragScalar:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7044], ecx
	je	SHORT $LN12@DragScalar
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7048], ecx
	jne	$LN11@DragScalar
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+11664], ecx
	je	$LN11@DragScalar
$LN12@DragScalar:

; 2247 : 	{
; 2248 : 		SetActiveID(id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 2249 : 		SetFocusID(id, window);

	mov	rdx, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetFocusID

; 2250 : 		FocusWindow(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 2251 : 		g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6804], 12

; 2252 : 		if (tab_focus_requested || g.IO.KeyCtrl || g.IO.MouseDoubleClicked[0] || g.NavInputId == id)

	movzx	eax, BYTE PTR tab_focus_requested$[rsp]
	test	eax, eax
	jne	SHORT $LN15@DragScalar
	mov	rax, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rax+325]
	test	eax, eax
	jne	SHORT $LN15@DragScalar
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1021]
	test	eax, eax
	jne	SHORT $LN15@DragScalar
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7048], ecx
	jne	SHORT $LN14@DragScalar
$LN15@DragScalar:

; 2253 : 		{
; 2254 : 			start_text_input = true;

	mov	BYTE PTR start_text_input$[rsp], 1

; 2255 : 			g.ScalarAsInputTextId = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+11664], 0
$LN14@DragScalar:
$LN11@DragScalar:

; 2256 : 		}
; 2257 : 	}
; 2258 : 	if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))

	movzx	eax, BYTE PTR start_text_input$[rsp]
	test	eax, eax
	jne	SHORT $LN17@DragScalar
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN16@DragScalar
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+11664], ecx
	jne	SHORT $LN16@DragScalar
$LN17@DragScalar:

; 2259 : 	{
; 2260 : 		window->DC.CursorPos = frame_bb.Min;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR frame_bb$[rsp]
	mov	QWORD PTR [rax+340], rcx

; 2261 : 		FocusableItemUnregister(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	?FocusableItemUnregister@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::FocusableItemUnregister

; 2262 : 		return InputScalarAsWidgetReplacement(frame_bb, id, label, data_type, v, format);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR v$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR data_type$[rsp]
	mov	r8, QWORD PTR label$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?InputScalarAsWidgetReplacement@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1@Z ; ImGui::InputScalarAsWidgetReplacement
	jmp	$LN1@DragScalar
$LN16@DragScalar:

; 2263 : 	}
; 2264 : 
; 2265 : 	// Actual drag behavior
; 2266 : 	const bool value_changed = DragBehavior(id, data_type, v, v_speed, v_min, v_max, format, power, ImGuiDragFlags_None);

	mov	DWORD PTR [rsp+64], 0
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movss	xmm3, DWORD PTR v_speed$[rsp]
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR data_type$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	call	?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDMH@Z ; ImGui::DragBehavior
	mov	BYTE PTR value_changed$[rsp], al

; 2267 : 	if (value_changed)

	movzx	eax, BYTE PTR value_changed$[rsp]
	test	eax, eax
	je	SHORT $LN18@DragScalar

; 2268 : 		MarkItemEdited(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN18@DragScalar:

; 2269 : 
; 2270 : 	// Draw frame
; 2271 : 	const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6704], ecx
	jne	SHORT $LN25@DragScalar
	mov	DWORD PTR tv257[rsp], 9
	jmp	SHORT $LN26@DragScalar
$LN25@DragScalar:
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+6696], ecx
	jne	SHORT $LN23@DragScalar
	mov	DWORD PTR tv256[rsp], 8
	jmp	SHORT $LN24@DragScalar
$LN23@DragScalar:
	mov	DWORD PTR tv256[rsp], 7
$LN24@DragScalar:
	mov	eax, DWORD PTR tv256[rsp]
	mov	DWORD PTR tv257[rsp], eax
$LN26@DragScalar:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv257[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR frame_col$[rsp], eax

; 2272 : 	RenderNavHighlight(frame_bb, id);

	mov	r8d, 1
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 2273 : 	RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	r8d, DWORD PTR frame_col$[rsp]
	mov	rdx, QWORD PTR frame_bb$[rsp+8]
	mov	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 2274 : 
; 2275 : 	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
; 2276 : 	char value_buf[64];
; 2277 : 	const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v$[rsp]
	mov	r8d, DWORD PTR data_type$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR value_buf$[rsp]
	call	?DataTypeFormatString@@YAHPEADHHPEBXPEBD@Z ; DataTypeFormatString
	cdqe
	lea	rax, QWORD PTR value_buf$[rsp+rax]
	mov	QWORD PTR value_buf_end$[rsp], rax

; 2278 : 	RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR [rsp+48], 0
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR value_buf_end$[rsp]
	lea	r8, QWORD PTR value_buf$[rsp]
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
	npad	1

; 2279 : 
; 2280 : 	if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN19@DragScalar

; 2281 : 		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR frame_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR frame_bb$[rsp+8]
	addss	xmm1, DWORD PTR [rax+76]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN19@DragScalar:
$LN4@DragScalar:

; 2282 : 
; 2283 : 	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);

	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@DragScalar

; 2284 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
$LN1@DragScalar:

; 2285 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 328				; 00000148H
	ret	0
?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20M@Z ENDP		; ImGui::DragScalar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 48
tv77 = 52
tv80 = 56
tv131 = 60
tv137 = 64
tv144 = 68
tv128 = 72
g$ = 80
window$ = 88
tv86 = 96
label$ = 128
v_current_min$ = 136
v_current_max$ = 144
v_speed$ = 152
v_min$ = 160
v_max$ = 168
format$ = 176
format_max$ = 184
?DragIntRange2@ImGui@@YA_NPEBDPEAH1MHH00@Z PROC		; ImGui::DragIntRange2

; 2381 : {

$LN14:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 2382 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 2383 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@DragIntRan

; 2384 : 		return false;

	xor	al, al
	jmp	$LN1@DragIntRan
$LN2@DragIntRan:

; 2385 : 
; 2386 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2387 : 	PushID(label);

	mov	rcx, QWORD PTR label$[rsp]
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 2388 : 	BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 2389 : 	PushMultiItemsWidths(2);

	xorps	xmm1, xmm1
	mov	ecx, 2
	call	?PushMultiItemsWidths@ImGui@@YAXHM@Z	; ImGui::PushMultiItemsWidths

; 2390 : 
; 2391 : 	bool value_changed = DragInt(("##+-min"), v_current_min, v_speed, (v_min >= v_max) ? INT_MIN : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv86[rsp], rax
	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_min$[rsp], eax
	jl	SHORT $LN4@DragIntRan
	mov	rax, QWORD PTR v_current_max$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv77[rsp], eax
	jmp	SHORT $LN5@DragIntRan
$LN4@DragIntRan:
	mov	rax, QWORD PTR v_current_max$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	ecx, DWORD PTR v_max$[rsp]
	call	??$ImMin@H@@YAHHH@Z			; ImMin<int>
	mov	DWORD PTR tv77[rsp], eax
$LN5@DragIntRan:
	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_min$[rsp], eax
	jl	SHORT $LN6@DragIntRan
	mov	DWORD PTR tv80[rsp], -2147483648	; ffffffff80000000H
	jmp	SHORT $LN7@DragIntRan
$LN6@DragIntRan:
	mov	eax, DWORD PTR v_min$[rsp]
	mov	DWORD PTR tv80[rsp], eax
$LN7@DragIntRan:
	mov	rax, QWORD PTR tv86[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv77[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR tv80[rsp]
	movss	xmm2, DWORD PTR v_speed$[rsp]
	mov	rdx, QWORD PTR v_current_min$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_07DCHPOBDK@?$CD?$CD?$CL?9min@
	call	?DragInt@ImGui@@YA_NPEBDPEAHMHH0@Z	; ImGui::DragInt
	mov	BYTE PTR value_changed$[rsp], al

; 2392 : 	PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 2393 : 	SameLine(0, g.Style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5548]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 2394 : 	value_changed |= DragInt(("##+-max"), v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? INT_MAX : v_max, format_max ? format_max : format);

	movzx	eax, BYTE PTR value_changed$[rsp]
	mov	DWORD PTR tv144[rsp], eax
	cmp	QWORD PTR format_max$[rsp], 0
	je	SHORT $LN8@DragIntRan
	mov	rax, QWORD PTR format_max$[rsp]
	mov	QWORD PTR tv128[rsp], rax
	jmp	SHORT $LN9@DragIntRan
$LN8@DragIntRan:
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv128[rsp], rax
$LN9@DragIntRan:
	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_min$[rsp], eax
	jl	SHORT $LN10@DragIntRan
	mov	DWORD PTR tv131[rsp], 2147483647	; 7fffffffH
	jmp	SHORT $LN11@DragIntRan
$LN10@DragIntRan:
	mov	eax, DWORD PTR v_max$[rsp]
	mov	DWORD PTR tv131[rsp], eax
$LN11@DragIntRan:
	mov	eax, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR v_min$[rsp], eax
	jl	SHORT $LN12@DragIntRan
	mov	rax, QWORD PTR v_current_min$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv137[rsp], eax
	jmp	SHORT $LN13@DragIntRan
$LN12@DragIntRan:
	mov	rax, QWORD PTR v_current_min$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	ecx, DWORD PTR v_min$[rsp]
	call	??$ImMax@H@@YAHHH@Z			; ImMax<int>
	mov	DWORD PTR tv137[rsp], eax
$LN13@DragIntRan:
	mov	rax, QWORD PTR tv128[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv131[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR tv137[rsp]
	movss	xmm2, DWORD PTR v_speed$[rsp]
	mov	rdx, QWORD PTR v_current_max$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_07CAPEAFFF@?$CD?$CD?$CL?9max@
	call	?DragInt@ImGui@@YA_NPEBDPEAHMHH0@Z	; ImGui::DragInt
	movzx	eax, al
	mov	ecx, DWORD PTR tv144[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR value_changed$[rsp], al

; 2395 : 	PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 2396 : 	SameLine(0, g.Style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5548]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 2397 : 
; 2398 : 	TextUnformatted(label, FindRenderedTextEnd(label));

	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	rdx, rax
	mov	rcx, QWORD PTR label$[rsp]
	call	?TextUnformatted@ImGui@@YAXPEBD0@Z	; ImGui::TextUnformatted

; 2399 : 	EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 2400 : 	PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 2401 : 
; 2402 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
$LN1@DragIntRan:

; 2403 : }

	add	rsp, 120				; 00000078H
	ret	0
?DragIntRange2@ImGui@@YA_NPEBDPEAH1MHH00@Z ENDP		; ImGui::DragIntRange2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 96
v$ = 104
v_speed$ = 112
v_min$ = 120
v_max$ = 128
format$ = 136
?DragInt4@ImGui@@YA_NPEBDQEAHMHH0@Z PROC		; ImGui::DragInt4

; 2376 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2377 : 	return DragScalarN(label, ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+64], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movss	xmm0, DWORD PTR v_speed$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, 4
	mov	r8, QWORD PTR v$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z ; ImGui::DragScalarN

; 2378 : }

	add	rsp, 88					; 00000058H
	ret	0
?DragInt4@ImGui@@YA_NPEBDQEAHMHH0@Z ENDP		; ImGui::DragInt4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 96
v$ = 104
v_speed$ = 112
v_min$ = 120
v_max$ = 128
format$ = 136
?DragInt3@ImGui@@YA_NPEBDQEAHMHH0@Z PROC		; ImGui::DragInt3

; 2371 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2372 : 	return DragScalarN(label, ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+64], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movss	xmm0, DWORD PTR v_speed$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, 3
	mov	r8, QWORD PTR v$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z ; ImGui::DragScalarN

; 2373 : }

	add	rsp, 88					; 00000058H
	ret	0
?DragInt3@ImGui@@YA_NPEBDQEAHMHH0@Z ENDP		; ImGui::DragInt3
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 96
v$ = 104
v_speed$ = 112
v_min$ = 120
v_max$ = 128
format$ = 136
?DragInt2@ImGui@@YA_NPEBDQEAHMHH0@Z PROC		; ImGui::DragInt2

; 2366 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2367 : 	return DragScalarN(label, ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+64], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movss	xmm0, DWORD PTR v_speed$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, 2
	mov	r8, QWORD PTR v$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z ; ImGui::DragScalarN

; 2368 : }

	add	rsp, 88					; 00000058H
	ret	0
?DragInt2@ImGui@@YA_NPEBDQEAHMHH0@Z ENDP		; ImGui::DragInt2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
v_speed$ = 96
v_min$ = 104
v_max$ = 112
format$ = 120
?DragInt@ImGui@@YA_NPEBDPEAHMHH0@Z PROC			; ImGui::DragInt

; 2361 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2362 : 	return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movss	xmm3, DWORD PTR v_speed$[rsp]
	mov	r8, QWORD PTR v$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20M@Z ; ImGui::DragScalar

; 2363 : }

	add	rsp, 72					; 00000048H
	ret	0
?DragInt@ImGui@@YA_NPEBDPEAHMHH0@Z ENDP			; ImGui::DragInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 64
tv78 = 68
tv81 = 72
tv133 = 76
tv139 = 80
tv145 = 84
tv148 = 88
tv130 = 96
g$ = 104
window$ = 112
tv87 = 120
label$ = 144
v_current_min$ = 152
v_current_max$ = 160
v_speed$ = 168
v_min$ = 176
v_max$ = 184
format$ = 192
format_max$ = 200
power$ = 208
?DragFloatRange2@ImGui@@YA_NPEBDPEAM1MMM00M@Z PROC	; ImGui::DragFloatRange2

; 2336 : {

$LN14:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 2337 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 2338 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@DragFloatR

; 2339 : 		return false;

	xor	al, al
	jmp	$LN1@DragFloatR
$LN2@DragFloatR:

; 2340 : 
; 2341 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 2342 : 	PushID(label);

	mov	rcx, QWORD PTR label$[rsp]
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 2343 : 	BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 2344 : 	PushMultiItemsWidths(2);

	xorps	xmm1, xmm1
	mov	ecx, 2
	call	?PushMultiItemsWidths@ImGui@@YAXHM@Z	; ImGui::PushMultiItemsWidths

; 2345 : 
; 2346 : 	bool value_changed = DragFloat(("##+-min"), v_current_min, v_speed, (v_min >= v_max) ? -FLT_MAX : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format, power);

	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv87[rsp], rax
	movss	xmm0, DWORD PTR v_min$[rsp]
	comiss	xmm0, DWORD PTR v_max$[rsp]
	jb	SHORT $LN4@DragFloatR
	mov	rax, QWORD PTR v_current_max$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv78[rsp], xmm0
	jmp	SHORT $LN5@DragFloatR
$LN4@DragFloatR:
	mov	rax, QWORD PTR v_current_max$[rsp]
	movss	xmm1, DWORD PTR [rax]
	movss	xmm0, DWORD PTR v_max$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR tv78[rsp], xmm0
$LN5@DragFloatR:
	movss	xmm0, DWORD PTR v_min$[rsp]
	comiss	xmm0, DWORD PTR v_max$[rsp]
	jb	SHORT $LN6@DragFloatR
	movss	xmm0, DWORD PTR __real@ff7fffff
	movss	DWORD PTR tv81[rsp], xmm0
	jmp	SHORT $LN7@DragFloatR
$LN6@DragFloatR:
	movss	xmm0, DWORD PTR v_min$[rsp]
	movss	DWORD PTR tv81[rsp], xmm0
$LN7@DragFloatR:
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	rax, QWORD PTR tv87[rsp]
	mov	QWORD PTR [rsp+40], rax
	movss	xmm0, DWORD PTR tv78[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR tv81[rsp]
	movss	xmm2, DWORD PTR v_speed$[rsp]
	mov	rdx, QWORD PTR v_current_min$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_07DCHPOBDK@?$CD?$CD?$CL?9min@
	call	?DragFloat@ImGui@@YA_NPEBDPEAMMMM0M@Z	; ImGui::DragFloat
	mov	BYTE PTR value_changed$[rsp], al

; 2347 : 	PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 2348 : 	SameLine(0, g.Style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5548]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 2349 : 	value_changed |= DragFloat(("##+-max"), v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? FLT_MAX : v_max, format_max ? format_max : format, power);

	movzx	eax, BYTE PTR value_changed$[rsp]
	mov	DWORD PTR tv148[rsp], eax
	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR tv145[rsp], xmm0
	cmp	QWORD PTR format_max$[rsp], 0
	je	SHORT $LN8@DragFloatR
	mov	rax, QWORD PTR format_max$[rsp]
	mov	QWORD PTR tv130[rsp], rax
	jmp	SHORT $LN9@DragFloatR
$LN8@DragFloatR:
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR tv130[rsp], rax
$LN9@DragFloatR:
	movss	xmm0, DWORD PTR v_min$[rsp]
	comiss	xmm0, DWORD PTR v_max$[rsp]
	jb	SHORT $LN10@DragFloatR
	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR tv133[rsp], xmm0
	jmp	SHORT $LN11@DragFloatR
$LN10@DragFloatR:
	movss	xmm0, DWORD PTR v_max$[rsp]
	movss	DWORD PTR tv133[rsp], xmm0
$LN11@DragFloatR:
	movss	xmm0, DWORD PTR v_min$[rsp]
	comiss	xmm0, DWORD PTR v_max$[rsp]
	jb	SHORT $LN12@DragFloatR
	mov	rax, QWORD PTR v_current_min$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv139[rsp], xmm0
	jmp	SHORT $LN13@DragFloatR
$LN12@DragFloatR:
	mov	rax, QWORD PTR v_current_min$[rsp]
	movss	xmm1, DWORD PTR [rax]
	movss	xmm0, DWORD PTR v_min$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR tv139[rsp], xmm0
$LN13@DragFloatR:
	movss	xmm0, DWORD PTR tv145[rsp]
	movss	DWORD PTR [rsp+48], xmm0
	mov	rax, QWORD PTR tv130[rsp]
	mov	QWORD PTR [rsp+40], rax
	movss	xmm0, DWORD PTR tv133[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR tv139[rsp]
	movss	xmm2, DWORD PTR v_speed$[rsp]
	mov	rdx, QWORD PTR v_current_max$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_07CAPEAFFF@?$CD?$CD?$CL?9max@
	call	?DragFloat@ImGui@@YA_NPEBDPEAMMMM0M@Z	; ImGui::DragFloat
	movzx	eax, al
	mov	ecx, DWORD PTR tv148[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR value_changed$[rsp], al

; 2350 : 	PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 2351 : 	SameLine(0, g.Style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5548]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine

; 2352 : 
; 2353 : 	TextUnformatted(label, FindRenderedTextEnd(label));

	xor	edx, edx
	mov	rcx, QWORD PTR label$[rsp]
	call	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
	mov	rdx, rax
	mov	rcx, QWORD PTR label$[rsp]
	call	?TextUnformatted@ImGui@@YAXPEBD0@Z	; ImGui::TextUnformatted

; 2354 : 	EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 2355 : 	PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 2356 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
$LN1@DragFloatR:

; 2357 : }

	add	rsp, 136				; 00000088H
	ret	0
?DragFloatRange2@ImGui@@YA_NPEBDPEAM1MMM00M@Z ENDP	; ImGui::DragFloatRange2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 96
v$ = 104
v_speed$ = 112
v_min$ = 120
v_max$ = 128
format$ = 136
power$ = 144
?DragFloat4@ImGui@@YA_NPEBDQEAMMMM0M@Z PROC		; ImGui::DragFloat4

; 2331 : {

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2332 : 	return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power);

	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movss	xmm0, DWORD PTR v_speed$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, 4
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z ; ImGui::DragScalarN

; 2333 : }

	add	rsp, 88					; 00000058H
	ret	0
?DragFloat4@ImGui@@YA_NPEBDQEAMMMM0M@Z ENDP		; ImGui::DragFloat4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 96
v$ = 104
v_speed$ = 112
v_min$ = 120
v_max$ = 128
format$ = 136
power$ = 144
?DragFloat3@ImGui@@YA_NPEBDQEAMMMM0M@Z PROC		; ImGui::DragFloat3

; 2326 : {

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2327 : 	return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power);

	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movss	xmm0, DWORD PTR v_speed$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, 3
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z ; ImGui::DragScalarN

; 2328 : }

	add	rsp, 88					; 00000058H
	ret	0
?DragFloat3@ImGui@@YA_NPEBDQEAMMMM0M@Z ENDP		; ImGui::DragFloat3
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 96
v$ = 104
v_speed$ = 112
v_min$ = 120
v_max$ = 128
format$ = 136
power$ = 144
?DragFloat2@ImGui@@YA_NPEBDQEAMMMM0M@Z PROC		; ImGui::DragFloat2

; 2321 : {

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2322 : 	return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power);

	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+64], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movss	xmm0, DWORD PTR v_speed$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, 2
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z ; ImGui::DragScalarN

; 2323 : }

	add	rsp, 88					; 00000058H
	ret	0
?DragFloat2@ImGui@@YA_NPEBDQEAMMMM0M@Z ENDP		; ImGui::DragFloat2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 80
v$ = 88
v_speed$ = 96
v_min$ = 104
v_max$ = 112
format$ = 120
power$ = 128
?DragFloat@ImGui@@YA_NPEBDPEAMMMM0M@Z PROC		; ImGui::DragFloat

; 2316 : {

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2317 : 	return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power);

	movss	xmm0, DWORD PTR power$[rsp]
	movss	DWORD PTR [rsp+56], xmm0
	mov	rax, QWORD PTR format$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR v_max$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_min$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movss	xmm3, DWORD PTR v_speed$[rsp]
	mov	r8, QWORD PTR v$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR label$[rsp]
	call	?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20M@Z ; ImGui::DragScalar

; 2318 : }

	add	rsp, 72					; 00000048H
	ret	0
?DragFloat@ImGui@@YA_NPEBDPEAMMMM0M@Z ENDP		; ImGui::DragFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
j$3 = 40
tv65 = 48
tv162 = 56
tv165 = 64
tv164 = 72
tv158 = 80
tv156 = 88
g$ = 96
$T4 = 104
preview$ = 112
$T5 = 144
$T6 = 176
__$ArrayPad$ = 208
label$ = 240
variable$ = 248
labels$ = 256
count$ = 264
?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z PROC		; ImGui::MultiCombo

; 1799 : {

$LN16:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 232				; 000000e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1800 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1801 : 
; 1802 : 	std::string preview = ("None");

	lea	rdx, OFFSET FLAT:??_C@_04OHJIHAFH@None@
	lea	rcx, QWORD PTR preview$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1803 : 
; 1804 : 	for (auto i = 0, j = 0; i < count; i++)

	mov	DWORD PTR i$1[rsp], 0
	mov	DWORD PTR j$3[rsp], 0
	jmp	SHORT $LN4@MultiCombo
$LN2@MultiCombo:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@MultiCombo:
	mov	eax, DWORD PTR count$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN3@MultiCombo

; 1805 : 	{
; 1806 : 		if (variable[i])

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR variable$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN8@MultiCombo

; 1807 : 		{
; 1808 : 			if (j)

	cmp	DWORD PTR j$3[rsp], 0
	je	$LN9@MultiCombo

; 1809 : 				preview += (", ") + (std::string)labels[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR labels$[rsp]
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv65[rsp], rax
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR tv162[rsp], rax
	mov	r8, QWORD PTR tv162[rsp]
	lea	rdx, OFFSET FLAT:??_C@_02KEGNLNML@?0?5@
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv165[rsp], rax
	mov	rax, QWORD PTR tv165[rsp]
	mov	QWORD PTR tv164[rsp], rax
	mov	rdx, QWORD PTR tv164[rsp]
	lea	rcx, QWORD PTR preview$[rsp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	npad	1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T6[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	SHORT $LN10@MultiCombo
$LN9@MultiCombo:

; 1810 : 			else
; 1811 : 				preview = labels[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR labels$[rsp]
	mov	rdx, QWORD PTR [rcx+rax*8]
	lea	rcx, QWORD PTR preview$[rsp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
$LN10@MultiCombo:

; 1812 : 
; 1813 : 			j++;

	mov	eax, DWORD PTR j$3[rsp]
	inc	eax
	mov	DWORD PTR j$3[rsp], eax
$LN8@MultiCombo:

; 1814 : 		}
; 1815 : 	}

	jmp	$LN2@MultiCombo
$LN3@MultiCombo:

; 1816 : 
; 1817 : 	if (ImGui::BeginCombo(label, preview.c_str(), count)) // draw start

	lea	rcx, QWORD PTR preview$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	r8d, DWORD PTR count$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR label$[rsp]
	call	?BeginCombo@ImGui@@YA_NPEBD0H@Z		; ImGui::BeginCombo
	movzx	eax, al
	test	eax, eax
	je	$LN11@MultiCombo

; 1818 : 	{
; 1819 : 		for (auto i = 0; i < count; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN7@MultiCombo
$LN5@MultiCombo:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN7@MultiCombo:
	mov	eax, DWORD PTR count$[rsp]
	cmp	DWORD PTR i$2[rsp], eax
	jge	SHORT $LN6@MultiCombo

; 1820 : 		{
; 1821 : 			ImGui::Selectable(labels[i], &variable[i], ImGuiSelectableFlags_DontClosePopups);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv158[rsp], rax
	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR labels$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR tv156[rsp], rax
	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR variable$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9, QWORD PTR tv158[rsp]
	mov	r8d, 1
	mov	rdx, rax
	mov	rcx, QWORD PTR tv156[rsp]
	call	?Selectable@ImGui@@YA_NPEBDPEA_NHAEBUImVec2@@@Z ; ImGui::Selectable
	npad	1

; 1822 : 		}

	jmp	SHORT $LN5@MultiCombo
$LN6@MultiCombo:

; 1823 : 		End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	npad	1
$LN11@MultiCombo:

; 1824 : 	}
; 1825 : 
; 1826 : 	preview = ("None"); // reset preview to use later

	lea	rdx, OFFSET FLAT:??_C@_04OHJIHAFH@None@
	lea	rcx, QWORD PTR preview$[rsp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1

; 1827 : }

	lea	rcx, QWORD PTR preview$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 232				; 000000e8H
	ret	0
?MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z ENDP		; ImGui::MultiCombo
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
i$2 = 36
j$3 = 40
tv65 = 48
tv162 = 56
tv165 = 64
tv164 = 72
tv158 = 80
tv156 = 88
g$ = 96
$T4 = 104
preview$ = 112
$T5 = 144
$T6 = 176
__$ArrayPad$ = 208
label$ = 240
variable$ = 248
labels$ = 256
count$ = 264
?dtor$0@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA PROC ; `ImGui::MultiCombo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR preview$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA ENDP ; `ImGui::MultiCombo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
i$2 = 36
j$3 = 40
tv65 = 48
tv162 = 56
tv165 = 64
tv164 = 72
tv158 = 80
tv156 = 88
g$ = 96
$T4 = 104
preview$ = 112
$T5 = 144
$T6 = 176
__$ArrayPad$ = 208
label$ = 240
variable$ = 248
labels$ = 256
count$ = 264
?dtor$1@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA PROC ; `ImGui::MultiCombo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T6[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA ENDP ; `ImGui::MultiCombo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 32
i$2 = 36
j$3 = 40
tv65 = 48
tv162 = 56
tv165 = 64
tv164 = 72
tv158 = 80
tv156 = 88
g$ = 96
$T4 = 104
preview$ = 112
$T5 = 144
$T6 = 176
__$ArrayPad$ = 208
label$ = 240
variable$ = 248
labels$ = 256
count$ = 264
?dtor$2@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA PROC ; `ImGui::MultiCombo'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T5[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??MultiCombo@ImGui@@YAXPEBDQEA_NQEAPEBDH@Z@4HA ENDP ; `ImGui::MultiCombo'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv136 = 32
item_selected$1 = 33
value_changed$ = 34
i$2 = 36
item_text$3 = 40
preview_value$ = 48
tv71 = 56
g$ = 64
tv92 = 72
tv90 = 80
tv142 = 88
tv162 = 96
tv160 = 104
$T4 = 112
$T5 = 120
$T6 = 128
label$ = 160
current_item$ = 168
items_getter$ = 176
data$ = 184
items_count$ = 192
popup_max_height_in_items$ = 200
?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z PROC	; ImGui::Combo

; 1733 : {

$LN16:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 1734 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1735 : 
; 1736 : 	// Call the getter to obtain the preview string which is a parameter to BeginCombo()
; 1737 : 	const char* preview_value = NULL;

	mov	QWORD PTR preview_value$[rsp], 0

; 1738 : 	if (*current_item >= 0 && *current_item < items_count)

	mov	rax, QWORD PTR current_item$[rsp]
	cmp	DWORD PTR [rax], 0
	jl	SHORT $LN5@Combo
	mov	rax, QWORD PTR current_item$[rsp]
	mov	ecx, DWORD PTR items_count$[rsp]
	cmp	DWORD PTR [rax], ecx
	jge	SHORT $LN5@Combo

; 1739 : 		items_getter(data, *current_item, &preview_value);

	mov	rax, QWORD PTR items_getter$[rsp]
	mov	QWORD PTR tv71[rsp], rax
	lea	r8, QWORD PTR preview_value$[rsp]
	mov	rax, QWORD PTR current_item$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR data$[rsp]
	call	QWORD PTR tv71[rsp]
	npad	1
$LN5@Combo:

; 1740 : 
; 1741 : 	// The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
; 1742 : 	if (popup_max_height_in_items != -1 && !g.NextWindowData.SizeConstraintCond)

	cmp	DWORD PTR popup_max_height_in_items$[rsp], -1
	je	SHORT $LN6@Combo
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+6920], 0
	jne	SHORT $LN6@Combo

; 1743 : 		SetNextWindowSizeConstraints(ImVec2(0, 0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));

	mov	ecx, DWORD PTR popup_max_height_in_items$[rsp]
	call	?CalcMaxPopupHeightFromItemCount@@YAMH@Z ; CalcMaxPopupHeightFromItemCount
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR __real@7f7fffff
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv92[rsp], rax
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv90[rsp], rax
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv92[rsp]
	mov	rcx, QWORD PTR tv90[rsp]
	call	?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z ; ImGui::SetNextWindowSizeConstraints
	npad	1
$LN6@Combo:

; 1744 : 
; 1745 : 	if (!BeginCombo(label, preview_value, ImGuiComboFlags_HeightRegular))

	mov	r8d, 4
	mov	rdx, QWORD PTR preview_value$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?BeginCombo@ImGui@@YA_NPEBD0H@Z		; ImGui::BeginCombo
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Combo

; 1746 : 		return false;

	xor	al, al
	jmp	$LN1@Combo
$LN7@Combo:

; 1747 : 
; 1748 : 	// Display items
; 1749 : 	// FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)
; 1750 : 	bool value_changed = false;

	mov	BYTE PTR value_changed$[rsp], 0

; 1751 : 	for (int i = 0; i < items_count; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN4@Combo
$LN2@Combo:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN4@Combo:
	mov	eax, DWORD PTR items_count$[rsp]
	cmp	DWORD PTR i$2[rsp], eax
	jge	$LN3@Combo

; 1752 : 	{
; 1753 : 		PushID((void*)(intptr_t)i);

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, rax
	call	?PushID@ImGui@@YAXPEBX@Z		; ImGui::PushID

; 1754 : 		const bool item_selected = (i == *current_item);

	mov	rax, QWORD PTR current_item$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$2[rsp], eax
	jne	SHORT $LN14@Combo
	mov	BYTE PTR tv136[rsp], 1
	jmp	SHORT $LN15@Combo
$LN14@Combo:
	mov	BYTE PTR tv136[rsp], 0
$LN15@Combo:
	movzx	eax, BYTE PTR tv136[rsp]
	mov	BYTE PTR item_selected$1[rsp], al

; 1755 : 		const char* item_text;
; 1756 : 		if (!items_getter(data, i, &item_text))

	mov	rax, QWORD PTR items_getter$[rsp]
	mov	QWORD PTR tv142[rsp], rax
	lea	r8, QWORD PTR item_text$3[rsp]
	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	QWORD PTR tv142[rsp]
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@Combo

; 1757 : 			item_text = ("*Unknown item*");

	lea	rax, OFFSET FLAT:??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@
	mov	QWORD PTR item_text$3[rsp], rax
$LN8@Combo:

; 1758 : 		if (!item_text || IsBadReadPtr(item_text, 1))

	cmp	QWORD PTR item_text$3[rsp], 0
	je	SHORT $LN10@Combo
	mov	edx, 1
	mov	rcx, QWORD PTR item_text$3[rsp]
	call	QWORD PTR __imp_IsBadReadPtr
	test	eax, eax
	je	SHORT $LN9@Combo
$LN10@Combo:

; 1759 : 		{
; 1760 : 			PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	npad	1

; 1761 : 			break;

	jmp	SHORT $LN3@Combo
$LN9@Combo:

; 1762 : 		}
; 1763 : 		if (Selectable(item_text, item_selected))

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv162[rsp], rax
	mov	rax, QWORD PTR item_text$3[rsp]
	mov	QWORD PTR tv160[rsp], rax
	mov	r9, QWORD PTR tv162[rsp]
	xor	r8d, r8d
	movzx	edx, BYTE PTR item_selected$1[rsp]
	mov	rcx, QWORD PTR tv160[rsp]
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@Combo

; 1764 : 		{
; 1765 : 			value_changed = true;

	mov	BYTE PTR value_changed$[rsp], 1

; 1766 : 			*current_item = i;

	mov	rax, QWORD PTR current_item$[rsp]
	mov	ecx, DWORD PTR i$2[rsp]
	mov	DWORD PTR [rax], ecx
$LN11@Combo:

; 1767 : 		}
; 1768 : 		if (item_selected)

	movzx	eax, BYTE PTR item_selected$1[rsp]
	test	eax, eax
	je	SHORT $LN12@Combo

; 1769 : 			SetItemDefaultFocus();

	call	?SetItemDefaultFocus@ImGui@@YAXXZ	; ImGui::SetItemDefaultFocus
	npad	1
$LN12@Combo:

; 1770 : 		PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	npad	1

; 1771 : 	}

	jmp	$LN2@Combo
$LN3@Combo:

; 1772 : 
; 1773 : 	EndCombo();

	call	?EndCombo@ImGui@@YAXXZ			; ImGui::EndCombo

; 1774 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]
$LN1@Combo:

; 1775 : }

	add	rsp, 152				; 00000098H
	ret	0
?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z ENDP	; ImGui::Combo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 48
items_count$ = 52
p$ = 56
label$ = 80
current_item$ = 88
items_separated_by_zeros$ = 96
height_in_items$ = 104
?Combo@ImGui@@YA_NPEBDPEAH0H@Z PROC			; ImGui::Combo

; 1786 : {

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1787 : 	int items_count = 0;

	mov	DWORD PTR items_count$[rsp], 0

; 1788 : 	const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open

	mov	rax, QWORD PTR items_separated_by_zeros$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@Combo:

; 1789 : 	while (*p)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@Combo

; 1790 : 	{
; 1791 : 		p += strlen(p) + 1;

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	rcx, QWORD PTR p$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR p$[rsp], rax

; 1792 : 		items_count++;

	mov	eax, DWORD PTR items_count$[rsp]
	inc	eax
	mov	DWORD PTR items_count$[rsp], eax

; 1793 : 	}

	jmp	SHORT $LN2@Combo
$LN3@Combo:

; 1794 : 	bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);

	mov	eax, DWORD PTR height_in_items$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR items_count$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR items_separated_by_zeros$[rsp]
	lea	r8, OFFSET FLAT:?Items_SingleStringGetter@@YA_NPEAXHPEAPEBD@Z ; Items_SingleStringGetter
	mov	rdx, QWORD PTR current_item$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z ; ImGui::Combo
	mov	BYTE PTR value_changed$[rsp], al

; 1795 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]

; 1796 : }

	add	rsp, 72					; 00000048H
	ret	0
?Combo@ImGui@@YA_NPEBDPEAH0H@Z ENDP			; ImGui::Combo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
value_changed$ = 48
label$ = 80
current_item$ = 88
items$ = 96
items_count$ = 104
height_in_items$ = 112
?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z PROC		; ImGui::Combo

; 1779 : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1780 : 	const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);

	mov	eax, DWORD PTR height_in_items$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR items_count$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR items$[rsp]
	lea	r8, OFFSET FLAT:?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z ; Items_ArrayGetter
	mov	rdx, QWORD PTR current_item$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z ; ImGui::Combo
	mov	BYTE PTR value_changed$[rsp], al

; 1781 : 	return value_changed;

	movzx	eax, BYTE PTR value_changed$[rsp]

; 1782 : }

	add	rsp, 72					; 00000048H
	ret	0
?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z ENDP		; ImGui::Combo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
?EndCombo@ImGui@@YAXXZ PROC				; ImGui::EndCombo

; 1697 : {

$LN3:
	sub	rsp, 40					; 00000028H

; 1698 : 	EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	npad	1

; 1699 : }

	add	rsp, 40					; 00000028H
	ret	0
?EndCombo@ImGui@@YAXXZ ENDP				; ImGui::EndCombo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
popup_open$ = 64
hovered$ = 65
pressed$ = 66
ret$ = 67
id$ = 68
arrow_size$ = 72
style$ = 80
frame_bb$ = 88
popup_max_height_in_items$1 = 104
w$ = 108
window$ = 112
g$ = 120
held$ = 128
popup_window$2 = 136
tv80 = 144
tv89 = 148
tv151 = 152
tv190 = 156
tv259 = 160
tv218 = 164
backup_next_window_size_constraint$ = 168
label_size$ = 176
frame_col$ = 184
tv282 = 188
window_flags$ = 192
tv212 = 200
tv280 = 208
tv278 = 216
tv284 = 224
tv335 = 232
tv333 = 240
tv331 = 248
tv408 = 256
tv406 = 264
tv432 = 272
size_expected$3 = 280
pos$4 = 288
tv210 = 296
total_bb$ = 304
$T5 = 320
$T6 = 328
$T7 = 336
$T8 = 344
$T9 = 352
$T10 = 360
$T11 = 368
$T12 = 376
$T13 = 384
$T14 = 392
$T15 = 400
$T16 = 408
$T17 = 416
$T18 = 424
$T19 = 432
$T20 = 440
$T21 = 448
$T22 = 456
$T23 = 464
$T24 = 472
$T25 = 480
value_bb$ = 488
r_outer$26 = 504
name$ = 520
__$ArrayPad$ = 536
label$ = 560
preview_value$ = 568
flags$ = 576
?BeginCombo@ImGui@@YA_NPEBD0H@Z PROC			; ImGui::BeginCombo

; 1592 : {

$LN37:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 552				; 00000228H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1593 : 	// Always consume the SetNextWindowSizeConstraint() call in our early return paths
; 1594 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1595 : 	ImGuiCond backup_next_window_size_constraint = g.NextWindowData.SizeConstraintCond;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+6920]
	mov	DWORD PTR backup_next_window_size_constraint$[rsp], eax

; 1596 : 	g.NextWindowData.SizeConstraintCond = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+6920], 0

; 1597 : 
; 1598 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1599 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@BeginCombo

; 1600 : 		return false;

	xor	al, al
	jmp	$LN1@BeginCombo
$LN2@BeginCombo:

; 1601 : 
; 1602 : 	IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together
; 1603 : 
; 1604 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 1605 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 1606 : 
; 1607 : 	const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN25@BeginCombo
	xorps	xmm0, xmm0
	movss	DWORD PTR tv80[rsp], xmm0
	jmp	SHORT $LN26@BeginCombo
$LN25@BeginCombo:
	call	?GetFrameHeight@ImGui@@YAMXZ		; ImGui::GetFrameHeight
	movss	DWORD PTR tv80[rsp], xmm0
$LN26@BeginCombo:
	movss	xmm0, DWORD PTR tv80[rsp]
	movss	DWORD PTR arrow_size$[rsp], xmm0

; 1608 : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 1609 : 	const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : CalcItemWidth();

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN27@BeginCombo
	movss	xmm0, DWORD PTR arrow_size$[rsp]
	movss	DWORD PTR tv89[rsp], xmm0
	jmp	SHORT $LN28@BeginCombo
$LN27@BeginCombo:
	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movss	DWORD PTR tv89[rsp], xmm0
$LN28@BeginCombo:
	movss	xmm0, DWORD PTR tv89[rsp]
	movss	DWORD PTR w$[rsp], xmm0

; 1610 : 
; 1611 : 	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR w$[rsp]
	lea	rcx, QWORD PTR $T25[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T5[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1612 : 	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN29@BeginCombo
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	addss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR tv151[rsp], xmm0
	jmp	SHORT $LN30@BeginCombo
$LN29@BeginCombo:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv151[rsp], xmm0
$LN30@BeginCombo:
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR tv151[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	lea	rcx, QWORD PTR $T7[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1613 : 	ItemSize(total_bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 1614 : 	if (!ItemAdd(total_bb, id, &frame_bb))

	lea	r8, QWORD PTR frame_bb$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@BeginCombo

; 1615 : 		return false;

	xor	al, al
	jmp	$LN1@BeginCombo
$LN3@BeginCombo:

; 1616 : 
; 1617 : 	bool hovered, held;
; 1618 : 	bool pressed = ButtonBehavior(frame_bb, id, &hovered, &held);

	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 1619 : 	bool popup_open = IsPopupOpen(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?IsPopupOpen@ImGui@@YA_NI@Z		; ImGui::IsPopupOpen
	mov	BYTE PTR popup_open$[rsp], al

; 1620 : 
; 1621 : 	const ImRect value_bb(frame_bb.Min, frame_bb.Max - ImVec2(arrow_size, 0.0f));

	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR arrow_size$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR value_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1622 : 	const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);

	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN31@BeginCombo
	mov	DWORD PTR tv190[rsp], 8
	jmp	SHORT $LN32@BeginCombo
$LN31@BeginCombo:
	mov	DWORD PTR tv190[rsp], 7
$LN32@BeginCombo:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv190[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR frame_col$[rsp], eax

; 1623 : 	RenderNavHighlight(frame_bb, id);

	mov	r8d, 1
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
	npad	1

; 1624 : 	if (!(flags & ImGuiComboFlags_NoPreview))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN4@BeginCombo

; 1625 : 		window->DrawList->AddRectFilled(frame_bb.Min, ImVec2(frame_bb.Max.x + 2, frame_bb.Max.y), frame_col, 4.f);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv212[rsp], rax
	movss	xmm0, DWORD PTR frame_bb$[rsp+8]
	addss	xmm0, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR frame_bb$[rsp+12]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv210[rsp], rax
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR frame_col$[rsp]
	mov	r8, QWORD PTR tv210[rsp]
	lea	rdx, QWORD PTR frame_bb$[rsp]
	mov	rcx, QWORD PTR tv212[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1
$LN4@BeginCombo:

; 1626 : 	if (!(flags & ImGuiComboFlags_NoArrowButton))

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	$LN5@BeginCombo

; 1627 : 	{
; 1628 : 		window->DrawList->AddRectFilled(ImVec2(frame_bb.Max.x - arrow_size, frame_bb.Min.y), frame_bb.Max + ImVec2(3.f, 0), GetColorU32((popup_open || hovered) ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 4.f, (w <= arrow_size) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Right);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv284[rsp], rax
	movss	xmm0, DWORD PTR arrow_size$[rsp]
	comiss	xmm0, DWORD PTR w$[rsp]
	jb	SHORT $LN33@BeginCombo
	mov	DWORD PTR tv218[rsp], 15
	jmp	SHORT $LN34@BeginCombo
$LN33@BeginCombo:
	mov	DWORD PTR tv218[rsp], 10
$LN34@BeginCombo:
	movzx	eax, BYTE PTR popup_open$[rsp]
	test	eax, eax
	jne	SHORT $LN35@BeginCombo
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	jne	SHORT $LN35@BeginCombo
	mov	DWORD PTR tv259[rsp], 7
	jmp	SHORT $LN36@BeginCombo
$LN35@BeginCombo:
	mov	DWORD PTR tv259[rsp], 8
$LN36@BeginCombo:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv259[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv282[rsp], eax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@40400000
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	lea	rcx, QWORD PTR $T12[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv280[rsp], rax
	movss	xmm0, DWORD PTR frame_bb$[rsp+8]
	subss	xmm0, DWORD PTR arrow_size$[rsp]
	movss	xmm2, DWORD PTR frame_bb$[rsp+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv278[rsp], rax
	mov	eax, DWORD PTR tv218[rsp]
	mov	DWORD PTR [rsp+40], eax
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv282[rsp]
	mov	r8, QWORD PTR tv280[rsp]
	mov	rdx, QWORD PTR tv278[rsp]
	mov	rcx, QWORD PTR tv284[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1

; 1629 : 		RenderArrow(ImVec2(frame_bb.Max.x - arrow_size + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y), ImGuiDir_Down);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR frame_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	movss	xmm1, DWORD PTR frame_bb$[rsp+8]
	subss	xmm1, DWORD PTR arrow_size$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	addss	xmm1, DWORD PTR [rax+56]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm2, DWORD PTR __real@3f800000
	mov	edx, 3
	mov	rcx, QWORD PTR [rax]
	call	?RenderArrow@ImGui@@YAXUImVec2@@HM@Z	; ImGui::RenderArrow
	npad	1
$LN5@BeginCombo:

; 1630 : 	}
; 1631 : 	RenderFrameBorder(frame_bb.Min, frame_bb.Max, style.FrameRounding);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR [rax+60]
	mov	rdx, QWORD PTR frame_bb$[rsp+8]
	mov	rcx, QWORD PTR frame_bb$[rsp]
	call	?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder
	npad	1

; 1632 : 	//
; 1633 : 	if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))

	cmp	QWORD PTR preview_value$[rsp], 0
	je	$LN6@BeginCombo
	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	$LN6@BeginCombo

; 1634 : 		RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max - ImVec2(0, 2), preview_value, NULL, NULL, ImVec2(0.0f, 0.0f));

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv335[rsp], rax
	movss	xmm2, DWORD PTR __real@40000000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR value_bb$[rsp+8]
	lea	rcx, QWORD PTR $T17[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv333[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	add	rax, 52					; 00000034H
	mov	r8, rax
	lea	rdx, QWORD PTR frame_bb$[rsp]
	lea	rcx, QWORD PTR $T18[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv331[rsp], rax
	mov	QWORD PTR [rsp+48], 0
	mov	rax, QWORD PTR tv335[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR preview_value$[rsp]
	mov	rdx, QWORD PTR tv333[rsp]
	mov	rcx, QWORD PTR tv331[rsp]
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
	npad	1
$LN6@BeginCombo:

; 1635 : 	//
; 1636 : 	if (label_size.x > 0)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN7@BeginCombo

; 1637 : 		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x + 2, frame_bb.Min.y + style.ItemInnerSpacing.y - 2), label);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR frame_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+80]
	subss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR frame_bb$[rsp+8]
	addss	xmm1, DWORD PTR [rax+76]
	addss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN7@BeginCombo:

; 1638 : 
; 1639 : 	if ((pressed || g.NavActivateId == id) && !popup_open)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	jne	SHORT $LN9@BeginCombo
	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax+7044], ecx
	jne	SHORT $LN8@BeginCombo
$LN9@BeginCombo:
	movzx	eax, BYTE PTR popup_open$[rsp]
	test	eax, eax
	jne	SHORT $LN8@BeginCombo

; 1640 : 	{
; 1641 : 		if (window->DC.NavLayerCurrent == 0)

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+400], 0
	jne	SHORT $LN10@BeginCombo

; 1642 : 			window->NavLastIds[0] = id;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR window$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	mov	DWORD PTR [rcx+rax+904], edx
$LN10@BeginCombo:

; 1643 : 		OpenPopupEx(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?OpenPopupEx@ImGui@@YAXI@Z		; ImGui::OpenPopupEx

; 1644 : 		popup_open = true;

	mov	BYTE PTR popup_open$[rsp], 1
$LN8@BeginCombo:

; 1645 : 	}
; 1646 : 
; 1647 : 	if (!popup_open)

	movzx	eax, BYTE PTR popup_open$[rsp]
	test	eax, eax
	jne	SHORT $LN11@BeginCombo

; 1648 : 		return false;

	xor	al, al
	jmp	$LN1@BeginCombo
$LN11@BeginCombo:

; 1649 : 
; 1650 : 	if (backup_next_window_size_constraint)

	cmp	DWORD PTR backup_next_window_size_constraint$[rsp], 0
	je	SHORT $LN12@BeginCombo

; 1651 : 	{
; 1652 : 		g.NextWindowData.SizeConstraintCond = backup_next_window_size_constraint;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR backup_next_window_size_constraint$[rsp]
	mov	DWORD PTR [rax+6920], ecx

; 1653 : 		g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);

	movss	xmm1, DWORD PTR w$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+7008]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR g$[rsp]
	movss	DWORD PTR [rax+7008], xmm0

; 1654 : 	}

	jmp	$LN13@BeginCombo
$LN12@BeginCombo:

; 1655 : 	else
; 1656 : 	{
; 1657 : 		if ((flags & ImGuiComboFlags_HeightMask_) == 0)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 30
	test	eax, eax
	jne	SHORT $LN14@BeginCombo

; 1658 : 			flags |= ImGuiComboFlags_HeightRegular;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 4
	mov	DWORD PTR flags$[rsp], eax
$LN14@BeginCombo:

; 1659 : 		IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_));    // Only one
; 1660 : 		int popup_max_height_in_items = -1;

	mov	DWORD PTR popup_max_height_in_items$1[rsp], -1

; 1661 : 		if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN15@BeginCombo
	mov	DWORD PTR popup_max_height_in_items$1[rsp], 8
	jmp	SHORT $LN16@BeginCombo
$LN15@BeginCombo:

; 1662 : 		else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN17@BeginCombo
	mov	DWORD PTR popup_max_height_in_items$1[rsp], 4
	jmp	SHORT $LN18@BeginCombo
$LN17@BeginCombo:

; 1663 : 		else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN19@BeginCombo
	mov	DWORD PTR popup_max_height_in_items$1[rsp], 20
$LN19@BeginCombo:
$LN18@BeginCombo:
$LN16@BeginCombo:

; 1664 : 		SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));

	mov	ecx, DWORD PTR popup_max_height_in_items$1[rsp]
	call	?CalcMaxPopupHeightFromItemCount@@YAMH@Z ; CalcMaxPopupHeightFromItemCount
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR __real@7f7fffff
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv408[rsp], rax
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR w$[rsp]
	lea	rcx, QWORD PTR $T21[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv406[rsp], rax
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv408[rsp]
	mov	rcx, QWORD PTR tv406[rsp]
	call	?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z ; ImGui::SetNextWindowSizeConstraints
	npad	1
$LN13@BeginCombo:

; 1665 : 	}
; 1666 : 
; 1667 : 	char name[16];
; 1668 : 	ImFormatString(name, IM_ARRAYSIZE(name), "##+-C.o.m.b.o_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth

	mov	rax, QWORD PTR g$[rsp]
	mov	r9d, DWORD PTR [rax+6888]
	lea	r8, OFFSET FLAT:??_C@_0BD@JMKMPHNG@?$CD?$CD?$CL?9C?4o?4m?4b?4o_?$CF02d@
	mov	edx, 16
	lea	rcx, QWORD PTR name$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	npad	1

; 1669 : 
; 1670 : 	// Peak into expected window size so we can position it
; 1671 : 	if (ImGuiWindow* popup_window = FindWindowByName(name))

	lea	rcx, QWORD PTR name$[rsp]
	call	?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z ; ImGui::FindWindowByName
	mov	QWORD PTR popup_window$2[rsp], rax
	cmp	QWORD PTR popup_window$2[rsp], 0
	je	$LN20@BeginCombo

; 1672 : 		if (popup_window->WasActive)

	mov	rax, QWORD PTR popup_window$2[rsp]
	movzx	eax, BYTE PTR [rax+132]
	test	eax, eax
	je	$LN21@BeginCombo

; 1673 : 		{
; 1674 : 			ImVec2 size_expected = CalcWindowExpectedSize(popup_window);

	mov	rdx, QWORD PTR popup_window$2[rsp]
	lea	rcx, QWORD PTR size_expected$3[rsp]
	call	?CalcWindowExpectedSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ; ImGui::CalcWindowExpectedSize
	npad	1

; 1675 : 			if (flags & ImGuiComboFlags_PopupAlignLeft)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN22@BeginCombo

; 1676 : 				popup_window->AutoPosLastDirection = ImGuiDir_Left;

	mov	rax, QWORD PTR popup_window$2[rsp]
	mov	DWORD PTR [rax+184], 0
$LN22@BeginCombo:

; 1677 : 			ImRect r_outer = GetWindowAllowedExtentRect(popup_window);

	mov	rdx, QWORD PTR popup_window$2[rsp]
	lea	rcx, QWORD PTR r_outer$26[rsp]
	call	?GetWindowAllowedExtentRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@@Z ; ImGui::GetWindowAllowedExtentRect
	npad	1

; 1678 : 			ImVec2 pos = FindBestWindowPosForPopupEx(frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, frame_bb, ImGuiPopupPositionPolicy_ComboBox);

	mov	rax, QWORD PTR popup_window$2[rsp]
	add	rax, 184				; 000000b8H
	mov	QWORD PTR tv432[rsp], rax
	lea	rdx, QWORD PTR $T22[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	call	?GetBL@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetBL
	mov	DWORD PTR [rsp+48], 1
	lea	rcx, QWORD PTR frame_bb$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, QWORD PTR r_outer$26[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR tv432[rsp]
	mov	r9, rcx
	lea	r8, QWORD PTR size_expected$3[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR pos$4[rsp]
	call	?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z ; ImGui::FindBestWindowPosForPopupEx
	npad	1

; 1679 : 			SetNextWindowPos(pos);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	xor	edx, edx
	lea	rcx, QWORD PTR pos$4[rsp]
	call	?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z ; ImGui::SetNextWindowPos
	npad	1
$LN21@BeginCombo:
$LN20@BeginCombo:

; 1680 : 		}
; 1681 : 
; 1682 : 	// Horizontally align ourselves with the framed text
; 1683 : 	ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize/* | ImGuiWindowFlags_NoSavedSettings*/;

	mov	DWORD PTR window_flags$[rsp], 67108931	; 04000043H

; 1684 : 	PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(style.FramePadding.x, style.WindowPadding.y));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+52]
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	mov	ecx, 1
	call	?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z	; ImGui::PushStyleVar
	npad	1

; 1685 : 	bool ret = Begin(name, NULL, window_flags);

	mov	r8d, DWORD PTR window_flags$[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR name$[rsp]
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin
	mov	BYTE PTR ret$[rsp], al

; 1686 : 	PopStyleVar();

	mov	ecx, 1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	npad	1

; 1687 : 	if (!ret)

	movzx	eax, BYTE PTR ret$[rsp]
	test	eax, eax
	jne	SHORT $LN23@BeginCombo

; 1688 : 	{
; 1689 : 		EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup

; 1690 : 		IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above
; 1691 : 		return false;

	xor	al, al
	jmp	SHORT $LN1@BeginCombo
$LN23@BeginCombo:

; 1692 : 	}
; 1693 : 	return true;

	mov	al, 1
$LN1@BeginCombo:

; 1694 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 552				; 00000228H
	ret	0
?BeginCombo@ImGui@@YA_NPEBD0H@Z ENDP			; ImGui::BeginCombo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 32
line_height$ = 40
window$ = 48
tv88 = 56
tv86 = 60
style$ = 64
bb$ = 72
$T1 = 88
$T2 = 96
$T3 = 104
$T4 = 112
?Bullet@ImGui@@YAXXZ PROC				; ImGui::Bullet

; 1372 : {

$LN5:
	sub	rsp, 136				; 00000088H

; 1373 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1374 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@Bullet

; 1375 : 		return;

	jmp	$LN1@Bullet
$LN2@Bullet:

; 1376 : 
; 1377 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1378 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 1379 : 	const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y * 2), g.FontSize);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv88[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5528]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+324]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR tv86[rsp], xmm0
	movss	xmm1, DWORD PTR tv88[rsp]
	movss	xmm0, DWORD PTR tv86[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR line_height$[rsp], xmm0

; 1380 : 	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));

	movss	xmm2, DWORD PTR line_height$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1381 : 	ItemSize(bb);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 1382 : 	if (!ItemAdd(bb, 0))

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@Bullet

; 1383 : 	{
; 1384 : 		SameLine(0, style.FramePadding.x * 2);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	mulss	xmm0, DWORD PTR __real@40000000
	xorps	xmm2, xmm2
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1

; 1385 : 		return;

	jmp	SHORT $LN1@Bullet
$LN3@Bullet:

; 1386 : 	}
; 1387 : 
; 1388 : 	// Render and stay on same line
; 1389 : 	RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize * 0.5f, line_height * 0.5f));

	movss	xmm0, DWORD PTR line_height$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	mulss	xmm1, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR [rax+52]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR bb$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR [rax]
	call	?RenderBullet@ImGui@@YAXUImVec2@@@Z	; ImGui::RenderBullet
	npad	1

; 1390 : 	SameLine(0, style.FramePadding.x * 2);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	mulss	xmm0, DWORD PTR __real@40000000
	xorps	xmm2, xmm2
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1
$LN1@Bullet:

; 1391 : }

	add	rsp, 136				; 00000088H
	ret	0
?Bullet@ImGui@@YAXXZ ENDP				; ImGui::Bullet
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
style$ = 64
bb$ = 72
tv91 = 88
tv88 = 92
tv152 = 96
tv150 = 100
tv186 = 104
tv184 = 108
tv223 = 112
window$ = 120
overlay_size$ = 128
g$ = 136
pos$ = 144
$T1 = 152
$T2 = 160
tv182 = 168
fill_br$ = 176
tv230 = 184
tv228 = 192
$T3 = 200
$T4 = 208
$T5 = 216
$T6 = 224
$T7 = 232
overlay_buf$ = 240
__$ArrayPad$ = 272
fraction$ = 304
size_arg$ = 312
overlay$ = 320
?ProgressBar@ImGui@@YAXMAEBUImVec2@@PEBD@Z PROC		; ImGui::ProgressBar

; 1337 : {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 296				; 00000128H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1338 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1339 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@ProgressBa

; 1340 : 		return;

	jmp	$LN1@ProgressBa
$LN2@ProgressBa:

; 1341 : 
; 1342 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1343 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 1344 : 
; 1345 : 	ImVec2 pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR pos$[rsp], rax

; 1346 : 	ImRect bb(pos, pos + CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y * 2.0f));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv91[rsp], xmm0
	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movss	DWORD PTR tv88[rsp], xmm0
	mov	rax, QWORD PTR size_arg$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T2[rsp], rax
	movss	xmm3, DWORD PTR tv91[rsp]
	movss	xmm2, DWORD PTR tv88[rsp]
	mov	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1347 : 	ItemSize(bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 1348 : 	if (!ItemAdd(bb, 0))

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@ProgressBa

; 1349 : 		return;

	jmp	$LN1@ProgressBa
$LN3@ProgressBa:

; 1350 : 
; 1351 : 	// Render
; 1352 : 	fraction = ImSaturate(fraction);

	movss	xmm0, DWORD PTR fraction$[rsp]
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR fraction$[rsp], xmm0

; 1353 : 	RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	movss	DWORD PTR tv152[rsp], xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 7
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv150[rsp], eax
	movss	xmm0, DWORD PTR tv152[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	r8d, DWORD PTR tv150[rsp]
	mov	rdx, QWORD PTR bb$[rsp+8]
	mov	rcx, QWORD PTR bb$[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	npad	1

; 1354 : 	bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+64]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+64]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, QWORD PTR bb$[rsp]
	call	?Expand@ImRect@@QEAAXAEBUImVec2@@@Z	; ImRect::Expand
	npad	1

; 1355 : 	const ImVec2 fill_br = ImVec2(ImLerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);

	movss	xmm2, DWORD PTR fraction$[rsp]
	movss	xmm1, DWORD PTR bb$[rsp+8]
	movss	xmm0, DWORD PTR bb$[rsp]
	call	??$ImLerp@M@@YAMMMM@Z			; ImLerp<float>
	movss	xmm2, DWORD PTR bb$[rsp+12]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR fill_br$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 1356 : 	RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), 0.0f, fraction, style.FrameRounding);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	movss	DWORD PTR tv186[rsp], xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 40					; 00000028H
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv184[rsp], eax
	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv182[rsp], rax
	movss	xmm0, DWORD PTR tv186[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	movss	xmm0, DWORD PTR fraction$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	mov	r8d, DWORD PTR tv184[rsp]
	lea	rdx, QWORD PTR bb$[rsp]
	mov	rcx, QWORD PTR tv182[rsp]
	call	?RenderRectFilledRangeH@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@IMMM@Z ; ImGui::RenderRectFilledRangeH
	npad	1

; 1357 : 
; 1358 : 	// Default displaying the fraction as percentage string, but user can override it
; 1359 : 	char overlay_buf[32];
; 1360 : 	if (!overlay)

	cmp	QWORD PTR overlay$[rsp], 0
	jne	SHORT $LN4@ProgressBa

; 1361 : 	{
; 1362 : 		ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), ("%.0f%%"), fraction * 100 + 0.01f);

	movss	xmm0, DWORD PTR fraction$[rsp]
	mulss	xmm0, DWORD PTR __real@42c80000
	addss	xmm0, DWORD PTR __real@3c23d70a
	cvtss2sd xmm0, xmm0
	movaps	xmm3, xmm0
	movq	r9, xmm3
	lea	r8, OFFSET FLAT:??_C@_06KLKJBGEJ@?$CF?40f?$CF?$CF@
	mov	edx, 32					; 00000020H
	lea	rcx, QWORD PTR overlay_buf$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 1363 : 		overlay = overlay_buf;

	lea	rax, QWORD PTR overlay_buf$[rsp]
	mov	QWORD PTR overlay$[rsp], rax
$LN4@ProgressBa:

; 1364 : 	}
; 1365 : 
; 1366 : 	ImVec2 overlay_size = CalcTextSize(overlay, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, QWORD PTR overlay$[rsp]
	lea	rcx, QWORD PTR overlay_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	npad	1

; 1367 : 	if (overlay_size.x > 0.0f)

	movss	xmm0, DWORD PTR overlay_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN5@ProgressBa

; 1368 : 		RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f, 0.5f), &bb);

	movss	xmm2, DWORD PTR __real@3f000000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv230[rsp], rax
	movss	xmm0, DWORD PTR bb$[rsp+8]
	subss	xmm0, DWORD PTR overlay_size$[rsp]
	mov	rax, QWORD PTR style$[rsp]
	subss	xmm0, DWORD PTR [rax+76]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR fill_br$[rsp]
	addss	xmm1, DWORD PTR [rax+68]
	movss	DWORD PTR tv223[rsp], xmm1
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR bb$[rsp]
	movss	xmm0, DWORD PTR tv223[rsp]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	xmm2, DWORD PTR bb$[rsp+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv228[rsp], rax
	lea	rax, QWORD PTR bb$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR tv230[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR overlay_size$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR overlay$[rsp]
	lea	rdx, QWORD PTR bb$[rsp+8]
	mov	rcx, QWORD PTR tv228[rsp]
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
	npad	1
$LN5@ProgressBa:
$LN1@ProgressBa:

; 1369 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 296				; 00000128H
	ret	0
?ProgressBar@ImGui@@YAXMAEBUImVec2@@PEBD@Z ENDP		; ImGui::ProgressBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv66 = 32
pressed$ = 33
label$ = 64
v$ = 72
v_button$ = 80
?RadioButton@ImGui@@YA_NPEBDPEAHH@Z PROC		; ImGui::RadioButton

; 1328 : {

$LN6:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1329 : 	const bool pressed = RadioButton(label, *v == v_button);

	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_button$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN4@RadioButto
	mov	BYTE PTR tv66[rsp], 1
	jmp	SHORT $LN5@RadioButto
$LN4@RadioButto:
	mov	BYTE PTR tv66[rsp], 0
$LN5@RadioButto:
	movzx	edx, BYTE PTR tv66[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?RadioButton@ImGui@@YA_NPEBD_N@Z	; ImGui::RadioButton
	mov	BYTE PTR pressed$[rsp], al

; 1330 : 	if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN2@RadioButto

; 1331 : 		*v = v_button;

	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR v_button$[rsp]
	mov	DWORD PTR [rax], ecx
$LN2@RadioButto:

; 1332 : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]

; 1333 : }

	add	rsp, 56					; 00000038H
	ret	0
?RadioButton@ImGui@@YA_NPEBDPEAHH@Z ENDP		; ImGui::RadioButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
hovered$ = 48
pressed$ = 49
held$ = 50
square_sz$ = 52
id$ = 56
radius$ = 60
style$ = 64
center$ = 72
window$ = 80
tv139 = 88
tv191 = 92
tv192 = 96
pos$ = 104
label_size$ = 112
tv143 = 120
tv198 = 124
pad$1 = 128
tv221 = 132
tv250 = 136
tv248 = 140
tv267 = 144
tv265 = 148
total_bb$ = 152
g$ = 168
tv200 = 176
tv223 = 184
tv246 = 192
tv252 = 200
tv269 = 208
check_bb$ = 216
$T2 = 232
$T3 = 240
$T4 = 248
$T5 = 256
$T6 = 264
$T7 = 272
$T8 = 280
label$ = 304
active$ = 312
?RadioButton@ImGui@@YA_NPEBD_N@Z PROC			; ImGui::RadioButton

; 1277 : {

$LN15:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 296				; 00000128H

; 1278 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1279 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@RadioButto

; 1280 : 		return false;

	xor	al, al
	jmp	$LN1@RadioButto
$LN2@RadioButto:

; 1281 : 
; 1282 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1283 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 1284 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 1285 : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 1286 : 
; 1287 : 	const float square_sz = GetFrameHeight();

	call	?GetFrameHeight@ImGui@@YAMXZ		; ImGui::GetFrameHeight
	movss	DWORD PTR square_sz$[rsp], xmm0

; 1288 : 	const ImVec2 pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR pos$[rsp], rax

; 1289 : 	const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));

	movss	xmm2, DWORD PTR square_sz$[rsp]
	movss	xmm1, DWORD PTR square_sz$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR check_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1290 : 	const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv143[rsp], xmm0
	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN9@RadioButto
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	addss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR tv139[rsp], xmm0
	jmp	SHORT $LN10@RadioButto
$LN9@RadioButto:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv139[rsp], xmm0
$LN10@RadioButto:
	movss	xmm0, DWORD PTR square_sz$[rsp]
	addss	xmm0, DWORD PTR tv139[rsp]
	movss	xmm2, DWORD PTR tv143[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1291 : 	ItemSize(total_bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 1292 : 	if (!ItemAdd(total_bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@RadioButto

; 1293 : 		return false;

	xor	al, al
	jmp	$LN1@RadioButto
$LN3@RadioButto:

; 1294 : 
; 1295 : 	ImVec2 center = check_bb.GetCenter();

	lea	rdx, QWORD PTR center$[rsp]
	lea	rcx, QWORD PTR check_bb$[rsp]
	call	?GetCenter@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetCenter

; 1296 : 	center.x = (float)(int)center.x + 0.5f;

	cvttss2si eax, DWORD PTR center$[rsp]
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR center$[rsp], xmm0

; 1297 : 	center.y = (float)(int)center.y + 0.5f;

	cvttss2si eax, DWORD PTR center$[rsp+4]
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR center$[rsp+4], xmm0

; 1298 : 	const float radius = (square_sz - 1.0f) * 0.5f;

	movss	xmm0, DWORD PTR square_sz$[rsp]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR radius$[rsp], xmm0

; 1299 : 
; 1300 : 	bool hovered, held;
; 1301 : 	bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 1302 : 	if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN4@RadioButto

; 1303 : 		MarkItemEdited(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN4@RadioButto:

; 1304 : 
; 1305 : 	RenderNavHighlight(total_bb, id);

	mov	r8d, 1
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 1306 : 	window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 16);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv200[rsp], rax
	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN11@RadioButto
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN11@RadioButto
	mov	DWORD PTR tv192[rsp], 9
	jmp	SHORT $LN14@RadioButto
$LN11@RadioButto:
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN12@RadioButto
	mov	DWORD PTR tv191[rsp], 8
	jmp	SHORT $LN13@RadioButto
$LN12@RadioButto:
	mov	DWORD PTR tv191[rsp], 7
$LN13@RadioButto:
	mov	eax, DWORD PTR tv191[rsp]
	mov	DWORD PTR tv192[rsp], eax
$LN14@RadioButto:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv192[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv198[rsp], eax
	mov	DWORD PTR [rsp+32], 16
	mov	r9d, DWORD PTR tv198[rsp]
	movss	xmm2, DWORD PTR radius$[rsp]
	lea	rdx, QWORD PTR center$[rsp]
	mov	rcx, QWORD PTR tv200[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1307 : 	if (active)

	movzx	eax, BYTE PTR active$[rsp]
	test	eax, eax
	je	$LN5@RadioButto

; 1308 : 	{
; 1309 : 		const float pad = ImMax(1.0f, (float)(int)(square_sz / 6.0f));

	movss	xmm0, DWORD PTR square_sz$[rsp]
	divss	xmm0, DWORD PTR __real@40c00000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR pad$1[rsp], xmm0

; 1310 : 		window->DrawList->AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark), 16);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv223[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 18
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv221[rsp], eax
	movss	xmm0, DWORD PTR radius$[rsp]
	subss	xmm0, DWORD PTR pad$1[rsp]
	mov	DWORD PTR [rsp+32], 16
	mov	r9d, DWORD PTR tv221[rsp]
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR center$[rsp]
	mov	rcx, QWORD PTR tv223[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1
$LN5@RadioButto:

; 1311 : 	}
; 1312 : 
; 1313 : 	if (style.FrameBorderSize > 0.0f)

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+64]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN6@RadioButto

; 1314 : 	{
; 1315 : 		window->DrawList->AddCircle(center + ImVec2(1, 1), radius, GetColorU32(ImGuiCol_BorderShadow), 16, style.FrameBorderSize);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv252[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+64]
	movss	DWORD PTR tv250[rsp], xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 6
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv248[rsp], eax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR center$[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv246[rsp], rax
	movss	xmm0, DWORD PTR tv250[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], 16
	mov	r9d, DWORD PTR tv248[rsp]
	movss	xmm2, DWORD PTR radius$[rsp]
	mov	rdx, QWORD PTR tv246[rsp]
	mov	rcx, QWORD PTR tv252[rsp]
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
	npad	1

; 1316 : 		window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), 16, style.FrameBorderSize);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv269[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+64]
	movss	DWORD PTR tv267[rsp], xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 5
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv265[rsp], eax
	movss	xmm0, DWORD PTR tv267[rsp]
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], 16
	mov	r9d, DWORD PTR tv265[rsp]
	movss	xmm2, DWORD PTR radius$[rsp]
	lea	rdx, QWORD PTR center$[rsp]
	mov	rcx, QWORD PTR tv269[rsp]
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
	npad	1
$LN6@RadioButto:

; 1317 : 	}
; 1318 : 
; 1319 : 	/*if (g.LogEnabled)
; 1320 : 		LogRenderedText(&total_bb.Min, active ? ("(x)") : ("( )"));*/
; 1321 : 	if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN7@RadioButto

; 1322 : 		RenderText(ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y), label);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	addss	xmm1, DWORD PTR [rax+76]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN7@RadioButto:

; 1323 : 
; 1324 : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@RadioButto:

; 1325 : }

	add	rsp, 296				; 00000128H
	ret	0
?RadioButton@ImGui@@YA_NPEBD_N@Z ENDP			; ImGui::RadioButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
v$ = 32
pressed$ = 33
tv66 = 36
label$ = 64
flags$ = 72
flags_value$ = 80
?CheckboxFlags@ImGui@@YA_NPEBDPEAII@Z PROC		; ImGui::CheckboxFlags

; 1262 : {

$LN8:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1263 : 	bool v = ((*flags & flags_value) == flags_value);

	mov	rax, QWORD PTR flags$[rsp]
	mov	ecx, DWORD PTR flags_value$[rsp]
	mov	eax, DWORD PTR [rax]
	and	eax, ecx
	cmp	eax, DWORD PTR flags_value$[rsp]
	jne	SHORT $LN6@CheckboxFl
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN7@CheckboxFl
$LN6@CheckboxFl:
	mov	DWORD PTR tv66[rsp], 0
$LN7@CheckboxFl:
	movzx	eax, BYTE PTR tv66[rsp]
	mov	BYTE PTR v$[rsp], al

; 1264 : 	bool pressed = Checkbox(label, &v);

	lea	rdx, QWORD PTR v$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z	; ImGui::Checkbox
	mov	BYTE PTR pressed$[rsp], al

; 1265 : 	if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN2@CheckboxFl

; 1266 : 	{
; 1267 : 		if (v)

	movzx	eax, BYTE PTR v$[rsp]
	test	eax, eax
	je	SHORT $LN3@CheckboxFl

; 1268 : 			*flags |= flags_value;

	mov	rax, QWORD PTR flags$[rsp]
	mov	ecx, DWORD PTR flags_value$[rsp]
	mov	eax, DWORD PTR [rax]
	or	eax, ecx
	mov	rcx, QWORD PTR flags$[rsp]
	mov	DWORD PTR [rcx], eax
	jmp	SHORT $LN4@CheckboxFl
$LN3@CheckboxFl:

; 1269 : 		else
; 1270 : 			*flags &= ~flags_value;

	mov	eax, DWORD PTR flags_value$[rsp]
	not	eax
	mov	rcx, QWORD PTR flags$[rsp]
	mov	ecx, DWORD PTR [rcx]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR flags$[rsp]
	mov	DWORD PTR [rcx], eax
$LN4@CheckboxFl:
$LN2@CheckboxFl:

; 1271 : 	}
; 1272 : 
; 1273 : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]

; 1274 : }

	add	rsp, 56					; 00000038H
	ret	0
?CheckboxFlags@ImGui@@YA_NPEBDPEAII@Z ENDP		; ImGui::CheckboxFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
held$ = 48
hovered$ = 49
pressed$ = 50
radius$ = 52
pos$ = 56
square_sz$ = 64
id$ = 68
width$ = 72
window$ = 80
t$ = 88
tv148 = 92
tv177 = 96
tv185 = 100
t_anim$1 = 104
tv206 = 108
tv219 = 112
tv220 = 116
style$ = 120
g$ = 128
label_size$ = 136
tv152 = 144
tv236 = 148
tv234 = 152
center$ = 160
backgroup_max$ = 168
total_bb$ = 176
ANIM_SPEED$ = 192
tv232 = 200
tv238 = 208
tv251 = 216
tv307 = 224
tv309 = 232
tv325 = 240
tv327 = 248
check_bb$ = 256
$T2 = 272
$T3 = 280
$T4 = 288
$T5 = 296
$T6 = 304
$T7 = 312
$T8 = 320
$T9 = 328
$T10 = 336
label$ = 368
v$ = 376
x_offset$ = 384
y_offset$ = 392
text_spacing_offset$ = 400
?ToggleButton@ImGui@@YA_NPEBDPEA_NMMM@Z PROC		; ImGui::ToggleButton

; 1202 : {

$LN22:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 360				; 00000168H

; 1203 : 
; 1204 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1205 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@ToggleButt

; 1206 : 		return false;

	xor	al, al
	jmp	$LN1@ToggleButt
$LN2@ToggleButt:

; 1207 : 
; 1208 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1209 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 1210 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 1211 : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 1212 : 
; 1213 : 	float square_sz = ImGui::GetFrameHeight();

	call	?GetFrameHeight@ImGui@@YAMXZ		; ImGui::GetFrameHeight
	movss	DWORD PTR square_sz$[rsp], xmm0

; 1214 : 	const ImVec2 pos = window->DC.CursorPos + ImVec2(x_offset, y_offset);

	movss	xmm2, DWORD PTR y_offset$[rsp]
	movss	xmm1, DWORD PTR x_offset$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR pos$[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	npad	1

; 1215 : 	const float width = square_sz * 1.70f;

	movss	xmm0, DWORD PTR square_sz$[rsp]
	mulss	xmm0, DWORD PTR __real@3fd9999a
	movss	DWORD PTR width$[rsp], xmm0

; 1216 : 	const float radius = square_sz * 0.50f;

	movss	xmm0, DWORD PTR square_sz$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR radius$[rsp], xmm0

; 1217 : 	const ImRect check_bb(pos, pos + ImVec2(width, square_sz));

	movss	xmm2, DWORD PTR square_sz$[rsp]
	movss	xmm1, DWORD PTR width$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR check_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1218 : 	const ImRect total_bb(pos, pos + ImVec2(width + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + text_spacing_offset + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv152[rsp], xmm0
	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN10@ToggleButt
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	addss	xmm0, DWORD PTR text_spacing_offset$[rsp]
	addss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR tv148[rsp], xmm0
	jmp	SHORT $LN11@ToggleButt
$LN10@ToggleButt:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv148[rsp], xmm0
$LN11@ToggleButt:
	movss	xmm0, DWORD PTR width$[rsp]
	addss	xmm0, DWORD PTR tv148[rsp]
	movss	xmm2, DWORD PTR tv152[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1219 : 	ItemSize(total_bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 1220 : 	if (!ItemAdd(total_bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@ToggleButt

; 1221 : 		return false;

	xor	al, al
	jmp	$LN1@ToggleButt
$LN3@ToggleButt:

; 1222 : 
; 1223 : 	bool hovered, held;
; 1224 : 	bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 1225 : 	if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN4@ToggleButt

; 1226 : 	{
; 1227 : 		*v = !(*v);

	mov	rax, QWORD PTR v$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN12@ToggleButt
	mov	DWORD PTR tv177[rsp], 1
	jmp	SHORT $LN13@ToggleButt
$LN12@ToggleButt:
	mov	DWORD PTR tv177[rsp], 0
$LN13@ToggleButt:
	mov	rax, QWORD PTR v$[rsp]
	movzx	ecx, BYTE PTR tv177[rsp]
	mov	BYTE PTR [rax], cl

; 1228 : 		MarkItemEdited(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN4@ToggleButt:

; 1229 : 	}
; 1230 : 	RenderNavHighlight(total_bb, id);

	mov	r8d, 1
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 1231 : 
; 1232 : 	float t = *v ? 1.0f : 0.0f;

	mov	rax, QWORD PTR v$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN14@ToggleButt
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv185[rsp], xmm0
	jmp	SHORT $LN15@ToggleButt
$LN14@ToggleButt:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv185[rsp], xmm0
$LN15@ToggleButt:
	movss	xmm0, DWORD PTR tv185[rsp]
	movss	DWORD PTR t$[rsp], xmm0

; 1233 : 	constexpr float ANIM_SPEED = 0.1f;

	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR ANIM_SPEED$[rsp], xmm0

; 1234 : 
; 1235 : 	if (held && hovered) g.LastActiveIdTimer = 0;

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN5@ToggleButt
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN5@ToggleButt
	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+6828], xmm0
$LN5@ToggleButt:

; 1236 : 
; 1237 : 	if (g.LastActiveId == window->GetID(label) && !held) // && g.LastActiveIdTimer < ANIM_SPEED)

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	rcx, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rcx+6824], eax
	jne	SHORT $LN6@ToggleButt
	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	jne	SHORT $LN6@ToggleButt

; 1238 : 	{
; 1239 : 		float t_anim = ImSaturate(g.LastActiveIdTimer / ANIM_SPEED);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6828]
	divss	xmm0, DWORD PTR __real@3dcccccd
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	movss	DWORD PTR t_anim$1[rsp], xmm0

; 1240 : 		t = *v ? (t_anim) : (1.0f - t_anim);

	mov	rax, QWORD PTR v$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN16@ToggleButt
	movss	xmm0, DWORD PTR t_anim$1[rsp]
	movss	DWORD PTR tv206[rsp], xmm0
	jmp	SHORT $LN17@ToggleButt
$LN16@ToggleButt:
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR t_anim$1[rsp]
	movss	DWORD PTR tv206[rsp], xmm0
$LN17@ToggleButt:
	movss	xmm0, DWORD PTR tv206[rsp]
	movss	DWORD PTR t$[rsp], xmm0
$LN6@ToggleButt:

; 1241 : 	}
; 1242 : 
; 1243 : 	window->DrawList->AddRectFilled(pos, ImVec2(pos.x + width, pos.y + square_sz),

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv238[rsp], rax
	movss	xmm0, DWORD PTR radius$[rsp]
	movss	DWORD PTR tv236[rsp], xmm0
	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN18@ToggleButt
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN18@ToggleButt
	mov	DWORD PTR tv220[rsp], 9
	jmp	SHORT $LN21@ToggleButt
$LN18@ToggleButt:
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN19@ToggleButt
	mov	DWORD PTR tv219[rsp], 8
	jmp	SHORT $LN20@ToggleButt
$LN19@ToggleButt:
	mov	DWORD PTR tv219[rsp], 7
$LN20@ToggleButt:
	mov	eax, DWORD PTR tv219[rsp]
	mov	DWORD PTR tv220[rsp], eax
$LN21@ToggleButt:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv220[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv234[rsp], eax
	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR square_sz$[rsp]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, DWORD PTR width$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv232[rsp], rax
	mov	DWORD PTR [rsp+40], 15
	movss	xmm0, DWORD PTR tv236[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv234[rsp]
	mov	r8, QWORD PTR tv232[rsp]
	lea	rdx, QWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR tv238[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1

; 1244 : 		GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), radius);
; 1245 : 
; 1246 : 	const auto center = ImVec2(pos.x + radius, pos.y + radius);

	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR radius$[rsp]
	movss	xmm1, DWORD PTR pos$[rsp]
	addss	xmm1, DWORD PTR radius$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR center$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 1247 : 	window->DrawList->AddCircleFilled(center, radius, IM_COL32(199, 79, 13, 255), 16);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv251[rsp], rax
	mov	DWORD PTR [rsp+32], 16
	mov	r9d, -15904825				; ff0d4fc7H
	movss	xmm2, DWORD PTR radius$[rsp]
	lea	rdx, QWORD PTR center$[rsp]
	mov	rcx, QWORD PTR tv251[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled

; 1248 : 	const auto backgroup_max = ImVec2(pos.x + t * radius * 2.0f + 2.0f, pos.y + square_sz);

	movss	xmm0, DWORD PTR pos$[rsp+4]
	addss	xmm0, DWORD PTR square_sz$[rsp]
	movss	xmm1, DWORD PTR t$[rsp]
	mulss	xmm1, DWORD PTR radius$[rsp]
	mulss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR pos$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR backgroup_max$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 1249 : 	if (backgroup_max.x > pos.x + radius)

	movss	xmm0, DWORD PTR pos$[rsp]
	addss	xmm0, DWORD PTR radius$[rsp]
	movss	xmm1, DWORD PTR backgroup_max$[rsp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN7@ToggleButt

; 1250 : 	{
; 1251 : 		window->DrawList->AddRectFilled(ImVec2(pos.x + radius, pos.y), backgroup_max, IM_COL32(199, 79, 13, 255));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv309[rsp], rax
	movss	xmm0, DWORD PTR pos$[rsp]
	addss	xmm0, DWORD PTR radius$[rsp]
	movss	xmm2, DWORD PTR pos$[rsp+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv307[rsp], rax
	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, -15904825				; ff0d4fc7H
	lea	r8, QWORD PTR backgroup_max$[rsp]
	mov	rdx, QWORD PTR tv307[rsp]
	mov	rcx, QWORD PTR tv309[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1
$LN7@ToggleButt:

; 1252 : 	}
; 1253 : 	window->DrawList->AddCircleFilled(ImVec2(center.x + t * (width - radius * 2.0f), center.y), radius, IM_COL32(255, 255, 255, 255), 16);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv327[rsp], rax
	movss	xmm0, DWORD PTR radius$[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR width$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR t$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR center$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR center$[rsp+4]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv325[rsp], rax
	mov	DWORD PTR [rsp+32], 16
	mov	r9d, -1					; ffffffffH
	movss	xmm2, DWORD PTR radius$[rsp]
	mov	rdx, QWORD PTR tv325[rsp]
	mov	rcx, QWORD PTR tv327[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1254 : 
; 1255 : 	/*if (g.LogEnabled)
; 1256 : 		LogRenderedText(&total_bb.Min, *v ? ("[x]") : ("[ ]"));*/
; 1257 : 	if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN8@ToggleButt

; 1258 : 		RenderText(ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x + text_spacing_offset, check_bb.Min.y + style.FramePadding.y - 1.0f), label);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	addss	xmm1, DWORD PTR [rax+76]
	addss	xmm1, DWORD PTR text_spacing_offset$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN8@ToggleButt:

; 1259 : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@ToggleButt:

; 1260 : }

	add	rsp, 360				; 00000168H
	ret	0
?ToggleButton@ImGui@@YA_NPEBDPEA_NMMM@Z ENDP		; ImGui::ToggleButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
check_bb$ = 48
window$ = 64
ActiveColor$ = 72
UnActiveColor$ = 76
pressed$ = 80
held$ = 81
hovered$ = 82
style$ = 88
label_size$ = 96
id$ = 104
check_sz$ = 108
tv196 = 112
tv194 = 116
tv201 = 120
tv244 = 124
tv242 = 128
tv554 = 132
tv584 = 136
tv892 = 140
tv922 = 144
tv951 = 148
tv981 = 152
text_bb$ = 160
tv181 = 176
tv179 = 184
tv199 = 192
tv217 = 200
tv215 = 208
tv317 = 216
tv319 = 224
tv336 = 232
tv338 = 240
tv355 = 248
tv357 = 256
tv374 = 264
tv376 = 272
tv393 = 280
tv395 = 288
tv412 = 296
tv414 = 304
tv430 = 312
tv432 = 320
tv449 = 328
tv451 = 336
tv468 = 344
tv470 = 352
tv487 = 360
tv489 = 368
tv506 = 376
tv508 = 384
tv525 = 392
tv527 = 400
tv552 = 408
tv556 = 416
tv582 = 424
tv586 = 432
tv604 = 440
tv606 = 448
tv623 = 456
tv625 = 464
tv642 = 472
tv644 = 480
tv661 = 488
tv663 = 496
tv712 = 504
tv714 = 512
tv731 = 520
tv733 = 528
tv749 = 536
tv751 = 544
tv768 = 552
tv770 = 560
tv787 = 568
tv789 = 576
tv806 = 584
tv808 = 592
tv825 = 600
tv827 = 608
tv844 = 616
tv846 = 624
tv863 = 632
tv865 = 640
tv890 = 648
tv894 = 656
tv920 = 664
tv924 = 672
tv949 = 680
tv953 = 688
tv979 = 696
tv983 = 704
tv1002 = 712
tv1000 = 720
check_sz2$ = 728
pad$ = 732
total_bb$ = 736
$T1 = 752
$T2 = 760
$T3 = 768
$T4 = 776
$T5 = 784
$T6 = 792
$T7 = 800
$T8 = 808
$T9 = 816
$T10 = 824
$T11 = 832
$T12 = 840
$T13 = 848
$T14 = 856
$T15 = 864
$T16 = 872
$T17 = 880
$T18 = 888
$T19 = 896
$T20 = 904
$T21 = 912
$T22 = 920
$T23 = 928
$T24 = 936
$T25 = 944
$T26 = 952
$T27 = 960
$T28 = 968
$T29 = 976
$T30 = 984
$T31 = 992
$T32 = 1000
$T33 = 1008
$T34 = 1016
$T35 = 1024
$T36 = 1032
$T37 = 1040
$T38 = 1048
$T39 = 1056
$T40 = 1064
$T41 = 1072
$T42 = 1080
$T43 = 1088
g$ = 1096
pading$ = 1104
$T44 = 1112
$T45 = 1120
$T46 = 1136
$T47 = 1152
$T48 = 1168
$T49 = 1184
$T50 = 1200
$T51 = 1216
$T52 = 1232
$T53 = 1248
$S25$ = 1264
__$ArrayPad$ = 2208
label$ = 2256
v$ = 2264
?Checkbox2@ImGui@@YA_NPEBDPEAH@Z PROC			; ImGui::Checkbox2

; 1120 : {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 2232				; 000008b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1121 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1122 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@Checkbox2

; 1123 : 		return false;

	xor	al, al
	jmp	$LN1@Checkbox2
$LN2@Checkbox2:

; 1124 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1125 : 	const ImGuiStyle& style = ImGuiStyle::ImGuiStyle();

	lea	rcx, QWORD PTR $S25$[rsp]
	call	??0ImGuiStyle@@QEAA@XZ			; ImGuiStyle::ImGuiStyle
	lea	rax, QWORD PTR $S25$[rsp]
	mov	QWORD PTR style$[rsp], rax

; 1126 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 1127 : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 1128 : 	const ImVec2 pading = ImVec2(2, 2);

	movss	xmm2, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@40000000
	lea	rcx, QWORD PTR pading$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 1129 : 	const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.x * 6, label_size.y + style.FramePadding.y / 2));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+52]
	mulss	xmm1, DWORD PTR __real@40c00000
	movss	xmm2, DWORD PTR label_size$[rsp+4]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T44[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR check_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1130 : 	ItemSize(check_bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR check_bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize

; 1131 : 	ImRect total_bb = check_bb;

	lea	rax, QWORD PTR total_bb$[rsp]
	lea	rcx, QWORD PTR check_bb$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 1132 : 	if (label_size.x > 0)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@Checkbox2

; 1133 : 		SameLine(0, style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1
$LN3@Checkbox2:

; 1134 : 	const ImRect text_bb(window->DC.CursorPos + ImVec2(0, style.FramePadding.y), window->DC.CursorPos + ImVec2(0, style.FramePadding.y) + label_size);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR [rax+56]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T3[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	lea	r8, QWORD PTR label_size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv181[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR [rax+56]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv179[rsp], rax
	mov	r8, QWORD PTR tv181[rsp]
	mov	rdx, QWORD PTR tv179[rsp]
	lea	rcx, QWORD PTR text_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1135 : 	if (label_size.x > 0)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN4@Checkbox2

; 1136 : 	{
; 1137 : 		ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	movss	DWORD PTR tv201[rsp], xmm0
	lea	rcx, QWORD PTR check_bb$[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	DWORD PTR tv196[rsp], xmm0
	lea	rcx, QWORD PTR text_bb$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	DWORD PTR tv194[rsp], xmm0
	movss	xmm2, DWORD PTR tv196[rsp]
	movss	xmm1, DWORD PTR tv194[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv199[rsp], rax
	movss	xmm1, DWORD PTR tv201[rsp]
	mov	rcx, QWORD PTR tv199[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 1138 : 		total_bb = ImRect(ImMin(check_bb.Min, text_bb.Min), ImMax(check_bb.Max, text_bb.Max));

	lea	r8, QWORD PTR text_bb$[rsp+8]
	lea	rdx, QWORD PTR check_bb$[rsp+8]
	lea	rcx, QWORD PTR $T8[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	QWORD PTR tv217[rsp], rax
	lea	r8, QWORD PTR text_bb$[rsp]
	lea	rdx, QWORD PTR check_bb$[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	?ImMin@@YA?AUImVec2@@AEBU1@0@Z		; ImMin
	mov	QWORD PTR tv215[rsp], rax
	mov	r8, QWORD PTR tv217[rsp]
	mov	rdx, QWORD PTR tv215[rsp]
	lea	rcx, QWORD PTR $T45[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	lea	rcx, QWORD PTR total_bb$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN4@Checkbox2:

; 1139 : 	}
; 1140 : 	if (!ItemAdd(total_bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Checkbox2

; 1141 : 		return false;

	xor	al, al
	jmp	$LN1@Checkbox2
$LN5@Checkbox2:

; 1142 : 	bool hovered, held;
; 1143 : 	bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 1144 : 	if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN6@Checkbox2

; 1145 : 	{
; 1146 : 		if (*v)

	mov	rax, QWORD PTR v$[rsp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN7@Checkbox2

; 1147 : 		{
; 1148 : 			*v = 0;

	mov	rax, QWORD PTR v$[rsp]
	mov	DWORD PTR [rax], 0

; 1149 : 		}

	jmp	SHORT $LN8@Checkbox2
$LN7@Checkbox2:

; 1150 : 		else
; 1151 : 		{
; 1152 : 			*v = 1;

	mov	rax, QWORD PTR v$[rsp]
	mov	DWORD PTR [rax], 1
$LN8@Checkbox2:
$LN6@Checkbox2:

; 1153 : 		}
; 1154 : 	}
; 1155 : 	const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());

	lea	rcx, QWORD PTR check_bb$[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	DWORD PTR tv244[rsp], xmm0
	lea	rcx, QWORD PTR check_bb$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	DWORD PTR tv242[rsp], xmm0
	movss	xmm1, DWORD PTR tv244[rsp]
	movss	xmm0, DWORD PTR tv242[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR check_sz$[rsp], xmm0

; 1156 : 	const float check_sz2 = check_sz / 2;

	movss	xmm0, DWORD PTR check_sz$[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR check_sz2$[rsp], xmm0

; 1157 : 	const float pad = ImMax(1.0f, (float)(int)(check_sz / 4.f));

	movss	xmm0, DWORD PTR check_sz$[rsp]
	divss	xmm0, DWORD PTR __real@40800000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR pad$[rsp], xmm0

; 1158 : 	auto ActiveColor = GetColorU32(ImVec4(0.8549f, 0.3686f, 0.3686f, 1.0f));

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ebcb924
	movss	xmm2, DWORD PTR __real@3ebcb924
	movss	xmm1, DWORD PTR __real@3f5adaba
	lea	rcx, QWORD PTR $T46[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR ActiveColor$[rsp], eax

; 1159 : 	auto UnActiveColor = GetColorU32(ImVec4(0.4039f, 0.5725f, 0.4039f, 1.0f));

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ececbfb
	movss	xmm2, DWORD PTR __real@3f128f5c
	movss	xmm1, DWORD PTR __real@3ececbfb
	lea	rcx, QWORD PTR $T47[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR UnActiveColor$[rsp], eax

; 1160 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 6, check_bb.Min.y + 9), 7, UnActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv319[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40c00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv317[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR UnActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv317[rsp]
	mov	rcx, QWORD PTR tv319[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1161 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 5, check_bb.Min.y + 9), 7, UnActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv338[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40a00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv336[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR UnActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv336[rsp]
	mov	rcx, QWORD PTR tv338[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1162 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 4, check_bb.Min.y + 9), 7, UnActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv357[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv355[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR UnActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv355[rsp]
	mov	rcx, QWORD PTR tv357[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1163 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 3, check_bb.Min.y + 9), 7, UnActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv376[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40400000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv374[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR UnActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv374[rsp]
	mov	rcx, QWORD PTR tv376[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1164 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 2, check_bb.Min.y + 9), 7, UnActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv395[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv393[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR UnActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv393[rsp]
	mov	rcx, QWORD PTR tv395[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1165 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 1, check_bb.Min.y + 9), 7, UnActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv414[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv412[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR UnActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv412[rsp]
	mov	rcx, QWORD PTR tv414[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1166 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2, check_bb.Min.y + 9), 7, UnActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv432[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv430[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR UnActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv430[rsp]
	mov	rcx, QWORD PTR tv432[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1167 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 1, check_bb.Min.y + 9), 7, UnActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv451[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv449[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR UnActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv449[rsp]
	mov	rcx, QWORD PTR tv451[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1168 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 2, check_bb.Min.y + 9), 7, UnActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv470[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv468[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR UnActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv468[rsp]
	mov	rcx, QWORD PTR tv470[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1169 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 3, check_bb.Min.y + 9), 7, UnActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv489[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40400000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv487[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR UnActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv487[rsp]
	mov	rcx, QWORD PTR tv489[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1170 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 4, check_bb.Min.y + 9), 7, UnActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv508[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv506[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR UnActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv506[rsp]
	mov	rcx, QWORD PTR tv508[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1171 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 5, check_bb.Min.y + 9), 7, UnActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv527[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40a00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T21[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv525[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR UnActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv525[rsp]
	mov	rcx, QWORD PTR tv527[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1172 : 	window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 6, check_bb.Min.y + 9), 7, GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)), 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv556[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T48[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv554[rsp], eax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40c00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T22[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv552[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR tv554[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv552[rsp]
	mov	rcx, QWORD PTR tv556[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1173 : 	window->DrawList->AddCircle(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 6, check_bb.Min.y + 9), 7, GetColorU32(ImVec4(0.39f, 0.39f, 0.39f, 1.0f)), 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv586[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ec7ae14
	movss	xmm2, DWORD PTR __real@3ec7ae14
	movss	xmm1, DWORD PTR __real@3ec7ae14
	lea	rcx, QWORD PTR $T49[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv584[rsp], eax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40c00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv582[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR tv584[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv582[rsp]
	mov	rcx, QWORD PTR tv586[rsp]
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
	npad	1

; 1174 : 	if (*v)

	mov	rax, QWORD PTR v$[rsp]
	cmp	DWORD PTR [rax], 0
	je	$LN9@Checkbox2

; 1175 : 	{
; 1176 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 6, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv606[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40c00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv604[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv604[rsp]
	mov	rcx, QWORD PTR tv606[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1177 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 5, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv625[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40a00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T25[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv623[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv623[rsp]
	mov	rcx, QWORD PTR tv625[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1178 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 4, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv644[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv642[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv642[rsp]
	mov	rcx, QWORD PTR tv644[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1179 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 3, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv663[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40400000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T27[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv661[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv661[rsp]
	mov	rcx, QWORD PTR tv663[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1180 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 2, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv714[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T28[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv712[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv712[rsp]
	mov	rcx, QWORD PTR tv714[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1181 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 1, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv733[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T29[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv731[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv731[rsp]
	mov	rcx, QWORD PTR tv733[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1182 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv751[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T30[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv749[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv749[rsp]
	mov	rcx, QWORD PTR tv751[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1183 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 1, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv770[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T31[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv768[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv768[rsp]
	mov	rcx, QWORD PTR tv770[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1184 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 2, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv789[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40000000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T32[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv787[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv787[rsp]
	mov	rcx, QWORD PTR tv789[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1185 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 3, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv808[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40400000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T33[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv806[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv806[rsp]
	mov	rcx, QWORD PTR tv808[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1186 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 4, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv827[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T34[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv825[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv825[rsp]
	mov	rcx, QWORD PTR tv827[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1187 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 5, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv846[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40a00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T35[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv844[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv844[rsp]
	mov	rcx, QWORD PTR tv846[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1188 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 6, check_bb.Min.y + 9), 7, ActiveColor, 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv865[rsp], rax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40c00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T36[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv863[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR ActiveColor$[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv863[rsp]
	mov	rcx, QWORD PTR tv865[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1189 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 6, check_bb.Min.y + 9), 7, GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)), 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv894[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T50[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv892[rsp], eax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40c00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T37[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv890[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR tv892[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv890[rsp]
	mov	rcx, QWORD PTR tv894[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1190 : 		window->DrawList->AddCircle(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 + 6, check_bb.Min.y + 9), 7, GetColorU32(ImVec4(0.39f, 0.39f, 0.39f, 1.0f)), 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv924[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ec7ae14
	movss	xmm2, DWORD PTR __real@3ec7ae14
	movss	xmm1, DWORD PTR __real@3ec7ae14
	lea	rcx, QWORD PTR $T51[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv922[rsp], eax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@40c00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T38[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv920[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR tv922[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv920[rsp]
	mov	rcx, QWORD PTR tv924[rsp]
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
	npad	1

; 1191 : 	}

	jmp	$LN10@Checkbox2
$LN9@Checkbox2:

; 1192 : 	else
; 1193 : 	{
; 1194 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 6, check_bb.Min.y + 9), 7, GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)), 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv953[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T52[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv951[rsp], eax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40c00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T39[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv949[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR tv951[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv949[rsp]
	mov	rcx, QWORD PTR tv953[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1195 : 		window->DrawList->AddCircle(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2 - 6, check_bb.Min.y + 9), 7, GetColorU32(ImVec4(0.39f, 0.39f, 0.39f, 1.0f)), 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv983[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3ec7ae14
	movss	xmm2, DWORD PTR __real@3ec7ae14
	movss	xmm1, DWORD PTR __real@3ec7ae14
	lea	rcx, QWORD PTR $T53[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv981[rsp], eax
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR __real@41100000
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR __real@40c00000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T40[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv979[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR tv981[rsp]
	movss	xmm2, DWORD PTR __real@40e00000
	mov	rdx, QWORD PTR tv979[rsp]
	mov	rcx, QWORD PTR tv983[rsp]
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
	npad	1
$LN10@Checkbox2:

; 1196 : 	}
; 1197 : 	if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN11@Checkbox2

; 1198 : 		RenderText(text_bb.GetTL() - ImVec2(0, 3), label);

	movss	xmm2, DWORD PTR __real@40400000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T41[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv1002[rsp], rax
	lea	rdx, QWORD PTR $T42[rsp]
	lea	rcx, QWORD PTR text_bb$[rsp]
	call	?GetTL@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetTL
	mov	QWORD PTR tv1000[rsp], rax
	mov	r8, QWORD PTR tv1002[rsp]
	mov	rdx, QWORD PTR tv1000[rsp]
	lea	rcx, QWORD PTR $T43[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN11@Checkbox2:

; 1199 : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@Checkbox2:

; 1200 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 2232				; 000008b8H
	pop	rdi
	pop	rsi
	ret	0
?Checkbox2@ImGui@@YA_NPEBDPEAH@Z ENDP			; ImGui::Checkbox2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
pressed$ = 48
window$ = 56
held$ = 64
hovered$ = 65
style$ = 72
check_bb$ = 80
label_size$ = 96
id$ = 104
tv232 = 108
check_sz$ = 112
T$1 = 120
tv194 = 128
tv192 = 132
tv199 = 136
tv243 = 140
tv241 = 144
tv306 = 148
tv331 = 152
text_bb$ = 160
g$ = 176
tv179 = 184
tv177 = 192
tv197 = 200
tv215 = 208
tv213 = 216
tv304 = 224
tv308 = 232
tv329 = 240
tv333 = 248
check_sz2$ = 256
pad$ = 260
total_bb$ = 264
$T2 = 280
$T3 = 288
$T4 = 296
$T5 = 304
$T6 = 312
$T7 = 320
$T8 = 328
$T9 = 336
$T10 = 344
$T11 = 352
$T12 = 360
$T13 = 368
$T14 = 376
label$ = 432
v$ = 440
Color$ = 448
?Checkbox1@ImGui@@YA_NPEBDPEAHPEAM@Z PROC		; ImGui::Checkbox1

; 1020 : {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 408				; 00000198H

; 1021 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1022 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@Checkbox1

; 1023 : 		return false;

	xor	al, al
	jmp	$LN1@Checkbox1
$LN2@Checkbox1:

; 1024 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1025 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 1026 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 1027 : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	npad	1

; 1028 : 	const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y * 2 + 16, label_size.y + style.FramePadding.y * 2)); // We want a square shape to we use Y twice

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	mulss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR label_size$[rsp+4]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@41800000
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T12[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR check_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1029 : 	ItemSize(check_bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR check_bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize

; 1030 : 	ImRect total_bb = check_bb;

	lea	rax, QWORD PTR total_bb$[rsp]
	lea	rcx, QWORD PTR check_bb$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 1031 : 	if (label_size.x > 0)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@Checkbox1

; 1032 : 		SameLine(0, style.ItemInnerSpacing.x);

	xorps	xmm2, xmm2
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+76]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMMM@Z		; ImGui::SameLine
	npad	1
$LN3@Checkbox1:

; 1033 : 	const ImRect text_bb(window->DC.CursorPos + ImVec2(0, style.FramePadding.y), window->DC.CursorPos + ImVec2(0, style.FramePadding.y) + label_size);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR [rax+56]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	lea	r8, QWORD PTR label_size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv179[rsp], rax
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR [rax+56]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T5[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv177[rsp], rax
	mov	r8, QWORD PTR tv179[rsp]
	mov	rdx, QWORD PTR tv177[rsp]
	lea	rcx, QWORD PTR text_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1034 : 	if (label_size.x > 0)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN4@Checkbox1

; 1035 : 	{
; 1036 : 		ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	movss	DWORD PTR tv199[rsp], xmm0
	lea	rcx, QWORD PTR check_bb$[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	DWORD PTR tv194[rsp], xmm0
	lea	rcx, QWORD PTR text_bb$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	DWORD PTR tv192[rsp], xmm0
	movss	xmm2, DWORD PTR tv194[rsp]
	movss	xmm1, DWORD PTR tv192[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv197[rsp], rax
	movss	xmm1, DWORD PTR tv199[rsp]
	mov	rcx, QWORD PTR tv197[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 1037 : 		total_bb = ImRect(ImMin(check_bb.Min, text_bb.Min), ImMax(check_bb.Max, text_bb.Max));

	lea	r8, QWORD PTR text_bb$[rsp+8]
	lea	rdx, QWORD PTR check_bb$[rsp+8]
	lea	rcx, QWORD PTR $T7[rsp]
	call	?ImMax@@YA?AUImVec2@@AEBU1@0@Z		; ImMax
	mov	QWORD PTR tv215[rsp], rax
	lea	r8, QWORD PTR text_bb$[rsp]
	lea	rdx, QWORD PTR check_bb$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	?ImMin@@YA?AUImVec2@@AEBU1@0@Z		; ImMin
	mov	QWORD PTR tv213[rsp], rax
	mov	r8, QWORD PTR tv215[rsp]
	mov	rdx, QWORD PTR tv213[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	lea	rcx, QWORD PTR total_bb$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN4@Checkbox1:

; 1038 : 	}
; 1039 : 
; 1040 : 	if (!ItemAdd(total_bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Checkbox1

; 1041 : 		return false;

	xor	al, al
	jmp	$LN1@Checkbox1
$LN5@Checkbox1:

; 1042 : 
; 1043 : 	bool hovered, held;
; 1044 : 	bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 1045 : 	if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN6@Checkbox1

; 1046 : 		*v = !(*v);

	mov	rax, QWORD PTR v$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN11@Checkbox1
	mov	DWORD PTR tv232[rsp], 1
	jmp	SHORT $LN12@Checkbox1
$LN11@Checkbox1:
	mov	DWORD PTR tv232[rsp], 0
$LN12@Checkbox1:
	mov	rax, QWORD PTR v$[rsp]
	mov	ecx, DWORD PTR tv232[rsp]
	mov	DWORD PTR [rax], ecx
$LN6@Checkbox1:

; 1047 : 
; 1048 : 	const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());

	lea	rcx, QWORD PTR check_bb$[rsp]
	call	?GetHeight@ImRect@@QEBAMXZ		; ImRect::GetHeight
	movss	DWORD PTR tv243[rsp], xmm0
	lea	rcx, QWORD PTR check_bb$[rsp]
	call	?GetWidth@ImRect@@QEBAMXZ		; ImRect::GetWidth
	movss	DWORD PTR tv241[rsp], xmm0
	movss	xmm1, DWORD PTR tv243[rsp]
	movss	xmm0, DWORD PTR tv241[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR check_sz$[rsp], xmm0

; 1049 : 	const float check_sz2 = check_sz / 2;

	movss	xmm0, DWORD PTR check_sz$[rsp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR check_sz2$[rsp], xmm0

; 1050 : 	const float pad = ImMax(1.0f, (float)(int)(check_sz / 4.f));

	movss	xmm0, DWORD PTR check_sz$[rsp]
	divss	xmm0, DWORD PTR __real@40800000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR pad$[rsp], xmm0

; 1051 : 	if (*v)

	mov	rax, QWORD PTR v$[rsp]
	cmp	DWORD PTR [rax], 0
	je	$LN7@Checkbox1

; 1052 : 	{
; 1053 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2, check_bb.Min.y + 10.25), 5.6f, GetColorU32(Color), 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv308[rsp], rax
	mov	rcx, QWORD PTR Color$[rsp]
	call	?GetColorU32@ImGui@@YAIQEAM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv306[rsp], eax
	cvtss2sd xmm0, DWORD PTR check_bb$[rsp+4]
	addsd	xmm0, QWORD PTR __real@4024800000000000
	cvtsd2ss xmm0, xmm0
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv304[rsp], rax
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR tv306[rsp]
	movss	xmm2, DWORD PTR __real@40b33333
	mov	rdx, QWORD PTR tv304[rsp]
	mov	rcx, QWORD PTR tv308[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	npad	1

; 1054 : 	}

	jmp	$LN8@Checkbox1
$LN7@Checkbox1:

; 1055 : 	else
; 1056 : 	{
; 1057 : 		/*float RevColor[4];
; 1058 : 		RevColor[0] = Color[2];
; 1059 : 		RevColor[1] = Color[0];
; 1060 : 		RevColor[2] = Color[1];
; 1061 : 		RevColor[3] = Color[3];
; 1062 : 		window->DrawList->AddCircleFilled(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2, check_bb.Min.y + 10.25), 5.6f, GetColorU32(RevColor), 12);*/
; 1063 : 		window->DrawList->AddCircle(ImVec2(check_bb.Min.x + (check_bb.Max.x - check_bb.Min.x) / 2, check_bb.Min.y + 10.25), 5.6f, GetColorU32(Color), 12);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv333[rsp], rax
	mov	rcx, QWORD PTR Color$[rsp]
	call	?GetColorU32@ImGui@@YAIQEAM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv331[rsp], eax
	cvtss2sd xmm0, DWORD PTR check_bb$[rsp+4]
	addsd	xmm0, QWORD PTR __real@4024800000000000
	cvtsd2ss xmm0, xmm0
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	subss	xmm1, DWORD PTR check_bb$[rsp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR check_bb$[rsp]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv329[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], 12
	mov	r9d, DWORD PTR tv331[rsp]
	movss	xmm2, DWORD PTR __real@40b33333
	mov	rdx, QWORD PTR tv329[rsp]
	mov	rcx, QWORD PTR tv333[rsp]
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
	npad	1
$LN8@Checkbox1:

; 1064 : 	}
; 1065 : 	if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN9@Checkbox1

; 1066 : 	{
; 1067 : 		ImVec2 T = text_bb.GetTL();

	lea	rdx, QWORD PTR T$1[rsp]
	lea	rcx, QWORD PTR text_bb$[rsp]
	call	?GetTL@ImRect@@QEBA?AUImVec2@@XZ	; ImRect::GetTL

; 1068 : 		T.y -= 2.f;

	movss	xmm0, DWORD PTR T$1[rsp+4]
	subss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR T$1[rsp+4], xmm0

; 1069 : 		T.x += -12.f;

	movss	xmm0, DWORD PTR T$1[rsp]
	addss	xmm0, DWORD PTR __real@c1400000
	movss	DWORD PTR T$1[rsp], xmm0

; 1070 : 		RenderText(T, label);

	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR T$1[rsp]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN9@Checkbox1:

; 1071 : 	}
; 1072 : 
; 1073 : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@Checkbox1:

; 1074 : }

	add	rsp, 408				; 00000198H
	pop	rdi
	pop	rsi
	ret	0
?Checkbox1@ImGui@@YA_NPEBDPEAHPEAM@Z ENDP		; ImGui::Checkbox1
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
hovered$ = 48
pressed$ = 49
held$ = 50
square_sz$ = 52
id$ = 56
pad$1 = 60
style$ = 64
tv128 = 72
tv157 = 76
tv185 = 80
tv186 = 84
pos$ = 88
label_size$ = 96
tv132 = 104
tv194 = 108
tv192 = 112
tv227 = 116
window$ = 120
check_bb$ = 128
total_bb$ = 144
g$ = 160
$T2 = 168
$T3 = 176
$T4 = 184
$T5 = 192
$T6 = 200
$T7 = 208
$T8 = 216
$T9 = 224
$T10 = 232
label$ = 272
v$ = 280
?Checkbox@ImGui@@YA_NPEBDPEA_N@Z PROC			; ImGui::Checkbox

; 1077 : {

$LN19:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 264				; 00000108H

; 1078 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1079 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN5@Checkbox

; 1080 : 		return false;

	xor	al, al
	jmp	$LN1@Checkbox
$LN5@Checkbox:

; 1081 : 
; 1082 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1083 : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 1084 : 	const ImGuiID id = window->GetID(label);

	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 1085 : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 1086 : 
; 1087 : 	const float square_sz = GetFrameHeight();

	call	?GetFrameHeight@ImGui@@YAMXZ		; ImGui::GetFrameHeight
	movss	DWORD PTR square_sz$[rsp], xmm0

; 1088 : 	const ImVec2 pos = window->DC.CursorPos;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+340]
	mov	QWORD PTR pos$[rsp], rax

; 1089 : 	const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv132[rsp], xmm0
	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN11@Checkbox
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	addss	xmm0, DWORD PTR label_size$[rsp]
	movss	DWORD PTR tv128[rsp], xmm0
	jmp	SHORT $LN12@Checkbox
$LN11@Checkbox:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv128[rsp], xmm0
$LN12@Checkbox:
	movss	xmm0, DWORD PTR square_sz$[rsp]
	addss	xmm0, DWORD PTR tv128[rsp]
	movss	xmm2, DWORD PTR tv132[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1090 : 	ItemSize(total_bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 1091 : 	if (!ItemAdd(total_bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Checkbox

; 1092 : 		return false;

	xor	al, al
	jmp	$LN1@Checkbox
$LN6@Checkbox:

; 1093 : 
; 1094 : 	bool hovered, held;
; 1095 : 	bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 1096 : 	if (pressed)

	movzx	eax, BYTE PTR pressed$[rsp]
	test	eax, eax
	je	SHORT $LN7@Checkbox

; 1097 : 	{
; 1098 : 		*v = !(*v);

	mov	rax, QWORD PTR v$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN13@Checkbox
	mov	DWORD PTR tv157[rsp], 1
	jmp	SHORT $LN14@Checkbox
$LN13@Checkbox:
	mov	DWORD PTR tv157[rsp], 0
$LN14@Checkbox:
	mov	rax, QWORD PTR v$[rsp]
	movzx	ecx, BYTE PTR tv157[rsp]
	mov	BYTE PTR [rax], cl

; 1099 : 		MarkItemEdited(id);

	mov	ecx, DWORD PTR id$[rsp]
	call	?MarkItemEdited@ImGui@@YAXI@Z		; ImGui::MarkItemEdited
	npad	1
$LN7@Checkbox:

; 1100 : 	}
; 1101 : 
; 1102 : 	const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));

	movss	xmm2, DWORD PTR square_sz$[rsp]
	movss	xmm1, DWORD PTR square_sz$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$[rsp]
	lea	rcx, QWORD PTR check_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1103 : 	RenderNavHighlight(total_bb, id);

	mov	r8d, 1
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 1104 : 	RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	movss	DWORD PTR tv194[rsp], xmm0
	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN15@Checkbox
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN15@Checkbox
	mov	DWORD PTR tv186[rsp], 9
	jmp	SHORT $LN18@Checkbox
$LN15@Checkbox:
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN16@Checkbox
	mov	DWORD PTR tv185[rsp], 8
	jmp	SHORT $LN17@Checkbox
$LN16@Checkbox:
	mov	DWORD PTR tv185[rsp], 7
$LN17@Checkbox:
	mov	eax, DWORD PTR tv185[rsp]
	mov	DWORD PTR tv186[rsp], eax
$LN18@Checkbox:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv186[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv192[rsp], eax
	movss	xmm0, DWORD PTR tv194[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	r8d, DWORD PTR tv192[rsp]
	mov	rdx, QWORD PTR check_bb$[rsp+8]
	mov	rcx, QWORD PTR check_bb$[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	npad	1

; 1105 : 	if (*v)

	mov	rax, QWORD PTR v$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN8@Checkbox

; 1106 : 	{
; 1107 : 		const float pad = ImMax(1.0f, (float)(int)(square_sz / 6.0f));

	movss	xmm0, DWORD PTR square_sz$[rsp]
	divss	xmm0, DWORD PTR __real@40c00000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR pad$1[rsp], xmm0

; 1108 : 		RenderCheckMark(check_bb.Min + ImVec2(pad, pad), GetColorU32(ImVec4(1.00f, 0.79f, 0.18f, 0.78f)), square_sz - pad * 2.0f);

	movss	xmm0, DWORD PTR __real@3f47ae14
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3e3851ec
	movss	xmm2, DWORD PTR __real@3f4a3d71
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	rcx, rax
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv227[rsp], eax
	movss	xmm2, DWORD PTR pad$1[rsp]
	movss	xmm1, DWORD PTR pad$1[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR check_bb$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T2[rsp], rax
	movss	xmm0, DWORD PTR pad$1[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR square_sz$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm2, xmm0
	mov	edx, DWORD PTR tv227[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	?RenderCheckMark@ImGui@@YAXUImVec2@@IM@Z ; ImGui::RenderCheckMark
	npad	1
$LN8@Checkbox:

; 1109 : 	}
; 1110 : 
; 1111 : 	/* if (g.LogEnabled)
; 1112 : 		 LogRenderedText(&total_bb.Min, *v ? ("[x]") : ("[ ]"));*/
; 1113 : 	if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN9@Checkbox

; 1114 : 		RenderText(ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y), label);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR check_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR check_bb$[rsp+8]
	addss	xmm1, DWORD PTR [rax+76]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN9@Checkbox:
$LN4@Checkbox:

; 1115 : 
; 1116 : 	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));

	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Checkbox

; 1117 : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@Checkbox:

; 1118 : }

	add	rsp, 264				; 00000108H
	ret	0
?Checkbox@ImGui@@YA_NPEBDPEA_N@Z ENDP			; ImGui::Checkbox
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
hovered$ = 64
held$ = 65
pressed$ = 66
window$ = 72
id$ = 80
tv186 = 84
tv187 = 88
padding$ = 96
tv203 = 104
tv201 = 108
tv221 = 112
tv267 = 116
bb$ = 120
tv84 = 136
style$ = 144
image_bb$ = 152
col$ = 168
$T1 = 176
tv137 = 184
tv135 = 192
tv164 = 200
tv162 = 208
tv223 = 216
tv269 = 224
g$ = 232
$T2 = 240
$T3 = 248
$T4 = 256
$T5 = 264
$T6 = 272
$T7 = 280
$T8 = 288
$T9 = 296
user_texture_id$ = 320
size$ = 328
uv0$ = 336
uv1$ = 344
frame_padding$ = 352
bg_col$ = 360
tint_col$ = 368
?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z PROC ; ImGui::ImageButton

; 978  : {

$LN13:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 312				; 00000138H

; 979  : 	if (!user_texture_id)

	cmp	QWORD PTR user_texture_id$[rsp], 0
	jne	SHORT $LN2@ImageButto

; 980  : 		return false;

	xor	al, al
	jmp	$LN1@ImageButto
$LN2@ImageButto:

; 981  : 
; 982  : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 983  : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN3@ImageButto

; 984  : 		return false;

	xor	al, al
	jmp	$LN1@ImageButto
$LN3@ImageButto:

; 985  : 
; 986  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 987  : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 988  : 
; 989  : 	// Default to using texture ID as ID. User can still push string/integer prefixes.
; 990  : 	// We could hash the size/uv to create a unique ID but that would prevent the user from animating UV.
; 991  : 	PushID((void*)(intptr_t)user_texture_id);

	mov	rcx, QWORD PTR user_texture_id$[rsp]
	call	?PushID@ImGui@@YAXPEBX@Z		; ImGui::PushID

; 992  : 	const ImGuiID id = window->GetID(("#image"));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_06EBHDMMP@?$CDimage@
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 993  : 	PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	npad	1

; 994  : 
; 995  : 	const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;

	cmp	DWORD PTR frame_padding$[rsp], 0
	jl	SHORT $LN7@ImageButto
	cvtsi2ss xmm0, DWORD PTR frame_padding$[rsp]
	cvtsi2ss xmm1, DWORD PTR frame_padding$[rsp]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv84[rsp], rax
	jmp	SHORT $LN8@ImageButto
$LN7@ImageButto:
	mov	rax, QWORD PTR style$[rsp]
	mov	rax, QWORD PTR [rax+52]
	mov	QWORD PTR $T2[rsp], rax
	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR tv84[rsp], rax
$LN8@ImageButto:
	mov	rax, QWORD PTR tv84[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR padding$[rsp], rax

; 996  : 	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size + padding * 2);

	movss	xmm2, DWORD PTR __real@40000000
	lea	rdx, QWORD PTR padding$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??D@YA?AUImVec2@@AEBU0@M@Z		; operator*
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	mov	r8, QWORD PTR size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T5[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv135[rsp], rax
	mov	r8, QWORD PTR tv137[rsp]
	mov	rdx, QWORD PTR tv135[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 997  : 	const ImRect image_bb(window->DC.CursorPos + padding, window->DC.CursorPos + padding + size);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	lea	r8, QWORD PTR padding$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T7[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, QWORD PTR size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T8[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv164[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	lea	r8, QWORD PTR padding$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T9[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv162[rsp], rax
	mov	r8, QWORD PTR tv164[rsp]
	mov	rdx, QWORD PTR tv162[rsp]
	lea	rcx, QWORD PTR image_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 998  : 	ItemSize(bb);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 999  : 	if (!ItemAdd(bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@ImageButto

; 1000 : 		return false;

	xor	al, al
	jmp	$LN1@ImageButto
$LN4@ImageButto:

; 1001 : 
; 1002 : 	bool hovered, held;
; 1003 : 	bool pressed = ButtonBehavior(bb, id, &hovered, &held/*, ImGuiButtonFlags_AllowItemOverlap*/);

	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 1004 : 
; 1005 : 	// Render
; 1006 : 	const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

	movzx	eax, BYTE PTR held$[rsp]
	test	eax, eax
	je	SHORT $LN9@ImageButto
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN9@ImageButto
	mov	DWORD PTR tv187[rsp], 23
	jmp	SHORT $LN12@ImageButto
$LN9@ImageButto:
	movzx	eax, BYTE PTR hovered$[rsp]
	test	eax, eax
	je	SHORT $LN10@ImageButto
	mov	DWORD PTR tv186[rsp], 22
	jmp	SHORT $LN11@ImageButto
$LN10@ImageButto:
	mov	DWORD PTR tv186[rsp], 21
$LN11@ImageButto:
	mov	eax, DWORD PTR tv186[rsp]
	mov	DWORD PTR tv187[rsp], eax
$LN12@ImageButto:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv187[rsp]
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR col$[rsp], eax

; 1007 : 	RenderNavHighlight(bb, id);

	mov	r8d, 1
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 1008 : 	RenderFrame(bb.Min, bb.Max, 0, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, style.FrameRounding));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	movss	DWORD PTR tv203[rsp], xmm0
	movss	xmm1, DWORD PTR padding$[rsp+4]
	movss	xmm0, DWORD PTR padding$[rsp]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR tv201[rsp], xmm0
	movss	xmm2, DWORD PTR tv203[rsp]
	xorps	xmm1, xmm1
	movss	xmm0, DWORD PTR tv201[rsp]
	call	??$ImClamp@M@@YAMMMM@Z			; ImClamp<float>
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR bb$[rsp+8]
	mov	rcx, QWORD PTR bb$[rsp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	npad	1

; 1009 : 	if (bg_col.w > 0.0f)

	mov	rax, QWORD PTR bg_col$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@ImageButto

; 1010 : 		window->DrawList->AddRectFilled(image_bb.Min, image_bb.Max, GetColorU32(bg_col));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv223[rsp], rax
	mov	rcx, QWORD PTR bg_col$[rsp]
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv221[rsp], eax
	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv221[rsp]
	lea	r8, QWORD PTR image_bb$[rsp+8]
	lea	rdx, QWORD PTR image_bb$[rsp]
	mov	rcx, QWORD PTR tv223[rsp]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	npad	1
$LN5@ImageButto:

; 1011 : 	window->DrawList->AddImage(user_texture_id, image_bb.Min, image_bb.Max, uv0, uv1, GetColorU32(tint_col));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv269[rsp], rax
	mov	rcx, QWORD PTR tint_col$[rsp]
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv267[rsp], eax
	mov	eax, DWORD PTR tv267[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR uv1$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR uv0$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR image_bb$[rsp+8]
	lea	r8, QWORD PTR image_bb$[rsp]
	mov	rdx, QWORD PTR user_texture_id$[rsp]
	mov	rcx, QWORD PTR tv269[rsp]
	call	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage

; 1012 : 
; 1013 : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@ImageButto:

; 1014 : }

	add	rsp, 312				; 00000138H
	ret	0
?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z ENDP ; ImGui::ImageButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 64
bb$ = 72
tv140 = 88
tv174 = 92
tv188 = 96
tv142 = 104
tv172 = 112
tv170 = 120
tv176 = 128
tv190 = 136
$T1 = 144
$T2 = 152
$T3 = 160
$T4 = 168
$T5 = 176
$T6 = 184
user_texture_id$ = 208
size$ = 216
uv0$ = 224
uv1$ = 232
tint_col$ = 240
border_col$ = 248
?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z PROC	; ImGui::Image

; 950  : {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 951  : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 952  : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@Image

; 953  : 		return;

	jmp	$LN1@Image
$LN2@Image:

; 954  : 
; 955  : 	ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	mov	r8, QWORD PTR size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 956  : 	if (border_col.w > 0.0f)

	mov	rax, QWORD PTR border_col$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@Image

; 957  : 		bb.Max += ImVec2(2, 2);

	movss	xmm2, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@40000000
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rdx, rax
	lea	rcx, QWORD PTR bb$[rsp+8]
	call	??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z	; operator+=
	npad	1
$LN3@Image:

; 958  : 	ItemSize(bb);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 959  : 	if (!ItemAdd(bb, 0))

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@Image

; 960  : 		return;

	jmp	$LN1@Image
$LN4@Image:

; 961  : 
; 962  : 	if (border_col.w > 0.0f)

	mov	rax, QWORD PTR border_col$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN5@Image

; 963  : 	{
; 964  : 		window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv142[rsp], rax
	mov	rcx, QWORD PTR border_col$[rsp]
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv140[rsp], eax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+48], xmm0
	mov	DWORD PTR [rsp+40], 15
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv140[rsp]
	lea	r8, QWORD PTR bb$[rsp+8]
	lea	rdx, QWORD PTR bb$[rsp]
	mov	rcx, QWORD PTR tv142[rsp]
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	npad	1

; 965  : 		window->DrawList->AddImage(user_texture_id, bb.Min + ImVec2(1, 1), bb.Max - ImVec2(1, 1), uv0, uv1, GetColorU32(tint_col));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv176[rsp], rax
	mov	rcx, QWORD PTR tint_col$[rsp]
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv174[rsp], eax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR bb$[rsp+8]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	mov	QWORD PTR tv172[rsp], rax
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR bb$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	QWORD PTR tv170[rsp], rax
	mov	eax, DWORD PTR tv174[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR uv1$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR uv0$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv172[rsp]
	mov	r8, QWORD PTR tv170[rsp]
	mov	rdx, QWORD PTR user_texture_id$[rsp]
	mov	rcx, QWORD PTR tv176[rsp]
	call	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
	npad	1

; 966  : 	}

	jmp	SHORT $LN6@Image
$LN5@Image:

; 967  : 	else
; 968  : 	{
; 969  : 		window->DrawList->AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv190[rsp], rax
	mov	rcx, QWORD PTR tint_col$[rsp]
	call	?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z	; ImGui::GetColorU32
	mov	DWORD PTR tv188[rsp], eax
	mov	eax, DWORD PTR tv188[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR uv1$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR uv0$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR bb$[rsp+8]
	lea	r8, QWORD PTR bb$[rsp]
	mov	rdx, QWORD PTR user_texture_id$[rsp]
	mov	rcx, QWORD PTR tv190[rsp]
	call	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
	npad	1
$LN6@Image:
$LN1@Image:

; 970  : 	}
; 971  : }

	add	rsp, 200				; 000000c8H
	ret	0
?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z ENDP	; ImGui::Image
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
sz$ = 32
$T1 = 36
str_id$ = 64
dir$ = 72
?ArrowButton@ImGui@@YA_NPEBDH@Z PROC			; ImGui::ArrowButton

; 764  : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 765  : 	float sz = GetFrameHeight();

	call	?GetFrameHeight@ImGui@@YAMXZ		; ImGui::GetFrameHeight
	movss	DWORD PTR sz$[rsp], xmm0

; 766  : 	return ArrowButtonEx(str_id, dir, ImVec2(sz, sz), 0);

	movss	xmm2, DWORD PTR sz$[rsp]
	movss	xmm1, DWORD PTR sz$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xor	r9d, r9d
	mov	r8, QWORD PTR [rax]
	mov	edx, DWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR str_id$[rsp]
	call	?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z ; ImGui::ArrowButtonEx

; 767  : }

	add	rsp, 56					; 00000038H
	ret	0
?ArrowButton@ImGui@@YA_NPEBDH@Z ENDP			; ImGui::ArrowButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
pressed$ = 48
held$ = 49
hovered$ = 50
id$ = 52
window$ = 56
size$ = 64
$T1 = 72
bb$ = 80
str_id$ = 112
size_arg$ = 120
?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@@Z PROC	; ImGui::InvisibleButton

; 713  : {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 714  : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 715  : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@InvisibleB

; 716  : 		return false;

	xor	al, al
	jmp	$LN1@InvisibleB
$LN2@InvisibleB:

; 717  : 
; 718  : 	// Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.
; 719  : 	IM_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);
; 720  : 
; 721  : 	const ImGuiID id = window->GetID(str_id);

	xor	r8d, r8d
	mov	rdx, QWORD PTR str_id$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	DWORD PTR id$[rsp], eax

; 722  : 	ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);

	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	mov	rax, QWORD PTR size_arg$[rsp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, QWORD PTR size$[rsp]
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
	npad	1

; 723  : 	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	lea	r8, QWORD PTR size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 724  : 	ItemSize(size);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR size$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 725  : 	if (!ItemAdd(bb, id))

	xor	r8d, r8d
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@InvisibleB

; 726  : 		return false;

	xor	al, al
	jmp	SHORT $LN1@InvisibleB
$LN3@InvisibleB:

; 727  : 
; 728  : 	bool hovered, held;
; 729  : 	bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	mov	DWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR held$[rsp]
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, DWORD PTR id$[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$[rsp], al

; 730  : 
; 731  : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]
$LN1@InvisibleB:

; 732  : }

	add	rsp, 104				; 00000068H
	ret	0
?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@@Z ENDP	; ImGui::InvisibleButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
pressed$ = 32
backup_padding_y$ = 36
g$ = 40
$T1 = 48
label$ = 80
?SmallButton@ImGui@@YA_NPEBD@Z PROC			; ImGui::SmallButton

; 701  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 702  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 703  : 	float backup_padding_y = g.Style.FramePadding.y;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5528]
	movss	DWORD PTR backup_padding_y$[rsp], xmm0

; 704  : 	g.Style.FramePadding.y = 0.0f;

	mov	rax, QWORD PTR g$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+5528], xmm0

; 705  : 	bool pressed = ButtonEx(label, ImVec2(0, 0), ImGuiButtonFlags_AlignTextBaseLine);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8d, 512				; 00000200H
	mov	rdx, rax
	mov	rcx, QWORD PTR label$[rsp]
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
	mov	BYTE PTR pressed$[rsp], al

; 706  : 	g.Style.FramePadding.y = backup_padding_y;

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR backup_padding_y$[rsp]
	movss	DWORD PTR [rax+5528], xmm0

; 707  : 	return pressed;

	movzx	eax, BYTE PTR pressed$[rsp]

; 708  : }

	add	rsp, 72					; 00000048H
	ret	0
?SmallButton@ImGui@@YA_NPEBD@Z ENDP			; ImGui::SmallButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
label$ = 48
size_arg$ = 56
?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z PROC		; ImGui::Button

; 695  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 696  : 	return ButtonEx(label, size_arg, 0);

	xor	r8d, r8d
	mov	rdx, QWORD PTR size_arg$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx

; 697  : }

	add	rsp, 40					; 00000028H
	ret	0
?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z ENDP		; ImGui::Button
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 48
tv155 = 56
line_height$ = 60
window$ = 64
tv139 = 72
tv137 = 76
tv159 = 80
tv161 = 84
text_base_offset_y$ = 88
label_size$ = 96
style$ = 104
text_begin$ = 112
text_end$ = 120
bb$ = 128
$T1 = 144
$T2 = 152
$T3 = 160
$T4 = 168
$T5 = 176
$T6 = 184
fmt$ = 208
args$ = 216
?BulletTextV@ImGui@@YAXPEBDPEAD@Z PROC			; ImGui::BulletTextV

; 453  : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 454  : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 455  : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@BulletText

; 456  : 		return;

	jmp	$LN1@BulletText
$LN2@BulletText:

; 457  : 
; 458  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 459  : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 460  : 
; 461  : 	const char* text_begin = g.TempBuffer;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 12240				; 00002fd0H
	mov	QWORD PTR text_begin$[rsp], rax

; 462  : 	const char* text_end = text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 12240				; 00002fd0H
	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	edx, 3073				; 00000c01H
	mov	rcx, rax
	call	?ImFormatStringV@@YAHPEAD_KPEBD0@Z	; ImFormatStringV
	cdqe
	mov	rcx, QWORD PTR text_begin$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR text_end$[rsp], rax

; 463  : 	const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	mov	r8, QWORD PTR text_end$[rsp]
	mov	rdx, QWORD PTR text_begin$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 464  : 	const float text_base_offset_y = ImMax(0.0f, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+328]
	xorps	xmm0, xmm0
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR text_base_offset_y$[rsp], xmm0

; 465  : 	const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y * 2), g.FontSize);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	movss	DWORD PTR tv139[rsp], xmm0
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5528]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+324]
	call	??$ImMin@M@@YAMMM@Z			; ImMin<float>
	movss	DWORD PTR tv137[rsp], xmm0
	movss	xmm1, DWORD PTR tv139[rsp]
	movss	xmm0, DWORD PTR tv137[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR line_height$[rsp], xmm0

; 466  : 	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x * 2) : 0.0f), ImMax(line_height, label_size.y)));  // Empty text doesn't add padding

	movss	xmm1, DWORD PTR label_size$[rsp+4]
	movss	xmm0, DWORD PTR line_height$[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR tv159[rsp], xmm0
	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@BulletText
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv155[rsp], xmm0
	jmp	SHORT $LN6@BulletText
$LN5@BulletText:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv155[rsp], xmm0
$LN6@BulletText:
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+6408]
	addss	xmm0, DWORD PTR tv155[rsp]
	movss	DWORD PTR tv161[rsp], xmm0
	movss	xmm2, DWORD PTR tv159[rsp]
	movss	xmm1, DWORD PTR tv161[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 467  : 	ItemSize(bb);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 468  : 	if (!ItemAdd(bb, 0))

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@BulletText

; 469  : 		return;

	jmp	$LN1@BulletText
$LN3@BulletText:

; 470  : 
; 471  : 	// Render
; 472  : 	RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize * 0.5f, line_height * 0.5f));

	movss	xmm0, DWORD PTR line_height$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	mulss	xmm1, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm2, DWORD PTR [rax+52]
	addss	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR bb$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR [rax]
	call	?RenderBullet@ImGui@@YAXUImVec2@@@Z	; ImGui::RenderBullet
	npad	1

; 473  : 	RenderText(bb.Min + ImVec2(g.FontSize + style.FramePadding.x * 2, text_base_offset_y), text_begin, text_end, false);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+52]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR text_base_offset_y$[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR bb$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	xor	r9d, r9d
	mov	r8, QWORD PTR text_end$[rsp]
	mov	rdx, QWORD PTR text_begin$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN1@BulletText:

; 474  : }

	add	rsp, 200				; 000000c8H
	ret	0
?BulletTextV@ImGui@@YAXPEBDPEAD@Z ENDP			; ImGui::BulletTextV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
args$ = 32
fmt$ = 64
?BulletText@ImGui@@YAXPEBDZZ PROC			; ImGui::BulletText

; 444  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 445  : 	va_list args;
; 446  : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 447  : 	BulletTextV(fmt, args);

	mov	rdx, QWORD PTR args$[rsp]
	mov	rcx, QWORD PTR fmt$[rsp]
	call	?BulletTextV@ImGui@@YAXPEBDPEAD@Z	; ImGui::BulletTextV

; 448  : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 449  : }

	add	rsp, 56					; 00000038H
	ret	0
?BulletText@ImGui@@YAXPEBDZZ ENDP			; ImGui::BulletText
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
style$ = 64
w$ = 72
tv140 = 76
window$ = 80
label_size$ = 88
tv144 = 96
g$ = 104
value_text_begin$ = 112
value_bb$ = 120
value_text_end$ = 136
total_bb$ = 144
$T1 = 160
$T2 = 168
$T3 = 176
$T4 = 184
$T5 = 192
$T6 = 200
$T7 = 208
label$ = 240
fmt$ = 248
args$ = 256
?LabelTextV@ImGui@@YAXPEBD0PEAD@Z PROC			; ImGui::LabelTextV

; 419  : {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 232				; 000000e8H

; 420  : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 421  : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@LabelTextV

; 422  : 		return;

	jmp	$LN1@LabelTextV
$LN2@LabelTextV:

; 423  : 
; 424  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 425  : 	const ImGuiStyle& style = g.Style;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 5472				; 00001560H
	mov	QWORD PTR style$[rsp], rax

; 426  : 	const float w = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movss	DWORD PTR w$[rsp], xmm0

; 427  : 
; 428  : 	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	lea	rcx, QWORD PTR label_size$[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	npad	1

; 429  : 	const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2));

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR label_size$[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR w$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T2[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR value_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 430  : 	const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y * 2) + label_size);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+56]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv144[rsp], xmm0
	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@LabelTextV
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR [rax+76]
	movss	DWORD PTR tv140[rsp], xmm0
	jmp	SHORT $LN7@LabelTextV
$LN6@LabelTextV:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv140[rsp], xmm0
$LN7@LabelTextV:
	movss	xmm0, DWORD PTR w$[rsp]
	addss	xmm0, DWORD PTR tv140[rsp]
	movss	xmm2, DWORD PTR tv144[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T4[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	lea	r8, QWORD PTR label_size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T5[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 431  : 	ItemSize(total_bb, style.FramePadding.y);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR [rax+56]
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize
	npad	1

; 432  : 	if (!ItemAdd(total_bb, 0))

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR total_bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@LabelTextV

; 433  : 		return;

	jmp	$LN1@LabelTextV
$LN3@LabelTextV:

; 434  : 
; 435  : 	// Render
; 436  : 	const char* value_text_begin = &g.TempBuffer[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax+12240]
	mov	QWORD PTR value_text_begin$[rsp], rax

; 437  : 	const char* value_text_end = value_text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 12240				; 00002fd0H
	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	edx, 3073				; 00000c01H
	mov	rcx, rax
	call	?ImFormatStringV@@YAHPEAD_KPEBD0@Z	; ImFormatStringV
	cdqe
	mov	rcx, QWORD PTR value_text_begin$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR value_text_end$[rsp], rax

; 438  : 	RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f, 0.5f));

	movss	xmm2, DWORD PTR __real@3f000000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR [rsp+48], 0
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR value_text_end$[rsp]
	mov	r8, QWORD PTR value_text_begin$[rsp]
	lea	rdx, QWORD PTR value_bb$[rsp+8]
	lea	rcx, QWORD PTR value_bb$[rsp]
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
	npad	1

; 439  : 	if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR label_size$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@LabelTextV

; 440  : 		RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);

	mov	rax, QWORD PTR style$[rsp]
	movss	xmm0, DWORD PTR value_bb$[rsp+4]
	addss	xmm0, DWORD PTR [rax+56]
	mov	rax, QWORD PTR style$[rsp]
	movss	xmm1, DWORD PTR value_bb$[rsp+8]
	addss	xmm1, DWORD PTR [rax+76]
	movaps	xmm2, xmm0
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	npad	1
$LN4@LabelTextV:
$LN1@LabelTextV:

; 441  : }

	add	rsp, 232				; 000000e8H
	ret	0
?LabelTextV@ImGui@@YAXPEBD0PEAD@Z ENDP			; ImGui::LabelTextV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
args$ = 32
label$ = 64
fmt$ = 72
?LabelText@ImGui@@YAXPEBD0ZZ PROC			; ImGui::LabelText

; 410  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 411  : 	va_list args;
; 412  : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 413  : 	LabelTextV(label, fmt, args);

	mov	r8, QWORD PTR args$[rsp]
	mov	rdx, QWORD PTR fmt$[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	call	?LabelTextV@ImGui@@YAXPEBD0PEAD@Z	; ImGui::LabelTextV

; 414  : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 415  : }

	add	rsp, 56					; 00000038H
	ret	0
?LabelText@ImGui@@YAXPEBD0ZZ ENDP			; ImGui::LabelText
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
need_backup$ = 32
tv68 = 36
fmt$ = 64
args$ = 72
?TextWrappedV@ImGui@@YAXPEBDPEAD@Z PROC			; ImGui::TextWrappedV

; 400  : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 401  : 	bool need_backup = (GImGui->CurrentWindow->DC.TextWrapPos < 0.0f);  // Keep existing wrap position if one is already set

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+6584]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+516]
	jbe	SHORT $LN5@TextWrappe
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN6@TextWrappe
$LN5@TextWrappe:
	mov	DWORD PTR tv68[rsp], 0
$LN6@TextWrappe:
	movzx	eax, BYTE PTR tv68[rsp]
	mov	BYTE PTR need_backup$[rsp], al

; 402  : 	if (need_backup)

	movzx	eax, BYTE PTR need_backup$[rsp]
	test	eax, eax
	je	SHORT $LN2@TextWrappe

; 403  : 		PushTextWrapPos(0.0f);

	xorps	xmm0, xmm0
	call	?PushTextWrapPos@ImGui@@YAXM@Z		; ImGui::PushTextWrapPos
	npad	1
$LN2@TextWrappe:

; 404  : 	TextV(fmt, args);

	mov	rdx, QWORD PTR args$[rsp]
	mov	rcx, QWORD PTR fmt$[rsp]
	call	?TextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextV
	npad	1

; 405  : 	if (need_backup)

	movzx	eax, BYTE PTR need_backup$[rsp]
	test	eax, eax
	je	SHORT $LN3@TextWrappe

; 406  : 		PopTextWrapPos();

	call	?PopTextWrapPos@ImGui@@YAXXZ		; ImGui::PopTextWrapPos
	npad	1
$LN3@TextWrappe:

; 407  : }

	add	rsp, 56					; 00000038H
	ret	0
?TextWrappedV@ImGui@@YAXPEBDPEAD@Z ENDP			; ImGui::TextWrappedV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
args$ = 32
fmt$ = 64
?TextWrapped@ImGui@@YAXPEBDZZ PROC			; ImGui::TextWrapped

; 392  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 393  : 	va_list args;
; 394  : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 395  : 	TextWrappedV(fmt, args);

	mov	rdx, QWORD PTR args$[rsp]
	mov	rcx, QWORD PTR fmt$[rsp]
	call	?TextWrappedV@ImGui@@YAXPEBDPEAD@Z	; ImGui::TextWrappedV

; 396  : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 397  : }

	add	rsp, 56					; 00000038H
	ret	0
?TextWrapped@ImGui@@YAXPEBDZZ ENDP			; ImGui::TextWrapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
fmt$ = 48
args$ = 56
?TextDisabledV@ImGui@@YAXPEBDPEAD@Z PROC		; ImGui::TextDisabledV

; 385  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 386  : 	PushStyleColor(ImGuiCol_Text, GImGui->Style.Colors[ImGuiCol_TextDisabled]);

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	lea	rax, QWORD PTR [rcx+rax+5640]
	mov	rdx, rax
	xor	ecx, ecx
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor

; 387  : 	TextV(fmt, args);

	mov	rdx, QWORD PTR args$[rsp]
	mov	rcx, QWORD PTR fmt$[rsp]
	call	?TextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextV

; 388  : 	PopStyleColor();

	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	npad	1

; 389  : }

	add	rsp, 40					; 00000028H
	ret	0
?TextDisabledV@ImGui@@YAXPEBDPEAD@Z ENDP		; ImGui::TextDisabledV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
args$ = 32
fmt$ = 64
?TextDisabled@ImGui@@YAXPEBDZZ PROC			; ImGui::TextDisabled

; 377  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 378  : 	va_list args;
; 379  : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 380  : 	TextDisabledV(fmt, args);

	mov	rdx, QWORD PTR args$[rsp]
	mov	rcx, QWORD PTR fmt$[rsp]
	call	?TextDisabledV@ImGui@@YAXPEBDPEAD@Z	; ImGui::TextDisabledV

; 381  : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 382  : }

	add	rsp, 56					; 00000038H
	ret	0
?TextDisabled@ImGui@@YAXPEBDZZ ENDP			; ImGui::TextDisabled
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
col$ = 48
fmt$ = 56
args$ = 64
?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z PROC	; ImGui::TextColoredV

; 370  : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 371  : 	PushStyleColor(ImGuiCol_Text, col);

	mov	rdx, QWORD PTR col$[rsp]
	xor	ecx, ecx
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor

; 372  : 	TextV(fmt, args);

	mov	rdx, QWORD PTR args$[rsp]
	mov	rcx, QWORD PTR fmt$[rsp]
	call	?TextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextV

; 373  : 	PopStyleColor();

	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	npad	1

; 374  : }

	add	rsp, 40					; 00000028H
	ret	0
?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z ENDP	; ImGui::TextColoredV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
args$ = 32
col$ = 64
fmt$ = 72
?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ PROC		; ImGui::TextColored

; 362  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 363  : 	va_list args;
; 364  : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 365  : 	TextColoredV(col, fmt, args);

	mov	r8, QWORD PTR args$[rsp]
	mov	rdx, QWORD PTR fmt$[rsp]
	mov	rcx, QWORD PTR col$[rsp]
	call	?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z ; ImGui::TextColoredV

; 366  : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 367  : }

	add	rsp, 56					; 00000038H
	ret	0
?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ ENDP		; ImGui::TextColored
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
g$ = 32
window$ = 40
text_end$ = 48
fmt$ = 80
args$ = 88
?TextV@ImGui@@YAXPEBDPEAD@Z PROC			; ImGui::TextV

; 351  : {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 352  : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 353  : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@TextV

; 354  : 		return;

	jmp	SHORT $LN1@TextV
$LN2@TextV:

; 355  : 
; 356  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 357  : 	const char* text_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 12240				; 00002fd0H
	mov	r9, QWORD PTR args$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	edx, 3073				; 00000c01H
	mov	rcx, rax
	call	?ImFormatStringV@@YAHPEAD_KPEBD0@Z	; ImFormatStringV
	cdqe
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax+12240]
	mov	QWORD PTR text_end$[rsp], rax

; 358  : 	TextUnformatted(g.TempBuffer, text_end);

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 12240				; 00002fd0H
	mov	rdx, QWORD PTR text_end$[rsp]
	mov	rcx, rax
	call	?TextUnformatted@ImGui@@YAXPEBD0@Z	; ImGui::TextUnformatted
	npad	1
$LN1@TextV:

; 359  : }

	add	rsp, 72					; 00000048H
	ret	0
?TextV@ImGui@@YAXPEBDPEAD@Z ENDP			; ImGui::TextV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
args$ = 32
fmt$ = 64
?Text@ImGui@@YAXPEBDZZ PROC				; ImGui::Text

; 343  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 344  : 	va_list args;
; 345  : 	va_start(args, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR args$[rsp], rax

; 346  : 	TextV(fmt, args);

	mov	rdx, QWORD PTR args$[rsp]
	mov	rcx, QWORD PTR fmt$[rsp]
	call	?TextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextV

; 347  : 	va_end(args);

	mov	QWORD PTR args$[rsp], 0

; 348  : }

	add	rsp, 56					; 00000038H
	ret	0
?Text@ImGui@@YAXPEBDZZ ENDP				; ImGui::Text
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv87 = 48
wrap_enabled$ = 49
line_height$1 = 52
line$2 = 56
pos$3 = 64
lines_skipped$4 = 72
text_pos$ = 80
lines_skipped$5 = 88
window$ = 96
text_size$6 = 104
lines_skippable$7 = 112
wrap_pos_x$ = 116
tv259 = 120
wrap_width$8 = 124
line_end$9 = 128
line_end$10 = 136
line_end$11 = 144
text_size$12 = 152
text_begin$ = 160
line_rect$13 = 168
line_size$14 = 184
bb$15 = 192
clip_rect$16 = 208
g$ = 224
$T17 = 232
$T18 = 240
$T19 = 248
$T20 = 256
$T21 = 264
$T22 = 272
bb$23 = 280
text$ = 336
text_end$ = 344
?TextUnformatted2@ImGui@@YAXPEBD0@Z PROC		; ImGui::TextUnformatted2

; 236  : {

$LN25:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 312				; 00000138H

; 237  : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 238  : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN8@TextUnform

; 239  : 		return;

	jmp	$LN1@TextUnform
$LN8@TextUnform:

; 240  : 
; 241  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 242  : 	IM_ASSERT(text != NULL);
; 243  : 	const char* text_begin = text;

	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR text_begin$[rsp], rax

; 244  : 	if (text_end == NULL)

	cmp	QWORD PTR text_end$[rsp], 0
	jne	SHORT $LN9@TextUnform

; 245  : 		text_end = text + strlen(text); // FIXME-OPT

	mov	rcx, QWORD PTR text$[rsp]
	call	strlen
	mov	rcx, QWORD PTR text$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR text_end$[rsp], rax
$LN9@TextUnform:

; 246  : 
; 247  : 	const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrentLineTextBaseOffset);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	addss	xmm0, DWORD PTR [rcx+328]
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+340]
	lea	rcx, QWORD PTR text_pos$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 248  : 	const float wrap_pos_x = window->DC.TextWrapPos;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+516]
	movss	DWORD PTR wrap_pos_x$[rsp], xmm0

; 249  : 	const bool wrap_enabled = wrap_pos_x >= 0.0f;

	movss	xmm0, DWORD PTR wrap_pos_x$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN21@TextUnform
	mov	BYTE PTR tv87[rsp], 1
	jmp	SHORT $LN22@TextUnform
$LN21@TextUnform:
	mov	BYTE PTR tv87[rsp], 0
$LN22@TextUnform:
	movzx	eax, BYTE PTR tv87[rsp]
	mov	BYTE PTR wrap_enabled$[rsp], al

; 250  : 	if (text_end - text > 2000 && !wrap_enabled)

	mov	rax, QWORD PTR text$[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	rax, 2000				; 000007d0H
	jle	$LN10@TextUnform
	movzx	eax, BYTE PTR wrap_enabled$[rsp]
	test	eax, eax
	jne	$LN10@TextUnform

; 251  : 	{
; 252  : 		// Long text!
; 253  : 		// Perform manual coarse clipping to optimize for long multi-line text
; 254  : 		// - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
; 255  : 		// - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
; 256  : 		// - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.
; 257  : 		const char* line = text;

	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR line$2[rsp], rax

; 258  : 		const float line_height = GetTextLineHeight();

	call	?GetTextLineHeight@ImGui@@YAMXZ		; ImGui::GetTextLineHeight
	movss	DWORD PTR line_height$1[rsp], xmm0

; 259  : 		const ImRect clip_rect = window->ClipRect;

	lea	rax, QWORD PTR clip_rect$16[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+248]
	mov	ecx, 16
	rep movsb

; 260  : 		ImVec2 text_size(0, 0);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR text_size$6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 261  : 
; 262  : 		if (text_pos.y <= clip_rect.Max.y)

	movss	xmm0, DWORD PTR clip_rect$16[rsp+12]
	comiss	xmm0, DWORD PTR text_pos$[rsp+4]
	jb	$LN12@TextUnform

; 263  : 		{
; 264  : 			ImVec2 pos = text_pos;

	mov	rax, QWORD PTR text_pos$[rsp]
	mov	QWORD PTR pos$3[rsp], rax

; 265  : 
; 266  : 			// Lines to skip (can't skip when logging text)
; 267  : 			//if (!g.LogEnabled)
; 268  : 			{
; 269  : 				int lines_skippable = (int)((clip_rect.Min.y - text_pos.y) / line_height);

	movss	xmm0, DWORD PTR clip_rect$16[rsp+4]
	subss	xmm0, DWORD PTR text_pos$[rsp+4]
	divss	xmm0, DWORD PTR line_height$1[rsp]
	cvttss2si eax, xmm0
	mov	DWORD PTR lines_skippable$7[rsp], eax

; 270  : 				if (lines_skippable > 0)

	cmp	DWORD PTR lines_skippable$7[rsp], 0
	jle	$LN13@TextUnform

; 271  : 				{
; 272  : 					int lines_skipped = 0;

	mov	DWORD PTR lines_skipped$4[rsp], 0
$LN2@TextUnform:

; 273  : 					while (line < text_end && lines_skipped < lines_skippable)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR line$2[rsp], rax
	jae	SHORT $LN3@TextUnform
	mov	eax, DWORD PTR lines_skippable$7[rsp]
	cmp	DWORD PTR lines_skipped$4[rsp], eax
	jge	SHORT $LN3@TextUnform

; 274  : 					{
; 275  : 						const char* line_end = (const char*)memchr(line, '\n', text_end - line);

	mov	rax, QWORD PTR line$2[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	edx, 10
	mov	rcx, QWORD PTR line$2[rsp]
	call	memchr
	mov	QWORD PTR line_end$10[rsp], rax

; 276  : 						if (!line_end)

	cmp	QWORD PTR line_end$10[rsp], 0
	jne	SHORT $LN14@TextUnform

; 277  : 							line_end = text_end;

	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR line_end$10[rsp], rax
$LN14@TextUnform:

; 278  : 						line = line_end + 1;

	mov	rax, QWORD PTR line_end$10[rsp]
	inc	rax
	mov	QWORD PTR line$2[rsp], rax

; 279  : 						lines_skipped++;

	mov	eax, DWORD PTR lines_skipped$4[rsp]
	inc	eax
	mov	DWORD PTR lines_skipped$4[rsp], eax

; 280  : 					}

	jmp	SHORT $LN2@TextUnform
$LN3@TextUnform:

; 281  : 					pos.y += lines_skipped * line_height;

	cvtsi2ss xmm0, DWORD PTR lines_skipped$4[rsp]
	mulss	xmm0, DWORD PTR line_height$1[rsp]
	movss	xmm1, DWORD PTR pos$3[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR pos$3[rsp+4], xmm0
$LN13@TextUnform:

; 282  : 				}
; 283  : 			}
; 284  : 
; 285  : 			// Lines to render
; 286  : 			if (line < text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR line$2[rsp], rax
	jae	$LN15@TextUnform

; 287  : 			{
; 288  : 				ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));

	movss	xmm2, DWORD PTR line_height$1[rsp]
	movss	xmm1, DWORD PTR __real@7f7fffff
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$3[rsp]
	lea	rcx, QWORD PTR $T18[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$3[rsp]
	lea	rcx, QWORD PTR line_rect$13[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1
$LN4@TextUnform:

; 289  : 				while (line < text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR line$2[rsp], rax
	jae	$LN5@TextUnform

; 290  : 				{
; 291  : 					if (IsClippedEx(line_rect, 0, false))

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR line_rect$13[rsp]
	call	?IsClippedEx@ImGui@@YA_NAEBUImRect@@I_N@Z ; ImGui::IsClippedEx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@TextUnform

; 292  : 						break;

	jmp	$LN5@TextUnform
$LN16@TextUnform:

; 293  : 
; 294  : 					const char* line_end = (const char*)memchr(line, '\n', text_end - line);

	mov	rax, QWORD PTR line$2[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	edx, 10
	mov	rcx, QWORD PTR line$2[rsp]
	call	memchr
	mov	QWORD PTR line_end$9[rsp], rax

; 295  : 					if (!line_end)

	cmp	QWORD PTR line_end$9[rsp], 0
	jne	SHORT $LN17@TextUnform

; 296  : 						line_end = text_end;

	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR line_end$9[rsp], rax
$LN17@TextUnform:

; 297  : 					const ImVec2 line_size = CalcTextSize(line, line_end, false);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	mov	r8, QWORD PTR line_end$9[rsp]
	mov	rdx, QWORD PTR line$2[rsp]
	lea	rcx, QWORD PTR line_size$14[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 298  : 					text_size.x = ImMax(text_size.x, line_size.x);

	movss	xmm1, DWORD PTR line_size$14[rsp]
	movss	xmm0, DWORD PTR text_size$6[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR text_size$6[rsp], xmm0

; 299  : 					RenderText(pos, line, line_end, false);

	xor	r9d, r9d
	mov	r8, QWORD PTR line_end$9[rsp]
	mov	rdx, QWORD PTR line$2[rsp]
	mov	rcx, QWORD PTR pos$3[rsp]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText

; 300  : 					line = line_end + 1;

	mov	rax, QWORD PTR line_end$9[rsp]
	inc	rax
	mov	QWORD PTR line$2[rsp], rax

; 301  : 					line_rect.Min.y += line_height;

	movss	xmm0, DWORD PTR line_rect$13[rsp+4]
	addss	xmm0, DWORD PTR line_height$1[rsp]
	movss	DWORD PTR line_rect$13[rsp+4], xmm0

; 302  : 					line_rect.Max.y += line_height;

	movss	xmm0, DWORD PTR line_rect$13[rsp+12]
	addss	xmm0, DWORD PTR line_height$1[rsp]
	movss	DWORD PTR line_rect$13[rsp+12], xmm0

; 303  : 					pos.y += line_height;

	movss	xmm0, DWORD PTR pos$3[rsp+4]
	addss	xmm0, DWORD PTR line_height$1[rsp]
	movss	DWORD PTR pos$3[rsp+4], xmm0

; 304  : 				}

	jmp	$LN4@TextUnform
$LN5@TextUnform:

; 305  : 
; 306  : 				// Count remaining lines
; 307  : 				int lines_skipped = 0;

	mov	DWORD PTR lines_skipped$5[rsp], 0
$LN6@TextUnform:

; 308  : 				while (line < text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR line$2[rsp], rax
	jae	SHORT $LN7@TextUnform

; 309  : 				{
; 310  : 					const char* line_end = (const char*)memchr(line, '\n', text_end - line);

	mov	rax, QWORD PTR line$2[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	edx, 10
	mov	rcx, QWORD PTR line$2[rsp]
	call	memchr
	mov	QWORD PTR line_end$11[rsp], rax

; 311  : 					if (!line_end)

	cmp	QWORD PTR line_end$11[rsp], 0
	jne	SHORT $LN18@TextUnform

; 312  : 						line_end = text_end;

	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR line_end$11[rsp], rax
$LN18@TextUnform:

; 313  : 					line = line_end + 1;

	mov	rax, QWORD PTR line_end$11[rsp]
	inc	rax
	mov	QWORD PTR line$2[rsp], rax

; 314  : 					lines_skipped++;

	mov	eax, DWORD PTR lines_skipped$5[rsp]
	inc	eax
	mov	DWORD PTR lines_skipped$5[rsp], eax

; 315  : 				}

	jmp	SHORT $LN6@TextUnform
$LN7@TextUnform:

; 316  : 				pos.y += lines_skipped * line_height;

	cvtsi2ss xmm0, DWORD PTR lines_skipped$5[rsp]
	mulss	xmm0, DWORD PTR line_height$1[rsp]
	movss	xmm1, DWORD PTR pos$3[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR pos$3[rsp+4], xmm0
$LN15@TextUnform:

; 317  : 			}
; 318  : 
; 319  : 			text_size.y += (pos - text_pos).y;

	lea	r8, QWORD PTR text_pos$[rsp]
	lea	rdx, QWORD PTR pos$3[rsp]
	lea	rcx, QWORD PTR $T19[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	movss	xmm0, DWORD PTR text_size$6[rsp+4]
	addss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR text_size$6[rsp+4], xmm0
$LN12@TextUnform:

; 320  : 		}
; 321  : 
; 322  : 		ImRect bb(text_pos, text_pos + text_size);

	lea	r8, QWORD PTR text_size$6[rsp]
	lea	rdx, QWORD PTR text_pos$[rsp]
	lea	rcx, QWORD PTR $T20[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR text_pos$[rsp]
	lea	rcx, QWORD PTR bb$23[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 323  : 		ItemSize(text_size);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR text_size$6[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize

; 324  : 		ItemAdd(bb, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR bb$23[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	npad	1

; 325  : 	}

	jmp	$LN11@TextUnform
$LN10@TextUnform:

; 326  : 	else
; 327  : 	{
; 328  : 		const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;

	movzx	eax, BYTE PTR wrap_enabled$[rsp]
	test	eax, eax
	je	SHORT $LN23@TextUnform
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	movss	xmm1, DWORD PTR wrap_pos_x$[rsp]
	mov	rcx, rax
	call	?CalcWrapWidthForPos@ImGui@@YAMAEBUImVec2@@M@Z ; ImGui::CalcWrapWidthForPos
	movss	DWORD PTR tv259[rsp], xmm0
	jmp	SHORT $LN24@TextUnform
$LN23@TextUnform:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv259[rsp], xmm0
$LN24@TextUnform:
	movss	xmm0, DWORD PTR tv259[rsp]
	movss	DWORD PTR wrap_width$8[rsp], xmm0

; 329  : 		const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);

	movss	xmm0, DWORD PTR wrap_width$8[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	mov	r8, QWORD PTR text_end$[rsp]
	mov	rdx, QWORD PTR text_begin$[rsp]
	lea	rcx, QWORD PTR text_size$12[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	npad	1

; 330  : 
; 331  : 		// Account of baseline offset
; 332  : 		ImRect bb(text_pos, text_pos + text_size);

	lea	r8, QWORD PTR text_size$12[rsp]
	lea	rdx, QWORD PTR text_pos$[rsp]
	lea	rcx, QWORD PTR $T21[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR text_pos$[rsp]
	lea	rcx, QWORD PTR bb$15[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 333  : 		ItemSize(text_size);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR text_size$12[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 334  : 		if (!ItemAdd(bb, 0))

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR bb$15[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN19@TextUnform

; 335  : 			return;

	jmp	SHORT $LN1@TextUnform
$LN19@TextUnform:

; 336  : 
; 337  : 		// Render (we don't hide text after ## in this end-user function)
; 338  : 		RenderTextWrapped(ImVec2(bb.Max.x, bb.Min.y), text_begin, text_end, wrap_width);

	movss	xmm2, DWORD PTR bb$15[rsp+4]
	movss	xmm1, DWORD PTR bb$15[rsp+8]
	lea	rcx, QWORD PTR $T22[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	movss	xmm3, DWORD PTR wrap_width$8[rsp]
	mov	r8, QWORD PTR text_end$[rsp]
	mov	rdx, QWORD PTR text_begin$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?RenderTextWrapped@ImGui@@YAXUImVec2@@PEBD1M@Z ; ImGui::RenderTextWrapped
	npad	1
$LN11@TextUnform:
$LN1@TextUnform:

; 339  : 	}
; 340  : }

	add	rsp, 312				; 00000138H
	pop	rdi
	pop	rsi
	ret	0
?TextUnformatted2@ImGui@@YAXPEBD0@Z ENDP		; ImGui::TextUnformatted2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
tv87 = 48
wrap_enabled$ = 49
line_height$1 = 52
line$2 = 56
pos$3 = 64
lines_skipped$4 = 72
text_pos$ = 80
lines_skipped$5 = 88
window$ = 96
text_size$6 = 104
lines_skippable$7 = 112
wrap_pos_x$ = 116
tv259 = 120
wrap_width$8 = 124
line_end$9 = 128
line_end$10 = 136
line_end$11 = 144
text_size$12 = 152
text_begin$ = 160
line_rect$13 = 168
line_size$14 = 184
clip_rect$15 = 192
bb$16 = 208
g$ = 224
$T17 = 232
$T18 = 240
$T19 = 248
$T20 = 256
$T21 = 264
bb$22 = 272
text$ = 320
text_end$ = 328
?TextUnformatted@ImGui@@YAXPEBD0@Z PROC			; ImGui::TextUnformatted

; 129  : {

$LN25:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 296				; 00000128H

; 130  : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 131  : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN8@TextUnform

; 132  : 		return;

	jmp	$LN1@TextUnform
$LN8@TextUnform:

; 133  : 
; 134  : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 135  : 	IM_ASSERT(text != NULL);
; 136  : 	const char* text_begin = text;

	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR text_begin$[rsp], rax

; 137  : 	if (text_end == NULL)

	cmp	QWORD PTR text_end$[rsp], 0
	jne	SHORT $LN9@TextUnform

; 138  : 		text_end = text + strlen(text); // FIXME-OPT

	mov	rcx, QWORD PTR text$[rsp]
	call	strlen
	mov	rcx, QWORD PTR text$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR text_end$[rsp], rax
$LN9@TextUnform:

; 139  : 
; 140  : 	const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrentLineTextBaseOffset);

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	addss	xmm0, DWORD PTR [rcx+328]
	movaps	xmm2, xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm1, DWORD PTR [rax+340]
	lea	rcx, QWORD PTR text_pos$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2

; 141  : 	const float wrap_pos_x = window->DC.TextWrapPos;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+516]
	movss	DWORD PTR wrap_pos_x$[rsp], xmm0

; 142  : 	const bool wrap_enabled = wrap_pos_x >= 0.0f;

	movss	xmm0, DWORD PTR wrap_pos_x$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN21@TextUnform
	mov	BYTE PTR tv87[rsp], 1
	jmp	SHORT $LN22@TextUnform
$LN21@TextUnform:
	mov	BYTE PTR tv87[rsp], 0
$LN22@TextUnform:
	movzx	eax, BYTE PTR tv87[rsp]
	mov	BYTE PTR wrap_enabled$[rsp], al

; 143  : 	if (text_end - text > 2000 && !wrap_enabled)

	mov	rax, QWORD PTR text$[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	rax, 2000				; 000007d0H
	jle	$LN10@TextUnform
	movzx	eax, BYTE PTR wrap_enabled$[rsp]
	test	eax, eax
	jne	$LN10@TextUnform

; 144  : 	{
; 145  : 		// Long text!
; 146  : 		// Perform manual coarse clipping to optimize for long multi-line text
; 147  : 		// - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
; 148  : 		// - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
; 149  : 		// - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.
; 150  : 		const char* line = text;

	mov	rax, QWORD PTR text$[rsp]
	mov	QWORD PTR line$2[rsp], rax

; 151  : 		const float line_height = GetTextLineHeight();

	call	?GetTextLineHeight@ImGui@@YAMXZ		; ImGui::GetTextLineHeight
	movss	DWORD PTR line_height$1[rsp], xmm0

; 152  : 		const ImRect clip_rect = window->ClipRect;

	lea	rax, QWORD PTR clip_rect$15[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+248]
	mov	ecx, 16
	rep movsb

; 153  : 		ImVec2 text_size(0, 0);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR text_size$6[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	npad	1

; 154  : 
; 155  : 		if (text_pos.y <= clip_rect.Max.y)

	movss	xmm0, DWORD PTR clip_rect$15[rsp+12]
	comiss	xmm0, DWORD PTR text_pos$[rsp+4]
	jb	$LN12@TextUnform

; 156  : 		{
; 157  : 			ImVec2 pos = text_pos;

	mov	rax, QWORD PTR text_pos$[rsp]
	mov	QWORD PTR pos$3[rsp], rax

; 158  : 
; 159  : 			// Lines to skip (can't skip when logging text)
; 160  : 			//if (!g.LogEnabled)
; 161  : 			{
; 162  : 				int lines_skippable = (int)((clip_rect.Min.y - text_pos.y) / line_height);

	movss	xmm0, DWORD PTR clip_rect$15[rsp+4]
	subss	xmm0, DWORD PTR text_pos$[rsp+4]
	divss	xmm0, DWORD PTR line_height$1[rsp]
	cvttss2si eax, xmm0
	mov	DWORD PTR lines_skippable$7[rsp], eax

; 163  : 				if (lines_skippable > 0)

	cmp	DWORD PTR lines_skippable$7[rsp], 0
	jle	$LN13@TextUnform

; 164  : 				{
; 165  : 					int lines_skipped = 0;

	mov	DWORD PTR lines_skipped$4[rsp], 0
$LN2@TextUnform:

; 166  : 					while (line < text_end && lines_skipped < lines_skippable)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR line$2[rsp], rax
	jae	SHORT $LN3@TextUnform
	mov	eax, DWORD PTR lines_skippable$7[rsp]
	cmp	DWORD PTR lines_skipped$4[rsp], eax
	jge	SHORT $LN3@TextUnform

; 167  : 					{
; 168  : 						const char* line_end = (const char*)memchr(line, '\n', text_end - line);

	mov	rax, QWORD PTR line$2[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	edx, 10
	mov	rcx, QWORD PTR line$2[rsp]
	call	memchr
	mov	QWORD PTR line_end$10[rsp], rax

; 169  : 						if (!line_end)

	cmp	QWORD PTR line_end$10[rsp], 0
	jne	SHORT $LN14@TextUnform

; 170  : 							line_end = text_end;

	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR line_end$10[rsp], rax
$LN14@TextUnform:

; 171  : 						line = line_end + 1;

	mov	rax, QWORD PTR line_end$10[rsp]
	inc	rax
	mov	QWORD PTR line$2[rsp], rax

; 172  : 						lines_skipped++;

	mov	eax, DWORD PTR lines_skipped$4[rsp]
	inc	eax
	mov	DWORD PTR lines_skipped$4[rsp], eax

; 173  : 					}

	jmp	SHORT $LN2@TextUnform
$LN3@TextUnform:

; 174  : 					pos.y += lines_skipped * line_height;

	cvtsi2ss xmm0, DWORD PTR lines_skipped$4[rsp]
	mulss	xmm0, DWORD PTR line_height$1[rsp]
	movss	xmm1, DWORD PTR pos$3[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR pos$3[rsp+4], xmm0
$LN13@TextUnform:

; 175  : 				}
; 176  : 			}
; 177  : 
; 178  : 			// Lines to render
; 179  : 			if (line < text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR line$2[rsp], rax
	jae	$LN15@TextUnform

; 180  : 			{
; 181  : 				ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));

	movss	xmm2, DWORD PTR line_height$1[rsp]
	movss	xmm1, DWORD PTR __real@7f7fffff
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	r8, rax
	lea	rdx, QWORD PTR pos$3[rsp]
	lea	rcx, QWORD PTR $T18[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR pos$3[rsp]
	lea	rcx, QWORD PTR line_rect$13[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1
$LN4@TextUnform:

; 182  : 				while (line < text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR line$2[rsp], rax
	jae	$LN5@TextUnform

; 183  : 				{
; 184  : 					if (IsClippedEx(line_rect, 0, false))

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR line_rect$13[rsp]
	call	?IsClippedEx@ImGui@@YA_NAEBUImRect@@I_N@Z ; ImGui::IsClippedEx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@TextUnform

; 185  : 						break;

	jmp	$LN5@TextUnform
$LN16@TextUnform:

; 186  : 
; 187  : 					const char* line_end = (const char*)memchr(line, '\n', text_end - line);

	mov	rax, QWORD PTR line$2[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	edx, 10
	mov	rcx, QWORD PTR line$2[rsp]
	call	memchr
	mov	QWORD PTR line_end$9[rsp], rax

; 188  : 					if (!line_end)

	cmp	QWORD PTR line_end$9[rsp], 0
	jne	SHORT $LN17@TextUnform

; 189  : 						line_end = text_end;

	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR line_end$9[rsp], rax
$LN17@TextUnform:

; 190  : 					const ImVec2 line_size = CalcTextSize(line, line_end, false);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	mov	r8, QWORD PTR line_end$9[rsp]
	mov	rdx, QWORD PTR line$2[rsp]
	lea	rcx, QWORD PTR line_size$14[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 191  : 					text_size.x = ImMax(text_size.x, line_size.x);

	movss	xmm1, DWORD PTR line_size$14[rsp]
	movss	xmm0, DWORD PTR text_size$6[rsp]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	movss	DWORD PTR text_size$6[rsp], xmm0

; 192  : 					RenderText(pos, line, line_end, false);

	xor	r9d, r9d
	mov	r8, QWORD PTR line_end$9[rsp]
	mov	rdx, QWORD PTR line$2[rsp]
	mov	rcx, QWORD PTR pos$3[rsp]
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText

; 193  : 					line = line_end + 1;

	mov	rax, QWORD PTR line_end$9[rsp]
	inc	rax
	mov	QWORD PTR line$2[rsp], rax

; 194  : 					line_rect.Min.y += line_height;

	movss	xmm0, DWORD PTR line_rect$13[rsp+4]
	addss	xmm0, DWORD PTR line_height$1[rsp]
	movss	DWORD PTR line_rect$13[rsp+4], xmm0

; 195  : 					line_rect.Max.y += line_height;

	movss	xmm0, DWORD PTR line_rect$13[rsp+12]
	addss	xmm0, DWORD PTR line_height$1[rsp]
	movss	DWORD PTR line_rect$13[rsp+12], xmm0

; 196  : 					pos.y += line_height;

	movss	xmm0, DWORD PTR pos$3[rsp+4]
	addss	xmm0, DWORD PTR line_height$1[rsp]
	movss	DWORD PTR pos$3[rsp+4], xmm0

; 197  : 				}

	jmp	$LN4@TextUnform
$LN5@TextUnform:

; 198  : 
; 199  : 				// Count remaining lines
; 200  : 				int lines_skipped = 0;

	mov	DWORD PTR lines_skipped$5[rsp], 0
$LN6@TextUnform:

; 201  : 				while (line < text_end)

	mov	rax, QWORD PTR text_end$[rsp]
	cmp	QWORD PTR line$2[rsp], rax
	jae	SHORT $LN7@TextUnform

; 202  : 				{
; 203  : 					const char* line_end = (const char*)memchr(line, '\n', text_end - line);

	mov	rax, QWORD PTR line$2[rsp]
	mov	rcx, QWORD PTR text_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	edx, 10
	mov	rcx, QWORD PTR line$2[rsp]
	call	memchr
	mov	QWORD PTR line_end$11[rsp], rax

; 204  : 					if (!line_end)

	cmp	QWORD PTR line_end$11[rsp], 0
	jne	SHORT $LN18@TextUnform

; 205  : 						line_end = text_end;

	mov	rax, QWORD PTR text_end$[rsp]
	mov	QWORD PTR line_end$11[rsp], rax
$LN18@TextUnform:

; 206  : 					line = line_end + 1;

	mov	rax, QWORD PTR line_end$11[rsp]
	inc	rax
	mov	QWORD PTR line$2[rsp], rax

; 207  : 					lines_skipped++;

	mov	eax, DWORD PTR lines_skipped$5[rsp]
	inc	eax
	mov	DWORD PTR lines_skipped$5[rsp], eax

; 208  : 				}

	jmp	SHORT $LN6@TextUnform
$LN7@TextUnform:

; 209  : 				pos.y += lines_skipped * line_height;

	cvtsi2ss xmm0, DWORD PTR lines_skipped$5[rsp]
	mulss	xmm0, DWORD PTR line_height$1[rsp]
	movss	xmm1, DWORD PTR pos$3[rsp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR pos$3[rsp+4], xmm0
$LN15@TextUnform:

; 210  : 			}
; 211  : 
; 212  : 			text_size.y += (pos - text_pos).y;

	lea	r8, QWORD PTR text_pos$[rsp]
	lea	rdx, QWORD PTR pos$3[rsp]
	lea	rcx, QWORD PTR $T19[rsp]
	call	??G@YA?AUImVec2@@AEBU0@0@Z		; operator-
	movss	xmm0, DWORD PTR text_size$6[rsp+4]
	addss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR text_size$6[rsp+4], xmm0
$LN12@TextUnform:

; 213  : 		}
; 214  : 
; 215  : 		ImRect bb(text_pos, text_pos + text_size);

	lea	r8, QWORD PTR text_size$6[rsp]
	lea	rdx, QWORD PTR text_pos$[rsp]
	lea	rcx, QWORD PTR $T20[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR text_pos$[rsp]
	lea	rcx, QWORD PTR bb$22[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 216  : 		ItemSize(text_size);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR text_size$6[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize

; 217  : 		ItemAdd(bb, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR bb$22[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	npad	1

; 218  : 	}

	jmp	$LN11@TextUnform
$LN10@TextUnform:

; 219  : 	else
; 220  : 	{
; 221  : 		const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;

	movzx	eax, BYTE PTR wrap_enabled$[rsp]
	test	eax, eax
	je	SHORT $LN23@TextUnform
	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	movss	xmm1, DWORD PTR wrap_pos_x$[rsp]
	mov	rcx, rax
	call	?CalcWrapWidthForPos@ImGui@@YAMAEBUImVec2@@M@Z ; ImGui::CalcWrapWidthForPos
	movss	DWORD PTR tv259[rsp], xmm0
	jmp	SHORT $LN24@TextUnform
$LN23@TextUnform:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv259[rsp], xmm0
$LN24@TextUnform:
	movss	xmm0, DWORD PTR tv259[rsp]
	movss	DWORD PTR wrap_width$8[rsp], xmm0

; 222  : 		const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);

	movss	xmm0, DWORD PTR wrap_width$8[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	xor	r9d, r9d
	mov	r8, QWORD PTR text_end$[rsp]
	mov	rdx, QWORD PTR text_begin$[rsp]
	lea	rcx, QWORD PTR text_size$12[rsp]
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
	npad	1

; 223  : 
; 224  : 		// Account of baseline offset
; 225  : 		ImRect bb(text_pos, text_pos + text_size);

	lea	r8, QWORD PTR text_size$12[rsp]
	lea	rdx, QWORD PTR text_pos$[rsp]
	lea	rcx, QWORD PTR $T21[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	r8, rax
	lea	rdx, QWORD PTR text_pos$[rsp]
	lea	rcx, QWORD PTR bb$16[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 226  : 		ItemSize(text_size);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR text_size$12[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 227  : 		if (!ItemAdd(bb, 0))

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR bb$16[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN19@TextUnform

; 228  : 			return;

	jmp	SHORT $LN1@TextUnform
$LN19@TextUnform:

; 229  : 
; 230  : 		// Render (we don't hide text after ## in this end-user function)
; 231  : 		RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);

	movss	xmm3, DWORD PTR wrap_width$8[rsp]
	mov	r8, QWORD PTR text_end$[rsp]
	mov	rdx, QWORD PTR text_begin$[rsp]
	mov	rcx, QWORD PTR bb$16[rsp]
	call	?RenderTextWrapped@ImGui@@YAXUImVec2@@PEBD1M@Z ; ImGui::RenderTextWrapped
	npad	1
$LN11@TextUnform:
$LN1@TextUnform:

; 232  : 	}
; 233  : }

	add	rsp, 296				; 00000128H
	pop	rdi
	pop	rsi
	ret	0
?TextUnformatted@ImGui@@YAXPEBD0@Z ENDP			; ImGui::TextUnformatted
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 32
g$ = 40
?AlignTextToFramePadding@ImGui@@YAXXZ PROC		; ImGui::AlignTextToFramePadding

; 1441 : {

$LN4:
	sub	rsp, 56					; 00000038H

; 1442 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1443 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@AlignTextT

; 1444 : 		return;

	jmp	$LN1@AlignTextT
$LN2@AlignTextT:

; 1445 : 
; 1446 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1447 : 	window->DC.CurrentLineSize.y = ImMax(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm0, DWORD PTR [rax+5528]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+6408]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm1, xmm0
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+324]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+324], xmm0

; 1448 : 	window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.CurrentLineTextBaseOffset, g.Style.FramePadding.y);

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR [rax+5528]
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+328]
	call	??$ImMax@M@@YAMMM@Z			; ImMax<float>
	mov	rax, QWORD PTR window$[rsp]
	movss	DWORD PTR [rax+328], xmm0
$LN1@AlignTextT:

; 1449 : }

	add	rsp, 56					; 00000038H
	ret	0
?AlignTextToFramePadding@ImGui@@YAXXZ ENDP		; ImGui::AlignTextToFramePadding
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 32
$T1 = 40
bb$ = 48
size$ = 80
?Dummy@ImGui@@YAXAEBUImVec2@@@Z PROC			; ImGui::Dummy

; 1414 : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1415 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1416 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@Dummy

; 1417 : 		return;

	jmp	SHORT $LN1@Dummy
$LN2@Dummy:

; 1418 : 
; 1419 : 	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 340				; 00000154H
	mov	r8, QWORD PTR size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??H@YA?AUImVec2@@AEBU0@0@Z		; operator+
	mov	rcx, QWORD PTR window$[rsp]
	add	rcx, 340				; 00000154H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1420 : 	ItemSize(bb);

	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z	; ImGui::ItemSize

; 1421 : 	ItemAdd(bb, 0);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	npad	1
$LN1@Dummy:

; 1422 : }

	add	rsp, 72					; 00000048H
	ret	0
?Dummy@ImGui@@YAXAEBUImVec2@@@Z ENDP			; ImGui::Dummy
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 32
$T1 = 40
?Spacing@ImGui@@YAXXZ PROC				; ImGui::Spacing

; 1406 : {

$LN4:
	sub	rsp, 56					; 00000038H

; 1407 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1408 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@Spacing

; 1409 : 		return;

	jmp	SHORT $LN1@Spacing
$LN2@Spacing:

; 1410 : 	ItemSize(ImVec2(0, 0));

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm1, xmm1
	mov	rcx, rax
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1
$LN1@Spacing:

; 1411 : }

	add	rsp, 56					; 00000038H
	ret	0
?Spacing@ImGui@@YAXXZ ENDP				; ImGui::Spacing
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
backup_layout_type$ = 32
window$ = 40
g$ = 48
$T1 = 56
$T2 = 64
?NewLine@ImGui@@YAXXZ PROC				; ImGui::NewLine

; 1425 : {

$LN6:
	sub	rsp, 88					; 00000058H

; 1426 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1427 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@NewLine

; 1428 : 		return;

	jmp	$LN1@NewLine
$LN2@NewLine:

; 1429 : 
; 1430 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1431 : 	const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;

	mov	rax, QWORD PTR window$[rsp]
	mov	eax, DWORD PTR [rax+468]
	mov	DWORD PTR backup_layout_type$[rsp], eax

; 1432 : 	window->DC.LayoutType = ImGuiLayoutType_Vertical;

	mov	rax, QWORD PTR window$[rsp]
	mov	DWORD PTR [rax+468], 1

; 1433 : 	if (window->DC.CurrentLineSize.y > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+324]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@NewLine

; 1434 : 		ItemSize(ImVec2(0, 0));

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm1, xmm1
	mov	rcx, rax
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1
	jmp	SHORT $LN4@NewLine
$LN3@NewLine:

; 1435 : 	else
; 1436 : 		ItemSize(ImVec2(0.0f, g.FontSize));

	mov	rax, QWORD PTR g$[rsp]
	movss	xmm2, DWORD PTR [rax+6408]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm1, xmm1
	mov	rcx, rax
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1
$LN4@NewLine:

; 1437 : 	window->DC.LayoutType = backup_layout_type;

	mov	rax, QWORD PTR window$[rsp]
	mov	ecx, DWORD PTR backup_layout_type$[rsp]
	mov	DWORD PTR [rax+468], ecx
$LN1@NewLine:

; 1438 : }

	add	rsp, 88					; 00000058H
	ret	0
?NewLine@ImGui@@YAXXZ ENDP				; ImGui::NewLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui_widgets.cpp
_TEXT	SEGMENT
window$ = 48
x1$ = 56
tv71 = 60
flags$ = 64
x2$ = 68
tv180 = 72
bb$ = 80
tv148 = 96
tv146 = 104
tv178 = 112
tv182 = 120
g$ = 128
$T1 = 136
$T2 = 144
$T3 = 152
$T4 = 160
?Separator@ImGui@@YAXXZ PROC				; ImGui::Separator

; 1453 : {

$LN12:
	sub	rsp, 184				; 000000b8H

; 1454 : 	ImGuiWindow* window = GetCurrentWindow();

	call	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
	mov	QWORD PTR window$[rsp], rax

; 1455 : 	if (window->SkipItems)

	mov	rax, QWORD PTR window$[rsp]
	movzx	eax, BYTE PTR [rax+115]
	test	eax, eax
	je	SHORT $LN2@Separator

; 1456 : 		return;

	jmp	$LN1@Separator
$LN2@Separator:

; 1457 : 	ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$[rsp], rax

; 1458 : 
; 1459 : 	// Those flags should eventually be overridable by the user
; 1460 : 	ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;

	mov	rax, QWORD PTR window$[rsp]
	cmp	DWORD PTR [rax+468], 0
	jne	SHORT $LN10@Separator
	mov	DWORD PTR tv71[rsp], 2
	jmp	SHORT $LN11@Separator
$LN10@Separator:
	mov	DWORD PTR tv71[rsp], 1
$LN11@Separator:
	mov	eax, DWORD PTR tv71[rsp]
	mov	DWORD PTR flags$[rsp], eax

; 1461 : 	IM_ASSERT(ImIsPowerOfTwo((int)(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical))));   // Check that only 1 option is selected
; 1462 : 	if (flags & ImGuiSeparatorFlags_Vertical)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN3@Separator

; 1463 : 	{
; 1464 : 		VerticalSeparator();

	call	?VerticalSeparator@ImGui@@YAXXZ		; ImGui::VerticalSeparator
	npad	1

; 1465 : 		return;

	jmp	$LN1@Separator
$LN3@Separator:

; 1466 : 	}
; 1467 : 
; 1468 : 	// Horizontal Separator
; 1469 : 	if (window->DC.ColumnsSet)

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN4@Separator

; 1470 : 		PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect
	npad	1
$LN4@Separator:

; 1471 : 
; 1472 : 	float x1 = window->Pos.x;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	movss	DWORD PTR x1$[rsp], xmm0

; 1473 : 	float x2 = window->Pos.x + window->Size.x;

	mov	rax, QWORD PTR window$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+48]
	addss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR x2$[rsp], xmm0

; 1474 : 	if (!window->DC.GroupStack.empty())

	mov	rax, QWORD PTR window$[rsp]
	add	rax, 536				; 00000218H
	mov	rcx, rax
	call	?empty@?$ImVector@UImGuiGroupData@@@@QEBA_NXZ ; ImVector<ImGuiGroupData>::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Separator

; 1475 : 		x1 += window->DC.Indent.x;

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR x1$[rsp]
	addss	xmm0, DWORD PTR [rax+576]
	movss	DWORD PTR x1$[rsp], xmm0
$LN5@Separator:

; 1476 : 
; 1477 : 	const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y + 1.0f));

	mov	rax, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rax+344]
	addss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	movss	xmm1, DWORD PTR x2$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv148[rsp], rax
	mov	rax, QWORD PTR window$[rsp]
	movss	xmm2, DWORD PTR [rax+344]
	movss	xmm1, DWORD PTR x1$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv146[rsp], rax
	mov	r8, QWORD PTR tv148[rsp]
	mov	rdx, QWORD PTR tv146[rsp]
	lea	rcx, QWORD PTR bb$[rsp]
	call	??0ImRect@@QEAA@AEBUImVec2@@0@Z		; ImRect::ImRect
	npad	1

; 1478 : 	ItemSize(ImVec2(0.0f, 0.0f)); // NB: we don't provide our width so that it doesn't get feed back into AutoFit, we don't provide height to not alter layout.

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	xorps	xmm1, xmm1
	mov	rcx, rax
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	npad	1

; 1479 : 	if (!ItemAdd(bb, 0))

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z ; ImGui::ItemAdd
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Separator

; 1480 : 	{
; 1481 : 		if (window->DC.ColumnsSet)

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN7@Separator

; 1482 : 			PushColumnClipRect();

	mov	ecx, -1
	call	?PushColumnClipRect@ImGui@@YAXH@Z	; ImGui::PushColumnClipRect
	npad	1
$LN7@Separator:

; 1483 : 		return;

	jmp	$LN1@Separator
$LN6@Separator:

; 1484 : 	}
; 1485 : 
; 1486 : 	window->DrawList->AddLine(bb.Min, ImVec2(bb.Max.x, bb.Min.y), GetColorU32(ImGuiCol_Separator));

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+696]
	mov	QWORD PTR tv182[rsp], rax
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, 27
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR tv180[rsp], eax
	movss	xmm2, DWORD PTR bb$[rsp+4]
	movss	xmm1, DWORD PTR bb$[rsp+8]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	QWORD PTR tv178[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR tv180[rsp]
	mov	r8, QWORD PTR tv178[rsp]
	lea	rdx, QWORD PTR bb$[rsp]
	mov	rcx, QWORD PTR tv182[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	npad	1

; 1487 : 
; 1488 : 	/*if (g.LogEnabled)
; 1489 : 		LogRenderedText(&bb.Min, ("--------------------------------"));*/
; 1490 : 
; 1491 : 	if (window->DC.ColumnsSet)

	mov	rax, QWORD PTR window$[rsp]
	cmp	QWORD PTR [rax+568], 0
	je	SHORT $LN8@Separator

; 1492 : 	{
; 1493 : 		PushColumnClipRect();

	mov	ecx, -1
	call	?PushColumnClipRect@ImGui@@YAXH@Z	; ImGui::PushColumnClipRect

; 1494 : 		window->DC.ColumnsSet->LineMinY = window->DC.CursorPos.y;

	mov	rax, QWORD PTR window$[rsp]
	mov	rax, QWORD PTR [rax+568]
	mov	rcx, QWORD PTR window$[rsp]
	movss	xmm0, DWORD PTR [rcx+344]
	movss	DWORD PTR [rax+12], xmm0
$LN8@Separator:
$LN1@Separator:

; 1495 : 	}
; 1496 : }

	add	rsp, 184				; 000000b8H
	ret	0
?Separator@ImGui@@YAXXZ ENDP				; ImGui::Separator
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec4@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
_z$ = 32
_w$ = 40
??0ImVec4@@QEAA@MMMM@Z PROC				; ImVec4::ImVec4, COMDAT

; 190  : 	ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _x$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _y$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _z$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _w$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec4@@QEAA@MMMM@Z ENDP				; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec4@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImVec4@@QEAA@XZ PROC					; ImVec4::ImVec4, COMDAT

; 189  : 	ImVec4() { x = y = z = w = 0.0f; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+12], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec4@@QEAA@XZ ENDP					; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??AImVec2@@QEAAAEAM_K@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
??AImVec2@@QEAAAEAM_K@Z PROC				; ImVec2::operator[], COMDAT

; 179  : 	float& operator[] (size_t idx) { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR idx$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	ret	0
??AImVec2@@QEAAAEAM_K@Z ENDP				; ImVec2::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??AImVec2@@QEBAM_K@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
??AImVec2@@QEBAM_K@Z PROC				; ImVec2::operator[], COMDAT

; 178  : 	float  operator[] (size_t idx) const { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR idx$[rsp]
	movss	xmm0, DWORD PTR [rax+rcx*4]
	ret	0
??AImVec2@@QEBAM_K@Z ENDP				; ImVec2::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec2@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
??0ImVec2@@QEAA@MM@Z PROC				; ImVec2::ImVec2, COMDAT

; 175  : 	ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _x$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _y$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec2@@QEAA@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec2@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImVec2@@QEAA@XZ PROC					; ImVec2::ImVec2, COMDAT

; 173  : 	ImVec2() { x = y = 0.0f; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec2@@QEAA@XZ ENDP					; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ PROC	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK'', COMDAT

; 157  : 	static const VectorRegister QINV_SIGN_MASK = MakeVectorRegister(-1.f, -1.f, -1.f, 1.f);

	sub	rsp, 40					; 00000028H
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@bf800000
	movss	xmm0, DWORD PTR __real@bf800000
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ENDP	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EXYZMask@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EXYZMask@Math@Core@IronMan@@YAXXZ PROC		; IronMan::Core::Math::`dynamic initializer for 'XYZMask'', COMDAT

; 155  : 	static const VectorRegister XYZMask = MakeVectorRegister((uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0x00000000);

	sub	rsp, 40					; 00000028H
	xor	r9d, r9d
	mov	r8d, -1					; ffffffffH
	mov	edx, -1					; ffffffffH
	mov	ecx, -1					; ffffffffH
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?XYZMask@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EXYZMask@Math@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::Math::`dynamic initializer for 'XYZMask''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
_TEXT	SEGMENT
$T1 = 0
X$ = 32
Y$ = 40
Z$ = 48
W$ = 56
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 135  : 	{

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24

; 136  : 		return _mm_setr_ps(X, Y, Z, W);

	movss	xmm0, DWORD PTR W$[rsp]
	movss	xmm1, DWORD PTR Z$[rsp]
	movss	xmm2, DWORD PTR Y$[rsp]
	movss	xmm3, DWORD PTR X$[rsp]
	unpcklps xmm1, xmm0
	unpcklps xmm3, xmm2
	movaps	xmm0, xmm3
	movlhps	xmm0, xmm1
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[rsp]

; 137  : 	}

	add	rsp, 24
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
_TEXT	SEGMENT
$T1 = 0
Tmp$ = 16
__$ArrayPad$ = 32
X$ = 64
Y$ = 72
Z$ = 80
W$ = 88
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 119  : 	{

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 120  : 		union { VectorRegister v; VectorRegisterInt i; } Tmp;
; 121  : 		Tmp.i = _mm_setr_epi32(X, Y, Z, W);

	movd	xmm0, DWORD PTR W$[rsp]
	movd	xmm1, DWORD PTR Z$[rsp]
	movd	xmm2, DWORD PTR Y$[rsp]
	movd	xmm3, DWORD PTR X$[rsp]
	punpckldq xmm1, xmm0
	punpckldq xmm3, xmm2
	movdqa	xmm0, xmm3
	punpcklqdq xmm0, xmm1
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	movdqa	xmm0, XMMWORD PTR $T1[rsp]
	movdqa	XMMWORD PTR Tmp$[rsp], xmm0

; 122  : 		return Tmp.v;

	movaps	xmm0, XMMWORD PTR Tmp$[rsp]

; 123  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Esslinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Esslinit_@detail@httplib@@YAXXZ PROC		; httplib::detail::`dynamic initializer for 'sslinit_'', COMDAT

; 8802 :         static SSLInit sslinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?sslinit_@detail@httplib@@3VSSLInit@12@A
	call	??0SSLInit@detail@httplib@@QEAA@XZ	; httplib::detail::SSLInit::SSLInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Esslinit_@detail@httplib@@YAXXZ ENDP		; httplib::detail::`dynamic initializer for 'sslinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0SSLInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0SSLInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::SSLInit::SSLInit, COMDAT

; 8693 :             SSLInit() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8694 :                 OPENSSL_init_ssl(

	xor	edx, edx
	mov	ecx, 2097154				; 00200002H
	call	OPENSSL_init_ssl
	npad	1

; 8695 :                     OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
; 8696 :             }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0SSLInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::SSLInit::SSLInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fwsinit_@detail@httplib@@YAXXZ
text$yd	SEGMENT
??__Fwsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic atexit destructor for 'wsinit_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??1WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::~WSInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fwsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic atexit destructor for 'wsinit_''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Ewsinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Ewsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic initializer for 'wsinit_'', COMDAT

; 5291 :         static WSInit wsinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??0WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::WSInit
	lea	rcx, OFFSET FLAT:??__Fwsinit_@detail@httplib@@YAXXZ ; httplib::detail::`dynamic atexit destructor for 'wsinit_''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ewsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic initializer for 'wsinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??1WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::~WSInit, COMDAT

; 5284 :             ~WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5285 :                 if (is_valid_) WSACleanup();

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@WSInit
	call	QWORD PTR __imp_WSACleanup
	npad	1
$LN2@WSInit:

; 5286 :             }

	add	rsp, 40					; 00000028H
	ret	0
??1WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::~WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
wsaData$ = 32
__$ArrayPad$ = 448
this$ = 480
??0WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::WSInit, COMDAT

; 5279 :             WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5283 : 
; 5284 :             ~WSInit() {
; 5285 :                 if (is_valid_) WSACleanup();
; 5286 :             }
; 5287 : 
; 5288 :             bool is_valid_ = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 5280 :                 WSADATA wsaData;
; 5281 :                 if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 2
	call	QWORD PTR __imp_WSAStartup
	test	eax, eax
	jne	SHORT $LN2@WSInit
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@WSInit:

; 5282 :             }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	ret	0
??0WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3197 :     _In_z_ const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 3198 :     return _STD move(_Right.insert(0, _Left));

	mov	r8, QWORD PTR _Left$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	mov	rcx, rax
	call	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3199 : }

	add	rsp, 56					; 00000038H
	ret	0
	int	3
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 102  : }

	add	rsp, 24
	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3074 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3075 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3076 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3070 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3071 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3072 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
tv79 = 32
this$ = 64
_Right$ = 72
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 3066 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3067 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv79[rsp]
	call	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
	npad	1

; 3068 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Al$2 = 48
this$ = 80
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3044 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3045 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3046 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 3047 :         if (_My_data._Large_mode_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 3048 :             _ASAN_STRING_REMOVE(*this);
; 3049 :             auto& _Al = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$2[rsp], rax

; 3050 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR [rax+24]
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$2[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3051 :             _My_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 3052 :         }
; 3053 : 
; 3054 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3058 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_size$ = 72
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT

; 3038 :     _CONSTEXPR20 void _Eos(const size_type _New_size) noexcept { // set new length and null terminator

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3039 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 3040 :         _Mypair._Myval2._Mysize = _New_size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 3041 :         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	rax, QWORD PTR _New_size$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3042 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv76 = 32
tv74 = 40
this$ = 64
_Requested$ = 72
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2954 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2955 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv76[rsp]
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR _Requested$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth

; 2956 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 32
$T1 = 40
_Requested$ = 64
_Old$ = 72
_Max$ = 80
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2941 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, QWORD PTR _Requested$[rsp]
	or	rax, 15
	mov	QWORD PTR _Masked$[rsp], rax

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	rax, QWORD PTR _Max$[rsp]
	cmp	QWORD PTR _Masked$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 2944 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Old$[rsp], rax
	jbe	SHORT $LN3@Calculate_

; 2948 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Old$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Masked$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
$LN1@Calculate_:

; 2952 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity, COMDAT

; 2403 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 2404 :         return _Mypair._Myval2._Myres;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]

; 2405 :     }

	ret	0
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
_TEXT	SEGMENT
_Old_size$ = 32
this$ = 64
_New_size$ = 72
_Ch$ = 80
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT

; 2358 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _New_size, const _Elem _Ch = _Elem()) {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2359 :         // determine new length, padding with _Ch elements as needed
; 2360 :         const size_type _Old_size = size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	QWORD PTR _Old_size$[rsp], rax

; 2361 :         if (_New_size <= _Old_size) {

	mov	rax, QWORD PTR _Old_size$[rsp]
	cmp	QWORD PTR _New_size$[rsp], rax
	ja	SHORT $LN2@resize

; 2362 :             _Eos(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	npad	1

; 2363 :         } else {

	jmp	SHORT $LN3@resize
$LN2@resize:

; 2364 :             append(_New_size - _Old_size, _Ch);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN3@resize:

; 2365 :         }
; 2366 :     }

	add	rsp, 56					; 00000038H
	ret	0
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
_Alloc_max$ = 40
_Storage_max$ = 48
$T2 = 56
$T3 = 64
this$ = 96
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 2349 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2350 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	mov	QWORD PTR _Alloc_max$[rsp], rax

; 2351 :         const size_type _Storage_max = // can always store small string

	mov	QWORD PTR $T1[rsp], 16
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Alloc_max$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Storage_max$[rsp], rax

; 2352 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2353 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

	mov	rax, QWORD PTR _Storage_max$[rsp]
	dec	rax
	mov	QWORD PTR $T2[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 2354 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2355 :         );
; 2356 :     }

	add	rsp, 88					; 00000058H
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 2345 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 2346 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]

; 2347 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2327 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2328 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2329 :     }

	add	rsp, 40					; 00000028H
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
_Ptr$ = 64
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 1754 :     _CONSTEXPR20 basic_string& insert(const size_type _Off, _In_z_ const _Elem* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1755 :         // insert [_Ptr, <null>) at _Off
; 1756 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r9, rax
	mov	r8, QWORD PTR _Ptr$[rsp]
	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1757 :     }

	add	rsp, 40					; 00000028H
	ret	0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
_TEXT	SEGMENT
tv78 = 48
_Check_overlap$ = 49
$T1 = 50
_Insert_at$2 = 56
_Ptr_shifted_after$3 = 64
_Old_size$ = 72
_Old_ptr$4 = 80
tv69 = 88
tv143 = 96
this$ = 128
_Off$ = 136
_Ptr$ = 144
_Count$ = 152
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 1706 :         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H

; 1707 :         // insert [_Ptr, _Ptr + _Count) at _Off
; 1708 :         _Mypair._Myval2._Check_offset(_Off);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 1709 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 1710 : 
; 1711 :         // We can't check for overlapping ranges when constant evaluated since comparison of pointers into string
; 1712 :         // literals is unspecified, so always reallocate and copy to the new buffer if constant evaluated.
; 1713 : #if _HAS_CXX20
; 1714 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();
; 1715 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1716 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	cmp	QWORD PTR _Count$[rsp], rax
	ja	SHORT $LN9@insert
	mov	BYTE PTR tv78[rsp], 1
	jmp	SHORT $LN10@insert
$LN9@insert:
	mov	BYTE PTR tv78[rsp], 0
$LN10@insert:
	movzx	eax, BYTE PTR tv78[rsp]
	mov	BYTE PTR _Check_overlap$[rsp], al

; 1717 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1718 : 
; 1719 :         if (_Check_overlap) {

	movzx	eax, BYTE PTR _Check_overlap$[rsp]
	test	eax, eax
	je	$LN2@insert

; 1720 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1721 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1722 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$4[rsp], rax

; 1723 :             _Elem* const _Insert_at = _Old_ptr + _Off;

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$4[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Insert_at$2[rsp], rax

; 1724 :             // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
; 1725 :             // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
; 1726 :             size_type _Ptr_shifted_after;
; 1727 :             if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	cmp	rax, QWORD PTR _Insert_at$2[rsp]
	jbe	SHORT $LN5@insert
	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$4[rsp]
	add	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Ptr$[rsp], rax
	jbe	SHORT $LN3@insert
$LN5@insert:

; 1728 :                 // inserted content is before the shifted region, or does not alias
; 1729 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts

	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR _Ptr_shifted_after$3[rsp], rax
	jmp	SHORT $LN4@insert
$LN3@insert:

; 1730 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts

	mov	rax, QWORD PTR _Ptr$[rsp]
	cmp	QWORD PTR _Insert_at$2[rsp], rax
	ja	SHORT $LN6@insert

; 1731 :                 _Ptr_shifted_after = 0;

	mov	QWORD PTR _Ptr_shifted_after$3[rsp], 0

; 1732 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts

	jmp	SHORT $LN7@insert
$LN6@insert:

; 1733 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Insert_at$2[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Ptr_shifted_after$3[rsp], rax
$LN7@insert:
$LN4@insert:

; 1734 :             }
; 1735 : 
; 1736 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	inc	rax
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Insert_at$2[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, QWORD PTR _Insert_at$2[rsp]
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 1737 :             _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);

	mov	r8, QWORD PTR _Ptr_shifted_after$3[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Insert_at$2[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1738 :             _Traits::copy(

	mov	rax, QWORD PTR _Ptr_shifted_after$3[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	add	rcx, QWORD PTR _Ptr_shifted_after$3[rsp]
	mov	rdx, QWORD PTR _Ptr_shifted_after$3[rsp]
	mov	r8, QWORD PTR _Insert_at$2[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv143[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv143[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1739 :                 _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 1740 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@insert
$LN2@insert:

; 1741 :         }
; 1742 : 
; 1743 :         return _Reallocate_grow_by(

	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Off$[rsp]
	movzx	r8d, BYTE PTR $T1[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const *,unsigned __int64>
$LN1@insert:

; 1744 :             _Count,
; 1745 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 1746 :                 const _Elem* const _Ptr, const size_type _Count) _STATIC_CALL_OPERATOR {
; 1747 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 1748 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 1749 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 1750 :             },
; 1751 :             _Off, _Ptr, _Count);
; 1752 :     }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 1613 :     _CONSTEXPR20 basic_string& assign(_In_z_ const _Elem* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1615 :     }

	add	rsp, 40					; 00000028H
	ret	0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Old_ptr$3 = 40
this$ = 64
_Ptr$ = 72
_Count$ = 80
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 1592 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H

; 1593 :         // assign [_Ptr, _Ptr + _Count)
; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR _Count$[rsp], rax
	ja	SHORT $LN2@assign

; 1595 :             _ASAN_STRING_REMOVE(*this);
; 1596 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$3[rsp], rax

; 1597 :             _Mypair._Myval2._Mysize = _Count;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 1598 :             _Traits::move(_Old_ptr, _Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move
	npad	1

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1600 :             _ASAN_STRING_CREATE(*this);
; 1601 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@assign
$LN2@assign:

; 1602 :         }
; 1603 : 
; 1604 :         return _Reallocate_for(

	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	mov	r9, QWORD PTR _Ptr$[rsp]
	movzx	r8d, BYTE PTR $T2[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
$LN1@assign:

; 1605 :             _Count,
; 1606 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) _STATIC_CALL_OPERATOR {
; 1607 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 1609 :             },
; 1610 :             _Ptr);
; 1611 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
_Old_size$ = 56
_Old_ptr$3 = 64
this$ = 96
_Count$ = 104
_Ch$ = 112
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1513 :     _CONSTEXPR20 basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

$LN4:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H

; 1514 :         // append _Count * _Ch
; 1515 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 1516 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	cmp	QWORD PTR _Count$[rsp], rax
	ja	$LN2@append

; 1517 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1518 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1519 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$3[rsp], rax

; 1520 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1521 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1522 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@append
$LN2@append:

; 1523 :         }
; 1524 : 
; 1525 :         return _Reallocate_grow_by(

	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	movzx	eax, BYTE PTR _Ch$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9, QWORD PTR _Count$[rsp]
	movzx	r8d, BYTE PTR $T2[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
$LN1@append:

; 1526 :             _Count,
; 1527 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 1528 :                 const _Elem _Ch) _STATIC_CALL_OPERATOR {
; 1529 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 1530 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 1531 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 1532 :             },
; 1533 :             _Count, _Ch);
; 1534 :     }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
_Old_size$ = 56
_Old_ptr$3 = 64
this$ = 96
_Ptr$ = 104
_Count$ = 112
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1486 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H

; 1487 :         // append [_Ptr, _Ptr + _Count)
; 1488 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 1489 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	cmp	QWORD PTR _Count$[rsp], rax
	ja	$LN2@append

; 1490 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1491 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1492 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$3[rsp], rax

; 1493 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move
	npad	1

; 1494 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1495 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@append
$LN2@append:

; 1496 :         }
; 1497 : 
; 1498 :         return _Reallocate_grow_by(

	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Ptr$[rsp]
	movzx	r8d, BYTE PTR $T2[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
$LN1@append:

; 1499 :             _Count,
; 1500 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 1501 :                 const size_type _Count) _STATIC_CALL_OPERATOR {
; 1502 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 1503 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 1505 :             },
; 1506 :             _Ptr, _Count);
; 1507 :     }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
this$ = 64
_Right$ = 72
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1458 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1459 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1460 :     }

	add	rsp, 56					; 00000038H
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 1438 :     _CONSTEXPR20 basic_string& operator+=(const basic_string& _Right) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1439 :         return append(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1440 :     }

	add	rsp, 40					; 00000028H
	ret	0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 1421 :     _CONSTEXPR20 basic_string& operator=(_In_z_ const _Elem* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1422 :         return assign(_Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1423 :     }

	add	rsp, 40					; 00000028H
	ret	0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1359 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 1360 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1361 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 1362 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 1363 :         _Mypair._Myval2._Myproxy = nullptr;
; 1364 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 1365 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1366 :     }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Right_data$ = 40
_My_data$ = 48
_Right_data_mem$3 = 56
_My_data_mem$4 = 64
tv148 = 72
this$ = 96
_Right$ = 104
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 1234 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1235 :         // assign by stealing _Right's buffer
; 1236 :         // pre: this != &_Right
; 1237 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 1238 :         // pre: *this owns no memory, iterators orphaned
; 1239 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 1240 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1241 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 1242 : 
; 1243 : #if !defined(_INSERT_STRING_ANNOTATION)
; 1244 :         if constexpr (_Can_memcpy_val) {
; 1245 : #if _HAS_CXX20
; 1246 :             if (!_STD is_constant_evaluated())
; 1247 : #endif // _HAS_CXX20
; 1248 :             {
; 1249 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1250 :                 if (_Right_data._Large_mode_engaged()) {
; 1251 :                     // take ownership of _Right's iterators along with its buffer
; 1252 :                     _Swap_proxy_and_iterators(_Right);
; 1253 :                 } else {
; 1254 :                     _Right_data._Orphan_all();
; 1255 :                 }
; 1256 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1257 : 
; 1258 :                 const auto _My_data_mem =

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR _My_data_mem$4[rsp], rax

; 1259 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 1260 :                 const auto _Right_data_mem =

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR _Right_data_mem$3[rsp], rax

; 1261 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	r8d, 32					; 00000020H
	mov	rdx, QWORD PTR _Right_data_mem$3[rsp]
	mov	rcx, QWORD PTR _My_data_mem$4[rsp]
	call	memcpy

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 1266 :                 _Right_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1268 :                 return;

	jmp	$LN1@Take_conte

; 1269 :             }
; 1270 :         }
; 1271 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 1272 : 
; 1273 :         if (_Right_data._Large_mode_engaged()) { // steal buffer

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Take_conte

; 1274 :             _Swap_proxy_and_iterators(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 1275 : 
; 1276 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rdx, rax
	call	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>

; 1277 :             _Right_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1

; 1278 :         } else { // copy small string buffer

	jmp	SHORT $LN3@Take_conte
$LN2@Take_conte:

; 1279 :             _Right_data._Orphan_all();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1280 : 
; 1281 :             _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 1282 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rdx, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR tv148[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv148[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1
$LN3@Take_conte:

; 1283 :         }
; 1284 : 
; 1285 :         _My_data._Myres  = _Right_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 1286 :         _My_data._Mysize = _Right_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 1287 : 
; 1288 :         _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1289 :         _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 1290 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1
$LN1@Take_conte:

; 1291 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1004 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
	mov	QWORD PTR tv75[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv75[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	npad	1

; 1005 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv89[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv89[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 1006 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 1007 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 826  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 827  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	rax, QWORD PTR _Capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1

; 829  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 744  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 746  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 482  :             _STD _Destroy_in_place(_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>
	npad	1

; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rdi, QWORD PTR this$[rsp]
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 462  :     [[noreturn]] static void _Xran() {

$LN3:
	sub	rsp, 40					; 00000028H

; 463  :         _Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	?_Xout_of_range@std@@YAXPEBD@Z		; std::_Xout_of_range
	npad	1
$LN2@Xran:

; 464  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT

; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	cmp	QWORD PTR [rax+16], rcx
	jae	SHORT $LN2@Check_offs

; 451  :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	npad	1
$LN2@Check_offs:
$LN3@Check_offs:

; 452  :         }
; 453  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 434  :         return _Myres > _Small_string_capacity;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 15
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[rsp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[rsp]

; 435  :     }

	add	rsp, 24
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 425  :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 426  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 427  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 428  :         }
; 429  : 
; 430  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 431  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 416  :         value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 417  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 418  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 419  :         }
; 420  : 
; 421  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 422  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
	npad	1

; 403  : 
; 404  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 405  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 406  :     // roundup mask for allocated buffers, [0, 15]
; 407  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 408  :                                            : sizeof(value_type) <= 2 ? 7
; 409  :                                            : sizeof(value_type) <= 4 ? 3
; 410  :                                            : sizeof(value_type) <= 8 ? 1
; 411  :                                                                      : 0;
; 412  :     // capacity in small mode
; 413  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 414  : 
; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 416  :         value_type* _Result = _Bx._Buf;
; 417  :         if (_Large_mode_engaged()) {
; 418  :             _Result = _Unfancy(_Bx._Ptr);
; 419  :         }
; 420  : 
; 421  :         return _Result;
; 422  :     }
; 423  : 
; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 425  :         const value_type* _Result = _Bx._Buf;
; 426  :         if (_Large_mode_engaged()) {
; 427  :             _Result = _Unfancy(_Bx._Ptr);
; 428  :         }
; 429  : 
; 430  :         return _Result;
; 431  :     }
; 432  : 
; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 434  :         return _Myres > _Small_string_capacity;
; 435  :     }
; 436  : 
; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }
; 447  : 
; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {
; 451  :             _Xran();
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 456  :         // checks whether _Off is in the bounds of [0, size())
; 457  :         if (_Mysize <= _Off) {
; 458  :             _Xran();
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     [[noreturn]] static void _Xran() {
; 463  :         _Xout_of_range("invalid string position");
; 464  :     }
; 465  : 
; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);
; 469  :     }
; 470  : 
; 471  :     union _Bxty { // storage for small buffer or pointer to larger one
; 472  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 473  :         // renaming `_String_val` (and fixing the visualizer).
; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 476  : 
; 477  :         value_type _Buf[_BUF_SIZE];
; 478  :         pointer _Ptr;
; 479  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 480  : 
; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 482  :             _STD _Destroy_in_place(_Ptr);
; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }
; 493  :     };
; 494  :     _Bxty _Bx;
; 495  : 
; 496  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 497  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 498  :     size_type _Mysize = 0; // current length of string (size)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$00@std@@YA_K_K@Z	; std::_Get_size_of_n<1>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 511  : [[noreturn]] inline void _Xlen_string() {

$LN3:
	sub	rsp, 40					; 00000028H

; 512  :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlen_strin:

; 513  : }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1449 :     _CONSTEXPR20 void _Release() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1446 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1182 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1181 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1180 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Back_shift$ = 32
_Ptr_container$ = 40
_Ptr_user$ = 48
_Min_back_shift$ = 56
_Ptr$ = 80
_Bytes$ = 88
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 200  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 201  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 202  :     _Bytes += _Non_user_size;

	mov	rax, QWORD PTR _Bytes$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 39					; 00000027H
	mov	rcx, QWORD PTR _Bytes$[rsp]
	mov	QWORD PTR [rcx], rax

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr_user$[rsp], rax

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr_user$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR _Ptr_container$[rsp], rax

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

	mov	QWORD PTR _Min_back_shift$[rsp], 8

; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Back_shift$[rsp], rax
$LN4@Adjust_man:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	QWORD PTR _Back_shift$[rsp], 8
	jb	SHORT $LN8@Adjust_man
	cmp	QWORD PTR _Back_shift$[rsp], 39		; 00000027H
	ja	SHORT $LN8@Adjust_man
	jmp	SHORT $LN9@Adjust_man
$LN8@Adjust_man:
$LN7@Adjust_man:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN9@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Adjust_man

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rax], rcx
$LN10@Adjust_man:

; 221  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 135  :     __declspec(allocator) static _CLANG_CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 136  :         return ::operator new(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??2@YAPEAX_K@Z				; operator new

; 137  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
	sub	rsp, 72					; 00000048H

; 108  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	npad	1
$LN2@Throw_bad_:

; 109  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_array_new_length@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@QEAA@AEBV01@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA PROC ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA ENDP ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 144  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 143  :         : bad_alloc("bad array new length")

	lea	rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@AEAA@QEBD@Z		; std::bad_alloc::bad_alloc
	npad	1

; 144  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx

; 145  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA PROC		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA ENDP		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 132  :         : exception(_Message, 1)

	mov	r8d, 1
	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception
	npad	1

; 133  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx

; 134  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Message$ = 56
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@what
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@what
$LN3@what:
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	mov	QWORD PTR tv69[rsp], rax
$LN4@what:
	mov	rax, QWORD PTR tv69[rsp]

; 97   :     }

	add	rsp, 24
	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 91   :         __std_exception_destroy(&_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	__std_exception_destroy
	npad	1

; 92   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 72   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR _Other$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	__std_exception_copy
	npad	1

; 75   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 16
_Message$ = 24
__formal$ = 32
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 66   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 68   :         _Data._What = _Message;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Message$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 69   :     }

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 470  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 471  : #if _HAS_CXX20
; 472  :         if (_STD is_constant_evaluated()) {
; 473  :             return _Primary_char_traits::assign(_Left, _Right);
; 474  :         }
; 475  : #endif // _HAS_CXX20
; 476  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 477  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 459  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 460  :         // assign _Count * _Ch to [_First, ...)
; 461  : #if _HAS_CXX20
; 462  :         if (_STD is_constant_evaluated()) {
; 463  :             return _Primary_char_traits::assign(_First, _Count, _Ch);
; 464  :         }
; 465  : #endif // _HAS_CXX20
; 466  : 
; 467  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR _Ch$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR _First$[rsp]
	call	memset
	npad	1

; 468  :     }

	add	rsp, 40					; 00000028H
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
tv68 = 0
tv67 = 8
_First$ = 32
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 417  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 418  :         // find length of null-terminated string
; 419  : #if _HAS_CXX17
; 420  : #ifdef __cpp_char8_t
; 421  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 422  : #if _HAS_U8_INTRINSICS
; 423  :             return __builtin_u8strlen(_First);
; 424  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 425  :             return _Primary_char_traits::length(_First);
; 426  : #endif // ^^^ no u8 intrinsics ^^^
; 427  :         } else
; 428  : #endif // defined(__cpp_char8_t)
; 429  :         {
; 430  :             return __builtin_strlen(_First);

	mov	rax, QWORD PTR _First$[rsp]
	mov	QWORD PTR tv67[rsp], rax
	mov	QWORD PTR tv68[rsp], -1
$LL3@length:
	inc	QWORD PTR tv68[rsp]
	mov	rax, QWORD PTR tv67[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL3@length
	mov	rax, QWORD PTR tv68[rsp]

; 431  :         }
; 432  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 434  : #endif // ^^^ !_HAS_CXX17 ^^^
; 435  :     }

	add	rsp, 24
	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 110  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 111  :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 112  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 113  :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 114  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 115  : #if _HAS_CXX20
; 116  :         if (_STD is_constant_evaluated()) {
; 117  :             // dest: [_First1, _First1 + _Count)
; 118  :             // src: [_First2, _First2 + _Count)
; 119  :             // We need to handle overlapping ranges.
; 120  :             // If _First1 is in the src range, we need a backward loop.
; 121  :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 122  : 
; 123  :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 124  :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 125  :             bool _Loop_forward = true;
; 126  : 
; 127  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 128  :                 if (_First1 == _Src) {
; 129  :                     _Loop_forward = false;
; 130  :                     break;
; 131  :                 }
; 132  :             }
; 133  : 
; 134  :             if (_Loop_forward) {
; 135  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 136  :                     _First1[_Idx] = _First2[_Idx];
; 137  :                 }
; 138  :             } else {
; 139  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 140  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 141  :                 }
; 142  :             }
; 143  : 
; 144  :             return _First1;
; 145  :         }
; 146  : #endif // _HAS_CXX20
; 147  : 
; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memmove

; 149  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 150  : 
; 151  :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 152  :     }

	add	rsp, 40					; 00000028H
	ret	0
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 87   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 88   :                 _First1[_Idx] = _First2[_Idx];
; 89   :             }
; 90   : 
; 91   :             return _First1;
; 92   :         }
; 93   : #endif // _HAS_CXX20
; 94   : 
; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcpy

; 96   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 97   : 
; 98   :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 99   :     }

	add	rsp, 40					; 00000028H
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\cstdlib
;	COMDAT ?abs@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 48
?abs@@YAMM@Z PROC					; abs, COMDAT

; 27   : _NODISCARD _Check_return_ inline float abs(_In_ float _Xx) noexcept /* strengthened */ {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 28   :     return _CSTD fabsf(_Xx);

	movss	xmm0, DWORD PTR _Xx$[rsp]
	call	fabsf
	npad	1

; 29   : }

	add	rsp, 40					; 00000028H
	ret	0
?abs@@YAMM@Z ENDP					; abs
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT fabsf
_TEXT	SEGMENT
_X$ = 48
fabsf	PROC						; COMDAT

; 719  :         {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 720  :             return (float)fabs(_X);

	cvtss2sd xmm0, DWORD PTR _X$[rsp]
	call	fabs
	cvtsd2ss xmm0, xmm0

; 721  :         }

	add	rsp, 40					; 00000028H
	ret	0
fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsscanf_l
	mov	DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 2254 :     }

	add	rsp, 56					; 00000038H
	ret	0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2153 :         return __stdio_common_vsscanf(

	call	__local_stdio_scanf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, -1
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

	add	rsp, 56					; 00000038H
	ret	0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

	ret	0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 164  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, QWORD PTR _Where$[rsp]

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rax, QWORD PTR __f$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
