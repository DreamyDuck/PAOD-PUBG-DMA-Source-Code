; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?StringBuilder_empty@asmjit@@3QBDB	ORG $+4		; asmjit::StringBuilder_empty
	ORG $+4
?StringBuilder_numbers@asmjit@@3QBDB DB '0123456789ABCDEFGHIJKLMNOPQRSTUV'
	DB	'WXYZ', 00H					; asmjit::StringBuilder_numbers
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsnprintf
PUBLIC	??0StringBuilder@asmjit@@QEAA@XZ		; asmjit::StringBuilder::StringBuilder
PUBLIC	??1StringBuilder@asmjit@@QEAA@XZ		; asmjit::StringBuilder::~StringBuilder
PUBLIC	?prepare@StringBuilder@asmjit@@QEAAPEADI_K@Z	; asmjit::StringBuilder::prepare
PUBLIC	?reserve@StringBuilder@asmjit@@QEAA_N_K@Z	; asmjit::StringBuilder::reserve
PUBLIC	?clear@StringBuilder@asmjit@@QEAAXXZ		; asmjit::StringBuilder::clear
PUBLIC	?_opString@StringBuilder@asmjit@@QEAA_NIPEBD_K@Z ; asmjit::StringBuilder::_opString
PUBLIC	?_opVFormat@StringBuilder@asmjit@@QEAA_NIPEBDPEAD@Z ; asmjit::StringBuilder::_opVFormat
PUBLIC	?_opChar@StringBuilder@asmjit@@QEAA_NID@Z	; asmjit::StringBuilder::_opChar
PUBLIC	?_opChars@StringBuilder@asmjit@@QEAA_NID_K@Z	; asmjit::StringBuilder::_opChars
PUBLIC	?_opNumber@StringBuilder@asmjit@@QEAA_NI_KI0I@Z	; asmjit::StringBuilder::_opNumber
PUBLIC	?_opHex@StringBuilder@asmjit@@QEAA_NIPEBX_K@Z	; asmjit::StringBuilder::_opHex
PUBLIC	?setFormat@StringBuilder@asmjit@@QEAA_NPEBDZZ	; asmjit::StringBuilder::setFormat
PUBLIC	?appendFormat@StringBuilder@asmjit@@QEAA_NPEBDZZ ; asmjit::StringBuilder::appendFormat
PUBLIC	?eq@StringBuilder@asmjit@@QEBA_NPEBD_K@Z	; asmjit::StringBuilder::eq
PUBLIC	??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ		; asmjit::IntUtil::maxUInt<unsigned __int64>
PUBLIC	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z		; asmjit::IntUtil::alignTo<unsigned __int64>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strlen:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$_vsnprintf
pdata	ENDS
pdata	SEGMENT
$pdata$??1StringBuilder@asmjit@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$??1StringBuilder@asmjit@@QEAA@XZ
$pdata$?prepare@StringBuilder@asmjit@@QEAAPEADI_K@Z DD imagerel $LN22
	DD	imagerel $LN22+801
	DD	imagerel $unwind$?prepare@StringBuilder@asmjit@@QEAAPEADI_K@Z
$pdata$?reserve@StringBuilder@asmjit@@QEAA_N_K@Z DD imagerel $LN7
	DD	imagerel $LN7+225
	DD	imagerel $unwind$?reserve@StringBuilder@asmjit@@QEAA_N_K@Z
$pdata$?_opString@StringBuilder@asmjit@@QEAA_NIPEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+138
	DD	imagerel $unwind$?_opString@StringBuilder@asmjit@@QEAA_NIPEBD_K@Z
$pdata$?_opVFormat@StringBuilder@asmjit@@QEAA_NIPEBDPEAD@Z DD imagerel $LN5
	DD	imagerel $LN5+178
	DD	imagerel $unwind$?_opVFormat@StringBuilder@asmjit@@QEAA_NIPEBDPEAD@Z
$pdata$?_opChar@StringBuilder@asmjit@@QEAA_NID@Z DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$?_opChar@StringBuilder@asmjit@@QEAA_NID@Z
$pdata$?_opChars@StringBuilder@asmjit@@QEAA_NID_K@Z DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$?_opChars@StringBuilder@asmjit@@QEAA_NID_K@Z
$pdata$?_opNumber@StringBuilder@asmjit@@QEAA_NI_KI0I@Z DD imagerel $LN22
	DD	imagerel $LN22+810
	DD	imagerel $unwind$?_opNumber@StringBuilder@asmjit@@QEAA_NI_KI0I@Z
$pdata$?_opHex@StringBuilder@asmjit@@QEAA_NIPEBX_K@Z DD imagerel $LN8
	DD	imagerel $LN8+289
	DD	imagerel $unwind$?_opHex@StringBuilder@asmjit@@QEAA_NIPEBX_K@Z
$pdata$?setFormat@StringBuilder@asmjit@@QEAA_NPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?setFormat@StringBuilder@asmjit@@QEAA_NPEBDZZ
$pdata$?appendFormat@StringBuilder@asmjit@@QEAA_NPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?appendFormat@StringBuilder@asmjit@@QEAA_NPEBDZZ
$pdata$?eq@StringBuilder@asmjit@@QEBA_NPEBD_K@Z DD imagerel $LN15
	DD	imagerel $LN15+303
	DD	imagerel $unwind$?eq@StringBuilder@asmjit@@QEBA_NPEBD_K@Z
pdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?_opNumber@StringBuilder@asmjit@@QEAA_NI_KI0I@Z
	DD	024H
	DD	0312H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?_opVFormat@StringBuilder@asmjit@@QEAA_NIPEBDPEAD@Z
	DD	024H
	DD	09aH
voltbl	ENDS
xdata	SEGMENT
$unwind$??1StringBuilder@asmjit@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1StringBuilder@asmjit@@QEAA@XZ
$cppxdata$??1StringBuilder@asmjit@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1StringBuilder@asmjit@@QEAA@XZ
$ip2state$??1StringBuilder@asmjit@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
$unwind$?prepare@StringBuilder@asmjit@@QEAAPEADI_K@Z DD 011201H
	DD	0a212H
$unwind$?reserve@StringBuilder@asmjit@@QEAA_N_K@Z DD 010e01H
	DD	0620eH
$unwind$?_opString@StringBuilder@asmjit@@QEAA_NIPEBD_K@Z DD 011701H
	DD	06217H
$unwind$?_opVFormat@StringBuilder@asmjit@@QEAA_NIPEBDPEAD@Z DD 022c19H
	DD	089011aH
	DD	imagerel __GSHandlerCheck
	DD	0430H
$unwind$?_opChar@StringBuilder@asmjit@@QEAA_NID@Z DD 011201H
	DD	06212H
$unwind$?_opChars@StringBuilder@asmjit@@QEAA_NID_K@Z DD 011701H
	DD	06217H
$unwind$?_opNumber@StringBuilder@asmjit@@QEAA_NI_KI0I@Z DD 022c19H
	DD	023011aH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$?_opHex@StringBuilder@asmjit@@QEAA_NIPEBX_K@Z DD 011701H
	DD	08217H
$unwind$?setFormat@StringBuilder@asmjit@@QEAA_NPEBDZZ DD 011801H
	DD	06218H
$unwind$?appendFormat@StringBuilder@asmjit@@QEAA_NPEBDZZ DD 011801H
	DD	06218H
$unwind$?eq@StringBuilder@asmjit@@QEBA_NPEBD_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z
_TEXT	SEGMENT
base$ = 8
alignment$ = 16
??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z PROC		; asmjit::IntUtil::alignTo<unsigned __int64>, COMDAT

; 401  :   static ASMJIT_INLINE T alignTo(T base, T alignment) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 402  :     return (base + (alignment - 1)) & ~(alignment - 1);

	mov	rax, QWORD PTR base$[rsp]
	mov	rcx, QWORD PTR alignment$[rsp]
	lea	rax, QWORD PTR [rax+rcx-1]
	mov	rcx, QWORD PTR alignment$[rsp]
	dec	rcx
	not	rcx
	and	rax, rcx

; 403  :   }

	ret	0
??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z ENDP		; asmjit::IntUtil::alignTo<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ
_TEXT	SEGMENT
??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ PROC		; asmjit::IntUtil::maxUInt<unsigned __int64>, COMDAT

; 131  :   static ASMJIT_INLINE T maxUInt() { return ~T(0); }

	mov	rax, -1
	ret	0
??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ ENDP		; asmjit::IntUtil::maxUInt<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
tv84 = 32
tv92 = 36
i$1 = 40
bData$ = 48
aLength$ = 56
bLength$ = 64
aData$ = 72
this$ = 96
str$ = 104
len$ = 112
?eq@StringBuilder@asmjit@@QEBA_NPEBD_K@Z PROC		; asmjit::StringBuilder::eq

; 347  : bool StringBuilder::eq(const char* str, size_t len) const {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 348  :   const char* aData = _data;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR aData$[rsp], rax

; 349  :   const char* bData = str;

	mov	rax, QWORD PTR str$[rsp]
	mov	QWORD PTR bData$[rsp], rax

; 350  : 
; 351  :   size_t aLength = _length;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR aLength$[rsp], rax

; 352  :   size_t bLength = len;

	mov	rax, QWORD PTR len$[rsp]
	mov	QWORD PTR bLength$[rsp], rax

; 353  : 
; 354  :   if (bLength == kInvalidIndex) {

	cmp	QWORD PTR bLength$[rsp], -1
	jne	$LN5@eq

; 355  :     size_t i;
; 356  :     for (i = 0; i < aLength; i++) {

	mov	QWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@eq
$LN2@eq:
	mov	rax, QWORD PTR i$1[rsp]
	inc	rax
	mov	QWORD PTR i$1[rsp], rax
$LN4@eq:
	mov	rax, QWORD PTR aLength$[rsp]
	cmp	QWORD PTR i$1[rsp], rax
	jae	SHORT $LN3@eq

; 357  :       if (aData[i] != bData[i] || bData[i] == 0)

	mov	rax, QWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR aData$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR bData$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movsx	ecx, BYTE PTR [rcx]
	cmp	eax, ecx
	jne	SHORT $LN8@eq
	mov	rax, QWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR bData$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN7@eq
$LN8@eq:

; 358  :         return false;

	xor	al, al
	jmp	SHORT $LN1@eq
$LN7@eq:

; 359  :     }

	jmp	SHORT $LN2@eq
$LN3@eq:

; 360  : 
; 361  :     return bData[i] == 0;

	mov	rax, QWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR bData$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN11@eq
	mov	DWORD PTR tv84[rsp], 1
	jmp	SHORT $LN12@eq
$LN11@eq:
	mov	DWORD PTR tv84[rsp], 0
$LN12@eq:
	movzx	eax, BYTE PTR tv84[rsp]
	jmp	SHORT $LN1@eq

; 362  :   }

	jmp	SHORT $LN6@eq
$LN5@eq:

; 363  :   else {
; 364  :     if (aLength != bLength)

	mov	rax, QWORD PTR bLength$[rsp]
	cmp	QWORD PTR aLength$[rsp], rax
	je	SHORT $LN9@eq

; 365  :       return false;

	xor	al, al
	jmp	SHORT $LN1@eq
$LN9@eq:

; 366  : 
; 367  :     return ::memcmp(aData, bData, aLength) == 0;

	mov	r8, QWORD PTR aLength$[rsp]
	mov	rdx, QWORD PTR bData$[rsp]
	mov	rcx, QWORD PTR aData$[rsp]
	call	memcmp
	test	eax, eax
	jne	SHORT $LN13@eq
	mov	DWORD PTR tv92[rsp], 1
	jmp	SHORT $LN14@eq
$LN13@eq:
	mov	DWORD PTR tv92[rsp], 0
$LN14@eq:
	movzx	eax, BYTE PTR tv92[rsp]
$LN6@eq:
$LN1@eq:

; 368  :   }
; 369  : }

	add	rsp, 88					; 00000058H
	ret	0
?eq@StringBuilder@asmjit@@QEBA_NPEBD_K@Z ENDP		; asmjit::StringBuilder::eq
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
result$ = 32
ap$ = 40
this$ = 64
fmt$ = 72
?appendFormat@StringBuilder@asmjit@@QEAA_NPEBDZZ PROC	; asmjit::StringBuilder::appendFormat

; 336  : bool StringBuilder::appendFormat(const char* fmt, ...) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 337  :   bool result;
; 338  : 
; 339  :   va_list ap;
; 340  :   va_start(ap, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR ap$[rsp], rax

; 341  :   result = _opVFormat(kStringOpAppend, fmt, ap);

	mov	r9, QWORD PTR ap$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?_opVFormat@StringBuilder@asmjit@@QEAA_NIPEBDPEAD@Z ; asmjit::StringBuilder::_opVFormat
	mov	BYTE PTR result$[rsp], al

; 342  :   va_end(ap);

	mov	QWORD PTR ap$[rsp], 0

; 343  : 
; 344  :   return result;

	movzx	eax, BYTE PTR result$[rsp]

; 345  : }

	add	rsp, 56					; 00000038H
	ret	0
?appendFormat@StringBuilder@asmjit@@QEAA_NPEBDZZ ENDP	; asmjit::StringBuilder::appendFormat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
result$ = 32
ap$ = 40
this$ = 64
fmt$ = 72
?setFormat@StringBuilder@asmjit@@QEAA_NPEBDZZ PROC	; asmjit::StringBuilder::setFormat

; 325  : bool StringBuilder::setFormat(const char* fmt, ...) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 326  :   bool result;
; 327  : 
; 328  :   va_list ap;
; 329  :   va_start(ap, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR ap$[rsp], rax

; 330  :   result = _opVFormat(kStringOpSet, fmt, ap);

	mov	r9, QWORD PTR ap$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?_opVFormat@StringBuilder@asmjit@@QEAA_NIPEBDPEAD@Z ; asmjit::StringBuilder::_opVFormat
	mov	BYTE PTR result$[rsp], al

; 331  :   va_end(ap);

	mov	QWORD PTR ap$[rsp], 0

; 332  : 
; 333  :   return result;

	movzx	eax, BYTE PTR result$[rsp]

; 334  : }

	add	rsp, 56					; 00000038H
	ret	0
?setFormat@StringBuilder@asmjit@@QEAA_NPEBDZZ ENDP	; asmjit::StringBuilder::setFormat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
dst$ = 32
src$ = 40
i$1 = 48
this$ = 80
op$ = 88
data$ = 96
len$ = 104
?_opHex@StringBuilder@asmjit@@QEAA_NIPEBX_K@Z PROC	; asmjit::StringBuilder::_opHex

; 298  : bool StringBuilder::_opHex(uint32_t op, const void* data, size_t len) {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 299  :   if (len >= IntUtil::maxUInt<size_t>() / 2)

	call	??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ	; asmjit::IntUtil::maxUInt<unsigned __int64>
	xor	edx, edx
	mov	ecx, 2
	div	rcx
	cmp	QWORD PTR len$[rsp], rax
	jb	SHORT $LN5@opHex

; 300  :     return false;

	xor	al, al
	jmp	$LN1@opHex
$LN5@opHex:

; 301  : 
; 302  :   char* dst = prepare(op, len * 2);

	mov	rax, QWORD PTR len$[rsp]
	shl	rax, 1
	mov	r8, rax
	mov	edx, DWORD PTR op$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?prepare@StringBuilder@asmjit@@QEAAPEADI_K@Z ; asmjit::StringBuilder::prepare
	mov	QWORD PTR dst$[rsp], rax

; 303  :   if (dst == NULL)

	cmp	QWORD PTR dst$[rsp], 0
	jne	SHORT $LN6@opHex

; 304  :     return false;

	xor	al, al
	jmp	$LN1@opHex
$LN6@opHex:

; 305  : 
; 306  :   const char* src = static_cast<const char*>(data);

	mov	rax, QWORD PTR data$[rsp]
	mov	QWORD PTR src$[rsp], rax

; 307  :   for (size_t i = 0; i < len; i++, dst += 2, src += 1)

	mov	QWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@opHex
$LN2@opHex:
	mov	rax, QWORD PTR i$1[rsp]
	inc	rax
	mov	QWORD PTR i$1[rsp], rax
	mov	rax, QWORD PTR dst$[rsp]
	add	rax, 2
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN4@opHex:
	mov	rax, QWORD PTR len$[rsp]
	cmp	QWORD PTR i$1[rsp], rax
	jae	SHORT $LN3@opHex

; 308  :   {
; 309  :     dst[0] = StringBuilder_numbers[(src[0] >> 4) & 0xF];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	sar	eax, 4
	and	eax, 15
	cdqe
	lea	rcx, OFFSET FLAT:?StringBuilder_numbers@asmjit@@3QBDB
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR dst$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al

; 310  :     dst[1] = StringBuilder_numbers[(src[0]     ) & 0xF];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	and	eax, 15
	cdqe
	lea	rcx, OFFSET FLAT:?StringBuilder_numbers@asmjit@@3QBDB
	mov	edx, 1
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR dst$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al

; 311  :   }

	jmp	$LN2@opHex
$LN3@opHex:

; 312  : 
; 313  :   return true;

	mov	al, 1
$LN1@opHex:

; 314  : }

	add	rsp, 72					; 00000048H
	ret	0
?_opHex@StringBuilder@asmjit@@QEAA_NIPEBX_K@Z ENDP	; asmjit::StringBuilder::_opHex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
sign$ = 32
p$ = 40
data$ = 48
numberLength$ = 56
prefixLength$ = 64
tv75 = 72
tv77 = 80
r$1 = 88
d$2 = 96
orig$ = 104
buf$ = 112
__$ArrayPad$ = 256
this$ = 288
op$ = 296
i$ = 304
base$ = 312
width$ = 320
flags$ = 328
?_opNumber@StringBuilder@asmjit@@QEAA_NI_KI0I@Z PROC	; asmjit::StringBuilder::_opNumber

; 209  : bool StringBuilder::_opNumber(uint32_t op, uint64_t i, uint32_t base, size_t width, uint32_t flags) {

$LN22:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 280				; 00000118H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 210  :   if (base < 2 || base > 36)

	cmp	DWORD PTR base$[rsp], 2
	jb	SHORT $LN6@opNumber
	cmp	DWORD PTR base$[rsp], 36		; 00000024H
	jbe	SHORT $LN5@opNumber
$LN6@opNumber:

; 211  :     base = 10;

	mov	DWORD PTR base$[rsp], 10
$LN5@opNumber:

; 212  : 
; 213  :   char buf[128];
; 214  :   char* p = buf + ASMJIT_ARRAY_SIZE(buf);

	lea	rax, QWORD PTR buf$[rsp+128]
	mov	QWORD PTR p$[rsp], rax

; 215  : 
; 216  :   uint64_t orig = i;

	mov	rax, QWORD PTR i$[rsp]
	mov	QWORD PTR orig$[rsp], rax

; 217  :   char sign = '\0';

	mov	BYTE PTR sign$[rsp], 0

; 218  : 
; 219  :   // --------------------------------------------------------------------------
; 220  :   // [Sign]
; 221  :   // --------------------------------------------------------------------------
; 222  : 
; 223  :   if ((flags & kStringFormatSigned) != 0 && static_cast<int64_t>(i) < 0) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	je	SHORT $LN7@opNumber
	cmp	QWORD PTR i$[rsp], 0
	jge	SHORT $LN7@opNumber

; 224  :     i = static_cast<uint64_t>(-static_cast<int64_t>(i));

	mov	rax, QWORD PTR i$[rsp]
	neg	rax
	mov	QWORD PTR i$[rsp], rax

; 225  :     sign = '-';

	mov	BYTE PTR sign$[rsp], 45			; 0000002dH

; 226  :   }

	jmp	SHORT $LN8@opNumber
$LN7@opNumber:

; 227  :   else if ((flags & kStringFormatShowSign) != 0) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@opNumber

; 228  :     sign = '+';

	mov	BYTE PTR sign$[rsp], 43			; 0000002bH

; 229  :   }

	jmp	SHORT $LN10@opNumber
$LN9@opNumber:

; 230  :   else if ((flags & kStringFormatShowSpace) != 0) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN11@opNumber

; 231  :     sign = ' ';

	mov	BYTE PTR sign$[rsp], 32			; 00000020H
$LN11@opNumber:
$LN10@opNumber:
$LN8@opNumber:
$LN4@opNumber:

; 232  :   }
; 233  : 
; 234  :   // --------------------------------------------------------------------------
; 235  :   // [Number]
; 236  :   // --------------------------------------------------------------------------
; 237  : 
; 238  :   do {
; 239  :     uint64_t d = i / base;

	mov	eax, DWORD PTR base$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	div	rcx
	mov	QWORD PTR d$2[rsp], rax

; 240  :     uint64_t r = i % base;

	mov	eax, DWORD PTR base$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	div	rcx
	mov	rax, rdx
	mov	QWORD PTR r$1[rsp], rax

; 241  : 
; 242  :     *--p = StringBuilder_numbers[r];

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	lea	rax, OFFSET FLAT:?StringBuilder_numbers@asmjit@@3QBDB
	mov	rcx, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR r$1[rsp]
	movzx	eax, BYTE PTR [rax+rdx]
	mov	BYTE PTR [rcx], al

; 243  :     i = d;

	mov	rax, QWORD PTR d$2[rsp]
	mov	QWORD PTR i$[rsp], rax

; 244  :   } while (i);

	cmp	QWORD PTR i$[rsp], 0
	jne	$LN4@opNumber

; 245  : 
; 246  :   size_t numberLength = (size_t)(buf + ASMJIT_ARRAY_SIZE(buf) - p);

	lea	rax, QWORD PTR buf$[rsp+128]
	sub	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR numberLength$[rsp], rax

; 247  : 
; 248  :   // --------------------------------------------------------------------------
; 249  :   // [Alternate Form]
; 250  :   // --------------------------------------------------------------------------
; 251  : 
; 252  :   if ((flags & kStringFormatAlternate) != 0) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN12@opNumber

; 253  :     if (base == 8) {

	cmp	DWORD PTR base$[rsp], 8
	jne	SHORT $LN13@opNumber

; 254  :       if (orig != 0)

	cmp	QWORD PTR orig$[rsp], 0
	je	SHORT $LN14@opNumber

; 255  :         *--p = '0';

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 48			; 00000030H
$LN14@opNumber:
$LN13@opNumber:

; 256  :     }
; 257  :     if (base == 16) {

	cmp	DWORD PTR base$[rsp], 16
	jne	SHORT $LN15@opNumber

; 258  :       *--p = 'x';

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 120			; 00000078H

; 259  :       *--p = '0';

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 48			; 00000030H
$LN15@opNumber:
$LN12@opNumber:

; 260  :     }
; 261  :   }
; 262  : 
; 263  :   // --------------------------------------------------------------------------
; 264  :   // [Width]
; 265  :   // --------------------------------------------------------------------------
; 266  : 
; 267  :   if (sign != 0)

	movsx	eax, BYTE PTR sign$[rsp]
	test	eax, eax
	je	SHORT $LN16@opNumber

; 268  :     *--p = sign;

	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR sign$[rsp]
	mov	BYTE PTR [rax], cl
$LN16@opNumber:

; 269  : 
; 270  :   if (width > 256)

	cmp	QWORD PTR width$[rsp], 256		; 00000100H
	jbe	SHORT $LN17@opNumber

; 271  :     width = 256;

	mov	QWORD PTR width$[rsp], 256		; 00000100H
$LN17@opNumber:

; 272  : 
; 273  :   if (width <= numberLength)

	mov	rax, QWORD PTR numberLength$[rsp]
	cmp	QWORD PTR width$[rsp], rax
	ja	SHORT $LN18@opNumber

; 274  :     width = 0;

	mov	QWORD PTR width$[rsp], 0
	jmp	SHORT $LN19@opNumber
$LN18@opNumber:

; 275  :   else
; 276  :     width -= numberLength;

	mov	rax, QWORD PTR numberLength$[rsp]
	mov	rcx, QWORD PTR width$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR width$[rsp], rax
$LN19@opNumber:

; 277  : 
; 278  :   // --------------------------------------------------------------------------
; 279  :   // Write]
; 280  :   // --------------------------------------------------------------------------
; 281  : 
; 282  :   size_t prefixLength = (size_t)(buf + ASMJIT_ARRAY_SIZE(buf) - p) - numberLength;

	lea	rax, QWORD PTR buf$[rsp+128]
	sub	rax, QWORD PTR p$[rsp]
	sub	rax, QWORD PTR numberLength$[rsp]
	mov	QWORD PTR prefixLength$[rsp], rax

; 283  :   char* data = prepare(op, prefixLength + width + numberLength);

	mov	rax, QWORD PTR width$[rsp]
	mov	rcx, QWORD PTR prefixLength$[rsp]
	add	rcx, rax
	mov	rax, rcx
	add	rax, QWORD PTR numberLength$[rsp]
	mov	r8, rax
	mov	edx, DWORD PTR op$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?prepare@StringBuilder@asmjit@@QEAAPEADI_K@Z ; asmjit::StringBuilder::prepare
	mov	QWORD PTR data$[rsp], rax

; 284  : 
; 285  :   if (data == NULL)

	cmp	QWORD PTR data$[rsp], 0
	jne	SHORT $LN20@opNumber

; 286  :     return false;

	xor	al, al
	jmp	SHORT $LN1@opNumber
$LN20@opNumber:

; 287  : 
; 288  :   ::memcpy(data, p, prefixLength);

	mov	r8, QWORD PTR prefixLength$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	call	memcpy

; 289  :   data += prefixLength;

	mov	rax, QWORD PTR prefixLength$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR data$[rsp], rax

; 290  : 
; 291  :   ::memset(data, '0', width);

	mov	r8, QWORD PTR width$[rsp]
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR data$[rsp]
	call	memset

; 292  :   data += width;

	mov	rax, QWORD PTR width$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR data$[rsp], rax

; 293  : 
; 294  :   ::memcpy(data, p + prefixLength, numberLength);

	mov	rax, QWORD PTR prefixLength$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR numberLength$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR data$[rsp]
	call	memcpy

; 295  :   return true;

	mov	al, 1
$LN1@opNumber:

; 296  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 280				; 00000118H
	ret	0
?_opNumber@StringBuilder@asmjit@@QEAA_NI_KI0I@Z ENDP	; asmjit::StringBuilder::_opNumber
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
p$ = 32
this$ = 64
op$ = 72
c$ = 80
len$ = 88
?_opChars@StringBuilder@asmjit@@QEAA_NID_K@Z PROC	; asmjit::StringBuilder::_opChars

; 198  : bool StringBuilder::_opChars(uint32_t op, char c, size_t len) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 199  :   char* p = prepare(op, len);

	mov	r8, QWORD PTR len$[rsp]
	mov	edx, DWORD PTR op$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?prepare@StringBuilder@asmjit@@QEAAPEADI_K@Z ; asmjit::StringBuilder::prepare
	mov	QWORD PTR p$[rsp], rax

; 200  :   if (p == NULL)

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN2@opChars

; 201  :     return false;

	xor	al, al
	jmp	SHORT $LN1@opChars
$LN2@opChars:

; 202  : 
; 203  :   ::memset(p, c, len);

	movsx	eax, BYTE PTR c$[rsp]
	mov	r8, QWORD PTR len$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR p$[rsp]
	call	memset

; 204  :   return true;

	mov	al, 1
$LN1@opChars:

; 205  : }

	add	rsp, 56					; 00000038H
	ret	0
?_opChars@StringBuilder@asmjit@@QEAA_NID_K@Z ENDP	; asmjit::StringBuilder::_opChars
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
p$ = 32
this$ = 64
op$ = 72
c$ = 80
?_opChar@StringBuilder@asmjit@@QEAA_NID@Z PROC		; asmjit::StringBuilder::_opChar

; 189  : bool StringBuilder::_opChar(uint32_t op, char c) {

$LN4:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 190  :   char* p = prepare(op, 1);

	mov	r8d, 1
	mov	edx, DWORD PTR op$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?prepare@StringBuilder@asmjit@@QEAAPEADI_K@Z ; asmjit::StringBuilder::prepare
	mov	QWORD PTR p$[rsp], rax

; 191  :   if (p == NULL)

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN2@opChar

; 192  :     return false;

	xor	al, al
	jmp	SHORT $LN1@opChar
$LN2@opChar:

; 193  : 
; 194  :   *p = c;

	mov	rax, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl

; 195  :   return true;

	mov	al, 1
$LN1@opChar:

; 196  : }

	add	rsp, 56					; 00000038H
	ret	0
?_opChar@StringBuilder@asmjit@@QEAA_NID@Z ENDP		; asmjit::StringBuilder::_opChar
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
$T1 = 32
buf$ = 48
__$ArrayPad$ = 1072
this$ = 1104
op$ = 1112
fmt$ = 1120
ap$ = 1128
?_opVFormat@StringBuilder@asmjit@@QEAA_NIPEBDPEAD@Z PROC ; asmjit::StringBuilder::_opVFormat

; 316  : bool StringBuilder::_opVFormat(uint32_t op, const char* fmt, va_list ap) {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1096				; 00000448H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 317  :   char buf[1024];
; 318  : 
; 319  :   vsnprintf(buf, ASMJIT_ARRAY_SIZE(buf), fmt, ap);

	mov	r9, QWORD PTR ap$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	edx, 1024				; 00000400H
	lea	rcx, QWORD PTR buf$[rsp]
	call	_vsnprintf
	npad	1

; 320  :   buf[ASMJIT_ARRAY_SIZE(buf) - 1] = '\0';

	mov	eax, 1
	imul	rax, rax, 1023				; 000003ffH
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 1024		; 00000400H
	jae	SHORT $LN3@opVFormat
	jmp	SHORT $LN4@opVFormat
$LN3@opVFormat:
	call	__report_rangecheckfailure
	npad	1
$LN4@opVFormat:
	mov	rax, QWORD PTR $T1[rsp]
	mov	BYTE PTR buf$[rsp+rax], 0

; 321  : 
; 322  :   return _opString(op, buf);

	mov	r9, -1
	lea	r8, QWORD PTR buf$[rsp]
	mov	edx, DWORD PTR op$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_opString@StringBuilder@asmjit@@QEAA_NIPEBD_K@Z ; asmjit::StringBuilder::_opString
$LN2@opVFormat:

; 323  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1096				; 00000448H
	ret	0
?_opVFormat@StringBuilder@asmjit@@QEAA_NIPEBDPEAD@Z ENDP ; asmjit::StringBuilder::_opVFormat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
tv68 = 32
p$ = 40
this$ = 64
op$ = 72
str$ = 80
len$ = 88
?_opString@StringBuilder@asmjit@@QEAA_NIPEBD_K@Z PROC	; asmjit::StringBuilder::_opString

; 177  : bool StringBuilder::_opString(uint32_t op, const char* str, size_t len) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 178  :   if (len == kInvalidIndex)

	cmp	QWORD PTR len$[rsp], -1
	jne	SHORT $LN2@opString

; 179  :     len = str != NULL ? ::strlen(str) : static_cast<size_t>(0);

	cmp	QWORD PTR str$[rsp], 0
	je	SHORT $LN5@opString
	mov	rcx, QWORD PTR str$[rsp]
	call	strlen
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN6@opString
$LN5@opString:
	mov	QWORD PTR tv68[rsp], 0
$LN6@opString:
	mov	rax, QWORD PTR tv68[rsp]
	mov	QWORD PTR len$[rsp], rax
$LN2@opString:

; 180  : 
; 181  :   char* p = prepare(op, len);

	mov	r8, QWORD PTR len$[rsp]
	mov	edx, DWORD PTR op$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?prepare@StringBuilder@asmjit@@QEAAPEADI_K@Z ; asmjit::StringBuilder::prepare
	mov	QWORD PTR p$[rsp], rax

; 182  :   if (p == NULL)

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN3@opString

; 183  :     return false;

	xor	al, al
	jmp	SHORT $LN1@opString
$LN3@opString:

; 184  : 
; 185  :   ::memcpy(p, str, len);

	mov	r8, QWORD PTR len$[rsp]
	mov	rdx, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	memcpy

; 186  :   return true;

	mov	al, 1
$LN1@opString:

; 187  : }

	add	rsp, 56					; 00000038H
	ret	0
?_opString@StringBuilder@asmjit@@QEAA_NIPEBD_K@Z ENDP	; asmjit::StringBuilder::_opString
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
this$ = 8
?clear@StringBuilder@asmjit@@QEAAXXZ PROC		; asmjit::StringBuilder::clear

; 167  : void StringBuilder::clear() {

	mov	QWORD PTR [rsp+8], rcx

; 168  :   if (_data != StringBuilder_empty)

	lea	rax, OFFSET FLAT:?StringBuilder_empty@asmjit@@3QBDB
	mov	rcx, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rcx], rax
	je	SHORT $LN2@clear

; 169  :     _data[0] = 0;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 0
$LN2@clear:

; 170  :   _length = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 171  : }

	ret	0
?clear@StringBuilder@asmjit@@QEAAXXZ ENDP		; asmjit::StringBuilder::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
newData$ = 32
this$ = 64
to$ = 72
?reserve@StringBuilder@asmjit@@QEAA_N_K@Z PROC		; asmjit::StringBuilder::reserve

; 140  : bool StringBuilder::reserve(size_t to) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 141  :   if (_capacity >= to)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR to$[rsp]
	cmp	QWORD PTR [rax+16], rcx
	jb	SHORT $LN2@reserve

; 142  :     return true;

	mov	al, 1
	jmp	$LN1@reserve
$LN2@reserve:

; 143  : 
; 144  :   if (to >= IntUtil::maxUInt<size_t>() - sizeof(intptr_t) * 2)

	call	??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ	; asmjit::IntUtil::maxUInt<unsigned __int64>
	sub	rax, 16
	cmp	QWORD PTR to$[rsp], rax
	jb	SHORT $LN3@reserve

; 145  :     return false;

	xor	al, al
	jmp	$LN1@reserve
$LN3@reserve:

; 146  : 
; 147  :   to = IntUtil::alignTo<size_t>(to, sizeof(intptr_t));

	mov	edx, 8
	mov	rcx, QWORD PTR to$[rsp]
	call	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z	; asmjit::IntUtil::alignTo<unsigned __int64>
	mov	QWORD PTR to$[rsp], rax

; 148  : 
; 149  :   char* newData = static_cast<char*>(ASMJIT_ALLOC(to + sizeof(intptr_t)));

	mov	rax, QWORD PTR to$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	malloc
	mov	QWORD PTR newData$[rsp], rax

; 150  :   if (newData == NULL)

	cmp	QWORD PTR newData$[rsp], 0
	jne	SHORT $LN4@reserve

; 151  :     return false;

	xor	al, al
	jmp	SHORT $LN1@reserve
$LN4@reserve:

; 152  : 
; 153  :   ::memcpy(newData, _data, _length + 1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR newData$[rsp]
	call	memcpy
	npad	1

; 154  :   if (_canFree)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN5@reserve

; 155  :     ASMJIT_FREE(_data);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	free
	npad	1
$LN5@reserve:

; 156  : 
; 157  :   _data = newData;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR newData$[rsp]
	mov	QWORD PTR [rax], rcx

; 158  :   _capacity = to + sizeof(intptr_t) - 1;

	mov	rax, QWORD PTR to$[rsp]
	add	rax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 159  :   _canFree = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 1

; 160  :   return true;

	mov	al, 1
$LN1@reserve:

; 161  : }

	add	rsp, 56					; 00000038H
	ret	0
?reserve@StringBuilder@asmjit@@QEAA_N_K@Z ENDP		; asmjit::StringBuilder::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
to$1 = 32
after$2 = 40
to$3 = 48
newData$4 = 56
newData$5 = 64
ret$6 = 72
this$ = 96
op$ = 104
len$ = 112
?prepare@StringBuilder@asmjit@@QEAAPEADI_K@Z PROC	; asmjit::StringBuilder::prepare

; 41   : char* StringBuilder::prepare(uint32_t op, size_t len) {

$LN22:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 42   :   // --------------------------------------------------------------------------
; 43   :   // [Set]
; 44   :   // --------------------------------------------------------------------------
; 45   : 
; 46   :   if (op == kStringOpSet) {

	cmp	DWORD PTR op$[rsp], 0
	jne	$LN4@prepare

; 47   :     // We don't care here, but we can't return a NULL pointer since it indicates
; 48   :     // failure in memory allocation.
; 49   :     if (len == 0) {

	cmp	QWORD PTR len$[rsp], 0
	jne	SHORT $LN6@prepare

; 50   :       if (_data != StringBuilder_empty)

	lea	rax, OFFSET FLAT:?StringBuilder_empty@asmjit@@3QBDB
	mov	rcx, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rcx], rax
	je	SHORT $LN7@prepare

; 51   :         _data[0] = 0;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 0
$LN7@prepare:

; 52   : 
; 53   :       _length = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 54   :       return _data;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	jmp	$LN1@prepare
$LN6@prepare:

; 55   :     }
; 56   : 
; 57   :     if (_capacity < len) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR len$[rsp]
	cmp	QWORD PTR [rax+16], rcx
	jae	$LN8@prepare

; 58   :       if (len >= IntUtil::maxUInt<size_t>() - sizeof(intptr_t) * 2)

	call	??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ	; asmjit::IntUtil::maxUInt<unsigned __int64>
	sub	rax, 16
	cmp	QWORD PTR len$[rsp], rax
	jb	SHORT $LN9@prepare

; 59   :         return NULL;

	xor	eax, eax
	jmp	$LN1@prepare
$LN9@prepare:

; 60   : 
; 61   :       size_t to = IntUtil::alignTo<size_t>(len, sizeof(intptr_t));

	mov	edx, 8
	mov	rcx, QWORD PTR len$[rsp]
	call	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z	; asmjit::IntUtil::alignTo<unsigned __int64>
	mov	QWORD PTR to$3[rsp], rax

; 62   :       if (to < 256 - sizeof(intptr_t))

	cmp	QWORD PTR to$3[rsp], 248		; 000000f8H
	jae	SHORT $LN10@prepare

; 63   :         to = 256 - sizeof(intptr_t);

	mov	QWORD PTR to$3[rsp], 248		; 000000f8H
$LN10@prepare:

; 64   : 
; 65   :       char* newData = static_cast<char*>(ASMJIT_ALLOC(to + sizeof(intptr_t)));

	mov	rax, QWORD PTR to$3[rsp]
	add	rax, 8
	mov	rcx, rax
	call	malloc
	mov	QWORD PTR newData$5[rsp], rax

; 66   :       if (newData == NULL) {

	cmp	QWORD PTR newData$5[rsp], 0
	jne	SHORT $LN11@prepare

; 67   :         clear();

	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@StringBuilder@asmjit@@QEAAXXZ	; asmjit::StringBuilder::clear

; 68   :         return NULL;

	xor	eax, eax
	jmp	$LN1@prepare
$LN11@prepare:

; 69   :       }
; 70   : 
; 71   :       if (_canFree)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN12@prepare

; 72   :         ASMJIT_FREE(_data);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	free
	npad	1
$LN12@prepare:

; 73   : 
; 74   :       _data = newData;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR newData$5[rsp]
	mov	QWORD PTR [rax], rcx

; 75   :       _capacity = to + sizeof(intptr_t) - 1;

	mov	rax, QWORD PTR to$3[rsp]
	add	rax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 76   :       _canFree = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 1
$LN8@prepare:

; 77   :     }
; 78   : 
; 79   :     _data[len] = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR len$[rsp]
	mov	BYTE PTR [rax+rcx], 0

; 80   :     _length = len;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR len$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 81   : 
; 82   :     ASMJIT_ASSERT(_length <= _capacity);
; 83   :     return _data;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	jmp	$LN1@prepare

; 84   :   }

	jmp	$LN5@prepare
$LN4@prepare:

; 85   : 
; 86   :   // --------------------------------------------------------------------------
; 87   :   // [Append]
; 88   :   // --------------------------------------------------------------------------
; 89   : 
; 90   :   else {
; 91   :     // We don't care here, but we can't return a NULL pointer since it indicates
; 92   :     // failure in memory allocation.
; 93   :     if (len == 0)

	cmp	QWORD PTR len$[rsp], 0
	jne	SHORT $LN13@prepare

; 94   :       return _data + _length;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	jmp	$LN1@prepare
$LN13@prepare:

; 95   : 
; 96   :     // Overflow.
; 97   :     if (IntUtil::maxUInt<size_t>() - sizeof(intptr_t) * 2 - _length < len)

	call	??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ	; asmjit::IntUtil::maxUInt<unsigned __int64>
	sub	rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	sub	rax, QWORD PTR [rcx+8]
	cmp	rax, QWORD PTR len$[rsp]
	jae	SHORT $LN14@prepare

; 98   :       return NULL;

	xor	eax, eax
	jmp	$LN1@prepare
$LN14@prepare:

; 99   : 
; 100  :     size_t after = _length + len;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, QWORD PTR len$[rsp]
	mov	QWORD PTR after$2[rsp], rax

; 101  :     if (_capacity < after) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR after$2[rsp]
	cmp	QWORD PTR [rax+16], rcx
	jae	$LN15@prepare

; 102  :       size_t to = _capacity;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR to$1[rsp], rax

; 103  : 
; 104  :       if (to < 256)

	cmp	QWORD PTR to$1[rsp], 256		; 00000100H
	jae	SHORT $LN16@prepare

; 105  :         to = 256;

	mov	QWORD PTR to$1[rsp], 256		; 00000100H
$LN16@prepare:
$LN2@prepare:

; 106  : 
; 107  :       while (to < 1024 * 1024 && to < after)

	cmp	QWORD PTR to$1[rsp], 1048576		; 00100000H
	jae	SHORT $LN3@prepare
	mov	rax, QWORD PTR after$2[rsp]
	cmp	QWORD PTR to$1[rsp], rax
	jae	SHORT $LN3@prepare

; 108  :         to *= 2;

	mov	rax, QWORD PTR to$1[rsp]
	shl	rax, 1
	mov	QWORD PTR to$1[rsp], rax
	jmp	SHORT $LN2@prepare
$LN3@prepare:

; 109  : 
; 110  :       if (to < after) {

	mov	rax, QWORD PTR after$2[rsp]
	cmp	QWORD PTR to$1[rsp], rax
	jae	SHORT $LN17@prepare

; 111  :         to = after;

	mov	rax, QWORD PTR after$2[rsp]
	mov	QWORD PTR to$1[rsp], rax

; 112  :         if (to < (IntUtil::maxUInt<size_t>() - 1024 * 32))

	call	??$maxUInt@_K@IntUtil@asmjit@@SA_KXZ	; asmjit::IntUtil::maxUInt<unsigned __int64>
	sub	rax, 32768				; 00008000H
	cmp	QWORD PTR to$1[rsp], rax
	jae	SHORT $LN18@prepare

; 113  :           to = IntUtil::alignTo<size_t>(to, 1024 * 32);

	mov	edx, 32768				; 00008000H
	mov	rcx, QWORD PTR to$1[rsp]
	call	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z	; asmjit::IntUtil::alignTo<unsigned __int64>
	mov	QWORD PTR to$1[rsp], rax
$LN18@prepare:
$LN17@prepare:

; 114  :       }
; 115  : 
; 116  :       to = IntUtil::alignTo<size_t>(to, sizeof(intptr_t));

	mov	edx, 8
	mov	rcx, QWORD PTR to$1[rsp]
	call	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z	; asmjit::IntUtil::alignTo<unsigned __int64>
	mov	QWORD PTR to$1[rsp], rax

; 117  :       char* newData = static_cast<char*>(ASMJIT_ALLOC(to + sizeof(intptr_t)));

	mov	rax, QWORD PTR to$1[rsp]
	add	rax, 8
	mov	rcx, rax
	call	malloc
	mov	QWORD PTR newData$4[rsp], rax

; 118  : 
; 119  :       if (newData == NULL)

	cmp	QWORD PTR newData$4[rsp], 0
	jne	SHORT $LN19@prepare

; 120  :         return NULL;

	xor	eax, eax
	jmp	$LN1@prepare
$LN19@prepare:

; 121  : 
; 122  :       ::memcpy(newData, _data, _length);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR newData$4[rsp]
	call	memcpy
	npad	1

; 123  :       if (_canFree)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN20@prepare

; 124  :         ASMJIT_FREE(_data);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	free
	npad	1
$LN20@prepare:

; 125  : 
; 126  :       _data = newData;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR newData$4[rsp]
	mov	QWORD PTR [rax], rcx

; 127  :       _capacity = to + sizeof(intptr_t) - 1;

	mov	rax, QWORD PTR to$1[rsp]
	add	rax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 128  :       _canFree = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 1
$LN15@prepare:

; 129  :     }
; 130  : 
; 131  :     char* ret = _data + _length;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR ret$6[rsp], rax

; 132  :     _data[after] = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR after$2[rsp]
	mov	BYTE PTR [rax+rcx], 0

; 133  :     _length = after;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR after$2[rsp]
	mov	QWORD PTR [rax+8], rcx

; 134  : 
; 135  :     ASMJIT_ASSERT(_length <= _capacity);
; 136  :     return ret;

	mov	rax, QWORD PTR ret$6[rsp]
$LN5@prepare:
$LN1@prepare:

; 137  :   }
; 138  : }

	add	rsp, 88					; 00000058H
	ret	0
?prepare@StringBuilder@asmjit@@QEAAPEADI_K@Z ENDP	; asmjit::StringBuilder::prepare
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
this$ = 48
??1StringBuilder@asmjit@@QEAA@XZ PROC			; asmjit::StringBuilder::~StringBuilder

; 32   : StringBuilder::~StringBuilder() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 33   :   if (_canFree)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN2@StringBuil

; 34   :     ASMJIT_FREE(_data);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	free
	npad	1
$LN2@StringBuil:

; 35   : }

	add	rsp, 40					; 00000028H
	ret	0
??1StringBuilder@asmjit@@QEAA@XZ ENDP			; asmjit::StringBuilder::~StringBuilder
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\string.cpp
_TEXT	SEGMENT
this$ = 8
??0StringBuilder@asmjit@@QEAA@XZ PROC			; asmjit::StringBuilder::StringBuilder

; 30   :   _canFree(false) {}

	mov	QWORD PTR [rsp+8], rcx

; 27   :   _data(const_cast<char*>(StringBuilder_empty)),

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:?StringBuilder_empty@asmjit@@3QBDB
	mov	QWORD PTR [rax], rcx

; 28   :   _length(0),

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 29   :   _capacity(0),

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 30   :   _canFree(false) {}

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0StringBuilder@asmjit@@QEAA@XZ ENDP			; asmjit::StringBuilder::StringBuilder
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
_vsnprintf PROC						; COMDAT

; 1411 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _BufferCount$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1413 :     }

	add	rsp, 56					; 00000038H
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	__stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1397 :     }

	add	rsp, 72					; 00000048H
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
