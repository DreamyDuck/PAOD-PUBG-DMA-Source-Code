; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLKGGCJO@LcOpen@			; `string'
PUBLIC	??_C@_06GJPHNGFG@LcRead@			; `string'
PUBLIC	??_C@_0O@CBBNAKKC@LcReadScatter@		; `string'
PUBLIC	??_C@_07MBHEMNEL@LcWrite@			; `string'
PUBLIC	??_C@_0P@DAJMPOFM@LcWriteScatter@		; `string'
PUBLIC	??_C@_0M@HBBFEIGD@LcGetOption@			; `string'
PUBLIC	??_C@_0M@FPFAGJPB@LcSetOption@			; `string'
PUBLIC	??_C@_09DCHLEDFD@LcCommand@			; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A@				; `string'
PUBLIC	??_C@_03HDGGCCPD@X86@				; `string'
PUBLIC	??_C@_06IDLKBMKC@X86PAE@			; `string'
PUBLIC	??_C@_03ELMOGNHL@X64@				; `string'
PUBLIC	??_C@_05DKFIPBAL@ARM64@				; `string'
PUBLIC	??_C@_04PCJGBDOP@Zero@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_07LNBDIIPN@Standby@			; `string'
PUBLIC	??_C@_07PFEKAJBJ@Modifiy@			; `string'
PUBLIC	??_C@_07DGKCKENG@ModNoWr@			; `string'
PUBLIC	??_C@_03KHCCLPOB@Bad@				; `string'
PUBLIC	??_C@_06MAFFGDO@Active@				; `string'
PUBLIC	??_C@_07KADDEKFE@Transit@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_06CGLFEPBO@Unused@			; `string'
PUBLIC	??_C@_08LBAJPEDB@ProcPriv@			; `string'
PUBLIC	??_C@_09BGPMMIPE@PageTable@			; `string'
PUBLIC	??_C@_09MFCNICMF@LargePage@			; `string'
PUBLIC	??_C@_0L@DHBAIELD@DriverLock@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_04PBAHLACE@File@				; `string'
PUBLIC	_Avx2WmemEnabledWeakValue
EXTRN	?x86RegData@asmjit@@3UX86RegData@1@B:BYTE	; asmjit::x86RegData
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04PBAHLACE@File@
CONST	SEGMENT
??_C@_04PBAHLACE@File@ DB 'File', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBAIELD@DriverLock@
CONST	SEGMENT
??_C@_0L@DHBAIELD@DriverLock@ DB 'DriverLock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCNICMF@LargePage@
CONST	SEGMENT
??_C@_09MFCNICMF@LargePage@ DB 'LargePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGPMMIPE@PageTable@
CONST	SEGMENT
??_C@_09BGPMMIPE@PageTable@ DB 'PageTable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBAJPEDB@ProcPriv@
CONST	SEGMENT
??_C@_08LBAJPEDB@ProcPriv@ DB 'ProcPriv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLFEPBO@Unused@
CONST	SEGMENT
??_C@_06CGLFEPBO@Unused@ DB 'Unused', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KADDEKFE@Transit@
CONST	SEGMENT
??_C@_07KADDEKFE@Transit@ DB 'Transit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAFFGDO@Active@
CONST	SEGMENT
??_C@_06MAFFGDO@Active@ DB 'Active', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHCCLPOB@Bad@
CONST	SEGMENT
??_C@_03KHCCLPOB@Bad@ DB 'Bad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGKCKENG@ModNoWr@
CONST	SEGMENT
??_C@_07DGKCKENG@ModNoWr@ DB 'ModNoWr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFEKAJBJ@Modifiy@
CONST	SEGMENT
??_C@_07PFEKAJBJ@Modifiy@ DB 'Modifiy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBDIIPN@Standby@
CONST	SEGMENT
??_C@_07LNBDIIPN@Standby@ DB 'Standby', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJGBDOP@Zero@
CONST	SEGMENT
??_C@_04PCJGBDOP@Zero@ DB 'Zero', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
?NoInit@asmjit@@3U_NoInit@1@B	ORG $+1			; asmjit::NoInit
CONST	ENDS
;	COMDAT ??_C@_05DKFIPBAL@ARM64@
CONST	SEGMENT
??_C@_05DKFIPBAL@ARM64@ DB 'ARM64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMOGNHL@X64@
CONST	SEGMENT
??_C@_03ELMOGNHL@X64@ DB 'X64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLKBMKC@X86PAE@
CONST	SEGMENT
??_C@_06IDLKBMKC@X86PAE@ DB 'X86PAE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDGGCCPD@X86@
CONST	SEGMENT
??_C@_03HDGGCCPD@X86@ DB 'X86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A@ DB 'N/A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCHLEDFD@LcCommand@
CONST	SEGMENT
??_C@_09DCHLEDFD@LcCommand@ DB 'LcCommand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPFAGJPB@LcSetOption@
CONST	SEGMENT
??_C@_0M@FPFAGJPB@LcSetOption@ DB 'LcSetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFEIGD@LcGetOption@
CONST	SEGMENT
??_C@_0M@HBBFEIGD@LcGetOption@ DB 'LcGetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJMPOFM@LcWriteScatter@
CONST	SEGMENT
??_C@_0P@DAJMPOFM@LcWriteScatter@ DB 'LcWriteScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBHEMNEL@LcWrite@
CONST	SEGMENT
??_C@_07MBHEMNEL@LcWrite@ DB 'LcWrite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBNAKKC@LcReadScatter@
CONST	SEGMENT
??_C@_0O@CBBNAKKC@LcReadScatter@ DB 'LcReadScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJPHNGFG@LcRead@
CONST	SEGMENT
??_C@_06GJPHNGFG@LcRead@ DB 'LcRead', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKGGCJO@LcOpen@
CONST	SEGMENT
??_C@_06GLKGGCJO@LcOpen@ DB 'LcOpen', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::WSInit
PUBLIC	??1WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::~WSInit
PUBLIC	??0SSLInit@detail@httplib@@QEAA@XZ		; httplib::detail::SSLInit::SSLInit
PUBLIC	??0Lock@asmjit@@QEAA@XZ				; asmjit::Lock::Lock
PUBLIC	??1Lock@asmjit@@QEAA@XZ				; asmjit::Lock::~Lock
PUBLIC	?lock@Lock@asmjit@@QEAAXXZ			; asmjit::Lock::lock
PUBLIC	?unlock@Lock@asmjit@@QEAAXXZ			; asmjit::Lock::unlock
PUBLIC	??0AutoLock@asmjit@@QEAA@AEAULock@1@@Z		; asmjit::AutoLock::AutoLock
PUBLIC	??1AutoLock@asmjit@@QEAA@XZ			; asmjit::AutoLock::~AutoLock
PUBLIC	?getPageSize@VMemUtil@asmjit@@SA_KXZ		; asmjit::VMemUtil::getPageSize
PUBLIC	?getPageGranularity@VMemUtil@asmjit@@SA_KXZ	; asmjit::VMemUtil::getPageGranularity
PUBLIC	?alloc@VMemUtil@asmjit@@SAPEAX_KPEA_KI@Z	; asmjit::VMemUtil::alloc
PUBLIC	?allocProcessMemory@VMemUtil@asmjit@@SAPEAXPEAX_KPEA_KI@Z ; asmjit::VMemUtil::allocProcessMemory
PUBLIC	?release@VMemUtil@asmjit@@SAIPEAX_K@Z		; asmjit::VMemUtil::release
PUBLIC	?releaseProcessMemory@VMemUtil@asmjit@@SAIPEAX0_K@Z ; asmjit::VMemUtil::releaseProcessMemory
PUBLIC	??0VMemMgr@asmjit@@QEAA@PEAX@Z			; asmjit::VMemMgr::VMemMgr
PUBLIC	??1VMemMgr@asmjit@@QEAA@XZ			; asmjit::VMemMgr::~VMemMgr
PUBLIC	?reset@VMemMgr@asmjit@@QEAAXXZ			; asmjit::VMemMgr::reset
PUBLIC	?alloc@VMemMgr@asmjit@@QEAAPEAX_KI@Z		; asmjit::VMemMgr::alloc
PUBLIC	?release@VMemMgr@asmjit@@QEAAIPEAX@Z		; asmjit::VMemMgr::release
PUBLIC	?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z		; asmjit::VMemMgr::shrink
PUBLIC	?getSafeProcessHandle@VMemLocal@asmjit@@QEBAPEAXPEAX@Z ; asmjit::VMemLocal::getSafeProcessHandle
PUBLIC	??$alignToPowerOf2@I@IntUtil@asmjit@@SAII@Z	; asmjit::IntUtil::alignToPowerOf2<unsigned int>
PUBLIC	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z		; asmjit::IntUtil::alignTo<unsigned __int64>
PUBLIC	?getAvailable@MemNode@VMemMgr@asmjit@@QEBA_KXZ	; asmjit::VMemMgr::MemNode::getAvailable
PUBLIC	?fillData@MemNode@VMemMgr@asmjit@@QEAAXPEAU123@@Z ; asmjit::VMemMgr::MemNode::fillData
PUBLIC	?getAvailable@PermanentNode@VMemMgr@asmjit@@QEBA_KXZ ; asmjit::VMemMgr::PermanentNode::getAvailable
PUBLIC	?vMemMgrAllocVMem@asmjit@@YAPEAEPEAUVMemMgr@1@_KPEA_K@Z ; asmjit::vMemMgrAllocVMem
PUBLIC	?vMemMgrReleaseVMem@asmjit@@YAIPEAUVMemMgr@1@PEAX_K@Z ; asmjit::vMemMgrReleaseVMem
PUBLIC	??$?0$0A@@id@locale@std@@QEAA@XZ		; std::locale::id::id<0>
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$collate@D@std@@2V0locale@2@A		; std::collate<char>::id
EXTRN	atexit:PROC
EXTRN	memset:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	__imp_InitializeCriticalSection:PROC
EXTRN	__imp_EnterCriticalSection:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_DeleteCriticalSection:PROC
EXTRN	__imp_GetCurrentProcess:PROC
EXTRN	__imp_GetSystemInfo:PROC
EXTRN	__imp_VirtualAllocEx:PROC
EXTRN	__imp_VirtualFreeEx:PROC
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	OPENSSL_init_ssl:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
?wsinit_@detail@httplib@@3VWSInit@12@A DB 01H DUP (?)	; httplib::detail::wsinit_
	ALIGN	4

?sslinit_@detail@httplib@@3VSSLInit@12@A DB 01H DUP (?)	; httplib::detail::sslinit_
	ALIGN	4

?vMemLocal@asmjit@@3UVMemLocal@1@A DB 018H DUP (?)	; asmjit::vMemLocal
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::collate<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??0WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??1WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ewsinit_@detail@httplib@@YAXXZ DD imagerel ??__Ewsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Ewsinit_@detail@httplib@@YAXXZ+34
	DD	imagerel $unwind$??__Ewsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fwsinit_@detail@httplib@@YAXXZ DD imagerel ??__Fwsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Fwsinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Fwsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SSLInit@detail@httplib@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0SSLInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Esslinit_@detail@httplib@@YAXXZ DD imagerel ??__Esslinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Esslinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Esslinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Lock@asmjit@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??0Lock@asmjit@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Lock@asmjit@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??1Lock@asmjit@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?lock@Lock@asmjit@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?lock@Lock@asmjit@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?unlock@Lock@asmjit@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?unlock@Lock@asmjit@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0AutoLock@asmjit@@QEAA@AEAULock@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??0AutoLock@asmjit@@QEAA@AEAULock@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1AutoLock@asmjit@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$??1AutoLock@asmjit@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?getPageSize@VMemUtil@asmjit@@SA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?getPageSize@VMemUtil@asmjit@@SA_KXZ
$pdata$?getPageGranularity@VMemUtil@asmjit@@SA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?getPageGranularity@VMemUtil@asmjit@@SA_KXZ
$pdata$?alloc@VMemUtil@asmjit@@SAPEAX_KPEA_KI@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?alloc@VMemUtil@asmjit@@SAPEAX_KPEA_KI@Z
$pdata$?allocProcessMemory@VMemUtil@asmjit@@SAPEAXPEAX_KPEA_KI@Z DD imagerel $LN12
	DD	imagerel $LN12+305
	DD	imagerel $unwind$?allocProcessMemory@VMemUtil@asmjit@@SAPEAXPEAX_KPEA_KI@Z
$pdata$?release@VMemUtil@asmjit@@SAIPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?release@VMemUtil@asmjit@@SAIPEAX_K@Z
$pdata$?releaseProcessMemory@VMemUtil@asmjit@@SAIPEAX0_K@Z DD imagerel $LN4
	DD	imagerel $LN4+92
	DD	imagerel $unwind$?releaseProcessMemory@VMemUtil@asmjit@@SAIPEAX0_K@Z
$pdata$??0VMemMgr@asmjit@@QEAA@PEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+202
	DD	imagerel $unwind$??0VMemMgr@asmjit@@QEAA@PEAX@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0VMemMgr@asmjit@@QEAA@PEAX@Z@4HA DD imagerel ?dtor$0@?0???0VMemMgr@asmjit@@QEAA@PEAX@Z@4HA
	DD	imagerel ?dtor$0@?0???0VMemMgr@asmjit@@QEAA@PEAX@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0VMemMgr@asmjit@@QEAA@PEAX@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??1VMemMgr@asmjit@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$??1VMemMgr@asmjit@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???1VMemMgr@asmjit@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1VMemMgr@asmjit@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1VMemMgr@asmjit@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1VMemMgr@asmjit@@QEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?reset@VMemMgr@asmjit@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?reset@VMemMgr@asmjit@@QEAAXXZ
$pdata$?alloc@VMemMgr@asmjit@@QEAAPEAX_KI@Z DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$?alloc@VMemMgr@asmjit@@QEAAPEAX_KI@Z
$pdata$?release@VMemMgr@asmjit@@QEAAIPEAX@Z DD imagerel $LN21
	DD	imagerel $LN21+971
	DD	imagerel $unwind$?release@VMemMgr@asmjit@@QEAAIPEAX@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??release@VMemMgr@asmjit@@QEAAIPEAX@Z@4HA DD imagerel ?dtor$0@?0??release@VMemMgr@asmjit@@QEAAIPEAX@Z@4HA
	DD	imagerel ?dtor$0@?0??release@VMemMgr@asmjit@@QEAAIPEAX@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??release@VMemMgr@asmjit@@QEAAIPEAX@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z DD imagerel $LN25
	DD	imagerel $LN25+1028
	DD	imagerel $unwind$?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z@4HA DD imagerel ?dtor$0@?0??shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z@4HA
	DD	imagerel ?dtor$0@?0??shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getSafeProcessHandle@VMemLocal@asmjit@@QEBAPEAXPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+55
	DD	imagerel $unwind$?getSafeProcessHandle@VMemLocal@asmjit@@QEBAPEAXPEAX@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?vMemGet@asmjit@@YAAEBUVMemLocal@1@XZ DD imagerel ?vMemGet@asmjit@@YAAEBUVMemLocal@1@XZ
	DD	imagerel ?vMemGet@asmjit@@YAAEBUVMemLocal@1@XZ+96
	DD	imagerel $unwind$?vMemGet@asmjit@@YAAEBUVMemLocal@1@XZ
$pdata$?_SetBits@asmjit@@YAXPEA_K_K1@Z DD imagerel ?_SetBits@asmjit@@YAXPEA_K_K1@Z
	DD	imagerel ?_SetBits@asmjit@@YAXPEA_K_K1@Z+342
	DD	imagerel $unwind$?_SetBits@asmjit@@YAXPEA_K_K1@Z
$pdata$?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z DD imagerel ?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z
	DD	imagerel ?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z+53
	DD	imagerel $unwind$?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z
$pdata$?rbRotateSingle@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z DD imagerel ?rbRotateSingle@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z
	DD	imagerel ?rbRotateSingle@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z+190
	DD	imagerel $unwind$?rbRotateSingle@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z
$pdata$?rbRotateDouble@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z DD imagerel ?rbRotateDouble@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z
	DD	imagerel ?rbRotateDouble@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z+174
	DD	imagerel $unwind$?rbRotateDouble@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?vMemMgrAllocVMem@asmjit@@YAPEAEPEAUVMemMgr@1@_KPEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?vMemMgrAllocVMem@asmjit@@YAPEAEPEAUVMemMgr@1@_KPEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?vMemMgrReleaseVMem@asmjit@@YAIPEAUVMemMgr@1@PEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?vMemMgrReleaseVMem@asmjit@@YAIPEAUVMemMgr@1@PEAX_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?vMemMgrCreateNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@_K1@Z DD imagerel ?vMemMgrCreateNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@_K1@Z
	DD	imagerel ?vMemMgrCreateNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@_K1@Z+457
	DD	imagerel $unwind$?vMemMgrCreateNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@_K1@Z
$pdata$?vMemMgrInsertNode@asmjit@@YAXPEAUVMemMgr@1@PEAUMemNode@21@@Z DD imagerel ?vMemMgrInsertNode@asmjit@@YAXPEAUVMemMgr@1@PEAUMemNode@21@@Z
	DD	imagerel ?vMemMgrInsertNode@asmjit@@YAXPEAUVMemMgr@1@PEAUMemNode@21@@Z+938
	DD	imagerel $unwind$?vMemMgrInsertNode@asmjit@@YAXPEAUVMemMgr@1@PEAUMemNode@21@@Z
$pdata$?vMemMgrRemoveNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAU231@@Z DD imagerel ?vMemMgrRemoveNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAU231@@Z
	DD	imagerel ?vMemMgrRemoveNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAU231@@Z+1521
	DD	imagerel $unwind$?vMemMgrRemoveNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAU231@@Z
$pdata$?vMemMgrFindNodeByPtr@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAE@Z DD imagerel ?vMemMgrFindNodeByPtr@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAE@Z
	DD	imagerel ?vMemMgrFindNodeByPtr@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAE@Z+154
	DD	imagerel $unwind$?vMemMgrFindNodeByPtr@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAE@Z
$pdata$?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z DD imagerel ?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z
	DD	imagerel ?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z+437
	DD	imagerel $unwind$?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA DD imagerel ?dtor$0@?0??vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA
	DD	imagerel ?dtor$0@?0??vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z DD imagerel ?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z
	DD	imagerel ?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z+1269
	DD	imagerel $unwind$?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA DD imagerel ?dtor$0@?0??vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA
	DD	imagerel ?dtor$0@?0??vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?vMemMgrReset@asmjit@@YAXPEAUVMemMgr@1@_N@Z DD imagerel ?vMemMgrReset@asmjit@@YAXPEAUVMemMgr@1@_N@Z
	DD	imagerel ?vMemMgrReset@asmjit@@YAXPEAUVMemMgr@1@_N@Z+206
	DD	imagerel $unwind$?vMemMgrReset@asmjit@@YAXPEAUVMemMgr@1@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
CRT$XCU	SEGMENT
?wsinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Ewsinit_@detail@httplib@@YAXXZ ; httplib::detail::wsinit_$initializer$
CRT$XCU	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?vMemMgrReleaseVMem@asmjit@@YAIPEAUVMemMgr@1@PEAX_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?vMemMgrAllocVMem@asmjit@@YAPEAEPEAUVMemMgr@1@_KPEA_K@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getSafeProcessHandle@VMemLocal@asmjit@@QEBAPEAXPEAX@Z DD 010e01H
	DD	0220eH
xdata	ENDS
xdata	SEGMENT
$unwind$?getPageSize@VMemUtil@asmjit@@SA_KXZ DD 010401H
	DD	06204H
$unwind$?getPageGranularity@VMemUtil@asmjit@@SA_KXZ DD 010401H
	DD	06204H
$unwind$?alloc@VMemUtil@asmjit@@SAPEAX_KPEA_KI@Z DD 011301H
	DD	04213H
$unwind$?allocProcessMemory@VMemUtil@asmjit@@SAPEAXPEAX_KPEA_KI@Z DD 011801H
	DD	0c218H
$unwind$?release@VMemUtil@asmjit@@SAIPEAX_K@Z DD 010e01H
	DD	0420eH
$unwind$?releaseProcessMemory@VMemUtil@asmjit@@SAIPEAX0_K@Z DD 011301H
	DD	06213H
$unwind$??0VMemMgr@asmjit@@QEAA@PEAX@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0VMemMgr@asmjit@@QEAA@PEAX@Z
$cppxdata$??0VMemMgr@asmjit@@QEAA@PEAX@Z DB 08H
	DD	imagerel $stateUnwindMap$??0VMemMgr@asmjit@@QEAA@PEAX@Z
	DD	imagerel $ip2state$??0VMemMgr@asmjit@@QEAA@PEAX@Z
$stateUnwindMap$??0VMemMgr@asmjit@@QEAA@PEAX@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0VMemMgr@asmjit@@QEAA@PEAX@Z@4HA
$ip2state$??0VMemMgr@asmjit@@QEAA@PEAX@Z DB 06H
	DB	00H
	DB	00H
	DB	082H
	DB	02H
	DB	0feH
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0???0VMemMgr@asmjit@@QEAA@PEAX@Z@4HA DD 020601H
	DD	050023206H
$unwind$??1VMemMgr@asmjit@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1VMemMgr@asmjit@@QEAA@XZ
$cppxdata$??1VMemMgr@asmjit@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1VMemMgr@asmjit@@QEAA@XZ
	DD	imagerel $ip2state$??1VMemMgr@asmjit@@QEAA@XZ
$stateUnwindMap$??1VMemMgr@asmjit@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1VMemMgr@asmjit@@QEAA@XZ@4HA
$ip2state$??1VMemMgr@asmjit@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	098H
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0???1VMemMgr@asmjit@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?reset@VMemMgr@asmjit@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?alloc@VMemMgr@asmjit@@QEAAPEAX_KI@Z DD 011301H
	DD	04213H
$unwind$?release@VMemMgr@asmjit@@QEAAIPEAX@Z DD 021111H
	DD	0150111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?release@VMemMgr@asmjit@@QEAAIPEAX@Z
$cppxdata$?release@VMemMgr@asmjit@@QEAAIPEAX@Z DB 08H
	DD	imagerel $stateUnwindMap$?release@VMemMgr@asmjit@@QEAAIPEAX@Z
	DD	imagerel $ip2state$?release@VMemMgr@asmjit@@QEAAIPEAX@Z
$stateUnwindMap$?release@VMemMgr@asmjit@@QEAAIPEAX@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??release@VMemMgr@asmjit@@QEAAIPEAX@Z@4HA
$ip2state$?release@VMemMgr@asmjit@@QEAAIPEAX@Z DB 0aH
	DB	00H
	DB	00H
	DB	080H
	DB	02H
	DB	'T'
	DB	00H
	DB	','
	DB	02H
	DB	0c9H, 0cH
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??release@VMemMgr@asmjit@@QEAAIPEAX@Z@4HA DD 020601H
	DD	050023206H
$unwind$?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z DD 021611H
	DD	0170116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z
$cppxdata$?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z DB 08H
	DD	imagerel $stateUnwindMap$?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z
	DD	imagerel $ip2state$?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z
$stateUnwindMap$?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z@4HA
$ip2state$?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z DB 0eH
	DB	00H
	DB	00H
	DB	0ceH
	DB	02H
	DB	'T'
	DB	00H
	DB	'&'
	DB	02H
	DB	')', 05H
	DB	00H
	DB	'&'
	DB	02H
	DB	0b5H, 07H
	DB	00H
$unwind$?dtor$0@?0??shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z@4HA DD 020601H
	DD	050023206H
$unwind$?vMemGet@asmjit@@YAAEBUVMemLocal@1@XZ DD 010401H
	DD	0c204H
$unwind$?_SetBits@asmjit@@YAXPEA_K_K1@Z DD 011301H
	DD	06213H
$unwind$?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z DD 010901H
	DD	02209H
$unwind$?rbRotateSingle@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z DD 010d01H
	DD	0620dH
$unwind$?rbRotateDouble@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z DD 010d01H
	DD	0a20dH
$unwind$?vMemMgrCreateNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@_K1@Z DD 011301H
	DD	0a213H
$unwind$?vMemMgrInsertNode@asmjit@@YAXPEAUVMemMgr@1@PEAUMemNode@21@@Z DD 031201H
	DD	0120112H
	DD	0700bH
$unwind$?vMemMgrRemoveNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAU231@@Z DD 031201H
	DD	0200112H
	DD	0700bH
$unwind$?vMemMgrFindNodeByPtr@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAE@Z DD 010e01H
	DD	0420eH
$unwind$?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z DD 010e11H
	DD	0c20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z
$cppxdata$?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z DB 08H
	DD	imagerel $stateUnwindMap$?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z
	DD	imagerel $ip2state$?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z
$stateUnwindMap$?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA
$ip2state$?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z DB 0eH
	DB	00H
	DB	00H
	DB	'r'
	DB	02H
	DB	05H, 02H
	DB	00H
	DB	'('
	DB	02H
	DB	088H
	DB	00H
	DB	'('
	DB	02H
	DB	0f6H
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA DD 020601H
	DD	050023206H
$unwind$?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z DD 021111H
	DD	0190111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z
$cppxdata$?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z DB 08H
	DD	imagerel $stateUnwindMap$?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z
	DD	imagerel $ip2state$?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z
$stateUnwindMap$?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA
$ip2state$?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	0b4H
	DB	02H
	DB	0ddH, 0cH
	DB	00H
	DB	'4'
	DB	02H
	DB	0b5H, 04H
	DB	00H
$unwind$?dtor$0@?0??vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA DD 020601H
	DD	050023206H
$unwind$?vMemMgrReset@asmjit@@YAXPEAUVMemMgr@1@_N@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1AutoLock@asmjit@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1AutoLock@asmjit@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1AutoLock@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1AutoLock@asmjit@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1AutoLock@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0AutoLock@asmjit@@QEAA@AEAULock@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?unlock@Lock@asmjit@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?lock@Lock@asmjit@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1Lock@asmjit@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1Lock@asmjit@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1Lock@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Lock@asmjit@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1Lock@asmjit@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Lock@asmjit@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Esslinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SSLInit@detail@httplib@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fwsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ewsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1WSInit@detail@httplib@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1WSInit@detail@httplib@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1WSInit@detail@httplib@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	04fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0WSInit@detail@httplib@@QEAA@XZ DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?sslinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Esslinit_@detail@httplib@@YAXXZ ; httplib::detail::sslinit_$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\locale
;	COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 124  : __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::collate<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 809  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0$0A@@id@locale@std@@QEAA@XZ PROC			; std::locale::id::id<0>, COMDAT

; 81   :         id() noexcept /* strengthened */ {}

	mov	QWORD PTR [rsp+8], rcx

; 82   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 83   : 
; 84   :         id(const id&)            = delete;
; 85   :         id& operator=(const id&) = delete;
; 86   : 
; 87   :         template <int = 0> // TRANSITION, ABI
; 88   :         size_t _Get_index() { // get stamp, with lazy allocation
; 89   :             if (_Id == 0) { // still zero, allocate stamp
; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 91   :                 if (_Id == 0) {
; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 93   :                 }
; 94   :                 _END_LOCK()
; 95   :             }
; 96   :             return _Id;
; 97   :         }
; 98   : 
; 99   : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 100  :         __CLR_OR_THIS_CALL operator size_t() {
; 101  :             return _Get_index();
; 102  :         }
; 103  : #endif // defined(_CRTBLD)
; 104  : 
; 105  :     private:
; 106  :         size_t _Id = 0; // the identifier stamp

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :         id() noexcept /* strengthened */ {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$0A@@id@locale@std@@QEAA@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
node$ = 32
next$1 = 40
self$ = 64
keepVirtualMemory$ = 72
?vMemMgrReset@asmjit@@YAXPEAUVMemMgr@1@_N@Z PROC	; asmjit::vMemMgrReset

; 901  : static void vMemMgrReset(VMemMgr* self, bool keepVirtualMemory) {

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 902  :   MemNode* node = self->_first;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR node$[rsp], rax
$LN2@vMemMgrRes:

; 903  : 
; 904  :   while (node != NULL) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN3@vMemMgrRes

; 905  :     MemNode* next = node->next;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR next$1[rsp], rax

; 906  : 
; 907  :     if (!keepVirtualMemory)

	movzx	eax, BYTE PTR keepVirtualMemory$[rsp]
	test	eax, eax
	jne	SHORT $LN4@vMemMgrRes

; 908  :       vMemMgrReleaseVMem(self, node->mem, node->size);

	mov	rax, QWORD PTR node$[rsp]
	mov	r8, QWORD PTR [rax+48]
	mov	rax, QWORD PTR node$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR self$[rsp]
	call	?vMemMgrReleaseVMem@asmjit@@YAIPEAUVMemMgr@1@PEAX_K@Z ; asmjit::vMemMgrReleaseVMem
	npad	1
$LN4@vMemMgrRes:

; 909  : 
; 910  :     ASMJIT_FREE(node->baUsed);

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR [rax+88]
	call	free

; 911  :     ASMJIT_FREE(node);

	mov	rcx, QWORD PTR node$[rsp]
	call	free

; 912  : 
; 913  :     node = next;

	mov	rax, QWORD PTR next$1[rsp]
	mov	QWORD PTR node$[rsp], rax

; 914  :   }

	jmp	SHORT $LN2@vMemMgrRes
$LN3@vMemMgrRes:

; 915  : 
; 916  :   self->_allocatedBytes = 0;

	mov	rax, QWORD PTR self$[rsp]
	mov	QWORD PTR [rax+72], 0

; 917  :   self->_usedBytes = 0;

	mov	rax, QWORD PTR self$[rsp]
	mov	QWORD PTR [rax+80], 0

; 918  : 
; 919  :   self->_root = NULL;

	mov	rax, QWORD PTR self$[rsp]
	mov	QWORD PTR [rax+88], 0

; 920  :   self->_first = NULL;

	mov	rax, QWORD PTR self$[rsp]
	mov	QWORD PTR [rax+96], 0

; 921  :   self->_last = NULL;

	mov	rax, QWORD PTR self$[rsp]
	mov	QWORD PTR [rax+104], 0

; 922  :   self->_optimal = NULL;

	mov	rax, QWORD PTR self$[rsp]
	mov	QWORD PTR [rax+112], 0

; 923  : }

	add	rsp, 56					; 00000038H
	ret	0
?vMemMgrReset@asmjit@@YAXPEAUVMemMgr@1@_N@Z ENDP	; asmjit::vMemMgrReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
node$ = 32
i$ = 40
cont$1 = 48
maxCont$2 = 56
need$ = 64
j$3 = 72
next$4 = 80
up$5 = 88
blocks$6 = 96
max$7 = 104
bit$8 = 112
blockSize$9 = 120
ubits$10 = 128
u$11 = 136
locked$ = 144
minVSize$ = 152
tv133 = 160
$T12 = 168
result$ = 176
$T13 = 184
self$ = 208
vSize$ = 216
?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z PROC ; asmjit::vMemMgrAllocFreeable

; 769  : static void* vMemMgrAllocFreeable(VMemMgr* self, size_t vSize) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 770  :   // Current index.
; 771  :   size_t i;
; 772  : 
; 773  :   // How many we need to be freed.
; 774  :   size_t need;
; 775  :   size_t minVSize;
; 776  : 
; 777  :   // Align to 32 bytes by default.
; 778  :   vSize = IntUtil::alignTo<size_t>(vSize, 32);

	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR vSize$[rsp]
	call	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z	; asmjit::IntUtil::alignTo<unsigned __int64>
	mov	QWORD PTR vSize$[rsp], rax

; 779  :   if (vSize == 0)

	cmp	QWORD PTR vSize$[rsp], 0
	jne	SHORT $LN9@vMemMgrAll

; 780  :     return NULL;

	xor	eax, eax
	jmp	$LN1@vMemMgrAll
$LN9@vMemMgrAll:

; 781  : 
; 782  :   AutoLock locked(self->_lock);

	mov	rax, QWORD PTR self$[rsp]
	add	rax, 8
	mov	rdx, rax
	lea	rcx, QWORD PTR locked$[rsp]
	call	??0AutoLock@asmjit@@QEAA@AEAULock@1@@Z	; asmjit::AutoLock::AutoLock
	npad	1

; 783  :   MemNode* node = self->_optimal;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR node$[rsp], rax

; 784  :   minVSize = self->_blockSize;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR minVSize$[rsp], rax
$LN2@vMemMgrAll:

; 785  : 
; 786  :   // Try to find memory block in existing nodes.
; 787  :   while (node) {

	cmp	QWORD PTR node$[rsp], 0
	je	$LN3@vMemMgrAll

; 788  :     // Skip this node?
; 789  :     if ((node->getAvailable() < vSize) || (node->largestBlock < vSize && node->largestBlock != 0)) {

	mov	rcx, QWORD PTR node$[rsp]
	call	?getAvailable@MemNode@VMemMgr@asmjit@@QEBA_KXZ ; asmjit::VMemMgr::MemNode::getAvailable
	cmp	rax, QWORD PTR vSize$[rsp]
	jb	SHORT $LN11@vMemMgrAll
	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR vSize$[rsp]
	cmp	QWORD PTR [rax+80], rcx
	jae	SHORT $LN10@vMemMgrAll
	mov	rax, QWORD PTR node$[rsp]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN10@vMemMgrAll
$LN11@vMemMgrAll:

; 790  :       MemNode* next = node->next;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR next$4[rsp], rax

; 791  : 
; 792  :       if (node->getAvailable() < minVSize && node == self->_optimal && next)

	mov	rcx, QWORD PTR node$[rsp]
	call	?getAvailable@MemNode@VMemMgr@asmjit@@QEBA_KXZ ; asmjit::VMemMgr::MemNode::getAvailable
	cmp	rax, QWORD PTR minVSize$[rsp]
	jae	SHORT $LN12@vMemMgrAll
	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+112]
	cmp	QWORD PTR node$[rsp], rax
	jne	SHORT $LN12@vMemMgrAll
	cmp	QWORD PTR next$4[rsp], 0
	je	SHORT $LN12@vMemMgrAll

; 793  :         self->_optimal = next;

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR next$4[rsp]
	mov	QWORD PTR [rax+112], rcx
$LN12@vMemMgrAll:

; 794  : 
; 795  :       node = next;

	mov	rax, QWORD PTR next$4[rsp]
	mov	QWORD PTR node$[rsp], rax

; 796  :       continue;

	jmp	$LN2@vMemMgrAll
$LN10@vMemMgrAll:

; 797  :     }
; 798  : 
; 799  :     size_t* up = node->baUsed;     // Current ubits address.

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR up$5[rsp], rax

; 800  :     size_t ubits;                  // Current ubits[0] value.
; 801  :     size_t bit;                    // Current bit mask.
; 802  :     size_t blocks = node->blocks;  // Count of blocks in node.

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR blocks$6[rsp], rax

; 803  :     size_t cont = 0;               // How many bits are currently freed in find loop.

	mov	QWORD PTR cont$1[rsp], 0

; 804  :     size_t maxCont = 0;            // Largest continuous block (bits count).

	mov	QWORD PTR maxCont$2[rsp], 0

; 805  :     size_t j;
; 806  : 
; 807  :     need = M_DIV((vSize + node->density - 1), node->density);

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR vSize$[rsp]
	lea	rax, QWORD PTR [rcx+rax-1]
	xor	edx, edx
	mov	rcx, QWORD PTR node$[rsp]
	div	QWORD PTR [rcx+72]
	mov	QWORD PTR need$[rsp], rax

; 808  :     i = 0;

	mov	QWORD PTR i$[rsp], 0
$LN4@vMemMgrAll:

; 809  : 
; 810  :     // Try to find node that is large enough.
; 811  :     while (i < blocks) {

	mov	rax, QWORD PTR blocks$6[rsp]
	cmp	QWORD PTR i$[rsp], rax
	jae	$LN5@vMemMgrAll

; 812  :       ubits = *up++;

	mov	rax, QWORD PTR up$5[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv133[rsp], rax
	mov	rax, QWORD PTR up$5[rsp]
	add	rax, 8
	mov	QWORD PTR up$5[rsp], rax
	mov	rax, QWORD PTR tv133[rsp]
	mov	QWORD PTR ubits$10[rsp], rax

; 813  : 
; 814  :       // Fast skip used blocks.
; 815  :       if (ubits == ~(size_t)0) {

	cmp	QWORD PTR ubits$10[rsp], -1
	jne	SHORT $LN13@vMemMgrAll

; 816  :         if (cont > maxCont)

	mov	rax, QWORD PTR maxCont$2[rsp]
	cmp	QWORD PTR cont$1[rsp], rax
	jbe	SHORT $LN14@vMemMgrAll

; 817  :           maxCont = cont;

	mov	rax, QWORD PTR cont$1[rsp]
	mov	QWORD PTR maxCont$2[rsp], rax
$LN14@vMemMgrAll:

; 818  :         cont = 0;

	mov	QWORD PTR cont$1[rsp], 0

; 819  : 
; 820  :         i += kBitsPerEntity;

	mov	rax, QWORD PTR i$[rsp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR i$[rsp], rax

; 821  :         continue;

	jmp	SHORT $LN4@vMemMgrAll
$LN13@vMemMgrAll:

; 822  :       }
; 823  : 
; 824  :       size_t max = kBitsPerEntity;

	mov	QWORD PTR max$7[rsp], 64		; 00000040H

; 825  :       if (i + max > blocks)

	mov	rax, QWORD PTR max$7[rsp]
	mov	rcx, QWORD PTR i$[rsp]
	add	rcx, rax
	mov	rax, rcx
	cmp	rax, QWORD PTR blocks$6[rsp]
	jbe	SHORT $LN15@vMemMgrAll

; 826  :         max = blocks - i;

	mov	rax, QWORD PTR i$[rsp]
	mov	rcx, QWORD PTR blocks$6[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR max$7[rsp], rax
$LN15@vMemMgrAll:

; 827  : 
; 828  :       for (j = 0, bit = 1; j < max; bit <<= 1) {

	mov	QWORD PTR j$3[rsp], 0
	mov	QWORD PTR bit$8[rsp], 1
	jmp	SHORT $LN8@vMemMgrAll
$LN6@vMemMgrAll:
	mov	rax, QWORD PTR bit$8[rsp]
	shl	rax, 1
	mov	QWORD PTR bit$8[rsp], rax
$LN8@vMemMgrAll:
	mov	rax, QWORD PTR max$7[rsp]
	cmp	QWORD PTR j$3[rsp], rax
	jae	$LN7@vMemMgrAll

; 829  :         j++;

	mov	rax, QWORD PTR j$3[rsp]
	inc	rax
	mov	QWORD PTR j$3[rsp], rax

; 830  :         if ((ubits & bit) == 0) {

	mov	rax, QWORD PTR bit$8[rsp]
	mov	rcx, QWORD PTR ubits$10[rsp]
	and	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jne	SHORT $LN16@vMemMgrAll

; 831  :           if (++cont == need) {

	mov	rax, QWORD PTR cont$1[rsp]
	inc	rax
	mov	QWORD PTR cont$1[rsp], rax
	mov	rax, QWORD PTR need$[rsp]
	cmp	QWORD PTR cont$1[rsp], rax
	jne	SHORT $LN17@vMemMgrAll

; 832  :             i += j;

	mov	rax, QWORD PTR j$3[rsp]
	mov	rcx, QWORD PTR i$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR i$[rsp], rax

; 833  :             i -= cont;

	mov	rax, QWORD PTR cont$1[rsp]
	mov	rcx, QWORD PTR i$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR i$[rsp], rax

; 834  :             goto _Found;

	jmp	$_Found$26
$LN17@vMemMgrAll:

; 835  :           }
; 836  : 
; 837  :           continue;

	jmp	$LN6@vMemMgrAll
$LN16@vMemMgrAll:

; 838  :         }
; 839  : 
; 840  :         if (cont > maxCont) maxCont = cont;

	mov	rax, QWORD PTR maxCont$2[rsp]
	cmp	QWORD PTR cont$1[rsp], rax
	jbe	SHORT $LN19@vMemMgrAll
	mov	rax, QWORD PTR cont$1[rsp]
	mov	QWORD PTR maxCont$2[rsp], rax
$LN19@vMemMgrAll:

; 841  :         cont = 0;

	mov	QWORD PTR cont$1[rsp], 0

; 842  :       }

	jmp	$LN6@vMemMgrAll
$LN7@vMemMgrAll:

; 843  : 
; 844  :       i += kBitsPerEntity;

	mov	rax, QWORD PTR i$[rsp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR i$[rsp], rax

; 845  :     }

	jmp	$LN4@vMemMgrAll
$LN5@vMemMgrAll:

; 846  : 
; 847  :     // Because we traversed the entire node, we can set largest node size that
; 848  :     // will be used to cache next traversing.
; 849  :     node->largestBlock = maxCont * node->density;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR maxCont$2[rsp]
	imul	rcx, QWORD PTR [rax+72]
	mov	rax, rcx
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 850  : 
; 851  :     node = node->next;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR node$[rsp], rax

; 852  :   }

	jmp	$LN2@vMemMgrAll
$LN3@vMemMgrAll:

; 853  : 
; 854  :   // If we are here, we failed to find existing memory block and we must
; 855  :   // allocate a new one.
; 856  :   {
; 857  :     size_t blockSize = self->_blockSize;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR blockSize$9[rsp], rax

; 858  :     if (blockSize < vSize)

	mov	rax, QWORD PTR vSize$[rsp]
	cmp	QWORD PTR blockSize$9[rsp], rax
	jae	SHORT $LN20@vMemMgrAll

; 859  :       blockSize = vSize;

	mov	rax, QWORD PTR vSize$[rsp]
	mov	QWORD PTR blockSize$9[rsp], rax
$LN20@vMemMgrAll:

; 860  : 
; 861  :     node = vMemMgrCreateNode(self, blockSize, self->_blockDensity);

	mov	rax, QWORD PTR self$[rsp]
	mov	r8, QWORD PTR [rax+56]
	mov	rdx, QWORD PTR blockSize$9[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	call	?vMemMgrCreateNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@_K1@Z ; asmjit::vMemMgrCreateNode
	mov	QWORD PTR node$[rsp], rax

; 862  :     if (node == NULL)

	cmp	QWORD PTR node$[rsp], 0
	jne	SHORT $LN21@vMemMgrAll

; 863  :       return NULL;

	mov	QWORD PTR $T12[rsp], 0
	lea	rcx, QWORD PTR locked$[rsp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	mov	rax, QWORD PTR $T12[rsp]
	jmp	$LN1@vMemMgrAll
$LN21@vMemMgrAll:

; 864  : 
; 865  :     // Update binary tree.
; 866  :     vMemMgrInsertNode(self, node);

	mov	rdx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	call	?vMemMgrInsertNode@asmjit@@YAXPEAUVMemMgr@1@PEAUMemNode@21@@Z ; asmjit::vMemMgrInsertNode

; 867  :     ASMJIT_ASSERT(vMemMgrCheckTree(self));
; 868  : 
; 869  :     // Alloc first node at start.
; 870  :     i = 0;

	mov	QWORD PTR i$[rsp], 0

; 871  :     need = (vSize + node->density - 1) / node->density;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR vSize$[rsp]
	lea	rax, QWORD PTR [rcx+rax-1]
	xor	edx, edx
	mov	rcx, QWORD PTR node$[rsp]
	div	QWORD PTR [rcx+72]
	mov	QWORD PTR need$[rsp], rax

; 872  : 
; 873  :     // Update statistics.
; 874  :     self->_allocatedBytes += node->size;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR node$[rsp]
	add	rax, QWORD PTR [rcx+48]
	mov	rcx, QWORD PTR self$[rsp]
	mov	QWORD PTR [rcx+72], rax
$_Found$26:

; 875  :   }
; 876  : 
; 877  : _Found:
; 878  :   // Update bits.
; 879  :   _SetBits(node->baUsed, i, need);

	mov	r8, QWORD PTR need$[rsp]
	mov	rdx, QWORD PTR i$[rsp]
	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR [rax+88]
	call	?_SetBits@asmjit@@YAXPEA_K_K1@Z		; asmjit::_SetBits

; 880  :   _SetBits(node->baCont, i, need - 1);

	mov	rax, QWORD PTR need$[rsp]
	dec	rax
	mov	r8, rax
	mov	rdx, QWORD PTR i$[rsp]
	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR [rax+96]
	call	?_SetBits@asmjit@@YAXPEA_K_K1@Z		; asmjit::_SetBits
	npad	1

; 881  : 
; 882  :   // Update statistics.
; 883  :   {
; 884  :     size_t u = need * node->density;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR need$[rsp]
	imul	rcx, QWORD PTR [rax+72]
	mov	rax, rcx
	mov	QWORD PTR u$11[rsp], rax

; 885  :     node->used += u;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+56]
	add	rax, QWORD PTR u$11[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+56], rax

; 886  :     node->largestBlock = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+80], 0

; 887  :     self->_usedBytes += u;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, QWORD PTR u$11[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 888  :   }
; 889  : 
; 890  :   // And return pointer to allocated memory.
; 891  :   uint8_t* result = node->mem + i * node->density;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR i$[rsp]
	imul	rcx, QWORD PTR [rax+72]
	mov	rax, rcx
	mov	rcx, QWORD PTR node$[rsp]
	add	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR result$[rsp], rax

; 892  :   ASMJIT_ASSERT(result >= node->mem && result <= node->mem + node->size - vSize);
; 893  :   return result;

	mov	rax, QWORD PTR result$[rsp]
	mov	QWORD PTR $T13[rsp], rax
	lea	rcx, QWORD PTR locked$[rsp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	mov	rax, QWORD PTR $T13[rsp]
$LN1@vMemMgrAll:

; 894  : }

	add	rsp, 200				; 000000c8H
	ret	0
?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z ENDP ; asmjit::vMemMgrAllocFreeable
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
node$ = 32
i$ = 40
cont$1 = 48
maxCont$2 = 56
need$ = 64
j$3 = 72
next$4 = 80
up$5 = 88
blocks$6 = 96
max$7 = 104
bit$8 = 112
blockSize$9 = 120
ubits$10 = 128
u$11 = 136
locked$ = 144
minVSize$ = 152
tv133 = 160
$T12 = 168
result$ = 176
$T13 = 184
self$ = 208
vSize$ = 216
?dtor$0@?0??vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA PROC ; `asmjit::vMemMgrAllocFreeable'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR locked$[rbp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA ENDP ; `asmjit::vMemMgrAllocFreeable'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
node$ = 32
nodeSize$1 = 40
locked$ = 48
$T2 = 56
$T3 = 64
result$ = 72
$T4 = 80
self$ = 112
vSize$ = 120
?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z PROC ; asmjit::vMemMgrAllocPermanent

; 719  : static void* vMemMgrAllocPermanent(VMemMgr* self, size_t vSize) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 720  :   static const size_t permanentAlignment = 32;
; 721  :   static const size_t permanentNodeSize  = 32768;
; 722  : 
; 723  :   vSize = IntUtil::alignTo<size_t>(vSize, permanentAlignment);

	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR vSize$[rsp]
	call	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z	; asmjit::IntUtil::alignTo<unsigned __int64>
	mov	QWORD PTR vSize$[rsp], rax

; 724  : 
; 725  :   AutoLock locked(self->_lock);

	mov	rax, QWORD PTR self$[rsp]
	add	rax, 8
	mov	rdx, rax
	lea	rcx, QWORD PTR locked$[rsp]
	call	??0AutoLock@asmjit@@QEAA@AEAULock@1@@Z	; asmjit::AutoLock::AutoLock
	npad	1

; 726  :   PermanentNode* node = self->_permanent;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR node$[rsp], rax
$LN2@vMemMgrAll:

; 727  : 
; 728  :   // Try to find space in allocated chunks.
; 729  :   while (node && vSize > node->getAvailable())

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN3@vMemMgrAll
	mov	rcx, QWORD PTR node$[rsp]
	call	?getAvailable@PermanentNode@VMemMgr@asmjit@@QEBA_KXZ ; asmjit::VMemMgr::PermanentNode::getAvailable
	cmp	QWORD PTR vSize$[rsp], rax
	jbe	SHORT $LN3@vMemMgrAll

; 730  :     node = node->prev;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR node$[rsp], rax
	jmp	SHORT $LN2@vMemMgrAll
$LN3@vMemMgrAll:

; 731  : 
; 732  :   // Or allocate new node.
; 733  :   if (node == NULL) {

	cmp	QWORD PTR node$[rsp], 0
	jne	$LN4@vMemMgrAll

; 734  :     size_t nodeSize = permanentNodeSize;

	mov	QWORD PTR nodeSize$1[rsp], 32768	; 00008000H

; 735  : 
; 736  :     if (nodeSize < vSize)

	mov	rax, QWORD PTR vSize$[rsp]
	cmp	QWORD PTR nodeSize$1[rsp], rax
	jae	SHORT $LN5@vMemMgrAll

; 737  :       nodeSize = vSize;

	mov	rax, QWORD PTR vSize$[rsp]
	mov	QWORD PTR nodeSize$1[rsp], rax
$LN5@vMemMgrAll:

; 738  : 
; 739  :     node = static_cast<PermanentNode*>(ASMJIT_ALLOC(sizeof(PermanentNode)));

	mov	ecx, 32					; 00000020H
	call	malloc
	mov	QWORD PTR node$[rsp], rax

; 740  : 
; 741  :     // Out of memory.
; 742  :     if (node == NULL)

	cmp	QWORD PTR node$[rsp], 0
	jne	SHORT $LN6@vMemMgrAll

; 743  :       return NULL;

	mov	QWORD PTR $T2[rsp], 0
	lea	rcx, QWORD PTR locked$[rsp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	mov	rax, QWORD PTR $T2[rsp]
	jmp	$LN1@vMemMgrAll
$LN6@vMemMgrAll:

; 744  : 
; 745  :     node->mem = vMemMgrAllocVMem(self, nodeSize, &node->size);

	mov	rax, QWORD PTR node$[rsp]
	add	rax, 16
	mov	r8, rax
	mov	rdx, QWORD PTR nodeSize$1[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	call	?vMemMgrAllocVMem@asmjit@@YAPEAEPEAUVMemMgr@1@_KPEA_K@Z ; asmjit::vMemMgrAllocVMem
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 746  : 
; 747  :     // Out of memory.
; 748  :     if (node->mem == NULL) {

	mov	rax, QWORD PTR node$[rsp]
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN7@vMemMgrAll

; 749  :       ASMJIT_FREE(node);

	mov	rcx, QWORD PTR node$[rsp]
	call	free
	npad	1

; 750  :       return NULL;

	mov	QWORD PTR $T3[rsp], 0
	lea	rcx, QWORD PTR locked$[rsp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	mov	rax, QWORD PTR $T3[rsp]
	jmp	$LN1@vMemMgrAll
$LN7@vMemMgrAll:

; 751  :     }
; 752  : 
; 753  :     node->used = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+24], 0

; 754  :     node->prev = self->_permanent;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR [rcx+120]
	mov	QWORD PTR [rax], rcx

; 755  :     self->_permanent = node;

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+120], rcx
$LN4@vMemMgrAll:

; 756  :   }
; 757  : 
; 758  :   // Finally, copy function code to our space we reserved for.
; 759  :   uint8_t* result = node->mem + node->used;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR node$[rsp]
	add	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR result$[rsp], rax

; 760  : 
; 761  :   // Update Statistics.
; 762  :   node->used += vSize;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+24]
	add	rax, QWORD PTR vSize$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 763  :   self->_usedBytes += vSize;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, QWORD PTR vSize$[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 764  : 
; 765  :   // Code can be null to only reserve space for code.
; 766  :   return static_cast<void*>(result);

	mov	rax, QWORD PTR result$[rsp]
	mov	QWORD PTR $T4[rsp], rax
	lea	rcx, QWORD PTR locked$[rsp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	mov	rax, QWORD PTR $T4[rsp]
$LN1@vMemMgrAll:

; 767  : }

	add	rsp, 104				; 00000068H
	ret	0
?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z ENDP ; asmjit::vMemMgrAllocPermanent
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
node$ = 32
nodeSize$1 = 40
locked$ = 48
$T2 = 56
$T3 = 64
result$ = 72
$T4 = 80
self$ = 112
vSize$ = 120
?dtor$0@?0??vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA PROC ; `asmjit::vMemMgrAllocPermanent'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR locked$[rbp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z@4HA ENDP ; `asmjit::vMemMgrAllocPermanent'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
node$ = 0
nodeMem$1 = 8
nodeEnd$2 = 16
self$ = 48
mem$ = 56
?vMemMgrFindNodeByPtr@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAE@Z PROC ; asmjit::vMemMgrFindNodeByPtr

; 695  : static MemNode* vMemMgrFindNodeByPtr(VMemMgr* self, uint8_t* mem) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 696  :   MemNode* node = self->_root;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR node$[rsp], rax
$LN7@vMemMgrFin:
$LN2@vMemMgrFin:

; 697  :   while (node != NULL) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN3@vMemMgrFin

; 698  :     uint8_t* nodeMem = node->mem;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR nodeMem$1[rsp], rax

; 699  : 
; 700  :     // Go left.
; 701  :     if (mem < nodeMem) {

	mov	rax, QWORD PTR nodeMem$1[rsp]
	cmp	QWORD PTR mem$[rsp], rax
	jae	SHORT $LN4@vMemMgrFin

; 702  :       node = static_cast<MemNode*>(node->node[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR node$[rsp], rax

; 703  :       continue;

	jmp	SHORT $LN2@vMemMgrFin
$LN4@vMemMgrFin:

; 704  :     }
; 705  : 
; 706  :     // Go right.
; 707  :     uint8_t* nodeEnd = nodeMem + node->size;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR nodeMem$1[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR nodeEnd$2[rsp], rax

; 708  :     if (mem >= nodeEnd) {

	mov	rax, QWORD PTR nodeEnd$2[rsp]
	cmp	QWORD PTR mem$[rsp], rax
	jb	SHORT $LN5@vMemMgrFin

; 709  :       node = static_cast<MemNode*>(node->node[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR node$[rsp], rax

; 710  :       continue;

	jmp	SHORT $LN7@vMemMgrFin
$LN5@vMemMgrFin:

; 711  :     }
; 712  : 
; 713  :     // Match.
; 714  :     break;

	jmp	SHORT $LN3@vMemMgrFin

; 715  :   }

	jmp	SHORT $LN2@vMemMgrFin
$LN3@vMemMgrFin:

; 716  :   return node;

	mov	rax, QWORD PTR node$[rsp]

; 717  : }

	add	rsp, 40					; 00000028H
	ret	0
?vMemMgrFindNodeByPtr@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAE@Z ENDP ; asmjit::vMemMgrFindNodeByPtr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
q$ = 32
dir$ = 40
last$1 = 44
dir2$2 = 48
p$ = 56
g$ = 64
s$3 = 72
prev$ = 80
tv128 = 88
tv149 = 92
tv168 = 96
tv179 = 100
tv189 = 104
tv213 = 108
tv232 = 112
tv297 = 116
tv286 = 120
next$ = 128
f$ = 136
tv162 = 144
tv344 = 152
tv153 = 160
tv172 = 168
tv183 = 176
tv193 = 184
tv236 = 192
tv301 = 200
tv290 = 208
tv304 = 216
head$ = 224
self$ = 272
node$ = 280
?vMemMgrRemoveNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAU231@@Z PROC ; asmjit::vMemMgrRemoveNode

; 595  : static MemNode* vMemMgrRemoveNode(VMemMgr* self, MemNode* node) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 256				; 00000100H

; 596  :   // False tree root.
; 597  :   RbNode head = { { 0 } };

	lea	rax, QWORD PTR head$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	lea	rax, QWORD PTR head$[rsp+16]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 598  : 
; 599  :   // Helpers.
; 600  :   RbNode* q = &head;

	lea	rax, QWORD PTR head$[rsp]
	mov	QWORD PTR q$[rsp], rax

; 601  :   RbNode* p = NULL;

	mov	QWORD PTR p$[rsp], 0

; 602  :   RbNode* g = NULL;

	mov	QWORD PTR g$[rsp], 0

; 603  : 
; 604  :   // Found item.
; 605  :   RbNode* f = NULL;

	mov	QWORD PTR f$[rsp], 0

; 606  :   int dir = 1;

	mov	DWORD PTR dir$[rsp], 1

; 607  : 
; 608  :   // Set up.
; 609  :   q->node[1] = self->_root;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR q$[rsp]
	mov	rdx, QWORD PTR self$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	QWORD PTR [rcx+rax], rdx
$LN2@vMemMgrRem:

; 610  : 
; 611  :   // Search and push a red down.
; 612  :   while (q->node[dir] != NULL) {

	movsxd	rax, DWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rcx+rax*8], 0
	je	$LN3@vMemMgrRem

; 613  :     int last = dir;

	mov	eax, DWORD PTR dir$[rsp]
	mov	DWORD PTR last$1[rsp], eax

; 614  : 
; 615  :     // Update helpers.
; 616  :     g = p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR g$[rsp], rax

; 617  :     p = q;

	mov	rax, QWORD PTR q$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 618  :     q = q->node[dir];

	movsxd	rax, DWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR q$[rsp], rax

; 619  :     dir = q->mem < node->mem;

	mov	rax, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax+16], rcx
	jae	SHORT $LN23@vMemMgrRem
	mov	DWORD PTR tv128[rsp], 1
	jmp	SHORT $LN24@vMemMgrRem
$LN23@vMemMgrRem:
	mov	DWORD PTR tv128[rsp], 0
$LN24@vMemMgrRem:
	mov	eax, DWORD PTR tv128[rsp]
	mov	DWORD PTR dir$[rsp], eax

; 620  : 
; 621  :     // Save found node.
; 622  :     if (q == node)

	mov	rax, QWORD PTR node$[rsp]
	cmp	QWORD PTR q$[rsp], rax
	jne	SHORT $LN4@vMemMgrRem

; 623  :       f = q;

	mov	rax, QWORD PTR q$[rsp]
	mov	QWORD PTR f$[rsp], rax
$LN4@vMemMgrRem:

; 624  : 
; 625  :     // Push the red node down.
; 626  :     if (!rbIsRed(q) && !rbIsRed(q->node[dir])) {

	mov	rcx, QWORD PTR q$[rsp]
	call	?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ; asmjit::rbIsRed
	movzx	eax, al
	test	eax, eax
	jne	$LN5@vMemMgrRem
	movsxd	rax, DWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ; asmjit::rbIsRed
	movzx	eax, al
	test	eax, eax
	jne	$LN5@vMemMgrRem

; 627  :       if (rbIsRed(q->node[!dir])) {

	mov	rax, QWORD PTR q$[rsp]
	mov	QWORD PTR tv153[rsp], rax
	cmp	DWORD PTR dir$[rsp], 0
	jne	SHORT $LN25@vMemMgrRem
	mov	DWORD PTR tv149[rsp], 1
	jmp	SHORT $LN26@vMemMgrRem
$LN25@vMemMgrRem:
	mov	DWORD PTR tv149[rsp], 0
$LN26@vMemMgrRem:
	movsxd	rax, DWORD PTR tv149[rsp]
	mov	rcx, QWORD PTR tv153[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ; asmjit::rbIsRed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@vMemMgrRem

; 628  :         p = p->node[last] = rbRotateSingle(q, dir);

	mov	edx, DWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	call	?rbRotateSingle@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z ; asmjit::rbRotateSingle
	mov	QWORD PTR tv162[rsp], rax
	movsxd	rax, DWORD PTR last$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR tv162[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx
	mov	rax, QWORD PTR tv162[rsp]
	mov	QWORD PTR p$[rsp], rax

; 629  :       }

	jmp	$LN7@vMemMgrRem
$LN6@vMemMgrRem:

; 630  :       else if (!rbIsRed(q->node[!dir])) {

	mov	rax, QWORD PTR q$[rsp]
	mov	QWORD PTR tv172[rsp], rax
	cmp	DWORD PTR dir$[rsp], 0
	jne	SHORT $LN27@vMemMgrRem
	mov	DWORD PTR tv168[rsp], 1
	jmp	SHORT $LN28@vMemMgrRem
$LN27@vMemMgrRem:
	mov	DWORD PTR tv168[rsp], 0
$LN28@vMemMgrRem:
	movsxd	rax, DWORD PTR tv168[rsp]
	mov	rcx, QWORD PTR tv172[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ; asmjit::rbIsRed
	movzx	eax, al
	test	eax, eax
	jne	$LN8@vMemMgrRem

; 631  :         RbNode* s = p->node[!last];

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR tv183[rsp], rax
	cmp	DWORD PTR last$1[rsp], 0
	jne	SHORT $LN29@vMemMgrRem
	mov	DWORD PTR tv179[rsp], 1
	jmp	SHORT $LN30@vMemMgrRem
$LN29@vMemMgrRem:
	mov	DWORD PTR tv179[rsp], 0
$LN30@vMemMgrRem:
	movsxd	rax, DWORD PTR tv179[rsp]
	mov	rcx, QWORD PTR tv183[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR s$3[rsp], rax

; 632  : 
; 633  :         if (s != NULL) {

	cmp	QWORD PTR s$3[rsp], 0
	je	$LN9@vMemMgrRem

; 634  :           if (!rbIsRed(s->node[!last]) && !rbIsRed(s->node[last])) {

	mov	rax, QWORD PTR s$3[rsp]
	mov	QWORD PTR tv193[rsp], rax
	cmp	DWORD PTR last$1[rsp], 0
	jne	SHORT $LN31@vMemMgrRem
	mov	DWORD PTR tv189[rsp], 1
	jmp	SHORT $LN32@vMemMgrRem
$LN31@vMemMgrRem:
	mov	DWORD PTR tv189[rsp], 0
$LN32@vMemMgrRem:
	movsxd	rax, DWORD PTR tv189[rsp]
	mov	rcx, QWORD PTR tv193[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ; asmjit::rbIsRed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@vMemMgrRem
	movsxd	rax, DWORD PTR last$1[rsp]
	mov	rcx, QWORD PTR s$3[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ; asmjit::rbIsRed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@vMemMgrRem

; 635  :             // Color flip.
; 636  :             p->red = 0;

	mov	rax, QWORD PTR p$[rsp]
	mov	DWORD PTR [rax+24], 0

; 637  :             s->red = 1;

	mov	rax, QWORD PTR s$3[rsp]
	mov	DWORD PTR [rax+24], 1

; 638  :             q->red = 1;

	mov	rax, QWORD PTR q$[rsp]
	mov	DWORD PTR [rax+24], 1

; 639  :           }

	jmp	$LN11@vMemMgrRem
$LN10@vMemMgrRem:

; 640  :           else {
; 641  :             int dir2 = g->node[1] == p;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN33@vMemMgrRem
	mov	DWORD PTR tv213[rsp], 1
	jmp	SHORT $LN34@vMemMgrRem
$LN33@vMemMgrRem:
	mov	DWORD PTR tv213[rsp], 0
$LN34@vMemMgrRem:
	mov	eax, DWORD PTR tv213[rsp]
	mov	DWORD PTR dir2$2[rsp], eax

; 642  : 
; 643  :             if (rbIsRed(s->node[last]))

	movsxd	rax, DWORD PTR last$1[rsp]
	mov	rcx, QWORD PTR s$3[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ; asmjit::rbIsRed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@vMemMgrRem

; 644  :               g->node[dir2] = rbRotateDouble(p, last);

	mov	edx, DWORD PTR last$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	?rbRotateDouble@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z ; asmjit::rbRotateDouble
	movsxd	rcx, DWORD PTR dir2$2[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax
	jmp	SHORT $LN13@vMemMgrRem
$LN12@vMemMgrRem:

; 645  :             else if (rbIsRed(s->node[!last]))

	mov	rax, QWORD PTR s$3[rsp]
	mov	QWORD PTR tv236[rsp], rax
	cmp	DWORD PTR last$1[rsp], 0
	jne	SHORT $LN35@vMemMgrRem
	mov	DWORD PTR tv232[rsp], 1
	jmp	SHORT $LN36@vMemMgrRem
$LN35@vMemMgrRem:
	mov	DWORD PTR tv232[rsp], 0
$LN36@vMemMgrRem:
	movsxd	rax, DWORD PTR tv232[rsp]
	mov	rcx, QWORD PTR tv236[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ; asmjit::rbIsRed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@vMemMgrRem

; 646  :               g->node[dir2] = rbRotateSingle(p, last);

	mov	edx, DWORD PTR last$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	?rbRotateSingle@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z ; asmjit::rbRotateSingle
	movsxd	rcx, DWORD PTR dir2$2[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax
$LN14@vMemMgrRem:
$LN13@vMemMgrRem:

; 647  : 
; 648  :             // Ensure correct coloring.
; 649  :             q->red = g->node[dir2]->red = 1;

	movsxd	rax, DWORD PTR dir2$2[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	DWORD PTR [rax+24], 1
	mov	rax, QWORD PTR q$[rsp]
	mov	DWORD PTR [rax+24], 1

; 650  :             g->node[dir2]->node[0]->red = 0;

	movsxd	rax, DWORD PTR dir2$2[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rax, QWORD PTR [rax+rcx]
	mov	DWORD PTR [rax+24], 0

; 651  :             g->node[dir2]->node[1]->red = 0;

	movsxd	rax, DWORD PTR dir2$2[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rax, QWORD PTR [rax+rcx]
	mov	DWORD PTR [rax+24], 0
$LN11@vMemMgrRem:
$LN9@vMemMgrRem:
$LN8@vMemMgrRem:
$LN7@vMemMgrRem:
$LN5@vMemMgrRem:

; 652  :           }
; 653  :         }
; 654  :       }
; 655  :     }
; 656  :   }

	jmp	$LN2@vMemMgrRem
$LN3@vMemMgrRem:

; 657  : 
; 658  :   // Replace and remove.
; 659  :   ASMJIT_ASSERT(f != NULL);
; 660  :   ASMJIT_ASSERT(f != &head);
; 661  :   ASMJIT_ASSERT(q != &head);
; 662  : 
; 663  :   if (f != q) {

	mov	rax, QWORD PTR q$[rsp]
	cmp	QWORD PTR f$[rsp], rax
	je	SHORT $LN15@vMemMgrRem

; 664  :     ASMJIT_ASSERT(f != &head);
; 665  :     static_cast<MemNode*>(f)->fillData(static_cast<MemNode*>(q));

	mov	rdx, QWORD PTR q$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	call	?fillData@MemNode@VMemMgr@asmjit@@QEAAXPEAU123@@Z ; asmjit::VMemMgr::MemNode::fillData
	npad	1
$LN15@vMemMgrRem:

; 666  :   }
; 667  : 
; 668  :   p->node[p->node[1] == q] = q->node[q->node[0] == NULL];

	mov	rax, QWORD PTR q$[rsp]
	mov	QWORD PTR tv301[rsp], rax
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rcx+rax], 0
	jne	SHORT $LN39@vMemMgrRem
	mov	DWORD PTR tv297[rsp], 1
	jmp	SHORT $LN40@vMemMgrRem
$LN39@vMemMgrRem:
	mov	DWORD PTR tv297[rsp], 0
$LN40@vMemMgrRem:
	movsxd	rax, DWORD PTR tv297[rsp]
	mov	rcx, QWORD PTR tv301[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR tv304[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR tv290[rsp], rax
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN37@vMemMgrRem
	mov	DWORD PTR tv286[rsp], 1
	jmp	SHORT $LN38@vMemMgrRem
$LN37@vMemMgrRem:
	mov	DWORD PTR tv286[rsp], 0
$LN38@vMemMgrRem:
	movsxd	rax, DWORD PTR tv286[rsp]
	mov	rcx, QWORD PTR tv290[rsp]
	mov	rdx, QWORD PTR tv304[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 669  : 
; 670  :   // Update root and make it black.
; 671  :   self->_root = static_cast<MemNode*>(head.node[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR head$[rsp+rax]
	mov	QWORD PTR [rcx+88], rax

; 672  :   if (self->_root != NULL)

	mov	rax, QWORD PTR self$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN16@vMemMgrRem

; 673  :     self->_root->red = 0;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	DWORD PTR [rax+24], 0
$LN16@vMemMgrRem:

; 674  : 
; 675  :   // Unlink.
; 676  :   MemNode* next = static_cast<MemNode*>(q)->next;

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR next$[rsp], rax

; 677  :   MemNode* prev = static_cast<MemNode*>(q)->prev;

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR prev$[rsp], rax

; 678  : 
; 679  :   if (prev)

	cmp	QWORD PTR prev$[rsp], 0
	je	SHORT $LN17@vMemMgrRem

; 680  :     prev->next = next;

	mov	rax, QWORD PTR prev$[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	mov	QWORD PTR [rax+40], rcx
	jmp	SHORT $LN18@vMemMgrRem
$LN17@vMemMgrRem:

; 681  :   else
; 682  :     self->_first = next;

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	mov	QWORD PTR [rax+96], rcx
$LN18@vMemMgrRem:

; 683  : 
; 684  :   if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN19@vMemMgrRem

; 685  :     next->prev = prev;

	mov	rax, QWORD PTR next$[rsp]
	mov	rcx, QWORD PTR prev$[rsp]
	mov	QWORD PTR [rax+32], rcx
	jmp	SHORT $LN20@vMemMgrRem
$LN19@vMemMgrRem:

; 686  :   else
; 687  :     self->_last  = prev;

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR prev$[rsp]
	mov	QWORD PTR [rax+104], rcx
$LN20@vMemMgrRem:

; 688  : 
; 689  :   if (self->_optimal == q)

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	cmp	QWORD PTR [rax+112], rcx
	jne	SHORT $LN21@vMemMgrRem

; 690  :     self->_optimal = prev ? prev : next;

	cmp	QWORD PTR prev$[rsp], 0
	je	SHORT $LN41@vMemMgrRem
	mov	rax, QWORD PTR prev$[rsp]
	mov	QWORD PTR tv344[rsp], rax
	jmp	SHORT $LN42@vMemMgrRem
$LN41@vMemMgrRem:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR tv344[rsp], rax
$LN42@vMemMgrRem:
	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR tv344[rsp]
	mov	QWORD PTR [rax+112], rcx
$LN21@vMemMgrRem:

; 691  : 
; 692  :   return static_cast<MemNode*>(q);

	mov	rax, QWORD PTR q$[rsp]

; 693  : }

	add	rsp, 256				; 00000100H
	pop	rdi
	ret	0
?vMemMgrRemoveNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAU231@@Z ENDP ; asmjit::vMemMgrRemoveNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
q$1 = 32
last$2 = 40
dir$3 = 44
g$4 = 48
tv166 = 56
tv178 = 60
tv183 = 64
tv199 = 68
t$5 = 72
p$6 = 80
dir2$7 = 88
tv186 = 96
head$8 = 104
self$ = 160
node$ = 168
?vMemMgrInsertNode@asmjit@@YAXPEAUVMemMgr@1@PEAUMemNode@21@@Z PROC ; asmjit::vMemMgrInsertNode

; 512  : static void vMemMgrInsertNode(VMemMgr* self, MemNode* node) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 144				; 00000090H

; 513  :   if (self->_root == NULL) {

	mov	rax, QWORD PTR self$[rsp]
	cmp	QWORD PTR [rax+88], 0
	jne	SHORT $LN5@vMemMgrIns

; 514  :     // Empty tree case.
; 515  :     self->_root = node;

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+88], rcx

; 516  :   }

	jmp	$LN6@vMemMgrIns
$LN5@vMemMgrIns:

; 517  :   else {
; 518  :     // False tree root.
; 519  :     RbNode head = { { 0 } };

	lea	rax, QWORD PTR head$8[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	lea	rax, QWORD PTR head$8[rsp+16]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 520  : 
; 521  :     // Grandparent & parent.
; 522  :     RbNode* g = NULL;

	mov	QWORD PTR g$4[rsp], 0

; 523  :     RbNode* t = &head;

	lea	rax, QWORD PTR head$8[rsp]
	mov	QWORD PTR t$5[rsp], rax

; 524  : 
; 525  :     // Iterator & parent.
; 526  :     RbNode* p = NULL;

	mov	QWORD PTR p$6[rsp], 0

; 527  :     RbNode* q = t->node[1] = self->_root;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR t$5[rsp]
	mov	rdx, QWORD PTR self$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	QWORD PTR [rcx+rax], rdx
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR t$5[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR q$1[rsp], rax

; 528  : 
; 529  :     int dir = 0, last = 0;

	mov	DWORD PTR dir$3[rsp], 0
	mov	DWORD PTR last$2[rsp], 0
$LN2@vMemMgrIns:

; 530  : 
; 531  :     // Search down the tree.
; 532  :     for (;;) {
; 533  :       if (q == NULL) {

	cmp	QWORD PTR q$1[rsp], 0
	jne	SHORT $LN7@vMemMgrIns

; 534  :         // Insert new node at the bottom.
; 535  :         q = node;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR q$1[rsp], rax

; 536  :         p->node[dir] = node;

	movsxd	rax, DWORD PTR dir$3[rsp]
	mov	rcx, QWORD PTR p$6[rsp]
	mov	rdx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 537  :       }

	jmp	SHORT $LN8@vMemMgrIns
$LN7@vMemMgrIns:

; 538  :       else if (rbIsRed(q->node[0]) && rbIsRed(q->node[1])) {

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR q$1[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ; asmjit::rbIsRed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@vMemMgrIns
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR q$1[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ; asmjit::rbIsRed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@vMemMgrIns

; 539  :         // Color flip.
; 540  :         q->red = 1;

	mov	rax, QWORD PTR q$1[rsp]
	mov	DWORD PTR [rax+24], 1

; 541  :         q->node[0]->red = 0;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR q$1[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	DWORD PTR [rax+24], 0

; 542  :         q->node[1]->red = 0;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR q$1[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	DWORD PTR [rax+24], 0
$LN9@vMemMgrIns:
$LN8@vMemMgrIns:

; 543  :       }
; 544  : 
; 545  :       // Fix red violation.
; 546  :       if (rbIsRed(q) && rbIsRed(p)) {

	mov	rcx, QWORD PTR q$1[rsp]
	call	?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ; asmjit::rbIsRed
	movzx	eax, al
	test	eax, eax
	je	$LN10@vMemMgrIns
	mov	rcx, QWORD PTR p$6[rsp]
	call	?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ; asmjit::rbIsRed
	movzx	eax, al
	test	eax, eax
	je	$LN10@vMemMgrIns

; 547  :         int dir2 = t->node[1] == g;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR t$5[rsp]
	mov	rdx, QWORD PTR g$4[rsp]
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN16@vMemMgrIns
	mov	DWORD PTR tv166[rsp], 1
	jmp	SHORT $LN17@vMemMgrIns
$LN16@vMemMgrIns:
	mov	DWORD PTR tv166[rsp], 0
$LN17@vMemMgrIns:
	mov	eax, DWORD PTR tv166[rsp]
	mov	DWORD PTR dir2$7[rsp], eax

; 548  :         t->node[dir2] = q == p->node[last] ? rbRotateSingle(g, !last) : rbRotateDouble(g, !last);

	movsxd	rax, DWORD PTR last$2[rsp]
	mov	rcx, QWORD PTR p$6[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	cmp	QWORD PTR q$1[rsp], rax
	jne	SHORT $LN22@vMemMgrIns
	cmp	DWORD PTR last$2[rsp], 0
	jne	SHORT $LN18@vMemMgrIns
	mov	DWORD PTR tv178[rsp], 1
	jmp	SHORT $LN19@vMemMgrIns
$LN18@vMemMgrIns:
	mov	DWORD PTR tv178[rsp], 0
$LN19@vMemMgrIns:
	mov	edx, DWORD PTR tv178[rsp]
	mov	rcx, QWORD PTR g$4[rsp]
	call	?rbRotateSingle@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z ; asmjit::rbRotateSingle
	mov	QWORD PTR tv186[rsp], rax
	jmp	SHORT $LN23@vMemMgrIns
$LN22@vMemMgrIns:
	cmp	DWORD PTR last$2[rsp], 0
	jne	SHORT $LN20@vMemMgrIns
	mov	DWORD PTR tv183[rsp], 1
	jmp	SHORT $LN21@vMemMgrIns
$LN20@vMemMgrIns:
	mov	DWORD PTR tv183[rsp], 0
$LN21@vMemMgrIns:
	mov	edx, DWORD PTR tv183[rsp]
	mov	rcx, QWORD PTR g$4[rsp]
	call	?rbRotateDouble@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z ; asmjit::rbRotateDouble
	mov	QWORD PTR tv186[rsp], rax
$LN23@vMemMgrIns:
	movsxd	rax, DWORD PTR dir2$7[rsp]
	mov	rcx, QWORD PTR t$5[rsp]
	mov	rdx, QWORD PTR tv186[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx
$LN10@vMemMgrIns:

; 549  :       }
; 550  : 
; 551  :       // Stop if found.
; 552  :       if (q == node)

	mov	rax, QWORD PTR node$[rsp]
	cmp	QWORD PTR q$1[rsp], rax
	jne	SHORT $LN11@vMemMgrIns

; 553  :         break;

	jmp	SHORT $LN3@vMemMgrIns
$LN11@vMemMgrIns:

; 554  : 
; 555  :       last = dir;

	mov	eax, DWORD PTR dir$3[rsp]
	mov	DWORD PTR last$2[rsp], eax

; 556  :       dir = q->mem < node->mem;

	mov	rax, QWORD PTR q$1[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax+16], rcx
	jae	SHORT $LN24@vMemMgrIns
	mov	DWORD PTR tv199[rsp], 1
	jmp	SHORT $LN25@vMemMgrIns
$LN24@vMemMgrIns:
	mov	DWORD PTR tv199[rsp], 0
$LN25@vMemMgrIns:
	mov	eax, DWORD PTR tv199[rsp]
	mov	DWORD PTR dir$3[rsp], eax

; 557  : 
; 558  :       // Update helpers.
; 559  :       if (g != NULL)

	cmp	QWORD PTR g$4[rsp], 0
	je	SHORT $LN12@vMemMgrIns

; 560  :         t = g;

	mov	rax, QWORD PTR g$4[rsp]
	mov	QWORD PTR t$5[rsp], rax
$LN12@vMemMgrIns:

; 561  : 
; 562  :       g = p;

	mov	rax, QWORD PTR p$6[rsp]
	mov	QWORD PTR g$4[rsp], rax

; 563  :       p = q;

	mov	rax, QWORD PTR q$1[rsp]
	mov	QWORD PTR p$6[rsp], rax

; 564  :       q = q->node[dir];

	movsxd	rax, DWORD PTR dir$3[rsp]
	mov	rcx, QWORD PTR q$1[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR q$1[rsp], rax

; 565  :     }

	jmp	$LN2@vMemMgrIns
$LN3@vMemMgrIns:

; 566  : 
; 567  :     // Update root.
; 568  :     self->_root = static_cast<MemNode*>(head.node[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR head$8[rsp+rax]
	mov	QWORD PTR [rcx+88], rax
$LN6@vMemMgrIns:

; 569  :   }
; 570  : 
; 571  :   // Make root black.
; 572  :   self->_root->red = 0;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	DWORD PTR [rax+24], 0

; 573  : 
; 574  :   // Link with others.
; 575  :   node->prev = self->_last;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	QWORD PTR [rax+32], rcx

; 576  : 
; 577  :   if (self->_first == NULL) {

	mov	rax, QWORD PTR self$[rsp]
	cmp	QWORD PTR [rax+96], 0
	jne	SHORT $LN13@vMemMgrIns

; 578  :     self->_first = node;

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+96], rcx

; 579  :     self->_last = node;

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+104], rcx

; 580  :     self->_optimal = node;

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+112], rcx

; 581  :   }

	jmp	SHORT $LN14@vMemMgrIns
$LN13@vMemMgrIns:

; 582  :   else {
; 583  :     node->prev = self->_last;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	QWORD PTR [rax+32], rcx

; 584  :     self->_last->next = node;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+40], rcx

; 585  :     self->_last = node;

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+104], rcx
$LN14@vMemMgrIns:

; 586  :   }
; 587  : }

	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
?vMemMgrInsertNode@asmjit@@YAXPEAUVMemMgr@1@PEAUMemNode@21@@Z ENDP ; asmjit::vMemMgrInsertNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
node$ = 32
data$ = 40
vSize$ = 48
vmem$ = 56
bsize$ = 64
blocks$ = 72
self$ = 96
size$ = 104
density$ = 112
?vMemMgrCreateNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@_K1@Z PROC ; asmjit::vMemMgrCreateNode

; 467  : static MemNode* vMemMgrCreateNode(VMemMgr* self, size_t size, size_t density) {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 468  :   size_t vSize;
; 469  :   uint8_t* vmem = vMemMgrAllocVMem(self, size, &vSize);

	lea	r8, QWORD PTR vSize$[rsp]
	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	call	?vMemMgrAllocVMem@asmjit@@YAPEAEPEAUVMemMgr@1@_KPEA_K@Z ; asmjit::vMemMgrAllocVMem
	mov	QWORD PTR vmem$[rsp], rax

; 470  : 
; 471  :   // Out of memory.
; 472  :   if (vmem == NULL)

	cmp	QWORD PTR vmem$[rsp], 0
	jne	SHORT $LN2@vMemMgrCre

; 473  :     return NULL;

	xor	eax, eax
	jmp	$LN1@vMemMgrCre
$LN2@vMemMgrCre:

; 474  : 
; 475  :   size_t blocks = (vSize / density);

	xor	edx, edx
	mov	rax, QWORD PTR vSize$[rsp]
	div	QWORD PTR density$[rsp]
	mov	QWORD PTR blocks$[rsp], rax

; 476  :   size_t bsize = (((blocks + 7) >> 3) + sizeof(size_t) - 1) & ~(size_t)(sizeof(size_t) - 1);

	mov	rax, QWORD PTR blocks$[rsp]
	add	rax, 7
	shr	rax, 3
	add	rax, 7
	and	rax, -8
	mov	QWORD PTR bsize$[rsp], rax

; 477  : 
; 478  :   MemNode* node = static_cast<MemNode*>(ASMJIT_ALLOC(sizeof(MemNode)));

	mov	ecx, 104				; 00000068H
	call	malloc
	mov	QWORD PTR node$[rsp], rax

; 479  :   uint8_t* data = static_cast<uint8_t*>(ASMJIT_ALLOC(bsize * 2));

	mov	rax, QWORD PTR bsize$[rsp]
	shl	rax, 1
	mov	rcx, rax
	call	malloc
	mov	QWORD PTR data$[rsp], rax

; 480  : 
; 481  :   // Out of memory.
; 482  :   if (node == NULL || data == NULL) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN4@vMemMgrCre
	cmp	QWORD PTR data$[rsp], 0
	jne	SHORT $LN3@vMemMgrCre
$LN4@vMemMgrCre:

; 483  :     vMemMgrReleaseVMem(self, vmem, vSize);

	mov	r8, QWORD PTR vSize$[rsp]
	mov	rdx, QWORD PTR vmem$[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	call	?vMemMgrReleaseVMem@asmjit@@YAIPEAUVMemMgr@1@PEAX_K@Z ; asmjit::vMemMgrReleaseVMem
	npad	1

; 484  :     if (node) ASMJIT_FREE(node);

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN5@vMemMgrCre
	mov	rcx, QWORD PTR node$[rsp]
	call	free
	npad	1
$LN5@vMemMgrCre:

; 485  :     if (data) ASMJIT_FREE(data);

	cmp	QWORD PTR data$[rsp], 0
	je	SHORT $LN6@vMemMgrCre
	mov	rcx, QWORD PTR data$[rsp]
	call	free
	npad	1
$LN6@vMemMgrCre:

; 486  :     return NULL;

	xor	eax, eax
	jmp	$LN1@vMemMgrCre
$LN3@vMemMgrCre:

; 487  :   }
; 488  : 
; 489  :   // Initialize RbNode data.
; 490  :   node->node[0] = NULL;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+rax], 0

; 491  :   node->node[1] = NULL;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+rax], 0

; 492  :   node->mem = vmem;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR vmem$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 493  :   node->red = 1;

	mov	rax, QWORD PTR node$[rsp]
	mov	DWORD PTR [rax+24], 1

; 494  : 
; 495  :   // Initialize MemNode data.
; 496  :   node->prev = NULL;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+32], 0

; 497  :   node->next = NULL;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+40], 0

; 498  : 
; 499  :   node->size = vSize;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR vSize$[rsp]
	mov	QWORD PTR [rax+48], rcx

; 500  :   node->used = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+56], 0

; 501  :   node->blocks = blocks;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR blocks$[rsp]
	mov	QWORD PTR [rax+64], rcx

; 502  :   node->density = density;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR density$[rsp]
	mov	QWORD PTR [rax+72], rcx

; 503  :   node->largestBlock = vSize;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR vSize$[rsp]
	mov	QWORD PTR [rax+80], rcx

; 504  : 
; 505  :   ::memset(data, 0, bsize * 2);

	mov	rax, QWORD PTR bsize$[rsp]
	shl	rax, 1
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR data$[rsp]
	call	memset

; 506  :   node->baUsed = reinterpret_cast<size_t*>(data);

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax+88], rcx

; 507  :   node->baCont = reinterpret_cast<size_t*>(data + bsize);

	mov	rax, QWORD PTR bsize$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+96], rax

; 508  : 
; 509  :   return node;

	mov	rax, QWORD PTR node$[rsp]
$LN1@vMemMgrCre:

; 510  : }

	add	rsp, 88					; 00000058H
	ret	0
?vMemMgrCreateNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@_K1@Z ENDP ; asmjit::vMemMgrCreateNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
;	COMDAT ?vMemMgrReleaseVMem@asmjit@@YAIPEAUVMemMgr@1@PEAX_K@Z
_TEXT	SEGMENT
self$ = 48
p$ = 56
vSize$ = 64
?vMemMgrReleaseVMem@asmjit@@YAIPEAUVMemMgr@1@PEAX_K@Z PROC ; asmjit::vMemMgrReleaseVMem, COMDAT

; 447  : ASMJIT_INLINE Error vMemMgrReleaseVMem(VMemMgr* self, void* p, size_t vSize) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 448  : #if !defined(ASMJIT_OS_WINDOWS)
; 449  :   return VMemUtil::release(p, vSize);
; 450  : #else
; 451  :   return VMemUtil::releaseProcessMemory(self->_hProcess, p, vSize);

	mov	r8, QWORD PTR vSize$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?releaseProcessMemory@VMemUtil@asmjit@@SAIPEAX0_K@Z ; asmjit::VMemUtil::releaseProcessMemory

; 452  : #endif
; 453  : }

	add	rsp, 40					; 00000028H
	ret	0
?vMemMgrReleaseVMem@asmjit@@YAIPEAUVMemMgr@1@PEAX_K@Z ENDP ; asmjit::vMemMgrReleaseVMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
;	COMDAT ?vMemMgrAllocVMem@asmjit@@YAPEAEPEAUVMemMgr@1@_KPEA_K@Z
_TEXT	SEGMENT
flags$ = 32
self$ = 64
size$ = 72
vSize$ = 80
?vMemMgrAllocVMem@asmjit@@YAPEAEPEAUVMemMgr@1@_KPEA_K@Z PROC ; asmjit::vMemMgrAllocVMem, COMDAT

; 435  : ASMJIT_INLINE uint8_t* vMemMgrAllocVMem(VMemMgr* self, size_t size, size_t* vSize) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 436  :   uint32_t flags = kVMemFlagWritable /*| kVMemFlagExecutable*/;

	mov	DWORD PTR flags$[rsp], 1

; 437  : #if !defined(ASMJIT_OS_WINDOWS)
; 438  :   return static_cast<uint8_t*>(VMemUtil::alloc(size, vSize, flags));
; 439  : #else
; 440  :   return static_cast<uint8_t*>(VMemUtil::allocProcessMemory(self->_hProcess, size, vSize, flags));

	mov	r9d, DWORD PTR flags$[rsp]
	mov	r8, QWORD PTR vSize$[rsp]
	mov	rdx, QWORD PTR size$[rsp]
	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?allocProcessMemory@VMemUtil@asmjit@@SAPEAXPEAX_KPEA_KI@Z ; asmjit::VMemUtil::allocProcessMemory

; 441  : #endif
; 442  : }

	add	rsp, 56					; 00000038H
	ret	0
?vMemMgrAllocVMem@asmjit@@YAPEAEPEAUVMemMgr@1@_KPEA_K@Z ENDP ; asmjit::vMemMgrAllocVMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
;	COMDAT ?getAvailable@PermanentNode@VMemMgr@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getAvailable@PermanentNode@VMemMgr@asmjit@@QEBA_KXZ PROC ; asmjit::VMemMgr::PermanentNode::getAvailable, COMDAT

; 414  :   ASMJIT_INLINE size_t getAvailable() const {

	mov	QWORD PTR [rsp+8], rcx

; 415  :     return size - used;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx

; 416  :   }

	ret	0
?getAvailable@PermanentNode@VMemMgr@asmjit@@QEBA_KXZ ENDP ; asmjit::VMemMgr::PermanentNode::getAvailable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
;	COMDAT ?fillData@MemNode@VMemMgr@asmjit@@QEAAXPEAU123@@Z
_TEXT	SEGMENT
this$ = 8
other$ = 16
?fillData@MemNode@VMemMgr@asmjit@@QEAAXPEAU123@@Z PROC	; asmjit::VMemMgr::MemNode::fillData, COMDAT

; 371  :   ASMJIT_INLINE void fillData(MemNode* other) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 372  :     mem = other->mem;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR other$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 373  : 
; 374  :     size = other->size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR other$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rax+48], rcx

; 375  :     used = other->used;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR other$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rax+56], rcx

; 376  :     blocks = other->blocks;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR other$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rax+64], rcx

; 377  :     density = other->density;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR other$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	mov	QWORD PTR [rax+72], rcx

; 378  :     largestBlock = other->largestBlock;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR other$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rax+80], rcx

; 379  : 
; 380  :     baUsed = other->baUsed;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR other$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	QWORD PTR [rax+88], rcx

; 381  :     baCont = other->baCont;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR other$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx

; 382  :   }

	ret	0
?fillData@MemNode@VMemMgr@asmjit@@QEAAXPEAU123@@Z ENDP	; asmjit::VMemMgr::MemNode::fillData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
;	COMDAT ?getAvailable@MemNode@VMemMgr@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getAvailable@MemNode@VMemMgr@asmjit@@QEBA_KXZ PROC	; asmjit::VMemMgr::MemNode::getAvailable, COMDAT

; 367  :   ASMJIT_INLINE size_t getAvailable() const {

	mov	QWORD PTR [rsp+8], rcx

; 368  :     return size - used;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rax, QWORD PTR [rax+48]
	sub	rax, rcx

; 369  :   }

	ret	0
?getAvailable@MemNode@VMemMgr@asmjit@@QEBA_KXZ ENDP	; asmjit::VMemMgr::MemNode::getAvailable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
tv78 = 32
tv74 = 36
tv66 = 40
tv82 = 48
tv70 = 56
tv86 = 64
root$ = 96
dir$ = 104
?rbRotateDouble@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z PROC ; asmjit::rbRotateDouble

; 352  : static ASMJIT_INLINE RbNode* rbRotateDouble(RbNode* root, int dir) {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 353  :   root->node[!dir] = rbRotateSingle(root->node[!dir], !dir);

	cmp	DWORD PTR dir$[rsp], 0
	jne	SHORT $LN5@rbRotateDo
	mov	DWORD PTR tv74[rsp], 1
	jmp	SHORT $LN6@rbRotateDo
$LN5@rbRotateDo:
	mov	DWORD PTR tv74[rsp], 0
$LN6@rbRotateDo:
	mov	rax, QWORD PTR root$[rsp]
	mov	QWORD PTR tv82[rsp], rax
	cmp	DWORD PTR dir$[rsp], 0
	jne	SHORT $LN7@rbRotateDo
	mov	DWORD PTR tv78[rsp], 1
	jmp	SHORT $LN8@rbRotateDo
$LN7@rbRotateDo:
	mov	DWORD PTR tv78[rsp], 0
$LN8@rbRotateDo:
	movsxd	rax, DWORD PTR tv78[rsp]
	mov	edx, DWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	?rbRotateSingle@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z ; asmjit::rbRotateSingle
	mov	QWORD PTR tv86[rsp], rax
	mov	rax, QWORD PTR root$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	cmp	DWORD PTR dir$[rsp], 0
	jne	SHORT $LN3@rbRotateDo
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@rbRotateDo
$LN3@rbRotateDo:
	mov	DWORD PTR tv66[rsp], 0
$LN4@rbRotateDo:
	movsxd	rax, DWORD PTR tv66[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	mov	rdx, QWORD PTR tv86[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 354  :   return rbRotateSingle(root, dir);

	mov	edx, DWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR root$[rsp]
	call	?rbRotateSingle@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z ; asmjit::rbRotateSingle

; 355  : }

	add	rsp, 88					; 00000058H
	ret	0
?rbRotateDouble@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z ENDP ; asmjit::rbRotateDouble
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
tv66 = 0
tv74 = 4
save$ = 8
tv70 = 16
tv78 = 24
tv85 = 32
root$ = 64
dir$ = 72
?rbRotateSingle@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z PROC ; asmjit::rbRotateSingle

; 337  : static ASMJIT_INLINE RbNode* rbRotateSingle(RbNode* root, int dir) {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 338  :   RbNode* save = root->node[!dir];

	mov	rax, QWORD PTR root$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	cmp	DWORD PTR dir$[rsp], 0
	jne	SHORT $LN3@rbRotateSi
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@rbRotateSi
$LN3@rbRotateSi:
	mov	DWORD PTR tv66[rsp], 0
$LN4@rbRotateSi:
	movsxd	rax, DWORD PTR tv66[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR save$[rsp], rax

; 339  : 
; 340  :   root->node[!dir] = save->node[dir];

	movsxd	rax, DWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR save$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR tv85[rsp], rax
	mov	rax, QWORD PTR root$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	cmp	DWORD PTR dir$[rsp], 0
	jne	SHORT $LN5@rbRotateSi
	mov	DWORD PTR tv74[rsp], 1
	jmp	SHORT $LN6@rbRotateSi
$LN5@rbRotateSi:
	mov	DWORD PTR tv74[rsp], 0
$LN6@rbRotateSi:
	movsxd	rax, DWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv85[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 341  :   save->node[dir] = root;

	movsxd	rax, DWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR save$[rsp]
	mov	rdx, QWORD PTR root$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 342  : 
; 343  :   root->red = 1;

	mov	rax, QWORD PTR root$[rsp]
	mov	DWORD PTR [rax+24], 1

; 344  :   save->red = 0;

	mov	rax, QWORD PTR save$[rsp]
	mov	DWORD PTR [rax+24], 0

; 345  : 
; 346  :   return save;

	mov	rax, QWORD PTR save$[rsp]

; 347  : }

	add	rsp, 56					; 00000038H
	ret	0
?rbRotateSingle@asmjit@@YAPEAURbNode@VMemMgr@1@PEAU231@H@Z ENDP ; asmjit::rbRotateSingle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
tv67 = 0
node$ = 32
?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z PROC	; asmjit::rbIsRed

; 300  : static ASMJIT_INLINE bool rbIsRed(RbNode* node) {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 301  :   return node != NULL && node->red;

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN3@rbIsRed
	mov	rax, QWORD PTR node$[rsp]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN3@rbIsRed
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@rbIsRed
$LN3@rbIsRed:
	mov	DWORD PTR tv67[rsp], 0
$LN4@rbIsRed:
	movzx	eax, BYTE PTR tv67[rsp]

; 302  : }

	add	rsp, 24
	ret	0
?rbIsRed@asmjit@@YA_NPEAURbNode@VMemMgr@1@@Z ENDP	; asmjit::rbIsRed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
c$ = 0
j$ = 8
i$ = 16
tv138 = 24
tv154 = 32
buf$ = 64
index$ = 72
len$ = 80
?_SetBits@asmjit@@YAXPEA_K_K1@Z PROC			; asmjit::_SetBits

; 243  : static void _SetBits(size_t* buf, size_t index, size_t len) {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 244  :   if (len == 0)

	cmp	QWORD PTR len$[rsp], 0
	jne	SHORT $LN4@SetBits

; 245  :     return;

	jmp	$LN1@SetBits
$LN4@SetBits:

; 246  : 
; 247  :   size_t i = index / kBitsPerEntity; // size_t[]

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 64					; 00000040H
	div	rcx
	mov	QWORD PTR i$[rsp], rax

; 248  :   size_t j = index % kBitsPerEntity; // size_t[][] bit index

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 64					; 00000040H
	div	rcx
	mov	rax, rdx
	mov	QWORD PTR j$[rsp], rax

; 249  : 
; 250  :   // How many bytes process in the first group.
; 251  :   size_t c = kBitsPerEntity - j;

	mov	eax, 64					; 00000040H
	sub	rax, QWORD PTR j$[rsp]
	mov	QWORD PTR c$[rsp], rax

; 252  :   if (c > len)

	mov	rax, QWORD PTR len$[rsp]
	cmp	QWORD PTR c$[rsp], rax
	jbe	SHORT $LN5@SetBits

; 253  :     c = len;

	mov	rax, QWORD PTR len$[rsp]
	mov	QWORD PTR c$[rsp], rax
$LN5@SetBits:

; 254  : 
; 255  :   // Offset.
; 256  :   buf += i;

	mov	rax, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR i$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR buf$[rsp], rax

; 257  : 
; 258  :   *buf++ |= ((~(size_t)0) >> (kBitsPerEntity - c)) << j;

	mov	eax, 64					; 00000040H
	sub	rax, QWORD PTR c$[rsp]
	mov	rcx, -1
	mov	QWORD PTR tv138[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv138[rsp]
	shr	rax, cl
	mov	rcx, QWORD PTR j$[rsp]
	shl	rax, cl
	mov	rcx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR [rcx]
	or	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR buf$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR buf$[rsp]
	add	rax, 8
	mov	QWORD PTR buf$[rsp], rax

; 259  :   len -= c;

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR len$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rsp], rax
$LN2@SetBits:

; 260  : 
; 261  :   while (len >= kBitsPerEntity) {

	cmp	QWORD PTR len$[rsp], 64			; 00000040H
	jb	SHORT $LN3@SetBits

; 262  :     *buf++ = ~(size_t)0;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR [rax], -1
	mov	rax, QWORD PTR buf$[rsp]
	add	rax, 8
	mov	QWORD PTR buf$[rsp], rax

; 263  :     len -= kBitsPerEntity;

	mov	rax, QWORD PTR len$[rsp]
	sub	rax, 64					; 00000040H
	mov	QWORD PTR len$[rsp], rax

; 264  :   }

	jmp	SHORT $LN2@SetBits
$LN3@SetBits:

; 265  : 
; 266  :   if (len)

	cmp	QWORD PTR len$[rsp], 0
	je	SHORT $LN6@SetBits

; 267  :     *buf |= ((~(size_t)0) >> (kBitsPerEntity - len));

	mov	eax, 64					; 00000040H
	sub	rax, QWORD PTR len$[rsp]
	mov	rcx, -1
	mov	QWORD PTR tv154[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv154[rsp]
	shr	rax, cl
	mov	rcx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR [rcx]
	or	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR buf$[rsp]
	mov	QWORD PTR [rcx], rax
$LN6@SetBits:
$LN1@SetBits:

; 268  : }

	add	rsp, 56					; 00000038H
	ret	0
?_SetBits@asmjit@@YAXPEA_K_K1@Z ENDP			; asmjit::_SetBits
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z
_TEXT	SEGMENT
base$ = 8
alignment$ = 16
??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z PROC		; asmjit::IntUtil::alignTo<unsigned __int64>, COMDAT

; 401  :   static ASMJIT_INLINE T alignTo(T base, T alignment) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 402  :     return (base + (alignment - 1)) & ~(alignment - 1);

	mov	rax, QWORD PTR base$[rsp]
	mov	rcx, QWORD PTR alignment$[rsp]
	lea	rax, QWORD PTR [rax+rcx-1]
	mov	rcx, QWORD PTR alignment$[rsp]
	dec	rcx
	not	rcx
	and	rax, rcx

; 403  :   }

	ret	0
??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z ENDP		; asmjit::IntUtil::alignTo<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$alignToPowerOf2@I@IntUtil@asmjit@@SAII@Z
_TEXT	SEGMENT
base$ = 8
??$alignToPowerOf2@I@IntUtil@asmjit@@SAII@Z PROC	; asmjit::IntUtil::alignToPowerOf2<unsigned int>, COMDAT

; 406  :   static ASMJIT_INLINE T alignToPowerOf2(T base) {

	mov	DWORD PTR [rsp+8], ecx

; 407  :     // Implementation is from "Hacker's Delight" by Henry S. Warren, Jr.
; 408  :     base -= 1;

	mov	eax, DWORD PTR base$[rsp]
	dec	eax
	mov	DWORD PTR base$[rsp], eax

; 409  : 
; 410  : #if defined(_MSC_VER)
; 411  : # pragma warning(push)
; 412  : # pragma warning(disable: 4293)
; 413  : #endif // _MSC_VER
; 414  : 
; 415  :     base = base | (base >> 1);

	mov	eax, DWORD PTR base$[rsp]
	shr	eax, 1
	mov	ecx, DWORD PTR base$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR base$[rsp], eax

; 416  :     base = base | (base >> 2);

	mov	eax, DWORD PTR base$[rsp]
	shr	eax, 2
	mov	ecx, DWORD PTR base$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR base$[rsp], eax

; 417  :     base = base | (base >> 4);

	mov	eax, DWORD PTR base$[rsp]
	shr	eax, 4
	mov	ecx, DWORD PTR base$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR base$[rsp], eax

; 418  : 
; 419  :     // 8/16/32 constants are multiplied by the condition to prevent a compiler
; 420  :     // complaining about the 'shift count >= type width' (GCC).
; 421  :     if (sizeof(T) >= 2) base = base | (base >> ( 8 * (sizeof(T) >= 2))); // Base >>  8.

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@alignToPow
	mov	eax, DWORD PTR base$[rsp]
	shr	eax, 8
	mov	ecx, DWORD PTR base$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR base$[rsp], eax
$LN2@alignToPow:

; 422  :     if (sizeof(T) >= 4) base = base | (base >> (16 * (sizeof(T) >= 4))); // Base >> 16.

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN3@alignToPow
	mov	eax, DWORD PTR base$[rsp]
	shr	eax, 16
	mov	ecx, DWORD PTR base$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR base$[rsp], eax
$LN3@alignToPow:

; 423  :     if (sizeof(T) >= 8) base = base | (base >> (32 * (sizeof(T) >= 8))); // Base >> 32.

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@alignToPow
	mov	eax, DWORD PTR base$[rsp]
	mov	ecx, DWORD PTR base$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR base$[rsp], eax
$LN4@alignToPow:

; 424  : 
; 425  : #if defined(_MSC_VER)
; 426  : # pragma warning(pop)
; 427  : #endif // _MSC_VER
; 428  : 
; 429  :     return base + 1;

	mov	eax, DWORD PTR base$[rsp]
	inc	eax

; 430  :   }

	ret	0
??$alignToPowerOf2@I@IntUtil@asmjit@@SAII@Z ENDP	; asmjit::IntUtil::alignToPowerOf2<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
vMem$ = 32
info$1 = 40
?vMemGet@asmjit@@YAAEBUVMemLocal@1@XZ PROC		; asmjit::vMemGet

; 90   : static const VMemLocal& vMemGet() {

	sub	rsp, 104				; 00000068H

; 91   :   VMemLocal& vMem = vMemLocal;

	lea	rax, OFFSET FLAT:?vMemLocal@asmjit@@3UVMemLocal@1@A
	mov	QWORD PTR vMem$[rsp], rax

; 92   : 
; 93   :   if (!vMem.hProcess) {

	mov	rax, QWORD PTR vMem$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN2@vMemGet

; 94   :     SYSTEM_INFO info;
; 95   :     ::GetSystemInfo(&info);

	lea	rcx, QWORD PTR info$1[rsp]
	call	QWORD PTR __imp_GetSystemInfo

; 96   : 
; 97   :     vMem.pageSize = IntUtil::alignToPowerOf2<uint32_t>(info.dwPageSize);

	mov	ecx, DWORD PTR info$1[rsp+4]
	call	??$alignToPowerOf2@I@IntUtil@asmjit@@SAII@Z ; asmjit::IntUtil::alignToPowerOf2<unsigned int>
	mov	eax, eax
	mov	rcx, QWORD PTR vMem$[rsp]
	mov	QWORD PTR [rcx], rax

; 98   :     vMem.pageGranularity = info.dwAllocationGranularity;

	mov	eax, DWORD PTR info$1[rsp+40]
	mov	rcx, QWORD PTR vMem$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 99   : 
; 100  :     vMem.hProcess = ::GetCurrentProcess();

	call	QWORD PTR __imp_GetCurrentProcess
	mov	rcx, QWORD PTR vMem$[rsp]
	mov	QWORD PTR [rcx+16], rax
$LN2@vMemGet:

; 101  :   }
; 102  : 
; 103  :   return vMem;

	mov	rax, QWORD PTR vMem$[rsp]

; 104  : };

	add	rsp, 104				; 00000068H
	ret	0
?vMemGet@asmjit@@YAAEBUVMemLocal@1@XZ ENDP		; asmjit::vMemGet
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
;	COMDAT ?getSafeProcessHandle@VMemLocal@asmjit@@QEBAPEAXPEAX@Z
_TEXT	SEGMENT
tv66 = 0
this$ = 32
hParam$ = 40
?getSafeProcessHandle@VMemLocal@asmjit@@QEBAPEAXPEAX@Z PROC ; asmjit::VMemLocal::getSafeProcessHandle, COMDAT

; 80   :   ASMJIT_INLINE HANDLE getSafeProcessHandle(HANDLE hParam) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 81   :     return hParam != NULL ? hParam : hProcess;

	cmp	QWORD PTR hParam$[rsp], 0
	je	SHORT $LN3@getSafePro
	mov	rax, QWORD PTR hParam$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	jmp	SHORT $LN4@getSafePro
$LN3@getSafePro:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv66[rsp], rax
$LN4@getSafePro:
	mov	rax, QWORD PTR tv66[rsp]

; 82   :   }

	add	rsp, 24
	ret	0
?getSafeProcessHandle@VMemLocal@asmjit@@QEBAPEAXPEAX@Z ENDP ; asmjit::VMemLocal::getSafeProcessHandle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
stop$ = 32
bit$ = 40
node$ = 48
cont$ = 56
up$ = 64
cp$ = 72
cbits$ = 80
tv134 = 88
tv146 = 92
ubits$ = 96
$T1 = 104
$T2 = 108
$T3 = 112
locked$ = 120
i$ = 128
bitpos$ = 136
offset$ = 144
tv209 = 152
usedBlocks$ = 160
this$ = 192
p$ = 200
used$ = 208
?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z PROC		; asmjit::VMemMgr::shrink

; 1071 : Error VMemMgr::shrink(void* p, size_t used) {

$LN25:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 1072 :   if (p == NULL)

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN8@shrink

; 1073 :     return kErrorOk;

	xor	eax, eax
	jmp	$LN1@shrink
$LN8@shrink:

; 1074 : 
; 1075 :   if (used == 0)

	cmp	QWORD PTR used$[rsp], 0
	jne	SHORT $LN9@shrink

; 1076 :     return release(p);

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?release@VMemMgr@asmjit@@QEAAIPEAX@Z	; asmjit::VMemMgr::release
	jmp	$LN1@shrink
$LN9@shrink:

; 1077 : 
; 1078 :   AutoLock locked(_lock);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdx, rax
	lea	rcx, QWORD PTR locked$[rsp]
	call	??0AutoLock@asmjit@@QEAA@AEAULock@1@@Z	; asmjit::AutoLock::AutoLock
	npad	1

; 1079 : 
; 1080 :   MemNode* node = vMemMgrFindNodeByPtr(this, (uint8_t*)p);

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?vMemMgrFindNodeByPtr@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAE@Z ; asmjit::vMemMgrFindNodeByPtr
	mov	QWORD PTR node$[rsp], rax

; 1081 :   if (node == NULL)

	cmp	QWORD PTR node$[rsp], 0
	jne	SHORT $LN10@shrink

; 1082 :     return kErrorInvalidArgument;

	mov	DWORD PTR $T1[rsp], 3
	lea	rcx, QWORD PTR locked$[rsp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	mov	eax, DWORD PTR $T1[rsp]
	jmp	$LN1@shrink
$LN10@shrink:

; 1083 : 
; 1084 :   size_t offset = (size_t)((uint8_t*)p - (uint8_t*)node->mem);

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR offset$[rsp], rax

; 1085 :   size_t bitpos = M_DIV(offset, node->density);

	xor	edx, edx
	mov	rax, QWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	div	QWORD PTR [rcx+72]
	mov	QWORD PTR bitpos$[rsp], rax

; 1086 :   size_t i = (bitpos / kBitsPerEntity);

	xor	edx, edx
	mov	rax, QWORD PTR bitpos$[rsp]
	mov	ecx, 64					; 00000040H
	div	rcx
	mov	QWORD PTR i$[rsp], rax

; 1087 : 
; 1088 :   size_t* up = node->baUsed + i;  // Current ubits address.

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rcx, QWORD PTR i$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR up$[rsp], rax

; 1089 :   size_t* cp = node->baCont + i;  // Current cbits address.

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR i$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR cp$[rsp], rax

; 1090 :   size_t ubits = *up;             // Current ubits[0] value.

	mov	rax, QWORD PTR up$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ubits$[rsp], rax

; 1091 :   size_t cbits = *cp;             // Current cbits[0] value.

	mov	rax, QWORD PTR cp$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR cbits$[rsp], rax

; 1092 :   size_t bit = (size_t)1 << (bitpos % kBitsPerEntity);

	xor	edx, edx
	mov	rax, QWORD PTR bitpos$[rsp]
	mov	ecx, 64					; 00000040H
	div	rcx
	mov	rax, rdx
	mov	ecx, 1
	mov	QWORD PTR tv209[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv209[rsp]
	shl	rax, cl
	mov	QWORD PTR bit$[rsp], rax

; 1093 : 
; 1094 :   size_t cont = 0;

	mov	QWORD PTR cont$[rsp], 0

; 1095 :   size_t usedBlocks = (used + node->density - 1) / node->density;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR used$[rsp]
	lea	rax, QWORD PTR [rcx+rax-1]
	xor	edx, edx
	mov	rcx, QWORD PTR node$[rsp]
	div	QWORD PTR [rcx+72]
	mov	QWORD PTR usedBlocks$[rsp], rax
$LN2@shrink:

; 1096 : 
; 1097 :   bool stop;
; 1098 : 
; 1099 :   // Find the first block we can mark as free.
; 1100 :   for (;;) {
; 1101 :     stop = (cbits & bit) == 0;

	mov	rax, QWORD PTR bit$[rsp]
	mov	rcx, QWORD PTR cbits$[rsp]
	and	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jne	SHORT $LN20@shrink
	mov	DWORD PTR tv134[rsp], 1
	jmp	SHORT $LN21@shrink
$LN20@shrink:
	mov	DWORD PTR tv134[rsp], 0
$LN21@shrink:
	movzx	eax, BYTE PTR tv134[rsp]
	mov	BYTE PTR stop$[rsp], al

; 1102 :     if (stop)

	movzx	eax, BYTE PTR stop$[rsp]
	test	eax, eax
	je	SHORT $LN11@shrink

; 1103 :       return kErrorOk;

	mov	DWORD PTR $T2[rsp], 0
	lea	rcx, QWORD PTR locked$[rsp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	mov	eax, DWORD PTR $T2[rsp]
	jmp	$LN1@shrink
$LN11@shrink:

; 1104 : 
; 1105 :     if (++cont == usedBlocks)

	mov	rax, QWORD PTR cont$[rsp]
	inc	rax
	mov	QWORD PTR cont$[rsp], rax
	mov	rax, QWORD PTR usedBlocks$[rsp]
	cmp	QWORD PTR cont$[rsp], rax
	jne	SHORT $LN12@shrink

; 1106 :       break;

	jmp	SHORT $LN3@shrink
$LN12@shrink:

; 1107 : 
; 1108 :     bit <<= 1;

	mov	rax, QWORD PTR bit$[rsp]
	shl	rax, 1
	mov	QWORD PTR bit$[rsp], rax

; 1109 :     if (bit == 0) {

	cmp	QWORD PTR bit$[rsp], 0
	jne	SHORT $LN13@shrink

; 1110 :       ubits = *++up;

	mov	rax, QWORD PTR up$[rsp]
	add	rax, 8
	mov	QWORD PTR up$[rsp], rax
	mov	rax, QWORD PTR up$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ubits$[rsp], rax

; 1111 :       cbits = *++cp;

	mov	rax, QWORD PTR cp$[rsp]
	add	rax, 8
	mov	QWORD PTR cp$[rsp], rax
	mov	rax, QWORD PTR cp$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR cbits$[rsp], rax

; 1112 :       bit = 1;

	mov	QWORD PTR bit$[rsp], 1
$LN13@shrink:

; 1113 :     }
; 1114 :   }

	jmp	$LN2@shrink
$LN3@shrink:

; 1115 : 
; 1116 :   // Free the tail blocks.
; 1117 :   cont = ~(size_t)0;

	mov	QWORD PTR cont$[rsp], -1

; 1118 :   goto _EnterFreeLoop;

	jmp	SHORT $_EnterFreeLoop$26
$LN5@shrink:

; 1119 : 
; 1120 :   for (;;) {
; 1121 :     stop = (cbits & bit) == 0;

	mov	rax, QWORD PTR bit$[rsp]
	mov	rcx, QWORD PTR cbits$[rsp]
	and	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jne	SHORT $LN22@shrink
	mov	DWORD PTR tv146[rsp], 1
	jmp	SHORT $LN23@shrink
$LN22@shrink:
	mov	DWORD PTR tv146[rsp], 0
$LN23@shrink:
	movzx	eax, BYTE PTR tv146[rsp]
	mov	BYTE PTR stop$[rsp], al

; 1122 :     ubits &= ~bit;

	mov	rax, QWORD PTR bit$[rsp]
	not	rax
	mov	rcx, QWORD PTR ubits$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ubits$[rsp], rax
$_EnterFreeLoop$26:

; 1123 : 
; 1124 : _EnterFreeLoop:
; 1125 :     cbits &= ~bit;

	mov	rax, QWORD PTR bit$[rsp]
	not	rax
	mov	rcx, QWORD PTR cbits$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cbits$[rsp], rax

; 1126 : 
; 1127 :     bit <<= 1;

	mov	rax, QWORD PTR bit$[rsp]
	shl	rax, 1
	mov	QWORD PTR bit$[rsp], rax

; 1128 :     cont++;

	mov	rax, QWORD PTR cont$[rsp]
	inc	rax
	mov	QWORD PTR cont$[rsp], rax

; 1129 : 
; 1130 :     if (stop || bit == 0) {

	movzx	eax, BYTE PTR stop$[rsp]
	test	eax, eax
	jne	SHORT $LN16@shrink
	cmp	QWORD PTR bit$[rsp], 0
	jne	SHORT $LN15@shrink
$LN16@shrink:

; 1131 :       *up = ubits;

	mov	rax, QWORD PTR up$[rsp]
	mov	rcx, QWORD PTR ubits$[rsp]
	mov	QWORD PTR [rax], rcx

; 1132 :       *cp = cbits;

	mov	rax, QWORD PTR cp$[rsp]
	mov	rcx, QWORD PTR cbits$[rsp]
	mov	QWORD PTR [rax], rcx

; 1133 :       if (stop)

	movzx	eax, BYTE PTR stop$[rsp]
	test	eax, eax
	je	SHORT $LN17@shrink

; 1134 :         break;

	jmp	SHORT $LN6@shrink
$LN17@shrink:

; 1135 : 
; 1136 :       ubits = *++up;

	mov	rax, QWORD PTR up$[rsp]
	add	rax, 8
	mov	QWORD PTR up$[rsp], rax
	mov	rax, QWORD PTR up$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ubits$[rsp], rax

; 1137 :       cbits = *++cp;

	mov	rax, QWORD PTR cp$[rsp]
	add	rax, 8
	mov	QWORD PTR cp$[rsp], rax
	mov	rax, QWORD PTR cp$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR cbits$[rsp], rax

; 1138 :       bit = 1;

	mov	QWORD PTR bit$[rsp], 1
$LN15@shrink:

; 1139 :     }
; 1140 :   }

	jmp	$LN5@shrink
$LN6@shrink:

; 1141 : 
; 1142 :   // Statistics.
; 1143 :   cont *= node->density;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR cont$[rsp]
	imul	rcx, QWORD PTR [rax+72]
	mov	rax, rcx
	mov	QWORD PTR cont$[rsp], rax

; 1144 :   if (node->largestBlock < cont)

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR cont$[rsp]
	cmp	QWORD PTR [rax+80], rcx
	jae	SHORT $LN18@shrink

; 1145 :     node->largestBlock = cont;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR cont$[rsp]
	mov	QWORD PTR [rax+80], rcx
$LN18@shrink:

; 1146 : 
; 1147 :   node->used -= cont;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR cont$[rsp]
	mov	rax, QWORD PTR [rax+56]
	sub	rax, rcx
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+56], rax

; 1148 :   _usedBytes -= cont;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR cont$[rsp]
	mov	rax, QWORD PTR [rax+80]
	sub	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 1149 : 
; 1150 :   return kErrorOk;

	mov	DWORD PTR $T3[rsp], 0
	lea	rcx, QWORD PTR locked$[rsp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	mov	eax, DWORD PTR $T3[rsp]
$LN1@shrink:

; 1151 : }

	add	rsp, 184				; 000000b8H
	ret	0
?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z ENDP		; asmjit::VMemMgr::shrink
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
stop$ = 32
bit$ = 40
node$ = 48
cont$ = 56
up$ = 64
cp$ = 72
cbits$ = 80
tv134 = 88
tv146 = 92
ubits$ = 96
$T1 = 104
$T2 = 108
$T3 = 112
locked$ = 120
i$ = 128
bitpos$ = 136
offset$ = 144
tv209 = 152
usedBlocks$ = 160
this$ = 192
p$ = 200
used$ = 208
?dtor$0@?0??shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z@4HA PROC ; `asmjit::VMemMgr::shrink'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR locked$[rbp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z@4HA ENDP ; `asmjit::VMemMgr::shrink'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
stop$ = 32
node$ = 40
cont$ = 48
bit$ = 56
tv93 = 64
up$ = 72
cp$ = 80
cbits$ = 88
ubits$ = 96
cur$1 = 104
$T2 = 112
$T3 = 116
i$ = 120
bitpos$ = 128
locked$ = 136
offset$ = 144
tv214 = 152
this$ = 176
p$ = 184
?release@VMemMgr@asmjit@@QEAAIPEAX@Z PROC		; asmjit::VMemMgr::release

; 984  : Error VMemMgr::release(void* p) {

$LN21:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 985  :   if (p == NULL)

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN8@release

; 986  :     return kErrorOk;

	xor	eax, eax
	jmp	$LN1@release
$LN8@release:

; 987  : 
; 988  :   AutoLock locked(_lock);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdx, rax
	lea	rcx, QWORD PTR locked$[rsp]
	call	??0AutoLock@asmjit@@QEAA@AEAULock@1@@Z	; asmjit::AutoLock::AutoLock
	npad	1

; 989  :   MemNode* node = vMemMgrFindNodeByPtr(this, static_cast<uint8_t*>(p));

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?vMemMgrFindNodeByPtr@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAE@Z ; asmjit::vMemMgrFindNodeByPtr
	mov	QWORD PTR node$[rsp], rax

; 990  : 
; 991  :   if (node == NULL)

	cmp	QWORD PTR node$[rsp], 0
	jne	SHORT $LN9@release

; 992  :     return kErrorInvalidArgument;

	mov	DWORD PTR $T2[rsp], 3
	lea	rcx, QWORD PTR locked$[rsp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	mov	eax, DWORD PTR $T2[rsp]
	jmp	$LN1@release
$LN9@release:

; 993  : 
; 994  :   size_t offset = (size_t)((uint8_t*)p - (uint8_t*)node->mem);

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR offset$[rsp], rax

; 995  :   size_t bitpos = M_DIV(offset, node->density);

	xor	edx, edx
	mov	rax, QWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	div	QWORD PTR [rcx+72]
	mov	QWORD PTR bitpos$[rsp], rax

; 996  :   size_t i = (bitpos / kBitsPerEntity);

	xor	edx, edx
	mov	rax, QWORD PTR bitpos$[rsp]
	mov	ecx, 64					; 00000040H
	div	rcx
	mov	QWORD PTR i$[rsp], rax

; 997  : 
; 998  :   size_t* up = node->baUsed + i;  // Current ubits address.

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	rcx, QWORD PTR i$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR up$[rsp], rax

; 999  :   size_t* cp = node->baCont + i;  // Current cbits address.

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	rcx, QWORD PTR i$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR cp$[rsp], rax

; 1000 :   size_t ubits = *up;             // Current ubits[0] value.

	mov	rax, QWORD PTR up$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ubits$[rsp], rax

; 1001 :   size_t cbits = *cp;             // Current cbits[0] value.

	mov	rax, QWORD PTR cp$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR cbits$[rsp], rax

; 1002 :   size_t bit = (size_t)1 << (bitpos % kBitsPerEntity);

	xor	edx, edx
	mov	rax, QWORD PTR bitpos$[rsp]
	mov	ecx, 64					; 00000040H
	div	rcx
	mov	rax, rdx
	mov	ecx, 1
	mov	QWORD PTR tv214[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv214[rsp]
	shl	rax, cl
	mov	QWORD PTR bit$[rsp], rax

; 1003 : 
; 1004 :   size_t cont = 0;

	mov	QWORD PTR cont$[rsp], 0
$LN2@release:

; 1005 :   bool stop;
; 1006 : 
; 1007 :   for (;;) {
; 1008 :     stop = (cbits & bit) == 0;

	mov	rax, QWORD PTR bit$[rsp]
	mov	rcx, QWORD PTR cbits$[rsp]
	and	rcx, rax
	mov	rax, rcx
	test	rax, rax
	jne	SHORT $LN18@release
	mov	DWORD PTR tv93[rsp], 1
	jmp	SHORT $LN19@release
$LN18@release:
	mov	DWORD PTR tv93[rsp], 0
$LN19@release:
	movzx	eax, BYTE PTR tv93[rsp]
	mov	BYTE PTR stop$[rsp], al

; 1009 :     ubits &= ~bit;

	mov	rax, QWORD PTR bit$[rsp]
	not	rax
	mov	rcx, QWORD PTR ubits$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ubits$[rsp], rax

; 1010 :     cbits &= ~bit;

	mov	rax, QWORD PTR bit$[rsp]
	not	rax
	mov	rcx, QWORD PTR cbits$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cbits$[rsp], rax

; 1011 : 
; 1012 :     bit <<= 1;

	mov	rax, QWORD PTR bit$[rsp]
	shl	rax, 1
	mov	QWORD PTR bit$[rsp], rax

; 1013 :     cont++;

	mov	rax, QWORD PTR cont$[rsp]
	inc	rax
	mov	QWORD PTR cont$[rsp], rax

; 1014 : 
; 1015 :     if (stop || bit == 0) {

	movzx	eax, BYTE PTR stop$[rsp]
	test	eax, eax
	jne	SHORT $LN11@release
	cmp	QWORD PTR bit$[rsp], 0
	jne	SHORT $LN10@release
$LN11@release:

; 1016 :       *up = ubits;

	mov	rax, QWORD PTR up$[rsp]
	mov	rcx, QWORD PTR ubits$[rsp]
	mov	QWORD PTR [rax], rcx

; 1017 :       *cp = cbits;

	mov	rax, QWORD PTR cp$[rsp]
	mov	rcx, QWORD PTR cbits$[rsp]
	mov	QWORD PTR [rax], rcx

; 1018 :       if (stop)

	movzx	eax, BYTE PTR stop$[rsp]
	test	eax, eax
	je	SHORT $LN12@release

; 1019 :         break;

	jmp	SHORT $LN3@release
$LN12@release:

; 1020 : 
; 1021 :       ubits = *++up;

	mov	rax, QWORD PTR up$[rsp]
	add	rax, 8
	mov	QWORD PTR up$[rsp], rax
	mov	rax, QWORD PTR up$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ubits$[rsp], rax

; 1022 :       cbits = *++cp;

	mov	rax, QWORD PTR cp$[rsp]
	add	rax, 8
	mov	QWORD PTR cp$[rsp], rax
	mov	rax, QWORD PTR cp$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR cbits$[rsp], rax

; 1023 :       bit = 1;

	mov	QWORD PTR bit$[rsp], 1
$LN10@release:

; 1024 :     }
; 1025 :   }

	jmp	$LN2@release
$LN3@release:

; 1026 : 
; 1027 :   // If the freed block is fully allocated node then it's needed to
; 1028 :   // update 'optimal' pointer in memory manager.
; 1029 :   if (node->used == node->size) {

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	cmp	QWORD PTR [rax+56], rcx
	jne	SHORT $LN13@release

; 1030 :     MemNode* cur = _optimal;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR cur$1[rsp], rax
$LN7@release:

; 1031 : 
; 1032 :     do {
; 1033 :       cur = cur->prev;

	mov	rax, QWORD PTR cur$1[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR cur$1[rsp], rax

; 1034 :       if (cur == node) {

	mov	rax, QWORD PTR node$[rsp]
	cmp	QWORD PTR cur$1[rsp], rax
	jne	SHORT $LN14@release

; 1035 :         _optimal = node;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+112], rcx

; 1036 :         break;

	jmp	SHORT $LN13@release
$LN14@release:

; 1037 :       }
; 1038 :     } while (cur);

	cmp	QWORD PTR cur$1[rsp], 0
	jne	SHORT $LN7@release
$LN13@release:

; 1039 :   }
; 1040 : 
; 1041 :   // Statistics.
; 1042 :   cont *= node->density;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR cont$[rsp]
	imul	rcx, QWORD PTR [rax+72]
	mov	rax, rcx
	mov	QWORD PTR cont$[rsp], rax

; 1043 :   if (node->largestBlock < cont)

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR cont$[rsp]
	cmp	QWORD PTR [rax+80], rcx
	jae	SHORT $LN15@release

; 1044 :     node->largestBlock = cont;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR cont$[rsp]
	mov	QWORD PTR [rax+80], rcx
$LN15@release:

; 1045 : 
; 1046 :   node->used -= cont;

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR cont$[rsp]
	mov	rax, QWORD PTR [rax+56]
	sub	rax, rcx
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rcx+56], rax

; 1047 :   _usedBytes -= cont;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR cont$[rsp]
	mov	rax, QWORD PTR [rax+80]
	sub	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 1048 : 
; 1049 :   // If page is empty, we can free it.
; 1050 :   if (node->used == 0) {

	mov	rax, QWORD PTR node$[rsp]
	cmp	QWORD PTR [rax+56], 0
	jne	$LN16@release

; 1051 :     // Free memory associated with node (this memory is not accessed
; 1052 :     // anymore so it's safe).
; 1053 :     vMemMgrReleaseVMem(this, node->mem, node->size);

	mov	rax, QWORD PTR node$[rsp]
	mov	r8, QWORD PTR [rax+48]
	mov	rax, QWORD PTR node$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR this$[rsp]
	call	?vMemMgrReleaseVMem@asmjit@@YAIPEAUVMemMgr@1@PEAX_K@Z ; asmjit::vMemMgrReleaseVMem

; 1054 :     ASMJIT_FREE(node->baUsed);

	mov	rax, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR [rax+88]
	call	free

; 1055 : 
; 1056 :     node->baUsed = NULL;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+88], 0

; 1057 :     node->baCont = NULL;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+96], 0

; 1058 : 
; 1059 :     // Statistics.
; 1060 :     _allocatedBytes -= node->size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rax, QWORD PTR [rax+72]
	sub	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+72], rax

; 1061 : 
; 1062 :     // Remove node. This function can return different node than
; 1063 :     // passed into, but data is copied into previous node if needed.
; 1064 :     ASMJIT_FREE(vMemMgrRemoveNode(this, node));

	mov	rdx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?vMemMgrRemoveNode@asmjit@@YAPEAUMemNode@VMemMgr@1@PEAU31@PEAU231@@Z ; asmjit::vMemMgrRemoveNode
	mov	rcx, rax
	call	free
	npad	1
$LN16@release:

; 1065 :     ASMJIT_ASSERT(vMemMgrCheckTree(this));
; 1066 :   }
; 1067 : 
; 1068 :   return kErrorOk;

	mov	DWORD PTR $T3[rsp], 0
	lea	rcx, QWORD PTR locked$[rsp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	mov	eax, DWORD PTR $T3[rsp]
$LN1@release:

; 1069 : }

	add	rsp, 168				; 000000a8H
	ret	0
?release@VMemMgr@asmjit@@QEAAIPEAX@Z ENDP		; asmjit::VMemMgr::release
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
stop$ = 32
node$ = 40
cont$ = 48
bit$ = 56
tv93 = 64
up$ = 72
cp$ = 80
cbits$ = 88
ubits$ = 96
cur$1 = 104
$T2 = 112
$T3 = 116
i$ = 120
bitpos$ = 128
locked$ = 136
offset$ = 144
tv214 = 152
this$ = 176
p$ = 184
?dtor$0@?0??release@VMemMgr@asmjit@@QEAAIPEAX@Z@4HA PROC ; `asmjit::VMemMgr::release'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR locked$[rbp]
	call	??1AutoLock@asmjit@@QEAA@XZ		; asmjit::AutoLock::~AutoLock
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??release@VMemMgr@asmjit@@QEAAIPEAX@Z@4HA ENDP ; `asmjit::VMemMgr::release'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
this$ = 48
size$ = 56
type$ = 64
?alloc@VMemMgr@asmjit@@QEAAPEAX_KI@Z PROC		; asmjit::VMemMgr::alloc

; 977  : void* VMemMgr::alloc(size_t size, uint32_t type) {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 978  :   if (type == kVMemAllocPermanent)

	cmp	DWORD PTR type$[rsp], 1
	jne	SHORT $LN2@alloc

; 979  :     return vMemMgrAllocPermanent(this, size);

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?vMemMgrAllocPermanent@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z ; asmjit::vMemMgrAllocPermanent
	jmp	SHORT $LN1@alloc
	jmp	SHORT $LN3@alloc
$LN2@alloc:

; 980  :   else
; 981  :     return vMemMgrAllocFreeable(this, size);

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?vMemMgrAllocFreeable@asmjit@@YAPEAXPEAUVMemMgr@1@_K@Z ; asmjit::vMemMgrAllocFreeable
$LN3@alloc:
$LN1@alloc:

; 982  : }

	add	rsp, 40					; 00000028H
	ret	0
?alloc@VMemMgr@asmjit@@QEAAPEAX_KI@Z ENDP		; asmjit::VMemMgr::alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
this$ = 48
?reset@VMemMgr@asmjit@@QEAAXXZ PROC			; asmjit::VMemMgr::reset

; 969  : void VMemMgr::reset() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 970  :   vMemMgrReset(this, false);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?vMemMgrReset@asmjit@@YAXPEAUVMemMgr@1@_N@Z ; asmjit::vMemMgrReset
	npad	1

; 971  : }

	add	rsp, 40					; 00000028H
	ret	0
?reset@VMemMgr@asmjit@@QEAAXXZ ENDP			; asmjit::VMemMgr::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
node$ = 32
prev$1 = 40
this$ = 64
??1VMemMgr@asmjit@@QEAA@XZ PROC				; asmjit::VMemMgr::~VMemMgr

; 952  : VMemMgr::~VMemMgr() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 953  :   // Freeable memory cleanup - Also frees the virtual memory if configured to.
; 954  :   vMemMgrReset(this, _keepVirtualMemory);

	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rax+64]
	mov	rcx, QWORD PTR this$[rsp]
	call	?vMemMgrReset@asmjit@@YAXPEAUVMemMgr@1@_N@Z ; asmjit::vMemMgrReset

; 955  : 
; 956  :   // Permanent memory cleanup - Never frees the virtual memory.
; 957  :   PermanentNode* node = _permanent;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR node$[rsp], rax
$LN2@VMemMgr:

; 958  :   while (node) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN3@VMemMgr

; 959  :     PermanentNode* prev = node->prev;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR prev$1[rsp], rax

; 960  :     ASMJIT_FREE(node);

	mov	rcx, QWORD PTR node$[rsp]
	call	free

; 961  :     node = prev;

	mov	rax, QWORD PTR prev$1[rsp]
	mov	QWORD PTR node$[rsp], rax

; 962  :   }

	jmp	SHORT $LN2@VMemMgr
$LN3@VMemMgr:

; 963  : }

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1Lock@asmjit@@QEAA@XZ			; asmjit::Lock::~Lock
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??1VMemMgr@asmjit@@QEAA@XZ ENDP				; asmjit::VMemMgr::~VMemMgr
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
node$ = 32
prev$1 = 40
this$ = 64
?dtor$0@?0???1VMemMgr@asmjit@@QEAA@XZ@4HA PROC		; `asmjit::VMemMgr::~VMemMgr'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1Lock@asmjit@@QEAA@XZ			; asmjit::Lock::~Lock
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1VMemMgr@asmjit@@QEAA@XZ@4HA ENDP		; `asmjit::VMemMgr::~VMemMgr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
tv70 = 32
this$ = 64
hProcess$ = 72
??0VMemMgr@asmjit@@QEAA@PEAX@Z PROC			; asmjit::VMemMgr::VMemMgr

; 935  : {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 933  :   _hProcess(vMemGet().getSafeProcessHandle(hProcess))

	call	?vMemGet@asmjit@@YAAEBUVMemLocal@1@XZ	; asmjit::vMemGet
	mov	QWORD PTR tv70[rsp], rax
	mov	rdx, QWORD PTR hProcess$[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	?getSafeProcessHandle@VMemLocal@asmjit@@QEBAPEAXPEAX@Z ; asmjit::VMemLocal::getSafeProcessHandle
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax

; 935  : {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??0Lock@asmjit@@QEAA@XZ			; asmjit::Lock::Lock
	npad	1

; 936  : 
; 937  :   _blockSize = VMemUtil::getPageGranularity();

	call	?getPageGranularity@VMemUtil@asmjit@@SA_KXZ ; asmjit::VMemUtil::getPageGranularity
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 938  :   _blockDensity = 64;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 64			; 00000040H

; 939  : 
; 940  :   _allocatedBytes = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+72], 0

; 941  :   _usedBytes = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+80], 0

; 942  : 
; 943  :   _root = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+88], 0

; 944  :   _first = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+96], 0

; 945  :   _last = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+104], 0

; 946  :   _optimal = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+112], 0

; 947  : 
; 948  :   _permanent = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+120], 0

; 949  :   _keepVirtualMemory = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+64], 0

; 950  : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0VMemMgr@asmjit@@QEAA@PEAX@Z ENDP			; asmjit::VMemMgr::VMemMgr
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
tv70 = 32
this$ = 64
hProcess$ = 72
?dtor$0@?0???0VMemMgr@asmjit@@QEAA@PEAX@Z@4HA PROC	; `asmjit::VMemMgr::VMemMgr'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1Lock@asmjit@@QEAA@XZ			; asmjit::Lock::~Lock
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0VMemMgr@asmjit@@QEAA@PEAX@Z@4HA ENDP	; `asmjit::VMemMgr::VMemMgr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
tv69 = 32
hProcess$ = 64
addr$ = 72
__formal$ = 80
?releaseProcessMemory@VMemUtil@asmjit@@SAIPEAX0_K@Z PROC ; asmjit::VMemUtil::releaseProcessMemory

; 155  : Error VMemUtil::releaseProcessMemory(HANDLE hProcess, void* addr, size_t /* length */) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 156  :   hProcess = vMemGet().getSafeProcessHandle(hProcess);

	call	?vMemGet@asmjit@@YAAEBUVMemLocal@1@XZ	; asmjit::vMemGet
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR hProcess$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?getSafeProcessHandle@VMemLocal@asmjit@@QEBAPEAXPEAX@Z ; asmjit::VMemLocal::getSafeProcessHandle
	mov	QWORD PTR hProcess$[rsp], rax

; 157  :   if (!::VirtualFreeEx(hProcess, addr, 0, MEM_RELEASE))

	mov	r9d, 32768				; 00008000H
	xor	r8d, r8d
	mov	rdx, QWORD PTR addr$[rsp]
	mov	rcx, QWORD PTR hProcess$[rsp]
	call	QWORD PTR __imp_VirtualFreeEx
	test	eax, eax
	jne	SHORT $LN2@releasePro

; 158  :     return kErrorInvalidState;

	mov	eax, 4
	jmp	SHORT $LN1@releasePro
$LN2@releasePro:

; 159  :   return kErrorOk;

	xor	eax, eax
$LN1@releasePro:

; 160  : }

	add	rsp, 56					; 00000038H
	ret	0
?releaseProcessMemory@VMemUtil@asmjit@@SAIPEAX0_K@Z ENDP ; asmjit::VMemUtil::releaseProcessMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
addr$ = 48
length$ = 56
?release@VMemUtil@asmjit@@SAIPEAX_K@Z PROC		; asmjit::VMemUtil::release

; 151  : Error VMemUtil::release(void* addr, size_t length) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 152  :   return releaseProcessMemory(static_cast<HANDLE>(0), addr, length);

	mov	r8, QWORD PTR length$[rsp]
	mov	rdx, QWORD PTR addr$[rsp]
	xor	ecx, ecx
	call	?releaseProcessMemory@VMemUtil@asmjit@@SAIPEAX0_K@Z ; asmjit::VMemUtil::releaseProcessMemory

; 153  : }

	add	rsp, 40					; 00000028H
	ret	0
?release@VMemUtil@asmjit@@SAIPEAX_K@Z ENDP		; asmjit::VMemUtil::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
protectFlags$ = 48
tv77 = 52
tv81 = 56
vMem$ = 64
mSize$ = 72
mBase$ = 80
hProcess$ = 112
length$ = 120
allocated$ = 128
flags$ = 136
?allocProcessMemory@VMemUtil@asmjit@@SAPEAXPEAX_KPEA_KI@Z PROC ; asmjit::VMemUtil::allocProcessMemory

; 120  : void* VMemUtil::allocProcessMemory(HANDLE hProcess, size_t length, size_t* allocated, uint32_t flags) {

$LN12:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 121  : 	return NULL;

	xor	eax, eax
	jmp	$LN1@allocProce

; 122  : 	if (length == 0)

	cmp	QWORD PTR length$[rsp], 0
	jne	SHORT $LN2@allocProce

; 123  :     return NULL;

	xor	eax, eax
	jmp	$LN1@allocProce
$LN2@allocProce:

; 124  : 
; 125  :      const VMemLocal& vMem = vMemGet();

	call	?vMemGet@asmjit@@YAAEBUVMemLocal@1@XZ	; asmjit::vMemGet
	mov	QWORD PTR vMem$[rsp], rax

; 126  :      hProcess = vMem.getSafeProcessHandle(hProcess);

	mov	rdx, QWORD PTR hProcess$[rsp]
	mov	rcx, QWORD PTR vMem$[rsp]
	call	?getSafeProcessHandle@VMemLocal@asmjit@@QEBAPEAXPEAX@Z ; asmjit::VMemLocal::getSafeProcessHandle
	mov	QWORD PTR hProcess$[rsp], rax

; 127  : 
; 128  :      // VirtualAlloc rounds allocated size to a page size automatically.
; 129  :      size_t mSize = IntUtil::alignTo(length, vMem.pageSize);

	mov	rax, QWORD PTR vMem$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR length$[rsp]
	call	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z	; asmjit::IntUtil::alignTo<unsigned __int64>
	mov	QWORD PTR mSize$[rsp], rax

; 130  : 
; 131  :      // Windows XP SP2 / Vista allow Data Excution Prevention (DEP).
; 132  :      DWORD protectFlags = 0;

	mov	DWORD PTR protectFlags$[rsp], 0

; 133  : 
; 134  :      if (flags & kVMemFlagExecutable)

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN3@allocProce

; 135  :        protectFlags |= (flags & kVMemFlagWritable) ? PAGE_EXECUTE_READWRITE : PAGE_EXECUTE_READ;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@allocProce
	mov	DWORD PTR tv77[rsp], 64			; 00000040H
	jmp	SHORT $LN9@allocProce
$LN8@allocProce:
	mov	DWORD PTR tv77[rsp], 32			; 00000020H
$LN9@allocProce:
	mov	eax, DWORD PTR tv77[rsp]
	mov	ecx, DWORD PTR protectFlags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR protectFlags$[rsp], eax
	jmp	SHORT $LN4@allocProce
$LN3@allocProce:

; 136  :      else
; 137  :        protectFlags |= (flags & kVMemFlagWritable) ? PAGE_READWRITE : PAGE_READONLY;

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN10@allocProce
	mov	DWORD PTR tv81[rsp], 4
	jmp	SHORT $LN11@allocProce
$LN10@allocProce:
	mov	DWORD PTR tv81[rsp], 2
$LN11@allocProce:
	mov	eax, DWORD PTR tv81[rsp]
	mov	ecx, DWORD PTR protectFlags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR protectFlags$[rsp], eax
$LN4@allocProce:

; 138  : 
; 139  :      LPVOID mBase = ::VirtualAllocEx(hProcess, NULL, mSize, MEM_COMMIT | MEM_RESERVE, protectFlags);

	mov	eax, DWORD PTR protectFlags$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, 12288				; 00003000H
	mov	r8, QWORD PTR mSize$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR hProcess$[rsp]
	call	QWORD PTR __imp_VirtualAllocEx
	mov	QWORD PTR mBase$[rsp], rax

; 140  :      if (mBase == NULL)

	cmp	QWORD PTR mBase$[rsp], 0
	jne	SHORT $LN5@allocProce

; 141  :        return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@allocProce
$LN5@allocProce:

; 142  : 
; 143  :      ASMJIT_ASSERT(IntUtil::isAligned<size_t>(
; 144  :        reinterpret_cast<size_t>(mBase), vMem.pageSize));
; 145  : 
; 146  :      if (allocated != NULL)

	cmp	QWORD PTR allocated$[rsp], 0
	je	SHORT $LN6@allocProce

; 147  :        *allocated = mSize;

	mov	rax, QWORD PTR allocated$[rsp]
	mov	rcx, QWORD PTR mSize$[rsp]
	mov	QWORD PTR [rax], rcx
$LN6@allocProce:

; 148  :      return mBase;

	mov	rax, QWORD PTR mBase$[rsp]
$LN1@allocProce:

; 149  : }

	add	rsp, 104				; 00000068H
	ret	0
?allocProcessMemory@VMemUtil@asmjit@@SAPEAXPEAX_KPEA_KI@Z ENDP ; asmjit::VMemUtil::allocProcessMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
length$ = 48
allocated$ = 56
flags$ = 64
?alloc@VMemUtil@asmjit@@SAPEAX_KPEA_KI@Z PROC		; asmjit::VMemUtil::alloc

; 116  : void* VMemUtil::alloc(size_t length, size_t* allocated, uint32_t flags) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 117  :   return allocProcessMemory(static_cast<HANDLE>(0), length, allocated, flags);

	mov	r9d, DWORD PTR flags$[rsp]
	mov	r8, QWORD PTR allocated$[rsp]
	mov	rdx, QWORD PTR length$[rsp]
	xor	ecx, ecx
	call	?allocProcessMemory@VMemUtil@asmjit@@SAPEAXPEAX_KPEA_KI@Z ; asmjit::VMemUtil::allocProcessMemory

; 118  : }

	add	rsp, 40					; 00000028H
	ret	0
?alloc@VMemUtil@asmjit@@SAPEAX_KPEA_KI@Z ENDP		; asmjit::VMemUtil::alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
vMem$ = 32
?getPageGranularity@VMemUtil@asmjit@@SA_KXZ PROC	; asmjit::VMemUtil::getPageGranularity

; 111  : size_t VMemUtil::getPageGranularity() {

$LN3:
	sub	rsp, 56					; 00000038H

; 112  :   const VMemLocal& vMem = vMemGet();

	call	?vMemGet@asmjit@@YAAEBUVMemLocal@1@XZ	; asmjit::vMemGet
	mov	QWORD PTR vMem$[rsp], rax

; 113  :   return vMem.pageGranularity;

	mov	rax, QWORD PTR vMem$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 114  : }

	add	rsp, 56					; 00000038H
	ret	0
?getPageGranularity@VMemUtil@asmjit@@SA_KXZ ENDP	; asmjit::VMemUtil::getPageGranularity
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\vmem.cpp
_TEXT	SEGMENT
vMem$ = 32
?getPageSize@VMemUtil@asmjit@@SA_KXZ PROC		; asmjit::VMemUtil::getPageSize

; 106  : size_t VMemUtil::getPageSize() {

$LN3:
	sub	rsp, 56					; 00000038H

; 107  :   const VMemLocal& vMem = vMemGet();

	call	?vMemGet@asmjit@@YAAEBUVMemLocal@1@XZ	; asmjit::vMemGet
	mov	QWORD PTR vMem$[rsp], rax

; 108  :   return vMem.pageSize;

	mov	rax, QWORD PTR vMem$[rsp]
	mov	rax, QWORD PTR [rax]

; 109  : }

	add	rsp, 56					; 00000038H
	ret	0
?getPageSize@VMemUtil@asmjit@@SA_KXZ ENDP		; asmjit::VMemUtil::getPageSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\lock.h
;	COMDAT ??1AutoLock@asmjit@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1AutoLock@asmjit@@QEAA@XZ PROC			; asmjit::AutoLock::~AutoLock, COMDAT

; 111  :   ASMJIT_INLINE ~AutoLock() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 112  :     _target.unlock();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?unlock@Lock@asmjit@@QEAAXXZ		; asmjit::Lock::unlock
	npad	1

; 113  :   }

	add	rsp, 40					; 00000028H
	ret	0
??1AutoLock@asmjit@@QEAA@XZ ENDP			; asmjit::AutoLock::~AutoLock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\lock.h
;	COMDAT ??0AutoLock@asmjit@@QEAA@AEAULock@1@@Z
_TEXT	SEGMENT
this$ = 48
target$ = 56
??0AutoLock@asmjit@@QEAA@AEAULock@1@@Z PROC		; asmjit::AutoLock::AutoLock, COMDAT

; 106  :   ASMJIT_INLINE AutoLock(Lock& target) : _target(target) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR target$[rsp]
	mov	QWORD PTR [rax], rcx

; 107  :     _target.lock();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?lock@Lock@asmjit@@QEAAXXZ		; asmjit::Lock::lock
	npad	1

; 108  :   }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0AutoLock@asmjit@@QEAA@AEAULock@1@@Z ENDP		; asmjit::AutoLock::AutoLock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\lock.h
;	COMDAT ?unlock@Lock@asmjit@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?unlock@Lock@asmjit@@QEAAXXZ PROC			; asmjit::Lock::unlock, COMDAT

; 50   :   ASMJIT_INLINE void unlock() { LeaveCriticalSection(&_handle); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_LeaveCriticalSection
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
?unlock@Lock@asmjit@@QEAAXXZ ENDP			; asmjit::Lock::unlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\lock.h
;	COMDAT ?lock@Lock@asmjit@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?lock@Lock@asmjit@@QEAAXXZ PROC				; asmjit::Lock::lock, COMDAT

; 48   :   ASMJIT_INLINE void lock() { EnterCriticalSection(&_handle); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_EnterCriticalSection
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
?lock@Lock@asmjit@@QEAAXXZ ENDP				; asmjit::Lock::lock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\lock.h
;	COMDAT ??1Lock@asmjit@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Lock@asmjit@@QEAA@XZ PROC				; asmjit::Lock::~Lock, COMDAT

; 45   :   ASMJIT_INLINE ~Lock() { DeleteCriticalSection(&_handle); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_DeleteCriticalSection
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1Lock@asmjit@@QEAA@XZ ENDP				; asmjit::Lock::~Lock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\lock.h
;	COMDAT ??0Lock@asmjit@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0Lock@asmjit@@QEAA@XZ PROC				; asmjit::Lock::Lock, COMDAT

; 43   :   ASMJIT_INLINE Lock() { InitializeCriticalSection(&_handle); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_InitializeCriticalSection
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0Lock@asmjit@@QEAA@XZ ENDP				; asmjit::Lock::Lock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Esslinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Esslinit_@detail@httplib@@YAXXZ PROC		; httplib::detail::`dynamic initializer for 'sslinit_'', COMDAT

; 8802 :         static SSLInit sslinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?sslinit_@detail@httplib@@3VSSLInit@12@A
	call	??0SSLInit@detail@httplib@@QEAA@XZ	; httplib::detail::SSLInit::SSLInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Esslinit_@detail@httplib@@YAXXZ ENDP		; httplib::detail::`dynamic initializer for 'sslinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0SSLInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0SSLInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::SSLInit::SSLInit, COMDAT

; 8693 :             SSLInit() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8694 :                 OPENSSL_init_ssl(

	xor	edx, edx
	mov	ecx, 2097154				; 00200002H
	call	OPENSSL_init_ssl
	npad	1

; 8695 :                     OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
; 8696 :             }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0SSLInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::SSLInit::SSLInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fwsinit_@detail@httplib@@YAXXZ
text$yd	SEGMENT
??__Fwsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic atexit destructor for 'wsinit_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??1WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::~WSInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fwsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic atexit destructor for 'wsinit_''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Ewsinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Ewsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic initializer for 'wsinit_'', COMDAT

; 5291 :         static WSInit wsinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??0WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::WSInit
	lea	rcx, OFFSET FLAT:??__Fwsinit_@detail@httplib@@YAXXZ ; httplib::detail::`dynamic atexit destructor for 'wsinit_''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ewsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic initializer for 'wsinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??1WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::~WSInit, COMDAT

; 5284 :             ~WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5285 :                 if (is_valid_) WSACleanup();

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@WSInit
	call	QWORD PTR __imp_WSACleanup
	npad	1
$LN2@WSInit:

; 5286 :             }

	add	rsp, 40					; 00000028H
	ret	0
??1WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::~WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
wsaData$ = 32
__$ArrayPad$ = 448
this$ = 480
??0WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::WSInit, COMDAT

; 5279 :             WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5283 : 
; 5284 :             ~WSInit() {
; 5285 :                 if (is_valid_) WSACleanup();
; 5286 :             }
; 5287 : 
; 5288 :             bool is_valid_ = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 5280 :                 WSADATA wsaData;
; 5281 :                 if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 2
	call	QWORD PTR __imp_WSAStartup
	test	eax, eax
	jne	SHORT $LN2@WSInit
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@WSInit:

; 5282 :             }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	ret	0
??0WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rax, QWORD PTR __f$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
