; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

EXTRN	?x86RegData@asmjit@@3UX86RegData@1@B:BYTE	; asmjit::x86RegData
CONST	SEGMENT
?x86OpCodePP@asmjit@@3QBEB DB 00H			; asmjit::x86OpCodePP
	DB	066H
	DB	0f3H
	DB	0f2H
	DB	00H
	DB	00H
	DB	00H
	DB	09bH
?NoInit@asmjit@@3U_NoInit@1@B	ORG $+1			; asmjit::NoInit
	ORG $+7
?x86OpCodeMM@asmjit@@3QBUX86OpCodeMM@1@B DB 00H		; asmjit::x86OpCodeMM
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	0fH
	DB	00H
	DB	00H
	DB	02H
	DB	0fH
	DB	038H
	DB	00H
	DB	02H
	DB	0fH
	DB	03aH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	0fH
	DB	01H
	DB	00H
?x86SegmentPrefix@asmjit@@3QBEB DB 00H			; asmjit::x86SegmentPrefix
	DB	026H
	DB	02eH
	DB	036H
	DB	03eH
	DB	064H
	DB	065H
	ORG $+1
?x86OpCodePushSeg@asmjit@@3QBEB DB 00H			; asmjit::x86OpCodePushSeg
	DB	06H
	DB	0eH
	DB	016H
	DB	01eH
	DB	0a0H
	DB	0a8H
	ORG $+1
?x86OpCodePopSeg@asmjit@@3QBEB DB 00H			; asmjit::x86OpCodePopSeg
	DB	07H
	DB	00H
	DB	017H
	DB	01fH
	DB	0a1H
	DB	0a9H
	ORG $+1
	ORG $+8
?x86PatchedHiRegs@asmjit@@3QBUVRegOp@Operand@1@B DB 01H	; asmjit::x86PatchedHiRegs
	DB	01H
	DW	0304H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DB	01H
	DB	01H
	DW	0305H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DB	01H
	DB	01H
	DW	0306H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DB	01H
	DB	01H
	DW	0307H
	DD	0ffffffffH
	DD	00H
	DD	00H
CONST	ENDS
PUBLIC	?pack32_2x8_1x16@IntUtil@asmjit@@SAIIII@Z	; asmjit::IntUtil::pack32_2x8_1x16
PUBLIC	?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z		; asmjit::IntUtil::pack32_4x8
PUBLIC	?getRuntime@CodeGen@asmjit@@QEBAPEAURuntime@2@XZ ; asmjit::CodeGen::getRuntime
PUBLIC	?getArch@CodeGen@asmjit@@QEBAIXZ		; asmjit::CodeGen::getArch
PUBLIC	?getBaseAddress@CodeGen@asmjit@@QEBA_KXZ	; asmjit::CodeGen::getBaseAddress
PUBLIC	?hasFeature@CodeGen@asmjit@@QEBA_NI@Z		; asmjit::CodeGen::hasFeature
PUBLIC	?getInstOptionsAndReset@CodeGen@asmjit@@QEAAIXZ	; asmjit::CodeGen::getInstOptionsAndReset
PUBLIC	?getData@PodVectorData@asmjit@@QEBAPEAXXZ	; asmjit::PodVectorData::getData
PUBLIC	??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z	; asmjit::Operand::Operand
PUBLIC	?getOp@Operand@asmjit@@QEBAIXZ			; asmjit::Operand::getOp
PUBLIC	?isReg@Operand@asmjit@@QEBA_NXZ			; asmjit::Operand::isReg
PUBLIC	?isMem@Operand@asmjit@@QEBA_NXZ			; asmjit::Operand::isMem
PUBLIC	?isImm@Operand@asmjit@@QEBA_NXZ			; asmjit::Operand::isImm
PUBLIC	?isRegType@Operand@asmjit@@QEBA_NI@Z		; asmjit::Operand::isRegType
PUBLIC	?getSize@Operand@asmjit@@QEBAIXZ		; asmjit::Operand::getSize
PUBLIC	?getId@Operand@asmjit@@QEBAIXZ			; asmjit::Operand::getId
PUBLIC	??0Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z		; asmjit::Reg::Reg
PUBLIC	?isRegType@Reg@asmjit@@QEBA_NI@Z		; asmjit::Reg::isRegType
PUBLIC	?getRegIndex@Reg@asmjit@@QEBAIXZ		; asmjit::Reg::getRegIndex
PUBLIC	?getMemType@BaseMem@asmjit@@QEBAIXZ		; asmjit::BaseMem::getMemType
PUBLIC	?isBaseIndexType@BaseMem@asmjit@@QEBA_NXZ	; asmjit::BaseMem::isBaseIndexType
PUBLIC	?getUInt8@Imm@asmjit@@QEBAEXZ			; asmjit::Imm::getUInt8
PUBLIC	?getUInt16@Imm@asmjit@@QEBAGXZ			; asmjit::Imm::getUInt16
PUBLIC	?getUInt32@Imm@asmjit@@QEBAIXZ			; asmjit::Imm::getUInt32
PUBLIC	?getInt64@Imm@asmjit@@QEBA_JXZ			; asmjit::Imm::getInt64
PUBLIC	??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z		; asmjit::IntUtil::isInt8<__int64>
PUBLIC	??$isInt32@_J@IntUtil@asmjit@@SA_N_J@Z		; asmjit::IntUtil::isInt32<__int64>
PUBLIC	?getRemainingSpace@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getRemainingSpace
PUBLIC	?getCursor@Assembler@asmjit@@QEBAPEAEXZ		; asmjit::Assembler::getCursor
PUBLIC	?setCursor@Assembler@asmjit@@QEAAXPEAE@Z	; asmjit::Assembler::setCursor
PUBLIC	?getOffset@Assembler@asmjit@@QEBA_KXZ		; asmjit::Assembler::getOffset
PUBLIC	?getCodeSize@Assembler@asmjit@@QEBA_KXZ		; asmjit::Assembler::getCodeSize
PUBLIC	?getTrampolineSize@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getTrampolineSize
PUBLIC	?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ; asmjit::Assembler::getLabelData
PUBLIC	?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ ; asmjit::PodVector<asmjit::LabelData>::getData
PUBLIC	??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z ; asmjit::PodVector<asmjit::LabelData>::operator[]
PUBLIC	?getLength@?$PodVector@URelocData@asmjit@@@asmjit@@QEBA_KXZ ; asmjit::PodVector<asmjit::RelocData>::getLength
PUBLIC	?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ ; asmjit::PodVector<asmjit::RelocData>::getData
PUBLIC	?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEBAPEBURelocData@2@XZ ; asmjit::PodVector<asmjit::RelocData>::getData
PUBLIC	?_grow@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAI_K@Z ; asmjit::PodVector<asmjit::RelocData>::_grow
PUBLIC	?append@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAIAEBURelocData@2@@Z ; asmjit::PodVector<asmjit::RelocData>::append
PUBLIC	??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z ; asmjit::PodVector<asmjit::RelocData>::operator[]
PUBLIC	?getEncodingId@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getEncodingId
PUBLIC	?getInstFlags@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getInstFlags
PUBLIC	?isLockable@X86InstExtendedInfo@asmjit@@QEBA_NXZ ; asmjit::X86InstExtendedInfo::isLockable
PUBLIC	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
PUBLIC	?getExtendedInfo@X86InstInfo@asmjit@@QEBAAEBUX86InstExtendedInfo@2@XZ ; asmjit::X86InstInfo::getExtendedInfo
PUBLIC	?getEncodingId@X86InstInfo@asmjit@@QEBAIXZ	; asmjit::X86InstInfo::getEncodingId
PUBLIC	?getInstFlags@X86InstInfo@asmjit@@QEBAIXZ	; asmjit::X86InstInfo::getInstFlags
PUBLIC	?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z	; asmjit::X86InstInfo::hasInstFlag
PUBLIC	?getPrimaryOpCode@X86InstInfo@asmjit@@QEBAIXZ	; asmjit::X86InstInfo::getPrimaryOpCode
PUBLIC	?reset@X86RegCount@asmjit@@QEAAXXZ		; asmjit::X86RegCount::reset
PUBLIC	??0X86Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z		; asmjit::X86Reg::X86Reg
PUBLIC	?isGp@X86Reg@asmjit@@QEBA_NXZ			; asmjit::X86Reg::isGp
PUBLIC	?isGpbLo@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isGpbLo
PUBLIC	?isGpq@X86Reg@asmjit@@QEBA_NXZ			; asmjit::X86Reg::isGpq
PUBLIC	?isMm@X86Reg@asmjit@@QEBA_NXZ			; asmjit::X86Reg::isMm
PUBLIC	?isXmm@X86Reg@asmjit@@QEBA_NXZ			; asmjit::X86Reg::isXmm
PUBLIC	?isYmm@X86Reg@asmjit@@QEBA_NXZ			; asmjit::X86Reg::isYmm
PUBLIC	?isSeg@X86Reg@asmjit@@QEBA_NXZ			; asmjit::X86Reg::isSeg
PUBLIC	?isGpbReg@X86Reg@asmjit@@SA_NAEBUOperand@2@@Z	; asmjit::X86Reg::isGpbReg
PUBLIC	??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z	; asmjit::X86GpReg::X86GpReg
PUBLIC	?hasSegment@X86Mem@asmjit@@QEBA_NXZ		; asmjit::X86Mem::hasSegment
PUBLIC	?getSegment@X86Mem@asmjit@@QEBAIXZ		; asmjit::X86Mem::getSegment
PUBLIC	?hasGpdBase@X86Mem@asmjit@@QEBA_NXZ		; asmjit::X86Mem::hasGpdBase
PUBLIC	?getVSib@X86Mem@asmjit@@QEBAIXZ			; asmjit::X86Mem::getVSib
PUBLIC	?getBase@X86Mem@asmjit@@QEBAIXZ			; asmjit::X86Mem::getBase
PUBLIC	?getIndex@X86Mem@asmjit@@QEBAIXZ		; asmjit::X86Mem::getIndex
PUBLIC	?hasBaseOrIndex@X86Mem@asmjit@@QEBA_NXZ		; asmjit::X86Mem::hasBaseOrIndex
PUBLIC	?getShift@X86Mem@asmjit@@QEBAIXZ		; asmjit::X86Mem::getShift
PUBLIC	?getDisplacement@X86Mem@asmjit@@QEBAHXZ		; asmjit::X86Mem::getDisplacement
PUBLIC	??0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z	; asmjit::X86Assembler::X86Assembler
PUBLIC	??1X86Assembler@asmjit@@UEAA@XZ			; asmjit::X86Assembler::~X86Assembler
PUBLIC	?setArch@X86Assembler@asmjit@@QEAAII@Z		; asmjit::X86Assembler::setArch
PUBLIC	?embedLabel@X86Assembler@asmjit@@QEAAIAEBULabel@2@@Z ; asmjit::X86Assembler::embedLabel
PUBLIC	?align@X86Assembler@asmjit@@UEAAIII@Z		; asmjit::X86Assembler::align
PUBLIC	?_relocCode@X86Assembler@asmjit@@UEBA_KPEAX_K@Z	; asmjit::X86Assembler::_relocCode
PUBLIC	?_emit@X86Assembler@asmjit@@UEAAIIAEBUOperand@2@000@Z ; asmjit::X86Assembler::_emit
PUBLIC	??_GX86Assembler@asmjit@@UEAAPEAXI@Z		; asmjit::X86Assembler::`scalar deleting destructor'
PUBLIC	?getVendorId@CpuInfo@asmjit@@QEBAIXZ		; asmjit::CpuInfo::getVendorId
PUBLIC	?getFamily@CpuInfo@asmjit@@QEBAIXZ		; asmjit::CpuInfo::getFamily
PUBLIC	??$isPowerOf2@I@IntUtil@asmjit@@SA_NI@Z		; asmjit::IntUtil::isPowerOf2<unsigned int>
PUBLIC	??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z		; asmjit::IntUtil::deltaTo<unsigned __int64>
PUBLIC	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z		; asmjit::IntUtil::alignTo<unsigned __int64>
PUBLIC	??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z		; asmjit::IntUtil::iMin<unsigned int>
PUBLIC	??$isInt8@H@IntUtil@asmjit@@SA_NH@Z		; asmjit::IntUtil::isInt8<int>
PUBLIC	??_7X86Assembler@asmjit@@6B@			; asmjit::X86Assembler::`vftable'
PUBLIC	??_R4X86Assembler@asmjit@@6B@			; asmjit::X86Assembler::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUX86Assembler@asmjit@@@8			; asmjit::X86Assembler `RTTI Type Descriptor'
PUBLIC	??_R3X86Assembler@asmjit@@8			; asmjit::X86Assembler::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2X86Assembler@asmjit@@8			; asmjit::X86Assembler::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@X86Assembler@asmjit@@8		; asmjit::X86Assembler::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Assembler@asmjit@@8		; asmjit::Assembler::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUAssembler@asmjit@@@8			; asmjit::Assembler `RTTI Type Descriptor'
PUBLIC	??_R3Assembler@asmjit@@8			; asmjit::Assembler::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Assembler@asmjit@@8			; asmjit::Assembler::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CodeGen@asmjit@@8			; asmjit::CodeGen::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUCodeGen@asmjit@@@8			; asmjit::CodeGen `RTTI Type Descriptor'
PUBLIC	??_R3CodeGen@asmjit@@8				; asmjit::CodeGen::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CodeGen@asmjit@@8				; asmjit::CodeGen::`RTTI Base Class Array'
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	memcpy:PROC
EXTRN	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z:PROC	; asmjit::CodeGen::setError
EXTRN	?_grow@PodVectorBase@asmjit@@IEAAI_K0@Z:PROC	; asmjit::PodVectorBase::_grow
EXTRN	??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z:PROC	; asmjit::Assembler::Assembler
EXTRN	??1Assembler@asmjit@@UEAA@XZ:PROC		; asmjit::Assembler::~Assembler
EXTRN	?_grow@Assembler@asmjit@@QEAAI_K@Z:PROC		; asmjit::Assembler::_grow
EXTRN	?_newLabelLink@Assembler@asmjit@@QEAAPEAULabelLink@2@XZ:PROC ; asmjit::Assembler::_newLabelLink
EXTRN	?bind@Assembler@asmjit@@UEAAIAEBULabel@2@@Z:PROC ; asmjit::Assembler::bind
EXTRN	?embed@Assembler@asmjit@@UEAAIPEBXI@Z:PROC	; asmjit::Assembler::embed
EXTRN	?make@Assembler@asmjit@@UEAAPEAXXZ:PROC		; asmjit::Assembler::make
EXTRN	??_EX86Assembler@asmjit@@UEAAPEAXI@Z:PROC	; asmjit::X86Assembler::`vector deleting destructor'
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	?_x86InstExtendedInfo@asmjit@@3QBUX86InstExtendedInfo@1@B:BYTE ; asmjit::_x86InstExtendedInfo
EXTRN	?_x86InstInfo@asmjit@@3QBUX86InstInfo@1@B:BYTE	; asmjit::_x86InstInfo
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hasFeature@CodeGen@asmjit@@QEBA_NI@Z DD imagerel $LN5
	DD	imagerel $LN5+76
	DD	imagerel $unwind$?hasFeature@CodeGen@asmjit@@QEBA_NI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getInstOptionsAndReset@CodeGen@asmjit@@QEAAIXZ DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?getInstOptionsAndReset@CodeGen@asmjit@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isReg@Operand@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$?isReg@Operand@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isMem@Operand@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$?isMem@Operand@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isImm@Operand@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$?isImm@Operand@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isRegType@Operand@asmjit@@QEBA_NI@Z DD imagerel $LN5
	DD	imagerel $LN5+145
	DD	imagerel $unwind$?isRegType@Operand@asmjit@@QEBA_NI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??0Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isRegType@Reg@asmjit@@QEBA_NI@Z DD imagerel $LN5
	DD	imagerel $LN5+53
	DD	imagerel $unwind$?isRegType@Reg@asmjit@@QEBA_NI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isBaseIndexType@BaseMem@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$?isBaseIndexType@BaseMem@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z DD imagerel $LN11
	DD	imagerel $LN11+116
	DD	imagerel $unwind$??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$isInt32@_J@IntUtil@asmjit@@SA_N_J@Z DD imagerel $LN15
	DD	imagerel $LN15+182
	DD	imagerel $unwind$??$isInt32@_J@IntUtil@asmjit@@SA_N_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getCodeSize@Assembler@asmjit@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?getCodeSize@Assembler@asmjit@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEBAPEBURelocData@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEBAPEBURelocData@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAI_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?_grow@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAI_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAIAEBURelocData@2@@Z DD imagerel $LN8
	DD	imagerel $LN8+167
	DD	imagerel $unwind$?append@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAIAEBURelocData@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isLockable@X86InstExtendedInfo@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+54
	DD	imagerel $unwind$?isLockable@X86InstExtendedInfo@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getEncodingId@X86InstInfo@asmjit@@QEBAIXZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$?getEncodingId@X86InstInfo@asmjit@@QEBAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getInstFlags@X86InstInfo@asmjit@@QEBAIXZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$?getInstFlags@X86InstInfo@asmjit@@QEBAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0X86Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??0X86Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isGp@X86Reg@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$?isGp@X86Reg@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isGpbLo@X86Reg@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$?isGpbLo@X86Reg@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isGpq@X86Reg@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$?isGpq@X86Reg@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isMm@X86Reg@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$?isMm@X86Reg@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isXmm@X86Reg@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$?isXmm@X86Reg@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isYmm@X86Reg@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$?isYmm@X86Reg@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isSeg@X86Reg@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$?isSeg@X86Reg@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isGpbReg@X86Reg@asmjit@@SA_NAEBUOperand@2@@Z DD imagerel $LN5
	DD	imagerel $LN5+130
	DD	imagerel $unwind$?isGpbReg@X86Reg@asmjit@@SA_NAEBUOperand@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hasSegment@X86Mem@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$?hasSegment@X86Mem@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hasGpdBase@X86Mem@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+111
	DD	imagerel $unwind$?hasGpdBase@X86Mem@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hasBaseOrIndex@X86Mem@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?hasBaseOrIndex@X86Mem@asmjit@@QEBA_NXZ
pdata	ENDS
pdata	SEGMENT
$pdata$??0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z DD imagerel $LN4
	DD	imagerel $LN4+342
	DD	imagerel $unwind$??0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z@4HA DD imagerel ?dtor$0@?0???0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z@4HA
	DD	imagerel ?dtor$0@?0???0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??1X86Assembler@asmjit@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$??1X86Assembler@asmjit@@UEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???1X86Assembler@asmjit@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1X86Assembler@asmjit@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1X86Assembler@asmjit@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1X86Assembler@asmjit@@UEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?setArch@X86Assembler@asmjit@@QEAAII@Z DD imagerel $LN4
	DD	imagerel $LN4+151
	DD	imagerel $unwind$?setArch@X86Assembler@asmjit@@QEAAII@Z
$pdata$?embedLabel@X86Assembler@asmjit@@QEAAIAEBULabel@2@@Z DD imagerel $LN19
	DD	imagerel $LN19+538
	DD	imagerel $unwind$?embedLabel@X86Assembler@asmjit@@QEAAIAEBULabel@2@@Z
$pdata$?align@X86Assembler@asmjit@@UEAAIII@Z DD imagerel $LN66
	DD	imagerel $LN66+1360
	DD	imagerel $unwind$?align@X86Assembler@asmjit@@UEAAIII@Z
$pdata$?_relocCode@X86Assembler@asmjit@@UEBA_KPEAX_K@Z DD imagerel $LN25
	DD	imagerel $LN25+818
	DD	imagerel $unwind$?_relocCode@X86Assembler@asmjit@@UEBA_KPEAX_K@Z
$pdata$?_emit@X86Assembler@asmjit@@UEAAIIAEBUOperand@2@000@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$?_emit@X86Assembler@asmjit@@UEAAIIAEBUOperand@2@000@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GX86Assembler@asmjit@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GX86Assembler@asmjit@@UEAAPEAXI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?x86RexFromOpCodeAndOptions@asmjit@@YAIII@Z DD imagerel ?x86RexFromOpCodeAndOptions@asmjit@@YAIII@Z
	DD	imagerel ?x86RexFromOpCodeAndOptions@asmjit@@YAIII@Z+43
	DD	imagerel $unwind$?x86RexFromOpCodeAndOptions@asmjit@@YAIII@Z
$pdata$?x86RexIsInvalid@asmjit@@YA_NI@Z DD imagerel ?x86RexIsInvalid@asmjit@@YA_NI@Z
	DD	imagerel ?x86RexIsInvalid@asmjit@@YA_NI@Z+43
	DD	imagerel $unwind$?x86RexIsInvalid@asmjit@@YA_NI@Z
$pdata$?x64IsRelative@asmjit@@YA_N_K0@Z DD imagerel ?x64IsRelative@asmjit@@YA_N_K0@Z
	DD	imagerel ?x64IsRelative@asmjit@@YA_N_K0@Z+50
	DD	imagerel $unwind$?x64IsRelative@asmjit@@YA_N_K0@Z
$pdata$?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z DD imagerel ?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z
	DD	imagerel ?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z+24
	DD	imagerel $unwind$?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$isPowerOf2@I@IntUtil@asmjit@@SA_NI@Z DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$??$isPowerOf2@I@IntUtil@asmjit@@SA_NI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??$X86Assembler_emit@$01@asmjit@@YAIPEAUAssembler@0@IPEBUOperand@0@111@Z DD imagerel ??$X86Assembler_emit@$01@asmjit@@YAIPEAUAssembler@0@IPEBUOperand@0@111@Z
	DD	imagerel ??$X86Assembler_emit@$01@asmjit@@YAIPEAUAssembler@0@IPEBUOperand@0@111@Z+40956
	DD	imagerel $unwind$??$X86Assembler_emit@$01@asmjit@@YAIPEAUAssembler@0@IPEBUOperand@0@111@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$isInt8@H@IntUtil@asmjit@@SA_NH@Z DD imagerel $LN11
	DD	imagerel $LN11+112
	DD	imagerel $unwind$??$isInt8@H@IntUtil@asmjit@@SA_NH@Z
pdata	ENDS
;	COMDAT ??_R2CodeGen@asmjit@@8
rdata$r	SEGMENT
??_R2CodeGen@asmjit@@8 DD imagerel ??_R1A@?0A@EA@CodeGen@asmjit@@8 ; asmjit::CodeGen::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3CodeGen@asmjit@@8
rdata$r	SEGMENT
??_R3CodeGen@asmjit@@8 DD 00H				; asmjit::CodeGen::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2CodeGen@asmjit@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUCodeGen@asmjit@@@8
data$rs	SEGMENT
??_R0?AUCodeGen@asmjit@@@8 DQ FLAT:??_7type_info@@6B@	; asmjit::CodeGen `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUCodeGen@asmjit@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CodeGen@asmjit@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CodeGen@asmjit@@8 DD imagerel ??_R0?AUCodeGen@asmjit@@@8 ; asmjit::CodeGen::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CodeGen@asmjit@@8
rdata$r	ENDS
;	COMDAT ??_R2Assembler@asmjit@@8
rdata$r	SEGMENT
??_R2Assembler@asmjit@@8 DD imagerel ??_R1A@?0A@EA@Assembler@asmjit@@8 ; asmjit::Assembler::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@CodeGen@asmjit@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3Assembler@asmjit@@8
rdata$r	SEGMENT
??_R3Assembler@asmjit@@8 DD 00H				; asmjit::Assembler::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2Assembler@asmjit@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUAssembler@asmjit@@@8
data$rs	SEGMENT
??_R0?AUAssembler@asmjit@@@8 DQ FLAT:??_7type_info@@6B@	; asmjit::Assembler `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUAssembler@asmjit@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@Assembler@asmjit@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Assembler@asmjit@@8 DD imagerel ??_R0?AUAssembler@asmjit@@@8 ; asmjit::Assembler::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Assembler@asmjit@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@X86Assembler@asmjit@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@X86Assembler@asmjit@@8 DD imagerel ??_R0?AUX86Assembler@asmjit@@@8 ; asmjit::X86Assembler::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3X86Assembler@asmjit@@8
rdata$r	ENDS
;	COMDAT ??_R2X86Assembler@asmjit@@8
rdata$r	SEGMENT
??_R2X86Assembler@asmjit@@8 DD imagerel ??_R1A@?0A@EA@X86Assembler@asmjit@@8 ; asmjit::X86Assembler::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Assembler@asmjit@@8
	DD	imagerel ??_R1A@?0A@EA@CodeGen@asmjit@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3X86Assembler@asmjit@@8
rdata$r	SEGMENT
??_R3X86Assembler@asmjit@@8 DD 00H			; asmjit::X86Assembler::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2X86Assembler@asmjit@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUX86Assembler@asmjit@@@8
data$rs	SEGMENT
??_R0?AUX86Assembler@asmjit@@@8 DQ FLAT:??_7type_info@@6B@ ; asmjit::X86Assembler `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUX86Assembler@asmjit@@', 00H
data$rs	ENDS
;	COMDAT ??_R4X86Assembler@asmjit@@6B@
rdata$r	SEGMENT
??_R4X86Assembler@asmjit@@6B@ DD 01H			; asmjit::X86Assembler::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AUX86Assembler@asmjit@@@8
	DD	imagerel ??_R3X86Assembler@asmjit@@8
	DD	imagerel ??_R4X86Assembler@asmjit@@6B@
rdata$r	ENDS
;	COMDAT ?nop11@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
CONST	SEGMENT
?nop11@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB DB 066H ; `asmjit::X86Assembler::align'::`18'::nop11
	DB	066H
	DB	066H
	DB	0fH
	DB	01fH
	DB	084H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?nop10@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
CONST	SEGMENT
?nop10@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB DB 066H ; `asmjit::X86Assembler::align'::`18'::nop10
	DB	066H
	DB	0fH
	DB	01fH
	DB	084H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?nop9@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
CONST	SEGMENT
?nop9@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB DB 066H ; `asmjit::X86Assembler::align'::`18'::nop9
	DB	0fH
	DB	01fH
	DB	084H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?nop8@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
CONST	SEGMENT
?nop8@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB DB 0fH ; `asmjit::X86Assembler::align'::`18'::nop8
	DB	01fH
	DB	084H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?nop7@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
CONST	SEGMENT
?nop7@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB DB 0fH ; `asmjit::X86Assembler::align'::`18'::nop7
	DB	01fH
	DB	080H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?nop6@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
CONST	SEGMENT
?nop6@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB DB 066H ; `asmjit::X86Assembler::align'::`18'::nop6
	DB	0fH
	DB	01fH
	DB	044H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?nop5@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
CONST	SEGMENT
?nop5@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB DB 0fH ; `asmjit::X86Assembler::align'::`18'::nop5
	DB	01fH
	DB	044H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?nop4@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
CONST	SEGMENT
?nop4@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB DB 0fH ; `asmjit::X86Assembler::align'::`18'::nop4
	DB	01fH
	DB	040H
	DB	00H
CONST	ENDS
;	COMDAT ?nop3@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
CONST	SEGMENT
?nop3@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB DB 0fH ; `asmjit::X86Assembler::align'::`18'::nop3
	DB	01fH
	DB	00H
CONST	ENDS
;	COMDAT ?nop2@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
CONST	SEGMENT
?nop2@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB DB 066H ; `asmjit::X86Assembler::align'::`18'::nop2
	DB	090H
CONST	ENDS
;	COMDAT ?nop1@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
CONST	SEGMENT
?nop1@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB DB 090H ; `asmjit::X86Assembler::align'::`18'::nop1
CONST	ENDS
;	COMDAT ??_7X86Assembler@asmjit@@6B@
CONST	SEGMENT
??_7X86Assembler@asmjit@@6B@ DQ FLAT:??_R4X86Assembler@asmjit@@6B@ ; asmjit::X86Assembler::`vftable'
	DQ	FLAT:??_EX86Assembler@asmjit@@UEAAPEAXI@Z
	DQ	FLAT:?make@Assembler@asmjit@@UEAAPEAXXZ
	DQ	FLAT:?bind@Assembler@asmjit@@UEAAIAEBULabel@2@@Z
	DQ	FLAT:?embed@Assembler@asmjit@@UEAAIPEBXI@Z
	DQ	FLAT:?align@X86Assembler@asmjit@@UEAAIII@Z
	DQ	FLAT:?_relocCode@X86Assembler@asmjit@@UEBA_KPEAX_K@Z
	DQ	FLAT:?_emit@X86Assembler@asmjit@@UEAAIIAEBUOperand@2@000@Z
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$isInt8@H@IntUtil@asmjit@@SA_NH@Z DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$isPowerOf2@I@IntUtil@asmjit@@SA_NI@Z DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GX86Assembler@asmjit@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??$X86Assembler_emit@$01@asmjit@@YAIPEAUAssembler@0@IPEBUOperand@0@111@Z
	DD	024H
	DD	09e2dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?embedLabel@X86Assembler@asmjit@@QEAAIAEBULabel@2@@Z
	DD	018H
	DD	0208H
voltbl	ENDS
xdata	SEGMENT
$unwind$??0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z DD 011311H
	DD	0c213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z
$cppxdata$??0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z DB 08H
	DD	imagerel $stateUnwindMap$??0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z
	DD	imagerel $ip2state$??0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z
$stateUnwindMap$??0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z@4HA
$ip2state$??0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z DB 06H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	0a5H, 04H
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0???0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z@4HA DD 020601H
	DD	050023206H
$unwind$??1X86Assembler@asmjit@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1X86Assembler@asmjit@@UEAA@XZ
$cppxdata$??1X86Assembler@asmjit@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1X86Assembler@asmjit@@UEAA@XZ
	DD	imagerel $ip2state$??1X86Assembler@asmjit@@UEAA@XZ
$stateUnwindMap$??1X86Assembler@asmjit@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1X86Assembler@asmjit@@UEAA@XZ@4HA
$ip2state$??1X86Assembler@asmjit@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0???1X86Assembler@asmjit@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?setArch@X86Assembler@asmjit@@QEAAII@Z DD 010d01H
	DD	0420dH
$unwind$?embedLabel@X86Assembler@asmjit@@QEAAIAEBULabel@2@@Z DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$?align@X86Assembler@asmjit@@UEAAIII@Z DD 011201H
	DD	0e212H
$unwind$?_relocCode@X86Assembler@asmjit@@UEBA_KPEAX_K@Z DD 021601H
	DD	0130116H
$unwind$?_emit@X86Assembler@asmjit@@UEAAIIAEBUOperand@2@000@Z DD 011701H
	DD	06217H
$unwind$?x86RexFromOpCodeAndOptions@asmjit@@YAIII@Z DD 010c01H
	DD	0220cH
$unwind$?x86RexIsInvalid@asmjit@@YA_NI@Z DD 010801H
	DD	02208H
$unwind$?x64IsRelative@asmjit@@YA_N_K0@Z DD 010e01H
	DD	0620eH
$unwind$?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z DD 010901H
	DD	04209H
$unwind$??$X86Assembler_emit@$01@asmjit@@YAIPEAUAssembler@0@IPEBUOperand@0@111@Z DD 022c19H
	DD	0b1011aH
	DD	imagerel __GSHandlerCheck
	DD	0570H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hasBaseOrIndex@X86Mem@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hasGpdBase@X86Mem@asmjit@@QEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hasSegment@X86Mem@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isGpbReg@X86Reg@asmjit@@SA_NAEBUOperand@2@@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isSeg@X86Reg@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isYmm@X86Reg@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isXmm@X86Reg@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isMm@X86Reg@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isGpq@X86Reg@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isGpbLo@X86Reg@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isGp@X86Reg@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0X86Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getInstFlags@X86InstInfo@asmjit@@QEBAIXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getEncodingId@X86InstInfo@asmjit@@QEBAIXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isLockable@X86InstExtendedInfo@asmjit@@QEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAIAEBURelocData@2@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAI_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEBAPEBURelocData@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getCodeSize@Assembler@asmjit@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$isInt32@_J@IntUtil@asmjit@@SA_N_J@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isBaseIndexType@BaseMem@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isRegType@Reg@asmjit@@QEBA_NI@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isRegType@Operand@asmjit@@QEBA_NI@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isImm@Operand@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isMem@Operand@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isReg@Operand@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getInstOptionsAndReset@CodeGen@asmjit@@QEAAIXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hasFeature@CodeGen@asmjit@@QEBA_NI@Z DD 010d01H
	DD	0220dH
xdata	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$isInt8@H@IntUtil@asmjit@@SA_NH@Z
_TEXT	SEGMENT
tv67 = 0
tv69 = 4
tv72 = 8
x$ = 32
??$isInt8@H@IntUtil@asmjit@@SA_NH@Z PROC		; asmjit::IntUtil::isInt8<int>, COMDAT

; 149  :   static ASMJIT_INLINE bool isInt8(T x) {

$LN11:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 150  :     if (IntTraits<T>::kIsSigned)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@isInt8

; 151  :       return sizeof(T) <= sizeof(int8_t) ? true : x >= T(-128) && x <= T(127);

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN7@isInt8
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN8@isInt8
$LN7@isInt8:
	cmp	DWORD PTR x$[rsp], -128			; ffffffffffffff80H
	jl	SHORT $LN5@isInt8
	cmp	DWORD PTR x$[rsp], 127			; 0000007fH
	jg	SHORT $LN5@isInt8
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN6@isInt8
$LN5@isInt8:
	mov	DWORD PTR tv67[rsp], 0
$LN6@isInt8:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR tv69[rsp], eax
$LN8@isInt8:
	movzx	eax, BYTE PTR tv69[rsp]
	jmp	SHORT $LN1@isInt8
	jmp	SHORT $LN3@isInt8
$LN2@isInt8:

; 152  :     else
; 153  :       return x <= T(127);

	cmp	DWORD PTR x$[rsp], 127			; 0000007fH
	jg	SHORT $LN9@isInt8
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN10@isInt8
$LN9@isInt8:
	mov	DWORD PTR tv72[rsp], 0
$LN10@isInt8:
	movzx	eax, BYTE PTR tv72[rsp]
$LN3@isInt8:
$LN1@isInt8:

; 154  :   }

	add	rsp, 24
	ret	0
??$isInt8@H@IntUtil@asmjit@@SA_NH@Z ENDP		; asmjit::IntUtil::isInt8<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z
_TEXT	SEGMENT
tv65 = 0
a$ = 32
b$ = 40
??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z PROC		; asmjit::IntUtil::iMin<unsigned int>, COMDAT

; 119  :   static ASMJIT_INLINE T iMin(const T& a, const T& b) { return a < b ? a : b; }

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jae	SHORT $LN3@iMin
	mov	rax, QWORD PTR a$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv65[rsp], eax
	jmp	SHORT $LN4@iMin
$LN3@iMin:
	mov	rax, QWORD PTR b$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv65[rsp], eax
$LN4@iMin:
	mov	eax, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z ENDP		; asmjit::IntUtil::iMin<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z
_TEXT	SEGMENT
base$ = 8
alignment$ = 16
??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z PROC		; asmjit::IntUtil::alignTo<unsigned __int64>, COMDAT

; 401  :   static ASMJIT_INLINE T alignTo(T base, T alignment) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 402  :     return (base + (alignment - 1)) & ~(alignment - 1);

	mov	rax, QWORD PTR base$[rsp]
	mov	rcx, QWORD PTR alignment$[rsp]
	lea	rax, QWORD PTR [rax+rcx-1]
	mov	rcx, QWORD PTR alignment$[rsp]
	dec	rcx
	not	rcx
	and	rax, rcx

; 403  :   }

	ret	0
??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z ENDP		; asmjit::IntUtil::alignTo<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
opCode$ = 32
cursor$ = 40
opReg$ = 48
encoded$ = 52
$S1$ = 56
imLen$ = 64
dispOffset$ = 68
imVal$ = 72
options$ = 80
mBase$ = 84
mIndex$ = 88
self$ = 96
vex_XvvvvLpp$1 = 104
vex_XvvvvLpp$2 = 108
vex_XvvvvLpp$3 = 112
extendedInfo$ = 120
imm8$4 = 128
rex$5 = 132
label$ = 136
vex_rxbmmmmm$6 = 144
vex_rxbmmmmm$7 = 148
dispSize$ = 152
xop_XvvvvLpp$8 = 156
vex_rxbmmmmm$9 = 160
vex_XvvvvLpp$10 = 164
rex$11 = 168
vex_rxbmmmmm$12 = 172
rex$13 = 176
xop_rxbmmmmm$14 = 180
ppCode$15 = 184
ppCode$16 = 185
ppCode$17 = 186
ppCode$18 = 187
ppCode$19 = 188
vex_XvvvvLpp$20 = 192
info$ = 200
memSize$21 = 208
memSize$22 = 212
rex$23 = 216
relocId$ = 224
tv4829 = 232
shift$24 = 236
shift$25 = 240
tv329 = 244
tv353 = 248
tv376 = 252
tv410 = 256
tv435 = 260
tv449 = 264
tv450 = 268
tv469 = 272
tv472 = 276
tv473 = 280
tv667 = 284
tv678 = 288
tv713 = 292
tv732 = 296
tv753 = 300
tv784 = 304
tv790 = 308
tv1163 = 312
tv1211 = 316
tv1253 = 320
tv1291 = 324
tv1312 = 328
tv1328 = 332
tv1351 = 336
tv1390 = 340
tv1422 = 344
segment$26 = 348
tv1479 = 352
tv1483 = 356
segment$27 = 360
tv1556 = 364
tv1588 = 368
tv1606 = 372
tv1705 = 376
tv1728 = 380
tv1751 = 384
tv1786 = 388
tv1825 = 392
tv1875 = 396
tv1881 = 400
tv1919 = 404
tv2036 = 408
tv2047 = 412
tv2136 = 416
tv2152 = 420
tv2174 = 424
tv2197 = 428
tv2431 = 432
tv2453 = 436
vSib$28 = 440
tv3611 = 444
ppIndex$29 = 448
mmIndex$30 = 452
ppIndex$31 = 456
mmIndex$32 = 460
ppIndex$33 = 464
mmIndex$34 = 468
ppIndex$35 = 472
tv4392 = 476
tv4397 = 480
mmIndex$36 = 484
ppIndex$37 = 488
tv5054 = 492
tv5059 = 496
tv5174 = 500
tv5179 = 504
tv5512 = 508
tv5517 = 512
trampolineSize$38 = 516
errval_$39 = 520
tv188 = 524
index$40 = 528
tv209 = 532
index$41 = 536
tv227 = 540
tv233 = 544
tv258 = 548
tv281 = 552
link$42 = 560
$T43 = 568
$T44 = 572
$T45 = 576
$T46 = 580
tv2484 = 584
tv2486 = 588
tv2552 = 592
tv2554 = 596
tv2642 = 600
tv2644 = 604
tv2683 = 608
tv2714 = 612
tv2753 = 616
tv2755 = 620
tv2786 = 624
tv2788 = 628
tv2825 = 632
tv2827 = 636
tv2858 = 640
tv2860 = 644
tv2897 = 648
tv2899 = 652
tv2915 = 656
tv2913 = 660
tv2930 = 664
tv2928 = 668
tv2948 = 672
tv2950 = 676
tv2974 = 680
tv2972 = 684
tv2989 = 688
tv2987 = 692
tv3007 = 696
tv3009 = 700
tv3035 = 704
tv3033 = 708
tv3050 = 712
tv3048 = 716
tv3064 = 720
tv3062 = 724
tv3079 = 728
tv3077 = 732
tv3103 = 736
tv3101 = 740
tv3118 = 744
tv3116 = 748
tv3136 = 752
tv3138 = 756
tv3178 = 760
tv3180 = 764
tv3196 = 768
tv3194 = 772
tv3211 = 776
tv3209 = 780
tv3246 = 784
tv3244 = 788
tv3261 = 792
tv3259 = 796
tv3292 = 800
tv3294 = 804
tv3310 = 808
tv3308 = 812
tv3325 = 816
tv3323 = 820
tv3343 = 824
tv3341 = 828
tv3361 = 832
tv3363 = 836
tv3379 = 840
tv3377 = 844
tv3394 = 848
tv3392 = 852
tv3458 = 856
tv3460 = 860
tv3503 = 864
tv3505 = 868
tv3529 = 872
tv3527 = 876
tv3552 = 880
tv3550 = 884
tv3576 = 888
tv3574 = 892
tv3604 = 896
tv3602 = 900
tv3626 = 904
tv3624 = 908
vSib$47 = 912
tv3647 = 916
tv3649 = 920
tv3669 = 924
tv3671 = 928
tv3695 = 932
tv3693 = 936
tv3718 = 940
tv3716 = 944
tv3742 = 948
tv3740 = 952
tv3760 = 956
tv3762 = 960
tv3789 = 964
tv3787 = 968
tv3804 = 972
tv3802 = 976
tv3818 = 980
tv3816 = 984
tv3834 = 988
tv3832 = 992
tv3849 = 996
tv3847 = 1000
tv3863 = 1004
tv3861 = 1008
tv3902 = 1012
tv3904 = 1016
tv3928 = 1020
tv3926 = 1024
tv3943 = 1028
tv3941 = 1032
tv3961 = 1036
tv3963 = 1040
tv3989 = 1044
tv3987 = 1048
tv4004 = 1052
tv4002 = 1056
tv4022 = 1060
tv4024 = 1064
tv4048 = 1068
tv4046 = 1072
tv4071 = 1076
tv4069 = 1080
tv4095 = 1084
tv4093 = 1088
shift$48 = 1092
shift$49 = 1096
vex_rxbmmmmm$50 = 1100
shift$51 = 1104
tv75 = 1108
tv79 = 1112
$T52 = 1116
$T53 = 1120
tv438 = 1124
$T54 = 1128
$T55 = 1132
$T56 = 1136
$T57 = 1140
offs$58 = 1144
offs$59 = 1152
mmCode$60 = 1160
mmCode$61 = 1168
mmCode$62 = 1176
mmCode$63 = 1184
offs$64 = 1192
tv4727 = 1200
tv5402 = 1208
baseAddress$65 = 1216
offs$66 = 1224
tv4703 = 1232
tv4724 = 1240
tv4731 = 1248
tv4729 = 1256
tv5378 = 1264
tv5399 = 1272
tv5406 = 1280
tv5404 = 1288
tv5593 = 1296
kRel8Size$67 = 1304
kRel32Size$68 = 1312
rd$69 = 1320
rd$70 = 1344
rd$71 = 1368
__$ArrayPad$ = 1392
self_$ = 1424
code$ = 1432
o0$ = 1440
o1$ = 1448
o2$ = 1456
o3$ = 1464
??$X86Assembler_emit@$01@asmjit@@YAIPEAUAssembler@0@IPEBUOperand@0@111@Z PROC ; asmjit::X86Assembler_emit<2>

; 985  : static Error ASMJIT_CDECL X86Assembler_emit(Assembler* self_, uint32_t code, const Operand* o0, const Operand* o1, const Operand* o2, const Operand* o3) {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1416				; 00000588H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 986  :   X86Assembler* self = static_cast<X86Assembler*>(self_);

	mov	rax, QWORD PTR self_$[rsp]
	mov	QWORD PTR self$[rsp], rax

; 987  : 
; 988  :   uint8_t* cursor = self->getCursor();

	mov	rcx, QWORD PTR self$[rsp]
	call	?getCursor@Assembler@asmjit@@QEBAPEAEXZ	; asmjit::Assembler::getCursor
	mov	QWORD PTR cursor$[rsp], rax

; 989  :   uint32_t encoded = o0->getOp() + (o1->getOp() << 3) + (o2->getOp() << 6);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getOp@Operand@asmjit@@QEBAIXZ		; asmjit::Operand::getOp
	mov	DWORD PTR tv75[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getOp@Operand@asmjit@@QEBAIXZ		; asmjit::Operand::getOp
	mov	ecx, DWORD PTR tv75[rsp]
	lea	eax, DWORD PTR [rcx+rax*8]
	mov	DWORD PTR tv79[rsp], eax
	mov	rcx, QWORD PTR o2$[rsp]
	call	?getOp@Operand@asmjit@@QEBAIXZ		; asmjit::Operand::getOp
	shl	eax, 6
	mov	ecx, DWORD PTR tv79[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR encoded$[rsp], eax

; 990  :   uint32_t options = self->getInstOptionsAndReset();

	mov	rcx, QWORD PTR self$[rsp]
	call	?getInstOptionsAndReset@CodeGen@asmjit@@QEAAIXZ ; asmjit::CodeGen::getInstOptionsAndReset
	mov	DWORD PTR options$[rsp], eax

; 991  : 
; 992  :   // Invalid instruction.
; 993  :   if (code >= _kX86InstIdCount) {

	cmp	DWORD PTR code$[rsp], 1062		; 00000426H
	jb	SHORT $LN996@X86Assembl

; 994  :     self->_comment = NULL;

	mov	rax, QWORD PTR self$[rsp]
	mov	QWORD PTR [rax+104], 0

; 995  :     return self->setError(kErrorUnknownInst);

	xor	r8d, r8d
	mov	edx, 8
	mov	rcx, QWORD PTR self$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	$LN1@X86Assembl
$LN996@X86Assembl:

; 996  :   }
; 997  : 
; 998  :   // Instruction opcode.
; 999  :   uint32_t opCode;
; 1000 :   // ModR/M opcode or register code.
; 1001 :   uint32_t opReg;
; 1002 : 
; 1003 :   // ModR/M, both rmReg and rmMem should refer to the same variable since they
; 1004 :   // are never used together - either `rmReg` or `rmMem`.
; 1005 :   union {
; 1006 :     // ModR/M - register code.
; 1007 :     uintptr_t rmReg;
; 1008 :     // ModR/M - Memory operand.
; 1009 :     const X86Mem* rmMem;
; 1010 :   };
; 1011 : 
; 1012 :   // Immediate value.
; 1013 :   int64_t imVal = 0;

	mov	QWORD PTR imVal$[rsp], 0

; 1014 :   // Immediate length.
; 1015 :   uint32_t imLen = 0;

	mov	DWORD PTR imLen$[rsp], 0

; 1016 : 
; 1017 :   // Memory operand base register index.
; 1018 :   uint32_t mBase;
; 1019 :   // Memory operand index register index.
; 1020 :   uint32_t mIndex;
; 1021 : 
; 1022 :   // Label.
; 1023 :   LabelData* label;
; 1024 :   // Displacement offset
; 1025 :   int32_t dispOffset;
; 1026 :   // Displacement size.
; 1027 :   uint32_t dispSize = 0;

	mov	DWORD PTR dispSize$[rsp], 0

; 1028 :   // Displacement relocation id.
; 1029 :   intptr_t relocId;
; 1030 : 
; 1031 : #if defined(ASMJIT_DEBUG)
; 1032 :   bool assertIllegal = false;
; 1033 : #endif // ASMJIT_DEBUG
; 1034 : 
; 1035 :   const X86InstInfo& info = _x86InstInfo[code];

	mov	eax, DWORD PTR code$[rsp]
	lea	rcx, OFFSET FLAT:?_x86InstInfo@asmjit@@3QBUX86InstInfo@1@B ; asmjit::_x86InstInfo
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR info$[rsp], rax

; 1036 :   const X86InstExtendedInfo& extendedInfo = info.getExtendedInfo();

	mov	rcx, QWORD PTR info$[rsp]
	call	?getExtendedInfo@X86InstInfo@asmjit@@QEBAAEBUX86InstExtendedInfo@2@XZ ; asmjit::X86InstInfo::getExtendedInfo
	mov	QWORD PTR extendedInfo$[rsp], rax

; 1037 : 
; 1038 :   // Grow request happens rarely. C++ compiler generates better code if it is
; 1039 :   // handled at the end of the function.
; 1040 :   if ((size_t)(self->_end - cursor) < 16)

	mov	rax, QWORD PTR self$[rsp]
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	rax, QWORD PTR [rax+80]
	sub	rax, rcx
	cmp	rax, 16
	jae	SHORT $LN997@X86Assembl

; 1041 :     goto _GrowBuffer;

	jmp	$LN998@X86Assembl
	jmp	$_GrowBuffer$1948
$LN997@X86Assembl:
$_Prepare$1949:

; 1042 : 
; 1043 :   // --------------------------------------------------------------------------
; 1044 :   // [Prepare]
; 1045 :   // --------------------------------------------------------------------------
; 1046 : 
; 1047 : _Prepare:
; 1048 :   opCode = info.getPrimaryOpCode();

	mov	rcx, QWORD PTR info$[rsp]
	call	?getPrimaryOpCode@X86InstInfo@asmjit@@QEBAIXZ ; asmjit::X86InstInfo::getPrimaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 1049 :   opReg = x86ExtractO(opCode);

	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86ExtractO@asmjit@@YAII@Z		; asmjit::x86ExtractO
	mov	DWORD PTR opReg$[rsp], eax

; 1050 : 
; 1051 :   if (Arch == kArchX86) {

	xor	eax, eax
	test	eax, eax
	je	$LN999@X86Assembl

; 1052 :     // Check if one or more register operand is one of AH, BH, CH, or DH and
; 1053 :     // patch them to ensure that the binary code with correct byte-index (4-7)
; 1054 :     // is generated.
; 1055 :     if (o0->isRegType(kX86RegTypeGpbHi))

	mov	edx, 2
	mov	rcx, QWORD PTR o0$[rsp]
	call	?isRegType@Operand@asmjit@@QEBA_NI@Z	; asmjit::Operand::isRegType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1001@X86Assembl

; 1056 :       o0 = (const Operand*)(&x86PatchedHiRegs[x86OpReg(o0)]);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?x86PatchedHiRegs@asmjit@@3QBUVRegOp@Operand@1@B
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR o0$[rsp], rax
$LN1001@X86Assembl:

; 1057 : 
; 1058 :     if (o1->isRegType(kX86RegTypeGpbHi))

	mov	edx, 2
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isRegType@Operand@asmjit@@QEBA_NI@Z	; asmjit::Operand::isRegType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1002@X86Assembl

; 1059 :       o1 = (const Operand*)(&x86PatchedHiRegs[x86OpReg(o1)]);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?x86PatchedHiRegs@asmjit@@3QBUVRegOp@Operand@1@B
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR o1$[rsp], rax
$LN1002@X86Assembl:

; 1060 :   }

	jmp	$LN1000@X86Assembl
$LN999@X86Assembl:

; 1061 :   else {
; 1062 :     // `W` field.
; 1063 :     ASMJIT_ASSERT(static_cast<uint32_t>(kX86InstOptionRex) ==
; 1064 :                   static_cast<uint32_t>(kX86ByteRex));
; 1065 : 
; 1066 :     // Check if one or more register operand is one of BPL, SPL, SIL, DIL and
; 1067 :     // force a REX prefix to be emitted in such case.
; 1068 :     if (X86Reg::isGpbReg(*o0)) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isGpbReg@X86Reg@asmjit@@SA_NAEBUOperand@2@@Z ; asmjit::X86Reg::isGpbReg
	movzx	eax, al
	test	eax, eax
	je	$LN1003@X86Assembl

; 1069 :       uint32_t index = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR index$40[rsp], eax

; 1070 :       if (static_cast<const X86Reg*>(o0)->isGpbLo()) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isGpbLo@X86Reg@asmjit@@QEBA_NXZ	; asmjit::X86Reg::isGpbLo
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1004@X86Assembl

; 1071 :         options |= (index >= 4) ? kX86InstOptionRex : 0;

	cmp	DWORD PTR index$40[rsp], 4
	jb	SHORT $LN1824@X86Assembl
	mov	DWORD PTR tv188[rsp], 64		; 00000040H
	jmp	SHORT $LN1825@X86Assembl
$LN1824@X86Assembl:
	mov	DWORD PTR tv188[rsp], 0
$LN1825@X86Assembl:
	mov	eax, DWORD PTR tv188[rsp]
	mov	ecx, DWORD PTR options$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR options$[rsp], eax

; 1072 :       }

	jmp	SHORT $LN1005@X86Assembl
$LN1004@X86Assembl:

; 1073 :       else {
; 1074 :         options |= _kX86InstOptionNoRex;

	mov	eax, DWORD PTR options$[rsp]
	bts	eax, 7
	mov	DWORD PTR options$[rsp], eax

; 1075 :         o0 = reinterpret_cast<const Operand*>(&x86PatchedHiRegs[index]);

	mov	eax, DWORD PTR index$40[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?x86PatchedHiRegs@asmjit@@3QBUVRegOp@Operand@1@B
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR o0$[rsp], rax
$LN1005@X86Assembl:
$LN1003@X86Assembl:

; 1076 :       }
; 1077 :     }
; 1078 : 
; 1079 :     if (X86Reg::isGpbReg(*o1)) {

	mov	rcx, QWORD PTR o1$[rsp]
	call	?isGpbReg@X86Reg@asmjit@@SA_NAEBUOperand@2@@Z ; asmjit::X86Reg::isGpbReg
	movzx	eax, al
	test	eax, eax
	je	$LN1006@X86Assembl

; 1080 :       uint32_t index = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR index$41[rsp], eax

; 1081 :       if (static_cast<const X86Reg*>(o1)->isGpbLo()) {

	mov	rcx, QWORD PTR o1$[rsp]
	call	?isGpbLo@X86Reg@asmjit@@QEBA_NXZ	; asmjit::X86Reg::isGpbLo
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1007@X86Assembl

; 1082 :         options |= (index >= 4) ? kX86InstOptionRex : 0;

	cmp	DWORD PTR index$41[rsp], 4
	jb	SHORT $LN1826@X86Assembl
	mov	DWORD PTR tv209[rsp], 64		; 00000040H
	jmp	SHORT $LN1827@X86Assembl
$LN1826@X86Assembl:
	mov	DWORD PTR tv209[rsp], 0
$LN1827@X86Assembl:
	mov	eax, DWORD PTR tv209[rsp]
	mov	ecx, DWORD PTR options$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR options$[rsp], eax

; 1083 :       }

	jmp	SHORT $LN1008@X86Assembl
$LN1007@X86Assembl:

; 1084 :       else {
; 1085 :         options |= _kX86InstOptionNoRex;

	mov	eax, DWORD PTR options$[rsp]
	bts	eax, 7
	mov	DWORD PTR options$[rsp], eax

; 1086 :         o1 = reinterpret_cast<const Operand*>(&x86PatchedHiRegs[index]);

	mov	eax, DWORD PTR index$41[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?x86PatchedHiRegs@asmjit@@3QBUVRegOp@Operand@1@B
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR o1$[rsp], rax
$LN1008@X86Assembl:
$LN1006@X86Assembl:
$LN1000@X86Assembl:

; 1087 :       }
; 1088 :     }
; 1089 :   }
; 1090 : 
; 1091 :   // --------------------------------------------------------------------------
; 1092 :   // [Lock-Prefix]
; 1093 :   // --------------------------------------------------------------------------
; 1094 : 
; 1095 :   if (options & kX86InstOptionLock) {

	mov	eax, DWORD PTR options$[rsp]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN1009@X86Assembl

; 1096 :     if (!extendedInfo.isLockable())

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?isLockable@X86InstExtendedInfo@asmjit@@QEBA_NXZ ; asmjit::X86InstExtendedInfo::isLockable
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1010@X86Assembl

; 1097 :       goto _IllegalInst;

	jmp	$LN1011@X86Assembl
	jmp	$_IllegalInst$1950
$LN1010@X86Assembl:
$LN4@X86Assembl:

; 1098 :     EMIT_BYTE(0xF0);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 240			; 000000f0H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@X86Assembl
$LN1009@X86Assembl:

; 1099 :   }
; 1100 : 
; 1101 :   // --------------------------------------------------------------------------
; 1102 :   // [Group]
; 1103 :   // --------------------------------------------------------------------------
; 1104 : 
; 1105 :   switch (info.getEncodingId()) {

	mov	rcx, QWORD PTR info$[rsp]
	call	?getEncodingId@X86InstInfo@asmjit@@QEBAIXZ ; asmjit::X86InstInfo::getEncodingId
	mov	DWORD PTR tv227[rsp], eax
	cmp	DWORD PTR tv227[rsp], 108		; 0000006cH
	ja	$LN5@X86Assembl
	mov	eax, DWORD PTR tv227[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN1947@X86Assembl[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN1012@X86Assembl:

; 1106 :     // ------------------------------------------------------------------------
; 1107 :     // [None]
; 1108 :     // ------------------------------------------------------------------------
; 1109 : 
; 1110 :     case kX86InstEncodingIdNone:
; 1111 :       goto _EmitDone;

	jmp	$LN1013@X86Assembl
	jmp	$_EmitDone$1951
$LN1014@X86Assembl:
$LN9@X86Assembl:

; 1112 : 
; 1113 :     // ------------------------------------------------------------------------
; 1114 :     // [X86]
; 1115 :     // ------------------------------------------------------------------------
; 1116 : 
; 1117 :     case kX86InstEncodingIdX86Op_66H:
; 1118 :       ADD_66H_P(true);

	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 20
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN9@X86Assembl
$LN1015@X86Assembl:

; 1119 :       // ... Fall through ...
; 1120 : 
; 1121 :     case kX86InstEncodingIdX86Op:
; 1122 :       goto _EmitX86Op;

	jmp	$LN1016@X86Assembl
	jmp	$_EmitX86Op$1952
$LN1017@X86Assembl:

; 1123 : 
; 1124 :     case kX86InstEncodingIdX86Rm_B:
; 1125 :       opCode += o0->getSize() != 1;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1828@X86Assembl
	mov	DWORD PTR tv233[rsp], 1
	jmp	SHORT $LN1829@X86Assembl
$LN1828@X86Assembl:
	mov	DWORD PTR tv233[rsp], 0
$LN1829@X86Assembl:
	mov	eax, DWORD PTR tv233[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN1018@X86Assembl:
$LN12@X86Assembl:

; 1126 :       // ... Fall through ...
; 1127 : 
; 1128 :     case kX86InstEncodingIdX86Rm:
; 1129 :       ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN12@X86Assembl
$LN15@X86Assembl:

; 1130 :       ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1019@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1019@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1019@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN15@X86Assembl

; 1131 : 
; 1132 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	SHORT $LN1020@X86Assembl

; 1133 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1134 :         goto _EmitX86R;

	jmp	$LN1021@X86Assembl
	jmp	$_EmitX86R$1953
$LN1020@X86Assembl:

; 1135 :       }
; 1136 : 
; 1137 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	SHORT $LN1022@X86Assembl

; 1138 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1139 :         goto _EmitX86M;

	jmp	$LN1023@X86Assembl
	jmp	$_EmitX86M$1954
$LN1022@X86Assembl:

; 1140 :       }
; 1141 :       break;

	jmp	$LN5@X86Assembl
$LN1024@X86Assembl:

; 1142 : 
; 1143 :     case kX86InstEncodingIdX86RmReg:
; 1144 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	$LN1025@X86Assembl

; 1145 :         opCode += o0->getSize() != 1;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1830@X86Assembl
	mov	DWORD PTR tv258[rsp], 1
	jmp	SHORT $LN1831@X86Assembl
$LN1830@X86Assembl:
	mov	DWORD PTR tv258[rsp], 0
$LN1831@X86Assembl:
	mov	eax, DWORD PTR tv258[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN18@X86Assembl:

; 1146 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN18@X86Assembl
$LN21@X86Assembl:

; 1147 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1026@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1026@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1026@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN21@X86Assembl

; 1148 : 
; 1149 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1150 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1151 :         goto _EmitX86R;

	jmp	$LN1027@X86Assembl
	jmp	$_EmitX86R$1953
$LN1025@X86Assembl:

; 1152 :       }
; 1153 : 
; 1154 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	$LN1028@X86Assembl

; 1155 :         opCode += o1->getSize() != 1;

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1832@X86Assembl
	mov	DWORD PTR tv281[rsp], 1
	jmp	SHORT $LN1833@X86Assembl
$LN1832@X86Assembl:
	mov	DWORD PTR tv281[rsp], 0
$LN1833@X86Assembl:
	mov	eax, DWORD PTR tv281[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN24@X86Assembl:

; 1156 :         ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN24@X86Assembl
$LN27@X86Assembl:

; 1157 :         ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1029@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1029@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1029@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN27@X86Assembl

; 1158 : 
; 1159 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1160 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1161 :         goto _EmitX86M;

	jmp	$LN1030@X86Assembl
	jmp	$_EmitX86M$1954
$LN1028@X86Assembl:

; 1162 :       }
; 1163 :       break;

	jmp	$LN5@X86Assembl
$LN1031@X86Assembl:
$LN30@X86Assembl:

; 1164 : 
; 1165 :     case kX86InstEncodingIdX86RegRm:
; 1166 :       ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN30@X86Assembl
$LN33@X86Assembl:

; 1167 :       ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1032@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1032@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1032@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN33@X86Assembl

; 1168 : 
; 1169 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1033@X86Assembl

; 1170 :         ASMJIT_ASSERT(o0->getSize() != 1);
; 1171 : 
; 1172 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1173 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1174 :         goto _EmitX86R;

	jmp	$LN1034@X86Assembl
	jmp	$_EmitX86R$1953
$LN1033@X86Assembl:

; 1175 :       }
; 1176 : 
; 1177 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1035@X86Assembl

; 1178 :         ASMJIT_ASSERT(o0->getSize() != 1);
; 1179 : 
; 1180 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1181 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1182 :         goto _EmitX86M;

	jmp	$LN1036@X86Assembl
	jmp	$_EmitX86M$1954
$LN1035@X86Assembl:

; 1183 :       }
; 1184 :       break;

	jmp	$LN5@X86Assembl
$LN1037@X86Assembl:

; 1185 : 
; 1186 :     case kX86InstEncodingIdX86M:
; 1187 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	SHORT $LN1038@X86Assembl

; 1188 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1189 :         goto _EmitX86M;

	jmp	$LN1039@X86Assembl
	jmp	$_EmitX86M$1954
$LN1038@X86Assembl:

; 1190 :       }
; 1191 :       break;

	jmp	$LN5@X86Assembl
$LN1040@X86Assembl:

; 1192 : 
; 1193 :     case kX86InstEncodingIdX86Arith:
; 1194 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	$LN1041@X86Assembl

; 1195 :         opCode +=(o0->getSize() != 1) + 2;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1834@X86Assembl
	mov	DWORD PTR tv329[rsp], 1
	jmp	SHORT $LN1835@X86Assembl
$LN1834@X86Assembl:
	mov	DWORD PTR tv329[rsp], 0
$LN1835@X86Assembl:
	mov	eax, DWORD PTR opCode$[rsp]
	mov	ecx, DWORD PTR tv329[rsp]
	lea	eax, DWORD PTR [rax+rcx+2]
	mov	DWORD PTR opCode$[rsp], eax
$LN36@X86Assembl:

; 1196 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN36@X86Assembl
$LN39@X86Assembl:

; 1197 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1042@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1042@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1042@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN39@X86Assembl

; 1198 : 
; 1199 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1200 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1201 :         goto _EmitX86R;

	jmp	$LN1043@X86Assembl
	jmp	$_EmitX86R$1953
$LN1041@X86Assembl:

; 1202 :       }
; 1203 : 
; 1204 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	$LN1044@X86Assembl

; 1205 :         opCode +=(o0->getSize() != 1) + 2;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1836@X86Assembl
	mov	DWORD PTR tv353[rsp], 1
	jmp	SHORT $LN1837@X86Assembl
$LN1836@X86Assembl:
	mov	DWORD PTR tv353[rsp], 0
$LN1837@X86Assembl:
	mov	eax, DWORD PTR opCode$[rsp]
	mov	ecx, DWORD PTR tv353[rsp]
	lea	eax, DWORD PTR [rax+rcx+2]
	mov	DWORD PTR opCode$[rsp], eax
$LN42@X86Assembl:

; 1206 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN42@X86Assembl
$LN45@X86Assembl:

; 1207 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1045@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1045@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1045@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN45@X86Assembl

; 1208 : 
; 1209 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1210 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1211 :         goto _EmitX86M;

	jmp	$LN1046@X86Assembl
	jmp	$_EmitX86M$1954
$LN1044@X86Assembl:

; 1212 :       }
; 1213 : 
; 1214 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	$LN1047@X86Assembl

; 1215 :         opCode += o1->getSize() != 1;

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1838@X86Assembl
	mov	DWORD PTR tv376[rsp], 1
	jmp	SHORT $LN1839@X86Assembl
$LN1838@X86Assembl:
	mov	DWORD PTR tv376[rsp], 0
$LN1839@X86Assembl:
	mov	eax, DWORD PTR tv376[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN48@X86Assembl:

; 1216 :         ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN48@X86Assembl
$LN51@X86Assembl:

; 1217 :         ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1048@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1048@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1048@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN51@X86Assembl

; 1218 : 
; 1219 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1220 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1221 :         goto _EmitX86M;

	jmp	$LN1049@X86Assembl
	jmp	$_EmitX86M$1954
$LN1047@X86Assembl:

; 1222 :       }
; 1223 : 
; 1224 :       // The remaining instructions use 0x80 opcode.
; 1225 :       opCode = 0x80;

	mov	DWORD PTR opCode$[rsp], 128		; 00000080H

; 1226 : 
; 1227 :       if (encoded == ENC_OPS(Reg, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 33		; 00000021H
	jne	$LN1050@X86Assembl

; 1228 :         imVal = static_cast<const Imm*>(o1)->getInt64();

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1229 :         imLen = IntUtil::isInt8(imVal) ? static_cast<uint32_t>(1) : IntUtil::iMin<uint32_t>(o0->getSize(), 4);

	mov	rcx, QWORD PTR imVal$[rsp]
	call	??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z	; asmjit::IntUtil::isInt8<__int64>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1840@X86Assembl
	mov	DWORD PTR tv410[rsp], 1
	jmp	SHORT $LN1841@X86Assembl
$LN1840@X86Assembl:
	mov	DWORD PTR $T52[rsp], 4
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	mov	DWORD PTR $T53[rsp], eax
	lea	rdx, QWORD PTR $T52[rsp]
	lea	rcx, QWORD PTR $T53[rsp]
	call	??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z	; asmjit::IntUtil::iMin<unsigned int>
	mov	DWORD PTR tv410[rsp], eax
$LN1841@X86Assembl:
	mov	eax, DWORD PTR tv410[rsp]
	mov	DWORD PTR imLen$[rsp], eax

; 1230 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax
$LN54@X86Assembl:

; 1231 : 
; 1232 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN54@X86Assembl
$LN57@X86Assembl:

; 1233 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1051@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1051@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1051@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN57@X86Assembl

; 1234 : 
; 1235 :         // Alternate Form - AL, AX, EAX, RAX.
; 1236 :         if (rmReg == 0 && (o0->getSize() == 1 || imLen != 1)) {

	cmp	QWORD PTR $S1$[rsp], 0
	jne	$LN1052@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1053@X86Assembl
	cmp	DWORD PTR imLen$[rsp], 1
	je	$LN1052@X86Assembl
$LN1053@X86Assembl:

; 1237 :           opCode = ((opReg << 3) | (0x04 + (o0->getSize() != 1)));

	mov	eax, DWORD PTR opReg$[rsp]
	shl	eax, 3
	mov	DWORD PTR tv438[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1842@X86Assembl
	mov	DWORD PTR tv435[rsp], 1
	jmp	SHORT $LN1843@X86Assembl
$LN1842@X86Assembl:
	mov	DWORD PTR tv435[rsp], 0
$LN1843@X86Assembl:
	mov	eax, DWORD PTR tv435[rsp]
	add	eax, 4
	mov	ecx, DWORD PTR tv438[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 1238 :           imLen = IntUtil::iMin<uint32_t>(o0->getSize(), 4);

	mov	DWORD PTR $T54[rsp], 4
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	mov	DWORD PTR $T55[rsp], eax
	lea	rdx, QWORD PTR $T54[rsp]
	lea	rcx, QWORD PTR $T55[rsp]
	call	??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z	; asmjit::IntUtil::iMin<unsigned int>
	mov	DWORD PTR imLen$[rsp], eax

; 1239 :           goto _EmitX86Op;

	jmp	$LN1054@X86Assembl
	jmp	$_EmitX86Op$1952
$LN1052@X86Assembl:

; 1240 :         }
; 1241 : 
; 1242 :         opCode += o0->getSize() != 1 ? (imLen != 1 ? 1 : 3) : 0;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1846@X86Assembl
	cmp	DWORD PTR imLen$[rsp], 1
	je	SHORT $LN1844@X86Assembl
	mov	DWORD PTR tv449[rsp], 1
	jmp	SHORT $LN1845@X86Assembl
$LN1844@X86Assembl:
	mov	DWORD PTR tv449[rsp], 3
$LN1845@X86Assembl:
	mov	eax, DWORD PTR tv449[rsp]
	mov	DWORD PTR tv450[rsp], eax
	jmp	SHORT $LN1847@X86Assembl
$LN1846@X86Assembl:
	mov	DWORD PTR tv450[rsp], 0
$LN1847@X86Assembl:
	mov	eax, DWORD PTR tv450[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 1243 :         goto _EmitX86R;

	jmp	$LN1055@X86Assembl
	jmp	$_EmitX86R$1953
$LN1050@X86Assembl:

; 1244 :       }
; 1245 : 
; 1246 :       if (encoded == ENC_OPS(Mem, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 35		; 00000023H
	jne	$LN1056@X86Assembl

; 1247 :         uint32_t memSize = o0->getSize();

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	mov	DWORD PTR memSize$21[rsp], eax

; 1248 : 
; 1249 :         if (memSize == 0)

	cmp	DWORD PTR memSize$21[rsp], 0
	jne	SHORT $LN1057@X86Assembl

; 1250 :           goto _IllegalInst;

	jmp	$LN1058@X86Assembl
	jmp	$_IllegalInst$1950
$LN1057@X86Assembl:

; 1251 : 
; 1252 :         imVal = static_cast<const Imm*>(o1)->getInt64();

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1253 :         imLen = IntUtil::isInt8(imVal) ? static_cast<uint32_t>(1) : IntUtil::iMin<uint32_t>(memSize, 4);

	mov	rcx, QWORD PTR imVal$[rsp]
	call	??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z	; asmjit::IntUtil::isInt8<__int64>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1848@X86Assembl
	mov	DWORD PTR tv469[rsp], 1
	jmp	SHORT $LN1849@X86Assembl
$LN1848@X86Assembl:
	mov	DWORD PTR $T56[rsp], 4
	lea	rdx, QWORD PTR $T56[rsp]
	lea	rcx, QWORD PTR memSize$21[rsp]
	call	??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z	; asmjit::IntUtil::iMin<unsigned int>
	mov	DWORD PTR tv469[rsp], eax
$LN1849@X86Assembl:
	mov	eax, DWORD PTR tv469[rsp]
	mov	DWORD PTR imLen$[rsp], eax

; 1254 : 
; 1255 :         opCode += memSize != 1 ? (imLen != 1 ? 1 : 3) : 0;

	cmp	DWORD PTR memSize$21[rsp], 1
	je	SHORT $LN1852@X86Assembl
	cmp	DWORD PTR imLen$[rsp], 1
	je	SHORT $LN1850@X86Assembl
	mov	DWORD PTR tv472[rsp], 1
	jmp	SHORT $LN1851@X86Assembl
$LN1850@X86Assembl:
	mov	DWORD PTR tv472[rsp], 3
$LN1851@X86Assembl:
	mov	eax, DWORD PTR tv472[rsp]
	mov	DWORD PTR tv473[rsp], eax
	jmp	SHORT $LN1853@X86Assembl
$LN1852@X86Assembl:
	mov	DWORD PTR tv473[rsp], 0
$LN1853@X86Assembl:
	mov	eax, DWORD PTR tv473[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN60@X86Assembl:

; 1256 :         ADD_66H_P_BY_SIZE(memSize);

	mov	eax, DWORD PTR memSize$21[rsp]
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN60@X86Assembl
$LN63@X86Assembl:

; 1257 :         ADD_REX_W_BY_SIZE(memSize);

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1059@X86Assembl
	cmp	DWORD PTR memSize$21[rsp], 8
	jne	SHORT $LN1059@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1059@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN63@X86Assembl

; 1258 : 
; 1259 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1260 :         goto _EmitX86M;

	jmp	$LN1060@X86Assembl
	jmp	$_EmitX86M$1954
$LN1056@X86Assembl:

; 1261 :       }
; 1262 :       break;

	jmp	$LN5@X86Assembl
$LN1061@X86Assembl:

; 1263 : 
; 1264 :     case kX86InstEncodingIdX86BSwap:
; 1265 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	SHORT $LN1062@X86Assembl

; 1266 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax
$LN66@X86Assembl:

; 1267 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1063@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1063@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1063@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN66@X86Assembl

; 1268 :         goto _EmitX86OpWithOpReg;

	jmp	$LN1064@X86Assembl
	jmp	$_EmitX86OpWithOpReg$1955
$LN1062@X86Assembl:

; 1269 :       }
; 1270 :       break;

	jmp	$LN5@X86Assembl
$LN1065@X86Assembl:

; 1271 : 
; 1272 :     case kX86InstEncodingIdX86BTest:
; 1273 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1066@X86Assembl
$LN69@X86Assembl:

; 1274 :         ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN69@X86Assembl
$LN72@X86Assembl:

; 1275 :         ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1067@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1067@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1067@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN72@X86Assembl

; 1276 : 
; 1277 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1278 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1279 :         goto _EmitX86R;

	jmp	$LN1068@X86Assembl
	jmp	$_EmitX86R$1953
$LN1066@X86Assembl:

; 1280 :       }
; 1281 : 
; 1282 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	SHORT $LN1069@X86Assembl
$LN75@X86Assembl:

; 1283 :         ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN75@X86Assembl
$LN78@X86Assembl:

; 1284 :         ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1070@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1070@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1070@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN78@X86Assembl

; 1285 : 
; 1286 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1287 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1288 :         goto _EmitX86M;

	jmp	$LN1071@X86Assembl
	jmp	$_EmitX86M$1954
$LN1069@X86Assembl:

; 1289 :       }
; 1290 : 
; 1291 :       // The remaining instructions use the secondary opcode/r.
; 1292 :       imVal = static_cast<const Imm*>(o1)->getInt64();

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1293 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 1294 : 
; 1295 :       opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 1296 :       opReg = x86ExtractO(opCode);

	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86ExtractO@asmjit@@YAII@Z		; asmjit::x86ExtractO
	mov	DWORD PTR opReg$[rsp], eax
$LN81@X86Assembl:

; 1297 : 
; 1298 :       ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN81@X86Assembl
$LN84@X86Assembl:

; 1299 :       ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1072@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1072@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1072@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN84@X86Assembl

; 1300 : 
; 1301 :       if (encoded == ENC_OPS(Reg, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 33		; 00000021H
	jne	SHORT $LN1073@X86Assembl

; 1302 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1303 :         goto _EmitX86R;

	jmp	$LN1074@X86Assembl
	jmp	$_EmitX86R$1953
$LN1073@X86Assembl:

; 1304 :       }
; 1305 : 
; 1306 :       if (encoded == ENC_OPS(Mem, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 35		; 00000023H
	jne	SHORT $LN1075@X86Assembl

; 1307 :         if (o0->getSize() == 0)

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	test	eax, eax
	jne	SHORT $LN1076@X86Assembl

; 1308 :           goto _IllegalInst;

	jmp	$LN1077@X86Assembl
	jmp	$_IllegalInst$1950
$LN1076@X86Assembl:

; 1309 : 
; 1310 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1311 :         goto _EmitX86M;

	jmp	$LN1078@X86Assembl
	jmp	$_EmitX86M$1954
$LN1075@X86Assembl:

; 1312 :       }
; 1313 :       break;

	jmp	$LN5@X86Assembl
$LN1079@X86Assembl:

; 1314 : 
; 1315 :     case kX86InstEncodingIdX86Call:
; 1316 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	SHORT $LN1080@X86Assembl

; 1317 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1318 :         goto _EmitX86R;

	jmp	$LN1081@X86Assembl
	jmp	$_EmitX86R$1953
$LN1080@X86Assembl:

; 1319 :       }
; 1320 : 
; 1321 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	SHORT $LN1082@X86Assembl

; 1322 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1323 :         goto _EmitX86M;

	jmp	$LN1083@X86Assembl
	jmp	$_EmitX86M$1954
$LN1082@X86Assembl:

; 1324 :       }
; 1325 : 
; 1326 :       // The following instructions use the secondary opcode.
; 1327 :       opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 1328 : 
; 1329 :       if (encoded == ENC_OPS(Imm, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 4
	jne	SHORT $LN1084@X86Assembl

; 1330 :         imVal = static_cast<const Imm*>(o0)->getInt64();

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1331 :         goto _EmitJmpOrCallAbs;

	jmp	$LN1085@X86Assembl
	jmp	$_EmitJmpOrCallAbs$1956
$LN1084@X86Assembl:

; 1332 :       }
; 1333 : 
; 1334 :       if (encoded == ENC_OPS(Label, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 5
	jne	$LN1086@X86Assembl

; 1335 :         label = self->getLabelData(static_cast<const Label*>(o0)->getId());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getId@Operand@asmjit@@QEBAIXZ		; asmjit::Operand::getId
	mov	edx, eax
	mov	rcx, QWORD PTR self$[rsp]
	call	?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ; asmjit::Assembler::getLabelData
	mov	QWORD PTR label$[rsp], rax

; 1336 :         if (label->offset != -1) {

	mov	rax, QWORD PTR label$[rsp]
	cmp	QWORD PTR [rax], -1
	je	$LN1087@X86Assembl

; 1337 :           // Bound label.
; 1338 :           static const intptr_t kRel32Size = 5;
; 1339 :           intptr_t offs = label->offset - (intptr_t)(cursor - self->_buffer);

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR cursor$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rcx]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR offs$66[rsp], rax
$LN87@X86Assembl:
$LN90@X86Assembl:

; 1340 : 
; 1341 :           ASMJIT_ASSERT(offs <= 0);
; 1342 :           EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN90@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN87@X86Assembl
$LN93@X86Assembl:

; 1343 :           EMIT_DWORD(static_cast<int32_t>(offs - kRel32Size));

	mov	rax, QWORD PTR offs$66[rsp]
	sub	rax, 5
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	DWORD PTR [rdx+rcx], eax
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN93@X86Assembl

; 1344 :         }

	jmp	SHORT $LN1088@X86Assembl
$LN1087@X86Assembl:
$LN96@X86Assembl:
$LN99@X86Assembl:

; 1345 :         else {
; 1346 :           // Non-bound label.
; 1347 :           EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN99@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN96@X86Assembl

; 1348 :           dispOffset = -4;

	mov	DWORD PTR dispOffset$[rsp], -4

; 1349 :           dispSize = 4;

	mov	DWORD PTR dispSize$[rsp], 4

; 1350 :           relocId = -1;

	mov	QWORD PTR relocId$[rsp], -1

; 1351 :           goto _EmitDisplacement;

	jmp	$LN1089@X86Assembl
	jmp	$_EmitDisplacement$1957
$LN1088@X86Assembl:

; 1352 :         }
; 1353 :         goto _EmitDone;

	jmp	$LN1090@X86Assembl
	jmp	$_EmitDone$1951
$LN1086@X86Assembl:

; 1354 :       }
; 1355 :       break;

	jmp	$LN5@X86Assembl
$LN1091@X86Assembl:

; 1356 : 
; 1357 :     case kX86InstEncodingIdX86Enter:
; 1358 :       if (encoded == ENC_OPS(Imm, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 36		; 00000024H
	jne	$LN1092@X86Assembl
$LN102@X86Assembl:

; 1359 :         EMIT_BYTE(0xC8);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 200			; 000000c8H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN102@X86Assembl
$LN105@X86Assembl:

; 1360 :         EMIT_WORD(static_cast<const Imm*>(o1)->getUInt16());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getUInt16@Imm@asmjit@@QEBAGXZ		; asmjit::Imm::getUInt16
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	WORD PTR [rdx+rcx], ax
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 2
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN105@X86Assembl
$LN108@X86Assembl:

; 1361 :         EMIT_BYTE(static_cast<const Imm*>(o0)->getUInt8());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getUInt8@Imm@asmjit@@QEBAEXZ		; asmjit::Imm::getUInt8
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN108@X86Assembl

; 1362 :         goto _EmitDone;

	jmp	$LN1093@X86Assembl
	jmp	$_EmitDone$1951
$LN1092@X86Assembl:

; 1363 :       }
; 1364 :       break;

	jmp	$LN5@X86Assembl
$LN1094@X86Assembl:
$LN111@X86Assembl:

; 1365 : 
; 1366 :     case kX86InstEncodingIdX86Imul:
; 1367 :       ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN111@X86Assembl
$LN114@X86Assembl:

; 1368 :       ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1095@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1095@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1095@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN114@X86Assembl

; 1369 : 
; 1370 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	SHORT $LN1096@X86Assembl

; 1371 :         opCode &= kX86InstOpCode_PP_66 | kX86InstOpCode_W;

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, -2146435072			; 80100000H
	mov	DWORD PTR opCode$[rsp], eax

; 1372 :         opCode |= 0xF6 + (o0->getSize() != 1);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1854@X86Assembl
	mov	DWORD PTR tv667[rsp], 1
	jmp	SHORT $LN1855@X86Assembl
$LN1854@X86Assembl:
	mov	DWORD PTR tv667[rsp], 0
$LN1855@X86Assembl:
	mov	eax, DWORD PTR tv667[rsp]
	add	eax, 246				; 000000f6H
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 1373 : 
; 1374 :         opReg = 5;

	mov	DWORD PTR opReg$[rsp], 5

; 1375 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1376 :         goto _EmitX86R;

	jmp	$LN1097@X86Assembl
	jmp	$_EmitX86R$1953
$LN1096@X86Assembl:

; 1377 :       }
; 1378 : 
; 1379 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	SHORT $LN1098@X86Assembl

; 1380 :         opCode &= kX86InstOpCode_PP_66 | kX86InstOpCode_W;

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, -2146435072			; 80100000H
	mov	DWORD PTR opCode$[rsp], eax

; 1381 :         opCode |= 0xF6 + (o0->getSize() != 1);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1856@X86Assembl
	mov	DWORD PTR tv678[rsp], 1
	jmp	SHORT $LN1857@X86Assembl
$LN1856@X86Assembl:
	mov	DWORD PTR tv678[rsp], 0
$LN1857@X86Assembl:
	mov	eax, DWORD PTR tv678[rsp]
	add	eax, 246				; 000000f6H
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 1382 : 
; 1383 :         opReg = 5;

	mov	DWORD PTR opReg$[rsp], 5

; 1384 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1385 :         goto _EmitX86M;

	jmp	$LN1099@X86Assembl
	jmp	$_EmitX86M$1954
$LN1098@X86Assembl:

; 1386 :       }
; 1387 : 
; 1388 :       // The following instructions use 0x0FAF opcode.
; 1389 :       opCode &= kX86InstOpCode_PP_66 | kX86InstOpCode_W;

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, -2146435072			; 80100000H
	mov	DWORD PTR opCode$[rsp], eax

; 1390 :       opCode |= kX86InstOpCode_MM_0F | 0xAF;

	mov	eax, DWORD PTR opCode$[rsp]
	or	eax, 65711				; 000100afH
	mov	DWORD PTR opCode$[rsp], eax

; 1391 : 
; 1392 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1100@X86Assembl

; 1393 :         ASMJIT_ASSERT(o0->getSize() != 1);
; 1394 : 
; 1395 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1396 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1397 : 
; 1398 :         goto _EmitX86R;

	jmp	$LN1101@X86Assembl
	jmp	$_EmitX86R$1953
$LN1100@X86Assembl:

; 1399 :       }
; 1400 : 
; 1401 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1102@X86Assembl

; 1402 :         ASMJIT_ASSERT(o0->getSize() != 1);
; 1403 : 
; 1404 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1405 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1406 : 
; 1407 :         goto _EmitX86M;

	jmp	$LN1103@X86Assembl
	jmp	$_EmitX86M$1954
$LN1102@X86Assembl:

; 1408 :       }
; 1409 : 
; 1410 :       // The following instructions use 0x69/0x6B opcode.
; 1411 :       opCode &= kX86InstOpCode_PP_66 | kX86InstOpCode_W;

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, -2146435072			; 80100000H
	mov	DWORD PTR opCode$[rsp], eax

; 1412 :       opCode |= 0x6B;

	mov	eax, DWORD PTR opCode$[rsp]
	or	eax, 107				; 0000006bH
	mov	DWORD PTR opCode$[rsp], eax

; 1413 : 
; 1414 :       if (encoded == ENC_OPS(Reg, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 33		; 00000021H
	jne	$LN1104@X86Assembl

; 1415 :         ASMJIT_ASSERT(o0->getSize() != 1);
; 1416 : 
; 1417 :         imVal = static_cast<const Imm*>(o1)->getInt64();

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1418 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 1419 : 
; 1420 :         if (!IntUtil::isInt8(imVal)) {

	mov	rcx, QWORD PTR imVal$[rsp]
	call	??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z	; asmjit::IntUtil::isInt8<__int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1105@X86Assembl

; 1421 :           opCode -= 2;

	mov	eax, DWORD PTR opCode$[rsp]
	sub	eax, 2
	mov	DWORD PTR opCode$[rsp], eax

; 1422 :           imLen = o0->getSize() == 2 ? 2 : 4;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 2
	jne	SHORT $LN1858@X86Assembl
	mov	DWORD PTR tv713[rsp], 2
	jmp	SHORT $LN1859@X86Assembl
$LN1858@X86Assembl:
	mov	DWORD PTR tv713[rsp], 4
$LN1859@X86Assembl:
	mov	eax, DWORD PTR tv713[rsp]
	mov	DWORD PTR imLen$[rsp], eax
$LN1105@X86Assembl:

; 1423 :         }
; 1424 : 
; 1425 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1426 :         rmReg = opReg;

	mov	eax, DWORD PTR opReg$[rsp]
	mov	QWORD PTR $S1$[rsp], rax

; 1427 :         goto _EmitX86R;

	jmp	$LN1106@X86Assembl
	jmp	$_EmitX86R$1953
$LN1104@X86Assembl:

; 1428 :       }
; 1429 : 
; 1430 :       if (encoded == ENC_OPS(Reg, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 265		; 00000109H
	jne	$LN1107@X86Assembl

; 1431 :         ASMJIT_ASSERT(o0->getSize() != 1);
; 1432 : 
; 1433 :         imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1434 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 1435 : 
; 1436 :         if (!IntUtil::isInt8(imVal)) {

	mov	rcx, QWORD PTR imVal$[rsp]
	call	??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z	; asmjit::IntUtil::isInt8<__int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1108@X86Assembl

; 1437 :           opCode -= 2;

	mov	eax, DWORD PTR opCode$[rsp]
	sub	eax, 2
	mov	DWORD PTR opCode$[rsp], eax

; 1438 :           imLen = o0->getSize() == 2 ? 2 : 4;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 2
	jne	SHORT $LN1860@X86Assembl
	mov	DWORD PTR tv732[rsp], 2
	jmp	SHORT $LN1861@X86Assembl
$LN1860@X86Assembl:
	mov	DWORD PTR tv732[rsp], 4
$LN1861@X86Assembl:
	mov	eax, DWORD PTR tv732[rsp]
	mov	DWORD PTR imLen$[rsp], eax
$LN1108@X86Assembl:

; 1439 :         }
; 1440 : 
; 1441 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1442 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1443 :         goto _EmitX86R;

	jmp	$LN1109@X86Assembl
	jmp	$_EmitX86R$1953
$LN1107@X86Assembl:

; 1444 :       }
; 1445 : 
; 1446 :       if (encoded == ENC_OPS(Reg, Mem, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 281		; 00000119H
	jne	$LN1110@X86Assembl

; 1447 :         ASMJIT_ASSERT(o0->getSize() != 1);
; 1448 : 
; 1449 :         imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1450 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 1451 : 
; 1452 :         if (!IntUtil::isInt8(imVal)) {

	mov	rcx, QWORD PTR imVal$[rsp]
	call	??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z	; asmjit::IntUtil::isInt8<__int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1111@X86Assembl

; 1453 :           opCode -= 2;

	mov	eax, DWORD PTR opCode$[rsp]
	sub	eax, 2
	mov	DWORD PTR opCode$[rsp], eax

; 1454 :           imLen = o0->getSize() == 2 ? 2 : 4;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 2
	jne	SHORT $LN1862@X86Assembl
	mov	DWORD PTR tv753[rsp], 2
	jmp	SHORT $LN1863@X86Assembl
$LN1862@X86Assembl:
	mov	DWORD PTR tv753[rsp], 4
$LN1863@X86Assembl:
	mov	eax, DWORD PTR tv753[rsp]
	mov	DWORD PTR imLen$[rsp], eax
$LN1111@X86Assembl:

; 1455 :         }
; 1456 : 
; 1457 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1458 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1459 :         goto _EmitX86M;

	jmp	$LN1112@X86Assembl
	jmp	$_EmitX86M$1954
$LN1110@X86Assembl:

; 1460 :       }
; 1461 :       break;

	jmp	$LN5@X86Assembl
$LN1113@X86Assembl:
$LN117@X86Assembl:

; 1462 : 
; 1463 :     case kX86InstEncodingIdX86IncDec:
; 1464 :       ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN117@X86Assembl
$LN120@X86Assembl:

; 1465 :       ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1114@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1114@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1114@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN120@X86Assembl

; 1466 : 
; 1467 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	$LN1115@X86Assembl

; 1468 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1469 : 
; 1470 :         // INC r16|r32 is not encodable in 64-bit mode.
; 1471 :         if (Arch == kArchX86 && (o0->getSize() == 2 || o0->getSize() == 4)) {

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN1116@X86Assembl

; 1472 :           opCode &= kX86InstOpCode_PP_66 | kX86InstOpCode_W;

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, -2146435072			; 80100000H
	mov	DWORD PTR opCode$[rsp], eax

; 1473 :           opCode |= extendedInfo.getSecondaryOpCode() + (static_cast<uint32_t>(rmReg) & 0x7);

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	ecx, DWORD PTR $S1$[rsp]
	and	ecx, 7
	add	eax, ecx
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 1474 :           goto _EmitX86Op;

	jmp	$LN1118@X86Assembl
	jmp	$_EmitX86Op$1952

; 1475 :         }

	jmp	SHORT $LN1117@X86Assembl
$LN1116@X86Assembl:

; 1476 :         else {
; 1477 :           opCode += o0->getSize() != 1;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1864@X86Assembl
	mov	DWORD PTR tv784[rsp], 1
	jmp	SHORT $LN1865@X86Assembl
$LN1864@X86Assembl:
	mov	DWORD PTR tv784[rsp], 0
$LN1865@X86Assembl:
	mov	eax, DWORD PTR tv784[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 1478 :           goto _EmitX86R;

	jmp	$LN1119@X86Assembl
	jmp	$_EmitX86R$1953
$LN1117@X86Assembl:
$LN1115@X86Assembl:

; 1479 :         }
; 1480 :       }
; 1481 : 
; 1482 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	SHORT $LN1120@X86Assembl

; 1483 :         opCode += o0->getSize() != 1;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1866@X86Assembl
	mov	DWORD PTR tv790[rsp], 1
	jmp	SHORT $LN1867@X86Assembl
$LN1866@X86Assembl:
	mov	DWORD PTR tv790[rsp], 0
$LN1867@X86Assembl:
	mov	eax, DWORD PTR tv790[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 1484 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1485 :         goto _EmitX86M;

	jmp	$LN1121@X86Assembl
	jmp	$_EmitX86M$1954
$LN1120@X86Assembl:

; 1486 :       }
; 1487 :       break;

	jmp	$LN5@X86Assembl
$LN1122@X86Assembl:

; 1488 : 
; 1489 :     case kX86InstEncodingIdX86Int:
; 1490 :       if (encoded == ENC_OPS(Imm, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 4
	jne	$LN1123@X86Assembl

; 1491 :         imVal = static_cast<const Imm*>(o0)->getInt64();

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1492 :         uint8_t imm8 = static_cast<uint8_t>(imVal & 0xFF);

	mov	rax, QWORD PTR imVal$[rsp]
	and	rax, 255				; 000000ffH
	mov	BYTE PTR imm8$4[rsp], al

; 1493 : 
; 1494 :         if (imm8 == 0x03) {

	movzx	eax, BYTE PTR imm8$4[rsp]
	cmp	eax, 3
	jne	SHORT $LN1124@X86Assembl
$LN123@X86Assembl:
$LN126@X86Assembl:

; 1495 :           EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN126@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN123@X86Assembl

; 1496 :         }

	jmp	SHORT $LN1125@X86Assembl
$LN1124@X86Assembl:
$LN129@X86Assembl:
$LN132@X86Assembl:

; 1497 :         else {
; 1498 :           EMIT_OP(opCode + 1);

	mov	eax, DWORD PTR opCode$[rsp]
	inc	eax
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN132@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN129@X86Assembl
$LN135@X86Assembl:

; 1499 :           EMIT_BYTE(imm8);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR imm8$4[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN135@X86Assembl
$LN1125@X86Assembl:

; 1500 :         }
; 1501 :         goto _EmitDone;

	jmp	$LN1126@X86Assembl
	jmp	$_EmitDone$1951
$LN1123@X86Assembl:

; 1502 :       }
; 1503 :       break;

	jmp	$LN5@X86Assembl
$LN1127@X86Assembl:

; 1504 : 
; 1505 :     case kX86InstEncodingIdX86Jcc:
; 1506 :       if (encoded == ENC_OPS(Label, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 5
	jne	$LN1128@X86Assembl

; 1507 :         label = self->getLabelData(static_cast<const Label*>(o0)->getId());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getId@Operand@asmjit@@QEBAIXZ		; asmjit::Operand::getId
	mov	edx, eax
	mov	rcx, QWORD PTR self$[rsp]
	call	?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ; asmjit::Assembler::getLabelData
	mov	QWORD PTR label$[rsp], rax

; 1508 : 
; 1509 :         if (self->hasFeature(kCodeGenPredictedJumps)) {

	mov	edx, 1
	mov	rcx, QWORD PTR self$[rsp]
	call	?hasFeature@CodeGen@asmjit@@QEBA_NI@Z	; asmjit::CodeGen::hasFeature
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1129@X86Assembl

; 1510 :           if (options & kInstOptionTaken)

	mov	eax, DWORD PTR options$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN1130@X86Assembl
$LN138@X86Assembl:

; 1511 :             EMIT_BYTE(0x3E);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 62			; 0000003eH
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN138@X86Assembl
$LN1130@X86Assembl:

; 1512 :           if (options & kInstOptionNotTaken)

	mov	eax, DWORD PTR options$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN1131@X86Assembl
$LN141@X86Assembl:

; 1513 :             EMIT_BYTE(0x2E);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN141@X86Assembl
$LN1131@X86Assembl:
$LN1129@X86Assembl:

; 1514 :         }
; 1515 : 
; 1516 :         if (label->offset != -1) {

	mov	rax, QWORD PTR label$[rsp]
	cmp	QWORD PTR [rax], -1
	je	$LN1132@X86Assembl

; 1517 :           // Bound label.
; 1518 :           static const intptr_t kRel8Size = 2;
; 1519 :           static const intptr_t kRel32Size = 6;
; 1520 : 
; 1521 :           intptr_t offs = label->offset - (intptr_t)(cursor - self->_buffer);

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR cursor$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rcx]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR offs$58[rsp], rax

; 1522 :           ASMJIT_ASSERT(offs <= 0);
; 1523 : 
; 1524 :           if ((options & kInstOptionLongForm) == 0 && IntUtil::isInt8(offs - kRel8Size)) {

	mov	eax, DWORD PTR options$[rsp]
	and	eax, 2
	test	eax, eax
	jne	$LN1134@X86Assembl
	mov	rax, QWORD PTR offs$58[rsp]
	sub	rax, 2
	mov	rcx, rax
	call	??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z	; asmjit::IntUtil::isInt8<__int64>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1134@X86Assembl
$LN144@X86Assembl:
$LN147@X86Assembl:

; 1525 :             EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN147@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN144@X86Assembl
$LN150@X86Assembl:

; 1526 :             EMIT_BYTE(offs - kRel8Size);

	mov	rax, QWORD PTR offs$58[rsp]
	sub	rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN150@X86Assembl

; 1527 : 
; 1528 :             options |= kInstOptionShortForm;

	mov	eax, DWORD PTR options$[rsp]
	or	eax, 1
	mov	DWORD PTR options$[rsp], eax

; 1529 :             goto _EmitDone;

	jmp	$LN1136@X86Assembl
	jmp	$_EmitDone$1951

; 1530 :           }

	jmp	$LN1135@X86Assembl
$LN1134@X86Assembl:
$LN153@X86Assembl:

; 1531 :           else {
; 1532 :             EMIT_BYTE(0x0F);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 15
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN153@X86Assembl
$LN156@X86Assembl:
$LN159@X86Assembl:

; 1533 :             EMIT_OP(opCode + 0x10);

	mov	eax, DWORD PTR opCode$[rsp]
	add	eax, 16
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN159@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN156@X86Assembl
$LN162@X86Assembl:

; 1534 :             EMIT_DWORD(static_cast<int32_t>(offs - kRel32Size));

	mov	rax, QWORD PTR offs$58[rsp]
	sub	rax, 6
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	DWORD PTR [rdx+rcx], eax
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN162@X86Assembl

; 1535 : 
; 1536 :             options &= ~kInstOptionShortForm;

	mov	eax, DWORD PTR options$[rsp]
	and	eax, -2					; fffffffeH
	mov	DWORD PTR options$[rsp], eax

; 1537 :             goto _EmitDone;

	jmp	$LN1137@X86Assembl
	jmp	$_EmitDone$1951
$LN1135@X86Assembl:

; 1538 :           }
; 1539 :         }

	jmp	$LN1133@X86Assembl
$LN1132@X86Assembl:

; 1540 :         else {
; 1541 :           // Non-bound label.
; 1542 :           if (options & kInstOptionShortForm) {

	mov	eax, DWORD PTR options$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN1138@X86Assembl
$LN165@X86Assembl:
$LN168@X86Assembl:

; 1543 :             EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN168@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN165@X86Assembl

; 1544 :             dispOffset = -1;

	mov	DWORD PTR dispOffset$[rsp], -1

; 1545 :             dispSize = 1;

	mov	DWORD PTR dispSize$[rsp], 1

; 1546 :             relocId = -1;

	mov	QWORD PTR relocId$[rsp], -1

; 1547 :             goto _EmitDisplacement;

	jmp	$LN1140@X86Assembl
	jmp	$_EmitDisplacement$1957

; 1548 :           }

	jmp	$LN1139@X86Assembl
$LN1138@X86Assembl:
$LN171@X86Assembl:

; 1549 :           else {
; 1550 :             EMIT_BYTE(0x0F);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 15
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN171@X86Assembl
$LN174@X86Assembl:
$LN177@X86Assembl:

; 1551 :             EMIT_OP(opCode + 0x10);

	mov	eax, DWORD PTR opCode$[rsp]
	add	eax, 16
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN177@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN174@X86Assembl

; 1552 :             dispOffset = -4;

	mov	DWORD PTR dispOffset$[rsp], -4

; 1553 :             dispSize = 4;

	mov	DWORD PTR dispSize$[rsp], 4

; 1554 :             relocId = -1;

	mov	QWORD PTR relocId$[rsp], -1

; 1555 :             goto _EmitDisplacement;

	jmp	$LN1141@X86Assembl
	jmp	$_EmitDisplacement$1957
$LN1139@X86Assembl:
$LN1133@X86Assembl:
$LN1128@X86Assembl:

; 1556 :           }
; 1557 :         }
; 1558 :       }
; 1559 :       break;

	jmp	$LN5@X86Assembl
$LN1142@X86Assembl:

; 1560 : 
; 1561 :     case kX86InstEncodingIdX86Jecxz:
; 1562 :       if (encoded == ENC_OPS(Reg, Label, None)) {

	cmp	DWORD PTR encoded$[rsp], 41		; 00000029H
	jne	$LN1143@X86Assembl

; 1563 :         ASMJIT_ASSERT(x86OpReg(o0) == kX86RegIndexCx);
; 1564 : 
; 1565 :         if ((Arch == kArchX86 && o0->getSize() == 2) ||

	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN1145@X86Assembl
	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1144@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 4
	jne	SHORT $LN1144@X86Assembl
$LN1145@X86Assembl:
$LN180@X86Assembl:

; 1566 :             (Arch == kArchX64 && o0->getSize() == 4)) {
; 1567 :           EMIT_BYTE(0x67);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 103			; 00000067H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN180@X86Assembl
$LN1144@X86Assembl:
$LN183@X86Assembl:

; 1568 :         }
; 1569 : 
; 1570 :         EMIT_BYTE(0xE3);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 227			; 000000e3H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN183@X86Assembl

; 1571 :         label = self->getLabelData(static_cast<const Label*>(o1)->getId());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getId@Operand@asmjit@@QEBAIXZ		; asmjit::Operand::getId
	mov	edx, eax
	mov	rcx, QWORD PTR self$[rsp]
	call	?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ; asmjit::Assembler::getLabelData
	mov	QWORD PTR label$[rsp], rax

; 1572 : 
; 1573 :         if (label->offset != -1) {

	mov	rax, QWORD PTR label$[rsp]
	cmp	QWORD PTR [rax], -1
	je	$LN1146@X86Assembl

; 1574 :           // Bound label.
; 1575 :           intptr_t offs = label->offset - (intptr_t)(cursor - self->_buffer) - 1;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR cursor$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rcx]
	sub	rcx, rax
	mov	rax, rcx
	dec	rax
	mov	QWORD PTR offs$64[rsp], rax

; 1576 :           if (!IntUtil::isInt8(offs))

	mov	rcx, QWORD PTR offs$64[rsp]
	call	??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z	; asmjit::IntUtil::isInt8<__int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1148@X86Assembl

; 1577 :             goto _IllegalInst;

	jmp	$LN1149@X86Assembl
	jmp	$_IllegalInst$1950
$LN1148@X86Assembl:
$LN186@X86Assembl:

; 1578 : 
; 1579 :           EMIT_BYTE(offs);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR offs$64[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN186@X86Assembl

; 1580 :           goto _EmitDone;

	jmp	$LN1150@X86Assembl
	jmp	$_EmitDone$1951

; 1581 :         }

	jmp	SHORT $LN1147@X86Assembl
$LN1146@X86Assembl:

; 1582 :         else {
; 1583 :           // Non-bound label.
; 1584 :           dispOffset = -1;

	mov	DWORD PTR dispOffset$[rsp], -1

; 1585 :           dispSize = 1;

	mov	DWORD PTR dispSize$[rsp], 1

; 1586 :           relocId = -1;

	mov	QWORD PTR relocId$[rsp], -1

; 1587 :           goto _EmitDisplacement;

	jmp	$LN1151@X86Assembl
	jmp	$_EmitDisplacement$1957
$LN1147@X86Assembl:
$LN1143@X86Assembl:

; 1588 :         }
; 1589 :       }
; 1590 :       break;

	jmp	$LN5@X86Assembl
$LN1152@X86Assembl:

; 1591 : 
; 1592 :     case kX86InstEncodingIdX86Jmp:
; 1593 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	SHORT $LN1153@X86Assembl

; 1594 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1595 :         goto _EmitX86R;

	jmp	$LN1154@X86Assembl
	jmp	$_EmitX86R$1953
$LN1153@X86Assembl:

; 1596 :       }
; 1597 : 
; 1598 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	SHORT $LN1155@X86Assembl

; 1599 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1600 :         goto _EmitX86M;

	jmp	$LN1156@X86Assembl
	jmp	$_EmitX86M$1954
$LN1155@X86Assembl:

; 1601 :       }
; 1602 : 
; 1603 :       // The following instructions use the secondary opcode (0xE9).
; 1604 :       opCode = 0xE9;

	mov	DWORD PTR opCode$[rsp], 233		; 000000e9H

; 1605 : 
; 1606 :       if (encoded == ENC_OPS(Imm, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 4
	jne	SHORT $LN1157@X86Assembl

; 1607 :         imVal = static_cast<const Imm*>(o0)->getInt64();

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1608 :         goto _EmitJmpOrCallAbs;

	jmp	$LN1158@X86Assembl
	jmp	$_EmitJmpOrCallAbs$1956
$LN1157@X86Assembl:

; 1609 :       }
; 1610 : 
; 1611 :       if (encoded == ENC_OPS(Label, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 5
	jne	$LN1159@X86Assembl

; 1612 :         label = self->getLabelData(static_cast<const Label*>(o0)->getId());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getId@Operand@asmjit@@QEBAIXZ		; asmjit::Operand::getId
	mov	edx, eax
	mov	rcx, QWORD PTR self$[rsp]
	call	?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ; asmjit::Assembler::getLabelData
	mov	QWORD PTR label$[rsp], rax

; 1613 :         if (label->offset != -1) {

	mov	rax, QWORD PTR label$[rsp]
	cmp	QWORD PTR [rax], -1
	je	$LN1160@X86Assembl

; 1614 :           // Bound label.
; 1615 :           const intptr_t kRel8Size = 2;

	mov	QWORD PTR kRel8Size$67[rsp], 2

; 1616 :           const intptr_t kRel32Size = 5;

	mov	QWORD PTR kRel32Size$68[rsp], 5

; 1617 : 
; 1618 :           intptr_t offs = label->offset - (intptr_t)(cursor - self->_buffer);

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR cursor$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rcx]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR offs$59[rsp], rax

; 1619 : 
; 1620 :           if ((options & kInstOptionLongForm) == 0 && IntUtil::isInt8(offs - kRel8Size)) {

	mov	eax, DWORD PTR options$[rsp]
	and	eax, 2
	test	eax, eax
	jne	$LN1162@X86Assembl
	mov	rax, QWORD PTR offs$59[rsp]
	sub	rax, 2
	mov	rcx, rax
	call	??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z	; asmjit::IntUtil::isInt8<__int64>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1162@X86Assembl

; 1621 :             options |= kInstOptionShortForm;

	mov	eax, DWORD PTR options$[rsp]
	or	eax, 1
	mov	DWORD PTR options$[rsp], eax
$LN189@X86Assembl:

; 1622 : 
; 1623 :             EMIT_BYTE(0xEB);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 235			; 000000ebH
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN189@X86Assembl
$LN192@X86Assembl:

; 1624 :             EMIT_BYTE(offs - kRel8Size);

	mov	rax, QWORD PTR offs$59[rsp]
	sub	rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN192@X86Assembl

; 1625 :             goto _EmitDone;

	jmp	$LN1164@X86Assembl
	jmp	$_EmitDone$1951

; 1626 :           }

	jmp	SHORT $LN1163@X86Assembl
$LN1162@X86Assembl:

; 1627 :           else {
; 1628 :             options &= ~kInstOptionShortForm;

	mov	eax, DWORD PTR options$[rsp]
	and	eax, -2					; fffffffeH
	mov	DWORD PTR options$[rsp], eax
$LN195@X86Assembl:

; 1629 : 
; 1630 :             EMIT_BYTE(0xE9);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 233			; 000000e9H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN195@X86Assembl
$LN198@X86Assembl:

; 1631 :             EMIT_DWORD(static_cast<int32_t>(offs - kRel32Size));

	mov	rax, QWORD PTR offs$59[rsp]
	sub	rax, 5
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	DWORD PTR [rdx+rcx], eax
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN198@X86Assembl

; 1632 :             goto _EmitDone;

	jmp	$LN1165@X86Assembl
	jmp	$_EmitDone$1951
$LN1163@X86Assembl:

; 1633 :           }
; 1634 :         }

	jmp	$LN1161@X86Assembl
$LN1160@X86Assembl:

; 1635 :         else {
; 1636 :           // Non-bound label.
; 1637 :           if ((options & kInstOptionShortForm) != 0) {

	mov	eax, DWORD PTR options$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN1166@X86Assembl
$LN201@X86Assembl:

; 1638 :             EMIT_BYTE(0xEB);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 235			; 000000ebH
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN201@X86Assembl

; 1639 :             dispOffset = -1;

	mov	DWORD PTR dispOffset$[rsp], -1

; 1640 :             dispSize = 1;

	mov	DWORD PTR dispSize$[rsp], 1

; 1641 :             relocId = -1;

	mov	QWORD PTR relocId$[rsp], -1

; 1642 :             goto _EmitDisplacement;

	jmp	$LN1168@X86Assembl
	jmp	$_EmitDisplacement$1957

; 1643 :           }

	jmp	SHORT $LN1167@X86Assembl
$LN1166@X86Assembl:
$LN204@X86Assembl:

; 1644 :           else {
; 1645 :             EMIT_BYTE(0xE9);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 233			; 000000e9H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN204@X86Assembl

; 1646 :             dispOffset = -4;

	mov	DWORD PTR dispOffset$[rsp], -4

; 1647 :             dispSize = 4;

	mov	DWORD PTR dispSize$[rsp], 4

; 1648 :             relocId = -1;

	mov	QWORD PTR relocId$[rsp], -1

; 1649 :             goto _EmitDisplacement;

	jmp	$LN1169@X86Assembl
	jmp	$_EmitDisplacement$1957
$LN1167@X86Assembl:
$LN1161@X86Assembl:
$LN1159@X86Assembl:

; 1650 :           }
; 1651 :         }
; 1652 :       }
; 1653 :       break;

	jmp	$LN5@X86Assembl
$LN1170@X86Assembl:

; 1654 : 
; 1655 :     case kX86InstEncodingIdX86Lea:
; 1656 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1171@X86Assembl
$LN207@X86Assembl:

; 1657 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN207@X86Assembl
$LN210@X86Assembl:

; 1658 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1172@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1172@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1172@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN210@X86Assembl

; 1659 : 
; 1660 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1661 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1662 :         goto _EmitX86M;

	jmp	$LN1173@X86Assembl
	jmp	$_EmitX86M$1954
$LN1171@X86Assembl:

; 1663 :       }
; 1664 :       break;

	jmp	$LN5@X86Assembl
$LN1174@X86Assembl:

; 1665 : 
; 1666 :     case kX86InstEncodingIdX86Mov:
; 1667 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	$LN1175@X86Assembl

; 1668 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1669 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1670 : 
; 1671 :         // Sreg <- Reg
; 1672 :         if (static_cast<const X86Reg*>(o0)->isSeg()) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isSeg@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isSeg
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1176@X86Assembl

; 1673 :           ASMJIT_ASSERT(static_cast<const X86Reg*>(o1)->isGpw() ||
; 1674 :                         static_cast<const X86Reg*>(o1)->isGpd() ||
; 1675 :                         static_cast<const X86Reg*>(o1)->isGpq() );
; 1676 :           opCode = 0x8E;

	mov	DWORD PTR opCode$[rsp], 142		; 0000008eH
$LN213@X86Assembl:

; 1677 :           ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN213@X86Assembl
$LN216@X86Assembl:

; 1678 :           ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1177@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1177@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1177@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN216@X86Assembl

; 1679 :           goto _EmitX86R;

	jmp	$LN1178@X86Assembl
	jmp	$_EmitX86R$1953
$LN1176@X86Assembl:

; 1680 :         }
; 1681 : 
; 1682 :         // Reg <- Sreg
; 1683 :         if (static_cast<const X86Reg*>(o1)->isSeg()) {

	mov	rcx, QWORD PTR o1$[rsp]
	call	?isSeg@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isSeg
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1179@X86Assembl

; 1684 :           ASMJIT_ASSERT(static_cast<const X86Reg*>(o0)->isGpw() ||
; 1685 :                         static_cast<const X86Reg*>(o0)->isGpd() ||
; 1686 :                         static_cast<const X86Reg*>(o0)->isGpq() );
; 1687 :           opCode = 0x8C;

	mov	DWORD PTR opCode$[rsp], 140		; 0000008cH
$LN219@X86Assembl:

; 1688 :           ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN219@X86Assembl
$LN222@X86Assembl:

; 1689 :           ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1181@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1181@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1181@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN222@X86Assembl

; 1690 :           goto _EmitX86R;

	jmp	$LN1182@X86Assembl
	jmp	$_EmitX86R$1953

; 1691 :         }

	jmp	$LN1180@X86Assembl
$LN1179@X86Assembl:

; 1692 :         // Reg <- Reg
; 1693 :         else {
; 1694 :           ASMJIT_ASSERT(static_cast<const X86Reg*>(o0)->isGpb() ||
; 1695 :                         static_cast<const X86Reg*>(o0)->isGpw() ||
; 1696 :                         static_cast<const X86Reg*>(o0)->isGpd() ||
; 1697 :                         static_cast<const X86Reg*>(o0)->isGpq() );
; 1698 :           opCode = 0x8A + (o0->getSize() != 1);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1868@X86Assembl
	mov	DWORD PTR tv1163[rsp], 1
	jmp	SHORT $LN1869@X86Assembl
$LN1868@X86Assembl:
	mov	DWORD PTR tv1163[rsp], 0
$LN1869@X86Assembl:
	mov	eax, DWORD PTR tv1163[rsp]
	add	eax, 138				; 0000008aH
	mov	DWORD PTR opCode$[rsp], eax
$LN225@X86Assembl:

; 1699 :           ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN225@X86Assembl
$LN228@X86Assembl:

; 1700 :           ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1183@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1183@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1183@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN228@X86Assembl

; 1701 :           goto _EmitX86R;

	jmp	$LN1184@X86Assembl
	jmp	$_EmitX86R$1953
$LN1180@X86Assembl:
$LN1175@X86Assembl:

; 1702 :         }
; 1703 :       }
; 1704 : 
; 1705 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	$LN1185@X86Assembl

; 1706 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1707 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1708 : 
; 1709 :         // Sreg <- Mem
; 1710 :         if (static_cast<const X86Reg*>(o0)->isRegType(kX86RegTypeSeg)) {

	mov	edx, 240				; 000000f0H
	mov	rcx, QWORD PTR o0$[rsp]
	call	?isRegType@Reg@asmjit@@QEBA_NI@Z	; asmjit::Reg::isRegType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1186@X86Assembl

; 1711 :           opCode = 0x8E;

	mov	DWORD PTR opCode$[rsp], 142		; 0000008eH

; 1712 :           opReg--;

	mov	eax, DWORD PTR opReg$[rsp]
	dec	eax
	mov	DWORD PTR opReg$[rsp], eax
$LN231@X86Assembl:

; 1713 :           ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN231@X86Assembl
$LN234@X86Assembl:

; 1714 :           ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1188@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1188@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1188@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN234@X86Assembl

; 1715 :           goto _EmitX86M;

	jmp	$LN1189@X86Assembl
	jmp	$_EmitX86M$1954

; 1716 :         }

	jmp	$LN1187@X86Assembl
$LN1186@X86Assembl:

; 1717 :         // Reg <- Mem
; 1718 :         else {
; 1719 :           ASMJIT_ASSERT(static_cast<const X86Reg*>(o0)->isGpb() ||
; 1720 :                         static_cast<const X86Reg*>(o0)->isGpw() ||
; 1721 :                         static_cast<const X86Reg*>(o0)->isGpd() ||
; 1722 :                         static_cast<const X86Reg*>(o0)->isGpq() );
; 1723 :           opCode = 0x8A + (o0->getSize() != 1);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1870@X86Assembl
	mov	DWORD PTR tv1211[rsp], 1
	jmp	SHORT $LN1871@X86Assembl
$LN1870@X86Assembl:
	mov	DWORD PTR tv1211[rsp], 0
$LN1871@X86Assembl:
	mov	eax, DWORD PTR tv1211[rsp]
	add	eax, 138				; 0000008aH
	mov	DWORD PTR opCode$[rsp], eax
$LN237@X86Assembl:

; 1724 :           ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN237@X86Assembl
$LN240@X86Assembl:

; 1725 :           ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1190@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1190@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1190@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN240@X86Assembl

; 1726 :           goto _EmitX86M;

	jmp	$LN1191@X86Assembl
	jmp	$_EmitX86M$1954
$LN1187@X86Assembl:
$LN1185@X86Assembl:

; 1727 :         }
; 1728 :       }
; 1729 : 
; 1730 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	$LN1192@X86Assembl

; 1731 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1732 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1733 : 
; 1734 :         // X86Mem <- Sreg
; 1735 :         if (static_cast<const X86Reg*>(o1)->isSeg()) {

	mov	rcx, QWORD PTR o1$[rsp]
	call	?isSeg@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isSeg
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1193@X86Assembl

; 1736 :           opCode = 0x8C;

	mov	DWORD PTR opCode$[rsp], 140		; 0000008cH
$LN243@X86Assembl:

; 1737 :           ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN243@X86Assembl
$LN246@X86Assembl:

; 1738 :           ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1195@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1195@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1195@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN246@X86Assembl

; 1739 :           goto _EmitX86M;

	jmp	$LN1196@X86Assembl
	jmp	$_EmitX86M$1954

; 1740 :         }

	jmp	$LN1194@X86Assembl
$LN1193@X86Assembl:

; 1741 :         // X86Mem <- Reg
; 1742 :         else {
; 1743 :           ASMJIT_ASSERT(static_cast<const X86Reg*>(o1)->isGpb() ||
; 1744 :                         static_cast<const X86Reg*>(o1)->isGpw() ||
; 1745 :                         static_cast<const X86Reg*>(o1)->isGpd() ||
; 1746 :                         static_cast<const X86Reg*>(o1)->isGpq() );
; 1747 :           opCode = 0x88 + (o1->getSize() != 1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1872@X86Assembl
	mov	DWORD PTR tv1253[rsp], 1
	jmp	SHORT $LN1873@X86Assembl
$LN1872@X86Assembl:
	mov	DWORD PTR tv1253[rsp], 0
$LN1873@X86Assembl:
	mov	eax, DWORD PTR tv1253[rsp]
	add	eax, 136				; 00000088H
	mov	DWORD PTR opCode$[rsp], eax
$LN249@X86Assembl:

; 1748 :           ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN249@X86Assembl
$LN252@X86Assembl:

; 1749 :           ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1197@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1197@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1197@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN252@X86Assembl

; 1750 :           goto _EmitX86M;

	jmp	$LN1198@X86Assembl
	jmp	$_EmitX86M$1954
$LN1194@X86Assembl:
$LN1192@X86Assembl:

; 1751 :         }
; 1752 :       }
; 1753 : 
; 1754 :       if (encoded == ENC_OPS(Reg, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 33		; 00000021H
	jne	$LN1199@X86Assembl

; 1755 :         // 64-bit immediate in 64-bit mode is allowed.
; 1756 :         imVal = static_cast<const Imm*>(o1)->getInt64();

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1757 :         imLen = o0->getSize();

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	mov	DWORD PTR imLen$[rsp], eax

; 1758 : 
; 1759 :         opReg = 0;

	mov	DWORD PTR opReg$[rsp], 0

; 1760 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1761 : 
; 1762 :         // Optimize instruction size by using 32-bit immediate if possible.
; 1763 :         if (Arch == kArchX64 && imLen == 8 && IntUtil::isInt32(imVal)) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1200@X86Assembl
	cmp	DWORD PTR imLen$[rsp], 8
	jne	SHORT $LN1200@X86Assembl
	mov	rcx, QWORD PTR imVal$[rsp]
	call	??$isInt32@_J@IntUtil@asmjit@@SA_N_J@Z	; asmjit::IntUtil::isInt32<__int64>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1200@X86Assembl

; 1764 :           opCode = 0xC7;

	mov	DWORD PTR opCode$[rsp], 199		; 000000c7H
$LN255@X86Assembl:

; 1765 :           ADD_REX_W(1);

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1202@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1202@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN255@X86Assembl

; 1766 :           imLen = 4;

	mov	DWORD PTR imLen$[rsp], 4

; 1767 :           goto _EmitX86R;

	jmp	$LN1203@X86Assembl
	jmp	$_EmitX86R$1953

; 1768 :         }

	jmp	SHORT $LN1201@X86Assembl
$LN1200@X86Assembl:

; 1769 :         else {
; 1770 :           opCode = 0xB0 + (static_cast<uint32_t>(o0->getSize() != 1) << 3);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1874@X86Assembl
	mov	DWORD PTR tv1291[rsp], 1
	jmp	SHORT $LN1875@X86Assembl
$LN1874@X86Assembl:
	mov	DWORD PTR tv1291[rsp], 0
$LN1875@X86Assembl:
	mov	eax, DWORD PTR tv1291[rsp]
	lea	eax, DWORD PTR [rax*8+176]
	mov	DWORD PTR opCode$[rsp], eax

; 1771 :           opReg = rmReg;

	mov	eax, DWORD PTR $S1$[rsp]
	mov	DWORD PTR opReg$[rsp], eax
$LN258@X86Assembl:

; 1772 : 
; 1773 :           ADD_REX_W_BY_SIZE(imLen);

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1204@X86Assembl
	cmp	DWORD PTR imLen$[rsp], 8
	jne	SHORT $LN1204@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1204@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN258@X86Assembl

; 1774 :           goto _EmitX86OpWithOpReg;

	jmp	$LN1205@X86Assembl
	jmp	$_EmitX86OpWithOpReg$1955
$LN1201@X86Assembl:
$LN1199@X86Assembl:

; 1775 :         }
; 1776 :       }
; 1777 : 
; 1778 :       if (encoded == ENC_OPS(Mem, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 35		; 00000023H
	jne	$LN1206@X86Assembl

; 1779 :         uint32_t memSize = o0->getSize();

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	mov	DWORD PTR memSize$22[rsp], eax

; 1780 : 
; 1781 :         if (memSize == 0)

	cmp	DWORD PTR memSize$22[rsp], 0
	jne	SHORT $LN1207@X86Assembl

; 1782 :           goto _IllegalInst;

	jmp	$LN1208@X86Assembl
	jmp	$_IllegalInst$1950
$LN1207@X86Assembl:

; 1783 : 
; 1784 :         imVal = static_cast<const Imm*>(o1)->getInt64();

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1785 :         imLen = IntUtil::iMin<uint32_t>(memSize, 4);

	mov	DWORD PTR $T57[rsp], 4
	lea	rdx, QWORD PTR $T57[rsp]
	lea	rcx, QWORD PTR memSize$22[rsp]
	call	??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z	; asmjit::IntUtil::iMin<unsigned int>
	mov	DWORD PTR imLen$[rsp], eax

; 1786 : 
; 1787 :         opCode = 0xC6 + (memSize != 1);

	cmp	DWORD PTR memSize$22[rsp], 1
	je	SHORT $LN1876@X86Assembl
	mov	DWORD PTR tv1312[rsp], 1
	jmp	SHORT $LN1877@X86Assembl
$LN1876@X86Assembl:
	mov	DWORD PTR tv1312[rsp], 0
$LN1877@X86Assembl:
	mov	eax, DWORD PTR tv1312[rsp]
	add	eax, 198				; 000000c6H
	mov	DWORD PTR opCode$[rsp], eax

; 1788 :         opReg = 0;

	mov	DWORD PTR opReg$[rsp], 0
$LN261@X86Assembl:

; 1789 :         ADD_66H_P_BY_SIZE(memSize);

	mov	eax, DWORD PTR memSize$22[rsp]
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN261@X86Assembl
$LN264@X86Assembl:

; 1790 :         ADD_REX_W_BY_SIZE(memSize);

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1209@X86Assembl
	cmp	DWORD PTR memSize$22[rsp], 8
	jne	SHORT $LN1209@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1209@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN264@X86Assembl

; 1791 : 
; 1792 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1793 :         goto _EmitX86M;

	jmp	$LN1210@X86Assembl
	jmp	$_EmitX86M$1954
$LN1206@X86Assembl:

; 1794 :       }
; 1795 :       break;

	jmp	$LN5@X86Assembl
$LN1211@X86Assembl:

; 1796 : 
; 1797 :     case kX86InstEncodingIdX86MovSxZx:
; 1798 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	$LN1212@X86Assembl

; 1799 :         opCode += o1->getSize() != 1;

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1878@X86Assembl
	mov	DWORD PTR tv1328[rsp], 1
	jmp	SHORT $LN1879@X86Assembl
$LN1878@X86Assembl:
	mov	DWORD PTR tv1328[rsp], 0
$LN1879@X86Assembl:
	mov	eax, DWORD PTR tv1328[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN267@X86Assembl:

; 1800 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN267@X86Assembl
$LN270@X86Assembl:

; 1801 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1213@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1213@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1213@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN270@X86Assembl

; 1802 : 
; 1803 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1804 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1805 :         goto _EmitX86R;

	jmp	$LN1214@X86Assembl
	jmp	$_EmitX86R$1953
$LN1212@X86Assembl:

; 1806 :       }
; 1807 : 
; 1808 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	$LN1215@X86Assembl

; 1809 :         opCode += o1->getSize() != 1;

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1880@X86Assembl
	mov	DWORD PTR tv1351[rsp], 1
	jmp	SHORT $LN1881@X86Assembl
$LN1880@X86Assembl:
	mov	DWORD PTR tv1351[rsp], 0
$LN1881@X86Assembl:
	mov	eax, DWORD PTR tv1351[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN273@X86Assembl:

; 1810 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN273@X86Assembl
$LN276@X86Assembl:

; 1811 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1216@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1216@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1216@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN276@X86Assembl

; 1812 : 
; 1813 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1814 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1815 :         goto _EmitX86M;

	jmp	$LN1217@X86Assembl
	jmp	$_EmitX86M$1954
$LN1215@X86Assembl:

; 1816 :       }
; 1817 :       break;

	jmp	$LN5@X86Assembl
$LN1218@X86Assembl:

; 1818 : 
; 1819 :     case kX86InstEncodingIdX86MovSxd:
; 1820 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1219@X86Assembl
$LN279@X86Assembl:

; 1821 :         ADD_REX_W(true);

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1220@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1220@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN279@X86Assembl

; 1822 : 
; 1823 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1824 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1825 :         goto _EmitX86R;

	jmp	$LN1221@X86Assembl
	jmp	$_EmitX86R$1953
$LN1219@X86Assembl:

; 1826 :       }
; 1827 : 
; 1828 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1222@X86Assembl
$LN282@X86Assembl:

; 1829 :         ADD_REX_W(true);

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1223@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1223@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN282@X86Assembl

; 1830 : 
; 1831 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 1832 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1833 :         goto _EmitX86M;

	jmp	$LN1224@X86Assembl
	jmp	$_EmitX86M$1954
$LN1222@X86Assembl:

; 1834 :       }
; 1835 :       break;

	jmp	$LN5@X86Assembl
$LN1225@X86Assembl:

; 1836 : 
; 1837 :     case kX86InstEncodingIdX86MovPtr:
; 1838 :       if (encoded == ENC_OPS(Reg, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 33		; 00000021H
	jne	$LN1226@X86Assembl

; 1839 :         ASMJIT_ASSERT(x86OpReg(o0) == 0);
; 1840 : 
; 1841 :         opCode += o0->getSize() != 1;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1882@X86Assembl
	mov	DWORD PTR tv1390[rsp], 1
	jmp	SHORT $LN1883@X86Assembl
$LN1882@X86Assembl:
	mov	DWORD PTR tv1390[rsp], 0
$LN1883@X86Assembl:
	mov	eax, DWORD PTR tv1390[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN285@X86Assembl:

; 1842 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN285@X86Assembl
$LN288@X86Assembl:

; 1843 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1227@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1227@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1227@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN288@X86Assembl

; 1844 : 
; 1845 :         imVal = static_cast<const Imm*>(o1)->getInt64();

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1846 :         imLen = self->_regSize;

	mov	rax, QWORD PTR self$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	mov	DWORD PTR imLen$[rsp], eax

; 1847 :         goto _EmitX86Op;

	jmp	$LN1228@X86Assembl
	jmp	$_EmitX86Op$1952
$LN1226@X86Assembl:

; 1848 :       }
; 1849 : 
; 1850 :       // The following instruction uses the secondary opcode.
; 1851 :       opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 1852 : 
; 1853 :       if (encoded == ENC_OPS(Imm, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 12
	jne	$LN1229@X86Assembl

; 1854 :         ASMJIT_ASSERT(x86OpReg(o1) == 0);
; 1855 : 
; 1856 :         opCode += o1->getSize() != 1;

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1884@X86Assembl
	mov	DWORD PTR tv1422[rsp], 1
	jmp	SHORT $LN1885@X86Assembl
$LN1884@X86Assembl:
	mov	DWORD PTR tv1422[rsp], 0
$LN1885@X86Assembl:
	mov	eax, DWORD PTR tv1422[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN291@X86Assembl:

; 1857 :         ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN291@X86Assembl
$LN294@X86Assembl:

; 1858 :         ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1230@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1230@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1230@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN294@X86Assembl

; 1859 : 
; 1860 :         imVal = static_cast<const Imm*>(o0)->getInt64();

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1861 :         imLen = self->_regSize;

	mov	rax, QWORD PTR self$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	mov	DWORD PTR imLen$[rsp], eax

; 1862 :         goto _EmitX86Op;

	jmp	$LN1231@X86Assembl
	jmp	$_EmitX86Op$1952
$LN1229@X86Assembl:

; 1863 :       }
; 1864 :       break;

	jmp	$LN5@X86Assembl
$LN1232@X86Assembl:

; 1865 : 
; 1866 :     case kX86InstEncodingIdX86Push:
; 1867 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	$LN1233@X86Assembl

; 1868 :         if (o0->isRegType(kX86RegTypeSeg)) {

	mov	edx, 240				; 000000f0H
	mov	rcx, QWORD PTR o0$[rsp]
	call	?isRegType@Operand@asmjit@@QEBA_NI@Z	; asmjit::Operand::isRegType
	movzx	eax, al
	test	eax, eax
	je	$LN1234@X86Assembl

; 1869 :           uint32_t segment = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR segment$26[rsp], eax

; 1870 :           ASMJIT_ASSERT(segment < kX86SegCount);
; 1871 : 
; 1872 :           if (segment >= kX86SegFs)

	cmp	DWORD PTR segment$26[rsp], 5
	jb	SHORT $LN1236@X86Assembl
$LN297@X86Assembl:

; 1873 :             EMIT_BYTE(0x0F);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 15
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN297@X86Assembl
$LN1236@X86Assembl:
$LN300@X86Assembl:

; 1874 : 
; 1875 :           EMIT_BYTE(x86OpCodePushSeg[segment]);

	mov	eax, DWORD PTR segment$26[rsp]
	lea	rcx, OFFSET FLAT:?x86OpCodePushSeg@asmjit@@3QBEB
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR cursor$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN300@X86Assembl

; 1876 :           goto _EmitDone;

	jmp	$LN1237@X86Assembl
	jmp	$_EmitDone$1951

; 1877 :         }

	jmp	SHORT $LN1235@X86Assembl
$LN1234@X86Assembl:

; 1878 :         else {
; 1879 :           goto _GroupPop_Gp;

	jmp	$LN1238@X86Assembl
	jmp	$_GroupPop_Gp$1958
$LN1235@X86Assembl:
$LN1233@X86Assembl:

; 1880 :         }
; 1881 :       }
; 1882 : 
; 1883 :       if (encoded == ENC_OPS(Imm, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 4
	jne	$LN1239@X86Assembl

; 1884 :         imVal = static_cast<const Imm*>(o0)->getInt64();

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1885 :         imLen = IntUtil::isInt8(imVal) ? 1 : 4;

	mov	rcx, QWORD PTR imVal$[rsp]
	call	??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z	; asmjit::IntUtil::isInt8<__int64>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1886@X86Assembl
	mov	DWORD PTR tv1479[rsp], 1
	jmp	SHORT $LN1887@X86Assembl
$LN1886@X86Assembl:
	mov	DWORD PTR tv1479[rsp], 4
$LN1887@X86Assembl:
	mov	eax, DWORD PTR tv1479[rsp]
	mov	DWORD PTR imLen$[rsp], eax
$LN303@X86Assembl:

; 1886 : 
; 1887 :         EMIT_BYTE(imLen == 1 ? 0x6A : 0x68);

	cmp	DWORD PTR imLen$[rsp], 1
	jne	SHORT $LN1888@X86Assembl
	mov	DWORD PTR tv1483[rsp], 106		; 0000006aH
	jmp	SHORT $LN1889@X86Assembl
$LN1888@X86Assembl:
	mov	DWORD PTR tv1483[rsp], 104		; 00000068H
$LN1889@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR tv1483[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN303@X86Assembl

; 1888 :         goto _EmitImm;

	jmp	$LN1240@X86Assembl
	jmp	$_EmitImm$1959
$LN1239@X86Assembl:
$LN1241@X86Assembl:

; 1889 :       }
; 1890 :       // ... Fall through ...
; 1891 : 
; 1892 :     case kX86InstEncodingIdX86Pop:
; 1893 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	$LN1242@X86Assembl

; 1894 :         if (o0->isRegType(kX86RegTypeSeg)) {

	mov	edx, 240				; 000000f0H
	mov	rcx, QWORD PTR o0$[rsp]
	call	?isRegType@Operand@asmjit@@QEBA_NI@Z	; asmjit::Operand::isRegType
	movzx	eax, al
	test	eax, eax
	je	$LN1243@X86Assembl

; 1895 :           uint32_t segment = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR segment$27[rsp], eax

; 1896 :           ASMJIT_ASSERT(segment < kX86SegCount);
; 1897 : 
; 1898 :           if (segment >= kX86SegFs)

	cmp	DWORD PTR segment$27[rsp], 5
	jb	SHORT $LN1245@X86Assembl
$LN306@X86Assembl:

; 1899 :             EMIT_BYTE(0x0F);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 15
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN306@X86Assembl
$LN1245@X86Assembl:
$LN309@X86Assembl:

; 1900 : 
; 1901 :           EMIT_BYTE(x86OpCodePopSeg[segment]);

	mov	eax, DWORD PTR segment$27[rsp]
	lea	rcx, OFFSET FLAT:?x86OpCodePopSeg@asmjit@@3QBEB
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR cursor$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN309@X86Assembl

; 1902 :           goto _EmitDone;

	jmp	$LN1246@X86Assembl
	jmp	$_EmitDone$1951

; 1903 :         }

	jmp	SHORT $LN1244@X86Assembl
$LN1243@X86Assembl:
$LN1238@X86Assembl:
$_GroupPop_Gp$1958:

; 1904 :         else {
; 1905 : _GroupPop_Gp:
; 1906 :           ASMJIT_ASSERT(static_cast<const X86Reg*>(o0)->getSize() == 2 ||
; 1907 :                         static_cast<const X86Reg*>(o0)->getSize() == self->_regSize);
; 1908 : 
; 1909 :           opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 1910 :           opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax
$LN312@X86Assembl:

; 1911 : 
; 1912 :           ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN312@X86Assembl

; 1913 :           goto _EmitX86OpWithOpReg;

	jmp	$LN1247@X86Assembl
	jmp	$_EmitX86OpWithOpReg$1955
$LN1244@X86Assembl:
$LN1242@X86Assembl:

; 1914 :         }
; 1915 :       }
; 1916 : 
; 1917 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	SHORT $LN1248@X86Assembl
$LN315@X86Assembl:

; 1918 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN315@X86Assembl

; 1919 : 
; 1920 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1921 :         goto _EmitX86M;

	jmp	$LN1249@X86Assembl
	jmp	$_EmitX86M$1954
$LN1248@X86Assembl:

; 1922 :       }
; 1923 :       break;

	jmp	$LN5@X86Assembl
$LN1250@X86Assembl:
$LN318@X86Assembl:

; 1924 : 
; 1925 :     case kX86InstEncodingIdX86Rep:
; 1926 :       // Emit REP 0xF2 or 0xF3 prefix first.
; 1927 :       EMIT_BYTE(0xF2 + opReg);

	mov	eax, DWORD PTR opReg$[rsp]
	add	eax, 242				; 000000f2H
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN318@X86Assembl

; 1928 :       goto _EmitX86Op;

	jmp	$LN1251@X86Assembl
	jmp	$_EmitX86Op$1952
$LN1252@X86Assembl:

; 1929 : 
; 1930 :     case kX86InstEncodingIdX86Ret:
; 1931 :       if (encoded == ENC_OPS(None, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 0
	jne	SHORT $LN1253@X86Assembl
$LN321@X86Assembl:

; 1932 :         EMIT_BYTE(0xC3);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 195			; 000000c3H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN321@X86Assembl

; 1933 :         goto _EmitDone;

	jmp	$LN1254@X86Assembl
	jmp	$_EmitDone$1951
$LN1253@X86Assembl:

; 1934 :       }
; 1935 : 
; 1936 :       if (encoded == ENC_OPS(Imm, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 4
	jne	$LN1255@X86Assembl

; 1937 :         imVal = static_cast<const Imm*>(o0)->getInt64();

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 1938 :         if (imVal == 0) {

	cmp	QWORD PTR imVal$[rsp], 0
	jne	SHORT $LN1256@X86Assembl
$LN324@X86Assembl:

; 1939 :           EMIT_BYTE(0xC3);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 195			; 000000c3H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN324@X86Assembl

; 1940 :           goto _EmitDone;

	jmp	$LN1258@X86Assembl
	jmp	$_EmitDone$1951

; 1941 :         }

	jmp	SHORT $LN1257@X86Assembl
$LN1256@X86Assembl:
$LN327@X86Assembl:

; 1942 :         else {
; 1943 :           EMIT_BYTE(0xC2);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 194			; 000000c2H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN327@X86Assembl

; 1944 :           imLen = 2;

	mov	DWORD PTR imLen$[rsp], 2

; 1945 :           goto _EmitImm;

	jmp	$LN1259@X86Assembl
	jmp	$_EmitImm$1959
$LN1257@X86Assembl:
$LN1255@X86Assembl:

; 1946 :         }
; 1947 :       }
; 1948 :       break;

	jmp	$LN5@X86Assembl
$LN1260@X86Assembl:

; 1949 : 
; 1950 :     case kX86InstEncodingIdX86Rot:
; 1951 :       opCode += o0->getSize() != 1;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1890@X86Assembl
	mov	DWORD PTR tv1556[rsp], 1
	jmp	SHORT $LN1891@X86Assembl
$LN1890@X86Assembl:
	mov	DWORD PTR tv1556[rsp], 0
$LN1891@X86Assembl:
	mov	eax, DWORD PTR tv1556[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN330@X86Assembl:

; 1952 :       ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN330@X86Assembl
$LN333@X86Assembl:

; 1953 :       ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1261@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1261@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1261@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN333@X86Assembl

; 1954 : 
; 1955 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1262@X86Assembl

; 1956 :         ASMJIT_ASSERT(static_cast<const X86Reg*>(o1)->isRegCode(kX86RegTypeGpbLo, kX86RegIndexCx));
; 1957 :         opCode += 2;

	mov	eax, DWORD PTR opCode$[rsp]
	add	eax, 2
	mov	DWORD PTR opCode$[rsp], eax

; 1958 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1959 :         goto _EmitX86R;

	jmp	$LN1263@X86Assembl
	jmp	$_EmitX86R$1953
$LN1262@X86Assembl:

; 1960 :       }
; 1961 : 
; 1962 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	SHORT $LN1264@X86Assembl

; 1963 :         ASMJIT_ASSERT(static_cast<const X86Reg*>(o1)->isRegCode(kX86RegTypeGpbLo, kX86RegIndexCx));
; 1964 :         opCode += 2;

	mov	eax, DWORD PTR opCode$[rsp]
	add	eax, 2
	mov	DWORD PTR opCode$[rsp], eax

; 1965 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1966 :         goto _EmitX86M;

	jmp	$LN1265@X86Assembl
	jmp	$_EmitX86M$1954
$LN1264@X86Assembl:

; 1967 :       }
; 1968 : 
; 1969 :       if (encoded == ENC_OPS(Reg, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 33		; 00000021H
	jne	SHORT $LN1266@X86Assembl

; 1970 :         imVal = static_cast<const Imm*>(o1)->getInt64() & 0xFF;

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	and	rax, 255				; 000000ffH
	mov	QWORD PTR imVal$[rsp], rax

; 1971 :         imLen = imVal != 1;

	cmp	QWORD PTR imVal$[rsp], 1
	je	SHORT $LN1892@X86Assembl
	mov	DWORD PTR tv1588[rsp], 1
	jmp	SHORT $LN1893@X86Assembl
$LN1892@X86Assembl:
	mov	DWORD PTR tv1588[rsp], 0
$LN1893@X86Assembl:
	mov	eax, DWORD PTR tv1588[rsp]
	mov	DWORD PTR imLen$[rsp], eax

; 1972 :         if (imLen)

	cmp	DWORD PTR imLen$[rsp], 0
	je	SHORT $LN1267@X86Assembl

; 1973 :           opCode -= 0x10;

	mov	eax, DWORD PTR opCode$[rsp]
	sub	eax, 16
	mov	DWORD PTR opCode$[rsp], eax
$LN1267@X86Assembl:

; 1974 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1975 :         goto _EmitX86R;

	jmp	$LN1268@X86Assembl
	jmp	$_EmitX86R$1953
$LN1266@X86Assembl:

; 1976 :       }
; 1977 : 
; 1978 :       if (encoded == ENC_OPS(Mem, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 35		; 00000023H
	jne	$LN1269@X86Assembl

; 1979 :         if (o0->getSize() == 0)

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	test	eax, eax
	jne	SHORT $LN1270@X86Assembl

; 1980 :           goto _IllegalInst;

	jmp	$LN1271@X86Assembl
	jmp	$_IllegalInst$1950
$LN1270@X86Assembl:

; 1981 : 
; 1982 :         imVal = static_cast<const Imm*>(o1)->getInt64() & 0xFF;

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	and	rax, 255				; 000000ffH
	mov	QWORD PTR imVal$[rsp], rax

; 1983 :         imLen = imVal != 1;

	cmp	QWORD PTR imVal$[rsp], 1
	je	SHORT $LN1894@X86Assembl
	mov	DWORD PTR tv1606[rsp], 1
	jmp	SHORT $LN1895@X86Assembl
$LN1894@X86Assembl:
	mov	DWORD PTR tv1606[rsp], 0
$LN1895@X86Assembl:
	mov	eax, DWORD PTR tv1606[rsp]
	mov	DWORD PTR imLen$[rsp], eax

; 1984 :         if (imLen)

	cmp	DWORD PTR imLen$[rsp], 0
	je	SHORT $LN1272@X86Assembl

; 1985 :           opCode -= 0x10;

	mov	eax, DWORD PTR opCode$[rsp]
	sub	eax, 16
	mov	DWORD PTR opCode$[rsp], eax
$LN1272@X86Assembl:

; 1986 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 1987 :         goto _EmitX86M;

	jmp	$LN1273@X86Assembl
	jmp	$_EmitX86M$1954
$LN1269@X86Assembl:

; 1988 :       }
; 1989 :       break;

	jmp	$LN5@X86Assembl
$LN1274@X86Assembl:

; 1990 : 
; 1991 :     case kX86InstEncodingIdX86Set:
; 1992 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	SHORT $LN1275@X86Assembl

; 1993 :         ASMJIT_ASSERT(o0->getSize() == 1);
; 1994 : 
; 1995 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 1996 :         goto _EmitX86R;

	jmp	$LN1276@X86Assembl
	jmp	$_EmitX86R$1953
$LN1275@X86Assembl:

; 1997 :       }
; 1998 : 
; 1999 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	SHORT $LN1277@X86Assembl

; 2000 :         ASMJIT_ASSERT(o0->getSize() <= 1);
; 2001 : 
; 2002 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2003 :         goto _EmitX86M;

	jmp	$LN1278@X86Assembl
	jmp	$_EmitX86M$1954
$LN1277@X86Assembl:

; 2004 :       }
; 2005 :       break;

	jmp	$LN5@X86Assembl
$LN1279@X86Assembl:

; 2006 : 
; 2007 :     case kX86InstEncodingIdX86Shlrd:
; 2008 :       if (encoded == ENC_OPS(Reg, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 265		; 00000109H
	jne	$LN1280@X86Assembl
$LN336@X86Assembl:

; 2009 :         ASMJIT_ASSERT(o0->getSize() == o1->getSize());
; 2010 : 
; 2011 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN336@X86Assembl
$LN339@X86Assembl:

; 2012 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1281@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1281@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1281@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN339@X86Assembl

; 2013 : 
; 2014 :         imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2015 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2016 : 
; 2017 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2018 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2019 :         goto _EmitX86R;

	jmp	$LN1282@X86Assembl
	jmp	$_EmitX86R$1953
$LN1280@X86Assembl:

; 2020 :       }
; 2021 : 
; 2022 :       if (encoded == ENC_OPS(Mem, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 267		; 0000010bH
	jne	$LN1283@X86Assembl
$LN342@X86Assembl:

; 2023 :         ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN342@X86Assembl
$LN345@X86Assembl:

; 2024 :         ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1284@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1284@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1284@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN345@X86Assembl

; 2025 : 
; 2026 :         imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2027 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2028 : 
; 2029 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2030 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2031 :         goto _EmitX86M;

	jmp	$LN1285@X86Assembl
	jmp	$_EmitX86M$1954
$LN1283@X86Assembl:

; 2032 :       }
; 2033 : 
; 2034 :       // The following instructions use opCode + 1.
; 2035 :       opCode++;

	mov	eax, DWORD PTR opCode$[rsp]
	inc	eax
	mov	DWORD PTR opCode$[rsp], eax

; 2036 : 
; 2037 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1286@X86Assembl
$LN348@X86Assembl:

; 2038 :         ASMJIT_ASSERT(static_cast<const X86Reg*>(o2)->isRegCode(kX86RegTypeGpbLo, kX86RegIndexCx));
; 2039 :         ASMJIT_ASSERT(o0->getSize() == o1->getSize());
; 2040 : 
; 2041 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN348@X86Assembl
$LN351@X86Assembl:

; 2042 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1287@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1287@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1287@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN351@X86Assembl

; 2043 : 
; 2044 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2045 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2046 :         goto _EmitX86R;

	jmp	$LN1288@X86Assembl
	jmp	$_EmitX86R$1953
$LN1286@X86Assembl:

; 2047 :       }
; 2048 : 
; 2049 :       if (encoded == ENC_OPS(Mem, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 75		; 0000004bH
	jne	SHORT $LN1289@X86Assembl
$LN354@X86Assembl:

; 2050 :         ASMJIT_ASSERT(static_cast<const X86Reg*>(o2)->isRegCode(kX86RegTypeGpbLo, kX86RegIndexCx));
; 2051 : 
; 2052 :         ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN354@X86Assembl
$LN357@X86Assembl:

; 2053 :         ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1290@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1290@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1290@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN357@X86Assembl

; 2054 : 
; 2055 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2056 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2057 :         goto _EmitX86M;

	jmp	$LN1291@X86Assembl
	jmp	$_EmitX86M$1954
$LN1289@X86Assembl:

; 2058 :       }
; 2059 :       break;

	jmp	$LN5@X86Assembl
$LN1292@X86Assembl:

; 2060 : 
; 2061 :     case kX86InstEncodingIdX86Test:
; 2062 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	$LN1293@X86Assembl

; 2063 :         ASMJIT_ASSERT(o0->getSize() == o1->getSize());
; 2064 : 
; 2065 :         opCode += o0->getSize() != 1;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1896@X86Assembl
	mov	DWORD PTR tv1705[rsp], 1
	jmp	SHORT $LN1897@X86Assembl
$LN1896@X86Assembl:
	mov	DWORD PTR tv1705[rsp], 0
$LN1897@X86Assembl:
	mov	eax, DWORD PTR tv1705[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN360@X86Assembl:

; 2066 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN360@X86Assembl
$LN363@X86Assembl:

; 2067 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1294@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1294@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1294@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN363@X86Assembl

; 2068 : 
; 2069 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2070 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2071 :         goto _EmitX86R;

	jmp	$LN1295@X86Assembl
	jmp	$_EmitX86R$1953
$LN1293@X86Assembl:

; 2072 :       }
; 2073 : 
; 2074 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	$LN1296@X86Assembl

; 2075 :         opCode += o1->getSize() != 1;

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1898@X86Assembl
	mov	DWORD PTR tv1728[rsp], 1
	jmp	SHORT $LN1899@X86Assembl
$LN1898@X86Assembl:
	mov	DWORD PTR tv1728[rsp], 0
$LN1899@X86Assembl:
	mov	eax, DWORD PTR tv1728[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN366@X86Assembl:

; 2076 :         ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN366@X86Assembl
$LN369@X86Assembl:

; 2077 :         ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1297@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1297@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1297@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN369@X86Assembl

; 2078 : 
; 2079 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2080 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2081 :         goto _EmitX86M;

	jmp	$LN1298@X86Assembl
	jmp	$_EmitX86M$1954
$LN1296@X86Assembl:

; 2082 :       }
; 2083 : 
; 2084 :       // The following instructions use the secondary opcode.
; 2085 :       opCode = extendedInfo.getSecondaryOpCode() + (o0->getSize() != 1);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1900@X86Assembl
	mov	DWORD PTR tv1751[rsp], 1
	jmp	SHORT $LN1901@X86Assembl
$LN1900@X86Assembl:
	mov	DWORD PTR tv1751[rsp], 0
$LN1901@X86Assembl:
	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	add	eax, DWORD PTR tv1751[rsp]
	mov	DWORD PTR opCode$[rsp], eax

; 2086 :       opReg = x86ExtractO(opCode);

	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86ExtractO@asmjit@@YAII@Z		; asmjit::x86ExtractO
	mov	DWORD PTR opReg$[rsp], eax

; 2087 : 
; 2088 :       if (encoded == ENC_OPS(Reg, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 33		; 00000021H
	jne	$LN1299@X86Assembl

; 2089 :         imVal = static_cast<const Imm*>(o1)->getInt64();

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2090 :         imLen = IntUtil::iMin<uint32_t>(o0->getSize(), 4);

	mov	DWORD PTR $T43[rsp], 4
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	mov	DWORD PTR $T44[rsp], eax
	lea	rdx, QWORD PTR $T43[rsp]
	lea	rcx, QWORD PTR $T44[rsp]
	call	??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z	; asmjit::IntUtil::iMin<unsigned int>
	mov	DWORD PTR imLen$[rsp], eax
$LN372@X86Assembl:

; 2091 : 
; 2092 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN372@X86Assembl
$LN375@X86Assembl:

; 2093 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1300@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1300@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1300@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN375@X86Assembl

; 2094 : 
; 2095 :         // Alternate Form - AL, AX, EAX, RAX.
; 2096 :         if (x86OpReg(o0) == 0) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	test	eax, eax
	jne	SHORT $LN1301@X86Assembl

; 2097 :           opCode &= kX86InstOpCode_PP_66 | kX86InstOpCode_W;

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, -2146435072			; 80100000H
	mov	DWORD PTR opCode$[rsp], eax

; 2098 :           opCode |= 0xA8 + (o0->getSize() != 1);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1902@X86Assembl
	mov	DWORD PTR tv1786[rsp], 1
	jmp	SHORT $LN1903@X86Assembl
$LN1902@X86Assembl:
	mov	DWORD PTR tv1786[rsp], 0
$LN1903@X86Assembl:
	mov	eax, DWORD PTR tv1786[rsp]
	add	eax, 168				; 000000a8H
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 2099 :           goto _EmitX86Op;

	jmp	$LN1302@X86Assembl
	jmp	$_EmitX86Op$1952
$LN1301@X86Assembl:

; 2100 :         }
; 2101 : 
; 2102 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2103 :         goto _EmitX86R;

	jmp	$LN1303@X86Assembl
	jmp	$_EmitX86R$1953
$LN1299@X86Assembl:

; 2104 :       }
; 2105 : 
; 2106 :       if (encoded == ENC_OPS(Mem, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 35		; 00000023H
	jne	$LN1304@X86Assembl

; 2107 :         if (o0->getSize() == 0)

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	test	eax, eax
	jne	SHORT $LN1305@X86Assembl

; 2108 :           goto _IllegalInst;

	jmp	$LN1306@X86Assembl
	jmp	$_IllegalInst$1950
$LN1305@X86Assembl:

; 2109 : 
; 2110 :         imVal = static_cast<const Imm*>(o1)->getInt64();

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2111 :         imLen = IntUtil::iMin<uint32_t>(o0->getSize(), 4);

	mov	DWORD PTR $T45[rsp], 4
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	mov	DWORD PTR $T46[rsp], eax
	lea	rdx, QWORD PTR $T45[rsp]
	lea	rcx, QWORD PTR $T46[rsp]
	call	??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z	; asmjit::IntUtil::iMin<unsigned int>
	mov	DWORD PTR imLen$[rsp], eax
$LN378@X86Assembl:

; 2112 : 
; 2113 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN378@X86Assembl
$LN381@X86Assembl:

; 2114 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1307@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1307@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1307@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN381@X86Assembl

; 2115 : 
; 2116 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2117 :         goto _EmitX86M;

	jmp	$LN1308@X86Assembl
	jmp	$_EmitX86M$1954
$LN1304@X86Assembl:

; 2118 :       }
; 2119 :       break;

	jmp	$LN5@X86Assembl
$LN1309@X86Assembl:

; 2120 : 
; 2121 :     case kX86InstEncodingIdX86Xchg:
; 2122 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	$LN1310@X86Assembl

; 2123 :         opCode += o0->getSize() != 1;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1904@X86Assembl
	mov	DWORD PTR tv1825[rsp], 1
	jmp	SHORT $LN1905@X86Assembl
$LN1904@X86Assembl:
	mov	DWORD PTR tv1825[rsp], 0
$LN1905@X86Assembl:
	mov	eax, DWORD PTR tv1825[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN384@X86Assembl:

; 2124 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN384@X86Assembl
$LN387@X86Assembl:

; 2125 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1311@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1311@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1311@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN387@X86Assembl

; 2126 : 
; 2127 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2128 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2129 :         goto _EmitX86M;

	jmp	$LN1312@X86Assembl
	jmp	$_EmitX86M$1954
$LN1310@X86Assembl:
$LN1313@X86Assembl:

; 2130 :       }
; 2131 :       // ... fall through ...
; 2132 : 
; 2133 :     case kX86InstEncodingIdX86Xadd:
; 2134 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	$LN1314@X86Assembl

; 2135 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2136 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax
$LN390@X86Assembl:

; 2137 : 
; 2138 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN390@X86Assembl
$LN393@X86Assembl:

; 2139 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1315@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1315@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1315@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN393@X86Assembl

; 2140 : 
; 2141 :         // Special opcode for 'xchg ?ax, reg'.
; 2142 :         if (code == kX86InstIdXchg && o0->getSize() > 1 && (opReg == 0 || rmReg == 0)) {

	cmp	DWORD PTR code$[rsp], 1050		; 0000041aH
	jne	SHORT $LN1316@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	jbe	SHORT $LN1316@X86Assembl
	cmp	DWORD PTR opReg$[rsp], 0
	je	SHORT $LN1317@X86Assembl
	cmp	QWORD PTR $S1$[rsp], 0
	jne	SHORT $LN1316@X86Assembl
$LN1317@X86Assembl:

; 2143 :           opCode &= kX86InstOpCode_PP_66 | kX86InstOpCode_W;

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, -2146435072			; 80100000H
	mov	DWORD PTR opCode$[rsp], eax

; 2144 :           opCode |= 0x90;

	mov	eax, DWORD PTR opCode$[rsp]
	or	eax, 144				; 00000090H
	mov	DWORD PTR opCode$[rsp], eax

; 2145 :           // One of `xchg a, b` or `xchg b, a` is AX/EAX/RAX.
; 2146 :           opReg += rmReg;

	mov	eax, DWORD PTR opReg$[rsp]
	add	rax, QWORD PTR $S1$[rsp]
	mov	DWORD PTR opReg$[rsp], eax

; 2147 :           goto _EmitX86OpWithOpReg;

	jmp	$LN1318@X86Assembl
	jmp	$_EmitX86OpWithOpReg$1955
$LN1316@X86Assembl:

; 2148 :         }
; 2149 : 
; 2150 :         opCode += o0->getSize() != 1;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1906@X86Assembl
	mov	DWORD PTR tv1875[rsp], 1
	jmp	SHORT $LN1907@X86Assembl
$LN1906@X86Assembl:
	mov	DWORD PTR tv1875[rsp], 0
$LN1907@X86Assembl:
	mov	eax, DWORD PTR tv1875[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 2151 :         goto _EmitX86R;

	jmp	$LN1319@X86Assembl
	jmp	$_EmitX86R$1953
$LN1314@X86Assembl:

; 2152 :       }
; 2153 : 
; 2154 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	$LN1320@X86Assembl

; 2155 :         opCode += o1->getSize() != 1;

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1908@X86Assembl
	mov	DWORD PTR tv1881[rsp], 1
	jmp	SHORT $LN1909@X86Assembl
$LN1908@X86Assembl:
	mov	DWORD PTR tv1881[rsp], 0
$LN1909@X86Assembl:
	mov	eax, DWORD PTR tv1881[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN396@X86Assembl:

; 2156 :         ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN396@X86Assembl
$LN399@X86Assembl:

; 2157 :         ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1321@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1321@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1321@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN399@X86Assembl

; 2158 : 
; 2159 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2160 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2161 :         goto _EmitX86M;

	jmp	$LN1322@X86Assembl
	jmp	$_EmitX86M$1954
$LN1320@X86Assembl:

; 2162 :       }
; 2163 :       break;

	jmp	$LN5@X86Assembl
$LN1323@X86Assembl:

; 2164 : 
; 2165 :     // ------------------------------------------------------------------------
; 2166 :     // [Fpu]
; 2167 :     // ------------------------------------------------------------------------
; 2168 : 
; 2169 :     case kX86InstEncodingIdFpuOp:
; 2170 :       goto _EmitFpuOp;

	jmp	$LN1324@X86Assembl
	jmp	$_EmitFpuOp$1960
$LN1325@X86Assembl:

; 2171 : 
; 2172 :     case kX86InstEncodingIdFpuArith:
; 2173 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	$LN1326@X86Assembl

; 2174 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2175 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2176 :         rmReg += opReg;

	mov	eax, DWORD PTR opReg$[rsp]
	mov	rcx, QWORD PTR $S1$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $S1$[rsp], rax

; 2177 : 
; 2178 :         // We switch to the alternative opcode if the first operand is zero.
; 2179 :         if (opReg == 0) {

	cmp	DWORD PTR opReg$[rsp], 0
	jne	SHORT $LN1327@X86Assembl
$_EmitFpArith_Reg$1961:

; 2180 : _EmitFpArith_Reg:
; 2181 :           opCode = 0xD800 + ((opCode >> 8) & 0xFF) + static_cast<uint32_t>(rmReg);

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR $S1$[rsp]
	lea	eax, DWORD PTR [rax+rcx+55296]
	mov	DWORD PTR opCode$[rsp], eax

; 2182 :           goto _EmitFpuOp;

	jmp	$LN1329@X86Assembl
	jmp	$_EmitFpuOp$1960

; 2183 :         }

	jmp	SHORT $LN1328@X86Assembl
$LN1327@X86Assembl:

; 2184 :         else {
; 2185 :           opCode = 0xDC00 + ((opCode >> 0) & 0xFF) + static_cast<uint32_t>(rmReg);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR $S1$[rsp]
	lea	eax, DWORD PTR [rax+rcx+56320]
	mov	DWORD PTR opCode$[rsp], eax

; 2186 :           goto _EmitFpuOp;

	jmp	$LN1330@X86Assembl
	jmp	$_EmitFpuOp$1960
$LN1328@X86Assembl:
$LN1326@X86Assembl:

; 2187 :         }
; 2188 :       }
; 2189 : 
; 2190 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	SHORT $LN1331@X86Assembl
$_EmitFpArith_Mem$1962:

; 2191 :         // 0xD8/0xDC, depends on the size of the memory operand; opReg has been
; 2192 :         // set already.
; 2193 : _EmitFpArith_Mem:
; 2194 :         opCode = (o0->getSize() == 4) ? 0xD8 : 0xDC;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 4
	jne	SHORT $LN1910@X86Assembl
	mov	DWORD PTR tv1919[rsp], 216		; 000000d8H
	jmp	SHORT $LN1911@X86Assembl
$LN1910@X86Assembl:
	mov	DWORD PTR tv1919[rsp], 220		; 000000dcH
$LN1911@X86Assembl:
	mov	eax, DWORD PTR tv1919[rsp]
	mov	DWORD PTR opCode$[rsp], eax

; 2195 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2196 :         goto _EmitX86M;

	jmp	$LN1332@X86Assembl
	jmp	$_EmitX86M$1954
$LN1331@X86Assembl:

; 2197 :       }
; 2198 :       break;

	jmp	$LN5@X86Assembl
$LN1333@X86Assembl:

; 2199 : 
; 2200 :     case kX86InstEncodingIdFpuCom:
; 2201 :       if (encoded == ENC_OPS(None, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 0
	jne	SHORT $LN1334@X86Assembl

; 2202 :         rmReg = 1;

	mov	QWORD PTR $S1$[rsp], 1

; 2203 :         goto _EmitFpArith_Reg;

	jmp	$_EmitFpArith_Reg$1961
$LN1334@X86Assembl:

; 2204 :       }
; 2205 : 
; 2206 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	SHORT $LN1335@X86Assembl

; 2207 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2208 :         goto _EmitFpArith_Reg;

	jmp	$_EmitFpArith_Reg$1961
$LN1335@X86Assembl:

; 2209 :       }
; 2210 : 
; 2211 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	SHORT $LN1336@X86Assembl

; 2212 :         goto _EmitFpArith_Mem;

	jmp	$_EmitFpArith_Mem$1962
$LN1336@X86Assembl:

; 2213 :       }
; 2214 :       break;

	jmp	$LN5@X86Assembl
$LN1337@X86Assembl:

; 2215 : 
; 2216 :     case kX86InstEncodingIdFpuFldFst:
; 2217 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	$LN1338@X86Assembl

; 2218 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2219 : 
; 2220 :         if (o0->getSize() == 4 && info.hasInstFlag(kX86InstFlagMem4)) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 4
	jne	SHORT $LN1339@X86Assembl
	mov	edx, 512				; 00000200H
	mov	rcx, QWORD PTR info$[rsp]
	call	?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z ; asmjit::X86InstInfo::hasInstFlag
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1339@X86Assembl

; 2221 :           goto _EmitX86M;

	jmp	$LN1340@X86Assembl
	jmp	$_EmitX86M$1954
$LN1339@X86Assembl:

; 2222 :         }
; 2223 : 
; 2224 :         if (o0->getSize() == 8 && info.hasInstFlag(kX86InstFlagMem8)) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1341@X86Assembl
	mov	edx, 1024				; 00000400H
	mov	rcx, QWORD PTR info$[rsp]
	call	?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z ; asmjit::X86InstInfo::hasInstFlag
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1341@X86Assembl

; 2225 :           opCode += 4;

	mov	eax, DWORD PTR opCode$[rsp]
	add	eax, 4
	mov	DWORD PTR opCode$[rsp], eax

; 2226 :           goto _EmitX86M;

	jmp	$LN1342@X86Assembl
	jmp	$_EmitX86M$1954
$LN1341@X86Assembl:

; 2227 :         }
; 2228 : 
; 2229 :         if (o0->getSize() == 10 && info.hasInstFlag(kX86InstFlagMem10)) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 10
	jne	SHORT $LN1343@X86Assembl
	mov	edx, 2048				; 00000800H
	mov	rcx, QWORD PTR info$[rsp]
	call	?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z ; asmjit::X86InstInfo::hasInstFlag
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1343@X86Assembl

; 2230 :           opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 2231 :           opReg  = x86ExtractO(opCode);

	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86ExtractO@asmjit@@YAII@Z		; asmjit::x86ExtractO
	mov	DWORD PTR opReg$[rsp], eax

; 2232 :           goto _EmitX86M;

	jmp	$LN1344@X86Assembl
	jmp	$_EmitX86M$1954
$LN1343@X86Assembl:
$LN1338@X86Assembl:

; 2233 :         }
; 2234 :       }
; 2235 : 
; 2236 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	$LN1345@X86Assembl

; 2237 :         if (code == kX86InstIdFld) {

	cmp	DWORD PTR code$[rsp], 173		; 000000adH
	jne	SHORT $LN1346@X86Assembl

; 2238 :           opCode = 0xD9C0 + x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	add	eax, 55744				; 0000d9c0H
	mov	DWORD PTR opCode$[rsp], eax

; 2239 :           goto _EmitFpuOp;

	jmp	$LN1347@X86Assembl
	jmp	$_EmitFpuOp$1960
$LN1346@X86Assembl:

; 2240 :         }
; 2241 : 
; 2242 :         if (code == kX86InstIdFst) {

	cmp	DWORD PTR code$[rsp], 203		; 000000cbH
	jne	SHORT $LN1348@X86Assembl

; 2243 :           opCode = 0xDDD0 + x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	add	eax, 56784				; 0000ddd0H
	mov	DWORD PTR opCode$[rsp], eax

; 2244 :           goto _EmitFpuOp;

	jmp	$LN1349@X86Assembl
	jmp	$_EmitFpuOp$1960
$LN1348@X86Assembl:

; 2245 :         }
; 2246 : 
; 2247 :         if (code == kX86InstIdFstp) {

	cmp	DWORD PTR code$[rsp], 206		; 000000ceH
	jne	SHORT $LN1350@X86Assembl

; 2248 :           opCode = 0xDDD8 + x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	add	eax, 56792				; 0000ddd8H
	mov	DWORD PTR opCode$[rsp], eax

; 2249 :           goto _EmitFpuOp;

	jmp	$LN1351@X86Assembl
	jmp	$_EmitFpuOp$1960
$LN1350@X86Assembl:
$LN1345@X86Assembl:

; 2250 :         }
; 2251 :       }
; 2252 :       break;

	jmp	$LN5@X86Assembl
$LN1352@X86Assembl:

; 2253 : 
; 2254 : 
; 2255 :     case kX86InstEncodingIdFpuM:
; 2256 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	$LN1353@X86Assembl

; 2257 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2258 : 
; 2259 :         if (o0->getSize() == 2 && info.hasInstFlag(kX86InstFlagMem2)) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 2
	jne	SHORT $LN1354@X86Assembl
	mov	edx, 256				; 00000100H
	mov	rcx, QWORD PTR info$[rsp]
	call	?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z ; asmjit::X86InstInfo::hasInstFlag
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1354@X86Assembl

; 2260 :           opCode += 4;

	mov	eax, DWORD PTR opCode$[rsp]
	add	eax, 4
	mov	DWORD PTR opCode$[rsp], eax

; 2261 :           goto _EmitX86M;

	jmp	$LN1355@X86Assembl
	jmp	$_EmitX86M$1954
$LN1354@X86Assembl:

; 2262 :         }
; 2263 : 
; 2264 :         if (o0->getSize() == 4 && info.hasInstFlag(kX86InstFlagMem4)) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 4
	jne	SHORT $LN1356@X86Assembl
	mov	edx, 512				; 00000200H
	mov	rcx, QWORD PTR info$[rsp]
	call	?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z ; asmjit::X86InstInfo::hasInstFlag
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1356@X86Assembl

; 2265 :           goto _EmitX86M;

	jmp	$LN1357@X86Assembl
	jmp	$_EmitX86M$1954
$LN1356@X86Assembl:

; 2266 :         }
; 2267 : 
; 2268 :         if (o0->getSize() == 8 && info.hasInstFlag(kX86InstFlagMem8)) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1358@X86Assembl
	mov	edx, 1024				; 00000400H
	mov	rcx, QWORD PTR info$[rsp]
	call	?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z ; asmjit::X86InstInfo::hasInstFlag
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1358@X86Assembl

; 2269 :           opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 2270 :           opReg  = x86ExtractO(opCode);

	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86ExtractO@asmjit@@YAII@Z		; asmjit::x86ExtractO
	mov	DWORD PTR opReg$[rsp], eax

; 2271 :           goto _EmitX86M;

	jmp	$LN1359@X86Assembl
	jmp	$_EmitX86M$1954
$LN1358@X86Assembl:
$LN1353@X86Assembl:

; 2272 :         }
; 2273 :       }
; 2274 :       break;

	jmp	$LN5@X86Assembl
$LN1360@X86Assembl:

; 2275 : 
; 2276 :     case kX86InstEncodingIdFpuRDef:
; 2277 :       if (encoded == ENC_OPS(None, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 0
	jne	SHORT $LN1361@X86Assembl

; 2278 :         opCode += 1;

	mov	eax, DWORD PTR opCode$[rsp]
	inc	eax
	mov	DWORD PTR opCode$[rsp], eax

; 2279 :         goto _EmitFpuOp;

	jmp	$LN1362@X86Assembl
	jmp	$_EmitFpuOp$1960
$LN1361@X86Assembl:
$LN1363@X86Assembl:

; 2280 :       }
; 2281 :       // ... Fall through ...
; 2282 : 
; 2283 :     case kX86InstEncodingIdFpuR:
; 2284 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	SHORT $LN1364@X86Assembl

; 2285 :         opCode += x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 2286 :         goto _EmitFpuOp;

	jmp	$LN1365@X86Assembl
	jmp	$_EmitFpuOp$1960
$LN1364@X86Assembl:

; 2287 :       }
; 2288 :       break;

	jmp	$LN5@X86Assembl
$LN1366@X86Assembl:

; 2289 : 
; 2290 :     case kX86InstEncodingIdFpuStsw:
; 2291 :       if (encoded == ENC_OPS(Reg, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 1
	jne	SHORT $LN1367@X86Assembl

; 2292 :         if (x86OpReg(o0) != 0)

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	test	eax, eax
	je	SHORT $LN1368@X86Assembl

; 2293 :           goto _IllegalInst;

	jmp	$LN1369@X86Assembl
	jmp	$_IllegalInst$1950
$LN1368@X86Assembl:

; 2294 : 
; 2295 :         opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 2296 :         goto _EmitX86Op;

	jmp	$LN1370@X86Assembl
	jmp	$_EmitX86Op$1952
$LN1367@X86Assembl:

; 2297 :       }
; 2298 : 
; 2299 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	SHORT $LN1371@X86Assembl

; 2300 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2301 :         goto _EmitX86M;

	jmp	$LN1372@X86Assembl
	jmp	$_EmitX86M$1954
$LN1371@X86Assembl:

; 2302 :       }
; 2303 :       break;

	jmp	$LN5@X86Assembl
$LN1373@X86Assembl:
$LN402@X86Assembl:

; 2304 : 
; 2305 :     // ------------------------------------------------------------------------
; 2306 :     // [Ext]
; 2307 :     // ------------------------------------------------------------------------
; 2308 : 
; 2309 :     case kX86InstEncodingIdExtCrc:
; 2310 :       ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN402@X86Assembl
$LN405@X86Assembl:

; 2311 :       ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1374@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1374@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1374@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN405@X86Assembl

; 2312 : 
; 2313 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1375@X86Assembl

; 2314 :         ASMJIT_ASSERT(static_cast<const Reg*>(o0)->getRegType() == kX86RegTypeGpd ||
; 2315 :                       static_cast<const Reg*>(o0)->getRegType() == kX86RegTypeGpq);
; 2316 : 
; 2317 :         opCode += o0->getSize() != 1;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1912@X86Assembl
	mov	DWORD PTR tv2036[rsp], 1
	jmp	SHORT $LN1913@X86Assembl
$LN1912@X86Assembl:
	mov	DWORD PTR tv2036[rsp], 0
$LN1913@X86Assembl:
	mov	eax, DWORD PTR tv2036[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 2318 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2319 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2320 :         goto _EmitX86R;

	jmp	$LN1376@X86Assembl
	jmp	$_EmitX86R$1953
$LN1375@X86Assembl:

; 2321 :       }
; 2322 : 
; 2323 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1377@X86Assembl

; 2324 :         ASMJIT_ASSERT(static_cast<const Reg*>(o0)->getRegType() == kX86RegTypeGpd ||
; 2325 :                       static_cast<const Reg*>(o0)->getRegType() == kX86RegTypeGpq);
; 2326 : 
; 2327 :         opCode += o0->getSize() != 1;

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 1
	je	SHORT $LN1914@X86Assembl
	mov	DWORD PTR tv2047[rsp], 1
	jmp	SHORT $LN1915@X86Assembl
$LN1914@X86Assembl:
	mov	DWORD PTR tv2047[rsp], 0
$LN1915@X86Assembl:
	mov	eax, DWORD PTR tv2047[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 2328 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2329 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2330 :         goto _EmitX86M;

	jmp	$LN1378@X86Assembl
	jmp	$_EmitX86M$1954
$LN1377@X86Assembl:

; 2331 :       }
; 2332 :       break;

	jmp	$LN5@X86Assembl
$LN1379@X86Assembl:

; 2333 : 
; 2334 :     case kX86InstEncodingIdExtExtract:
; 2335 :       if (encoded == ENC_OPS(Reg, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 265		; 00000109H
	jne	SHORT $LN1380@X86Assembl
$LN408@X86Assembl:

; 2336 :         ADD_66H_P(static_cast<const X86Reg*>(o1)->isXmm());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	shl	eax, 20
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN408@X86Assembl

; 2337 : 
; 2338 :         imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2339 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2340 : 
; 2341 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2342 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2343 :         goto _EmitX86R;

	jmp	$LN1381@X86Assembl
	jmp	$_EmitX86R$1953
$LN1380@X86Assembl:

; 2344 :       }
; 2345 : 
; 2346 :       if (encoded == ENC_OPS(Mem, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 267		; 0000010bH
	jne	SHORT $LN1382@X86Assembl

; 2347 :         // Secondary opcode for 'pextrw' instruction (SSE2).
; 2348 :         opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax
$LN411@X86Assembl:

; 2349 :         ADD_66H_P(static_cast<const X86Reg*>(o1)->isXmm());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	shl	eax, 20
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN411@X86Assembl

; 2350 : 
; 2351 :         imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2352 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2353 : 
; 2354 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2355 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2356 :         goto _EmitX86M;

	jmp	$LN1383@X86Assembl
	jmp	$_EmitX86M$1954
$LN1382@X86Assembl:

; 2357 :       }
; 2358 :       break;

	jmp	$LN5@X86Assembl
$LN1384@X86Assembl:

; 2359 : 
; 2360 :     case kX86InstEncodingIdExtFence:
; 2361 :       if (Arch == kArchX64 && (opCode & kX86InstOpCode_W_Mask)) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1385@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	je	SHORT $LN1385@X86Assembl
$LN414@X86Assembl:

; 2362 :         EMIT_BYTE(kX86ByteRex | kX86ByteRexW);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 72			; 00000048H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN414@X86Assembl
$LN1385@X86Assembl:
$LN417@X86Assembl:

; 2363 :       }
; 2364 : 
; 2365 :       EMIT_BYTE(0x0F);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 15
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN417@X86Assembl
$LN420@X86Assembl:
$LN423@X86Assembl:

; 2366 :       EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN423@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN420@X86Assembl
$LN426@X86Assembl:

; 2367 :       EMIT_BYTE(0xC0 | (opReg << 3));

	mov	eax, DWORD PTR opReg$[rsp]
	shl	eax, 3
	or	eax, 192				; 000000c0H
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN426@X86Assembl

; 2368 :       goto _EmitDone;

	jmp	$LN1386@X86Assembl
	jmp	$_EmitDone$1951
$LN1387@X86Assembl:
$LN1388@X86Assembl:

; 2369 : 
; 2370 :     case kX86InstEncodingIdExtMov:
; 2371 :     case kX86InstEncodingIdExtMovNoRexW:
; 2372 :       ASMJIT_ASSERT(extendedInfo._opFlags[0] != 0);
; 2373 :       ASMJIT_ASSERT(extendedInfo._opFlags[1] != 0);
; 2374 : 
; 2375 :       // Check parameters Gpd|Gpq|Mm|Xmm <- Gpd|Gpq|Mm|Xmm|X86Mem|Imm.
; 2376 :       ASMJIT_ASSERT(!((o0->isMem()                   && (extendedInfo._opFlags[0] & kX86InstOpMem) == 0) ||
; 2377 :                       (o0->isRegType(kX86RegTypeMm ) && (extendedInfo._opFlags[0] & kX86InstOpMm ) == 0) ||
; 2378 :                       (o0->isRegType(kX86RegTypeXmm) && (extendedInfo._opFlags[0] & kX86InstOpXmm) == 0) ||
; 2379 :                       (o0->isRegType(kX86RegTypeGpd) && (extendedInfo._opFlags[0] & kX86InstOpGd ) == 0) ||
; 2380 :                       (o0->isRegType(kX86RegTypeGpq) && (extendedInfo._opFlags[0] & kX86InstOpGq ) == 0) ||
; 2381 :                       (o1->isMem()                   && (extendedInfo._opFlags[1] & kX86InstOpMem) == 0) ||
; 2382 :                       (o1->isRegType(kX86RegTypeMm ) && (extendedInfo._opFlags[1] & kX86InstOpMm ) == 0) ||
; 2383 :                       (o1->isRegType(kX86RegTypeXmm) && (extendedInfo._opFlags[1] & kX86InstOpXmm) == 0) ||
; 2384 :                       (o1->isRegType(kX86RegTypeGpd) && (extendedInfo._opFlags[1] & kX86InstOpGd ) == 0) ||
; 2385 :                       (o1->isRegType(kX86RegTypeGpq) && (extendedInfo._opFlags[1] & kX86InstOpGq ) == 0) ));
; 2386 : 
; 2387 :       // Gp|Mm|Xmm <- Gp|Mm|Xmm
; 2388 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	$LN1389@X86Assembl
$LN429@X86Assembl:

; 2389 :         ADD_REX_W(static_cast<const X86Reg*>(o0)->isGpq() && (info.getEncodingId() != kX86InstEncodingIdExtMovNoRexW));

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1390@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?isGpq@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isGpq
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1916@X86Assembl
	mov	rcx, QWORD PTR info$[rsp]
	call	?getEncodingId@X86InstInfo@asmjit@@QEBAIXZ ; asmjit::X86InstInfo::getEncodingId
	cmp	eax, 54					; 00000036H
	je	SHORT $LN1916@X86Assembl
	mov	DWORD PTR tv2136[rsp], 1
	jmp	SHORT $LN1917@X86Assembl
$LN1916@X86Assembl:
	mov	DWORD PTR tv2136[rsp], 0
$LN1917@X86Assembl:
	mov	eax, DWORD PTR tv2136[rsp]
	shl	eax, 31
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN1390@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN429@X86Assembl
$LN432@X86Assembl:

; 2390 :         ADD_REX_W(static_cast<const X86Reg*>(o1)->isGpq() && (info.getEncodingId() != kX86InstEncodingIdExtMovNoRexW));

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1391@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isGpq@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isGpq
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1918@X86Assembl
	mov	rcx, QWORD PTR info$[rsp]
	call	?getEncodingId@X86InstInfo@asmjit@@QEBAIXZ ; asmjit::X86InstInfo::getEncodingId
	cmp	eax, 54					; 00000036H
	je	SHORT $LN1918@X86Assembl
	mov	DWORD PTR tv2152[rsp], 1
	jmp	SHORT $LN1919@X86Assembl
$LN1918@X86Assembl:
	mov	DWORD PTR tv2152[rsp], 0
$LN1919@X86Assembl:
	mov	eax, DWORD PTR tv2152[rsp]
	shl	eax, 31
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN1391@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN432@X86Assembl

; 2391 : 
; 2392 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2393 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2394 :         goto _EmitX86R;

	jmp	$LN1392@X86Assembl
	jmp	$_EmitX86R$1953
$LN1389@X86Assembl:

; 2395 :       }
; 2396 : 
; 2397 :       // Gp|Mm|Xmm <- Mem
; 2398 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	$LN1393@X86Assembl
$LN435@X86Assembl:

; 2399 :         ADD_REX_W(static_cast<const X86Reg*>(o0)->isGpq() && (info.getEncodingId() != kX86InstEncodingIdExtMovNoRexW));

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1394@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?isGpq@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isGpq
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1920@X86Assembl
	mov	rcx, QWORD PTR info$[rsp]
	call	?getEncodingId@X86InstInfo@asmjit@@QEBAIXZ ; asmjit::X86InstInfo::getEncodingId
	cmp	eax, 54					; 00000036H
	je	SHORT $LN1920@X86Assembl
	mov	DWORD PTR tv2174[rsp], 1
	jmp	SHORT $LN1921@X86Assembl
$LN1920@X86Assembl:
	mov	DWORD PTR tv2174[rsp], 0
$LN1921@X86Assembl:
	mov	eax, DWORD PTR tv2174[rsp]
	shl	eax, 31
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN1394@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN435@X86Assembl

; 2400 : 
; 2401 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2402 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2403 :         goto _EmitX86M;

	jmp	$LN1395@X86Assembl
	jmp	$_EmitX86M$1954
$LN1393@X86Assembl:

; 2404 :       }
; 2405 : 
; 2406 :       // The following instruction uses opCode[1].
; 2407 :       opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 2408 : 
; 2409 :       // X86Mem <- Gp|Mm|Xmm
; 2410 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	$LN1396@X86Assembl
$LN438@X86Assembl:

; 2411 :         ADD_REX_W(static_cast<const X86Reg*>(o1)->isGpq() && (info.getEncodingId() != kX86InstEncodingIdExtMovNoRexW));

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1397@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isGpq@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isGpq
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1922@X86Assembl
	mov	rcx, QWORD PTR info$[rsp]
	call	?getEncodingId@X86InstInfo@asmjit@@QEBAIXZ ; asmjit::X86InstInfo::getEncodingId
	cmp	eax, 54					; 00000036H
	je	SHORT $LN1922@X86Assembl
	mov	DWORD PTR tv2197[rsp], 1
	jmp	SHORT $LN1923@X86Assembl
$LN1922@X86Assembl:
	mov	DWORD PTR tv2197[rsp], 0
$LN1923@X86Assembl:
	mov	eax, DWORD PTR tv2197[rsp]
	shl	eax, 31
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN1397@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN438@X86Assembl

; 2412 : 
; 2413 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2414 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2415 :         goto _EmitX86M;

	jmp	$LN1398@X86Assembl
	jmp	$_EmitX86M$1954
$LN1396@X86Assembl:

; 2416 :       }
; 2417 :       break;

	jmp	$LN5@X86Assembl
$LN1399@X86Assembl:

; 2418 : 
; 2419 :     case kX86InstEncodingIdExtMovBe:
; 2420 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1400@X86Assembl
$LN441@X86Assembl:

; 2421 :         ADD_66H_P_BY_SIZE(o0->getSize());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN441@X86Assembl
$LN444@X86Assembl:

; 2422 :         ADD_REX_W_BY_SIZE(o0->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1401@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1401@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1401@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN444@X86Assembl

; 2423 : 
; 2424 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2425 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2426 :         goto _EmitX86M;

	jmp	$LN1402@X86Assembl
	jmp	$_EmitX86M$1954
$LN1400@X86Assembl:

; 2427 :       }
; 2428 : 
; 2429 :       // The following instruction uses the secondary opcode.
; 2430 :       opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 2431 : 
; 2432 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	SHORT $LN1403@X86Assembl
$LN447@X86Assembl:

; 2433 :         ADD_66H_P_BY_SIZE(o1->getSize());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	and	eax, 2
	shl	eax, 19
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN447@X86Assembl
$LN450@X86Assembl:

; 2434 :         ADD_REX_W_BY_SIZE(o1->getSize());

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1404@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	jne	SHORT $LN1404@X86Assembl
	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
$LN1404@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN450@X86Assembl

; 2435 : 
; 2436 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2437 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2438 :         goto _EmitX86M;

	jmp	$LN1405@X86Assembl
	jmp	$_EmitX86M$1954
$LN1403@X86Assembl:

; 2439 :       }
; 2440 :       break;

	jmp	$LN5@X86Assembl
$LN1406@X86Assembl:
$_EmitMmMovD$1963:

; 2441 : 
; 2442 :     case kX86InstEncodingIdExtMovD:
; 2443 : _EmitMmMovD:
; 2444 :       opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax
$LN453@X86Assembl:

; 2445 :       ADD_66H_P(static_cast<const X86Reg*>(o0)->isXmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	shl	eax, 20
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN453@X86Assembl

; 2446 : 
; 2447 :       // Mm/Xmm <- Gp
; 2448 :       if (encoded == ENC_OPS(Reg, Reg, None) && static_cast<const X86Reg*>(o1)->isGp()) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1407@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isGp@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isGp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1407@X86Assembl

; 2449 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2450 :         goto _EmitX86R;

	jmp	$LN1408@X86Assembl
	jmp	$_EmitX86R$1953
$LN1407@X86Assembl:

; 2451 :       }
; 2452 : 
; 2453 :       // Mm/Xmm <- Mem
; 2454 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1409@X86Assembl

; 2455 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2456 :         goto _EmitX86M;

	jmp	$LN1410@X86Assembl
	jmp	$_EmitX86M$1954
$LN1409@X86Assembl:

; 2457 :       }
; 2458 : 
; 2459 :       // The following instructions use the secondary opcode.
; 2460 :       opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 2461 :       opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax
$LN456@X86Assembl:

; 2462 :       ADD_66H_P(static_cast<const X86Reg*>(o1)->isXmm());

	mov	rcx, QWORD PTR o1$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	shl	eax, 20
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN456@X86Assembl

; 2463 : 
; 2464 :       // Gp <- Mm/Xmm
; 2465 :       if (encoded == ENC_OPS(Reg, Reg, None) && static_cast<const X86Reg*>(o0)->isGp()) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1411@X86Assembl
	mov	rcx, QWORD PTR o0$[rsp]
	call	?isGp@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isGp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1411@X86Assembl

; 2466 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2467 :         goto _EmitX86R;

	jmp	$LN1412@X86Assembl
	jmp	$_EmitX86R$1953
$LN1411@X86Assembl:

; 2468 :       }
; 2469 : 
; 2470 :       // X86Mem <- Mm/Xmm
; 2471 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	SHORT $LN1413@X86Assembl

; 2472 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2473 :         goto _EmitX86M;

	jmp	$LN1414@X86Assembl
	jmp	$_EmitX86M$1954
$LN1413@X86Assembl:

; 2474 :       }
; 2475 :       break;

	jmp	$LN5@X86Assembl
$LN1415@X86Assembl:

; 2476 : 
; 2477 :     case kX86InstEncodingIdExtMovQ:
; 2478 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	$LN1416@X86Assembl

; 2479 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2480 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2481 : 
; 2482 :         // Mm <- Mm
; 2483 :         if (static_cast<const X86Reg*>(o0)->isMm() && static_cast<const X86Reg*>(o1)->isMm()) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isMm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isMm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1417@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isMm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isMm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1417@X86Assembl

; 2484 :           opCode = kX86InstOpCode_PP_00 | kX86InstOpCode_MM_0F | 0x6F;

	mov	DWORD PTR opCode$[rsp], 65647		; 0001006fH

; 2485 :           goto _EmitX86R;

	jmp	$LN1418@X86Assembl
	jmp	$_EmitX86R$1953
$LN1417@X86Assembl:

; 2486 :         }
; 2487 : 
; 2488 :         // Xmm <- Xmm
; 2489 :         if (static_cast<const X86Reg*>(o0)->isXmm() && static_cast<const X86Reg*>(o1)->isXmm()) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1419@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1419@X86Assembl

; 2490 :           opCode = kX86InstOpCode_PP_F3 | kX86InstOpCode_MM_0F | 0x7E;

	mov	DWORD PTR opCode$[rsp], 2162814		; 0021007eH

; 2491 :           goto _EmitX86R;

	jmp	$LN1420@X86Assembl
	jmp	$_EmitX86R$1953
$LN1419@X86Assembl:

; 2492 :         }
; 2493 : 
; 2494 :         // Mm <- Xmm (Movdq2q)
; 2495 :         if (static_cast<const X86Reg*>(o0)->isMm() && static_cast<const X86Reg*>(o1)->isXmm()) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isMm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isMm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1421@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1421@X86Assembl

; 2496 :           opCode = kX86InstOpCode_PP_F2 | kX86InstOpCode_MM_0F | 0xD6;

	mov	DWORD PTR opCode$[rsp], 3211478		; 003100d6H

; 2497 :           goto _EmitX86R;

	jmp	$LN1422@X86Assembl
	jmp	$_EmitX86R$1953
$LN1421@X86Assembl:

; 2498 :         }
; 2499 : 
; 2500 :         // Xmm <- Mm (Movq2dq)
; 2501 :         if (static_cast<const X86Reg*>(o0)->isXmm() && static_cast<const X86Reg*>(o1)->isMm()) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1423@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isMm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isMm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1423@X86Assembl

; 2502 :           opCode = kX86InstOpCode_PP_F3 | kX86InstOpCode_MM_0F | 0xD6;

	mov	DWORD PTR opCode$[rsp], 2162902		; 002100d6H

; 2503 :           goto _EmitX86R;

	jmp	$LN1424@X86Assembl
	jmp	$_EmitX86R$1953
$LN1423@X86Assembl:
$LN1416@X86Assembl:

; 2504 :         }
; 2505 :       }
; 2506 : 
; 2507 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1425@X86Assembl

; 2508 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2509 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2510 : 
; 2511 :         // Mm <- Mem
; 2512 :         if (static_cast<const X86Reg*>(o0)->isMm()) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isMm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isMm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1426@X86Assembl

; 2513 :           opCode = kX86InstOpCode_PP_00 | kX86InstOpCode_MM_0F | 0x6F;

	mov	DWORD PTR opCode$[rsp], 65647		; 0001006fH

; 2514 :           goto _EmitX86M;

	jmp	$LN1427@X86Assembl
	jmp	$_EmitX86M$1954
$LN1426@X86Assembl:

; 2515 :         }
; 2516 : 
; 2517 :         // Xmm <- Mem
; 2518 :         if (static_cast<const X86Reg*>(o0)->isXmm()) {

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1428@X86Assembl

; 2519 :           opCode = kX86InstOpCode_PP_F3 | kX86InstOpCode_MM_0F | 0x7E;

	mov	DWORD PTR opCode$[rsp], 2162814		; 0021007eH

; 2520 :           goto _EmitX86M;

	jmp	$LN1429@X86Assembl
	jmp	$_EmitX86M$1954
$LN1428@X86Assembl:
$LN1425@X86Assembl:

; 2521 :         }
; 2522 :       }
; 2523 : 
; 2524 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	SHORT $LN1430@X86Assembl

; 2525 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2526 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2527 : 
; 2528 :         // X86Mem <- Mm
; 2529 :         if (static_cast<const X86Reg*>(o1)->isMm()) {

	mov	rcx, QWORD PTR o1$[rsp]
	call	?isMm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isMm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1431@X86Assembl

; 2530 :           opCode = kX86InstOpCode_PP_00 | kX86InstOpCode_MM_0F | 0x7F;

	mov	DWORD PTR opCode$[rsp], 65663		; 0001007fH

; 2531 :           goto _EmitX86M;

	jmp	$LN1432@X86Assembl
	jmp	$_EmitX86M$1954
$LN1431@X86Assembl:

; 2532 :         }
; 2533 : 
; 2534 :         // X86Mem <- Xmm
; 2535 :         if (static_cast<const X86Reg*>(o1)->isXmm()) {

	mov	rcx, QWORD PTR o1$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1433@X86Assembl

; 2536 :           opCode = kX86InstOpCode_PP_66 | kX86InstOpCode_MM_0F | 0xD6;

	mov	DWORD PTR opCode$[rsp], 1114326		; 001100d6H

; 2537 :           goto _EmitX86M;

	jmp	$LN1434@X86Assembl
	jmp	$_EmitX86M$1954
$LN1433@X86Assembl:
$LN1430@X86Assembl:

; 2538 :         }
; 2539 :       }
; 2540 : 
; 2541 :       if (Arch == kArchX64) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1435@X86Assembl

; 2542 :         // Movq in other case is simply a MOVD instruction promoted to 64-bit.
; 2543 :         opCode |= kX86InstOpCode_W;

	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax

; 2544 :         goto _EmitMmMovD;

	jmp	$_EmitMmMovD$1963
$LN1435@X86Assembl:

; 2545 :       }
; 2546 :       break;

	jmp	$LN5@X86Assembl
$LN1436@X86Assembl:

; 2547 : 
; 2548 :     case kX86InstEncodingIdExtPrefetch:
; 2549 :       if (encoded == ENC_OPS(Mem, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 35		; 00000023H
	jne	SHORT $LN1437@X86Assembl

; 2550 :         opReg = static_cast<const Imm*>(o1)->getUInt32() & 0x3;

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getUInt32@Imm@asmjit@@QEBAIXZ		; asmjit::Imm::getUInt32
	and	eax, 3
	mov	DWORD PTR opReg$[rsp], eax

; 2551 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2552 :         goto _EmitX86M;

	jmp	$LN1438@X86Assembl
	jmp	$_EmitX86M$1954
$LN1437@X86Assembl:

; 2553 :       }
; 2554 :       break;

	jmp	$LN5@X86Assembl
$LN1439@X86Assembl:
$LN459@X86Assembl:

; 2555 : 
; 2556 :     case kX86InstEncodingIdExtRm_PQ:
; 2557 :       ADD_66H_P(o0->isRegType(kX86RegTypeXmm) || o1->isRegType(kX86RegTypeXmm));

	mov	edx, 112				; 00000070H
	mov	rcx, QWORD PTR o0$[rsp]
	call	?isRegType@Operand@asmjit@@QEBA_NI@Z	; asmjit::Operand::isRegType
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1924@X86Assembl
	mov	edx, 112				; 00000070H
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isRegType@Operand@asmjit@@QEBA_NI@Z	; asmjit::Operand::isRegType
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1924@X86Assembl
	mov	DWORD PTR tv2431[rsp], 0
	jmp	SHORT $LN1925@X86Assembl
$LN1924@X86Assembl:
	mov	DWORD PTR tv2431[rsp], 1
$LN1925@X86Assembl:
	mov	eax, DWORD PTR tv2431[rsp]
	shl	eax, 20
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN459@X86Assembl
$LN1440@X86Assembl:
$LN462@X86Assembl:

; 2558 :       // ... Fall through ...
; 2559 : 
; 2560 :     case kX86InstEncodingIdExtRm_Q:
; 2561 :       ADD_REX_W(o0->isRegType(kX86RegTypeGpq) || o1->isRegType(kX86RegTypeGpq) || (o1->isMem() && o1->getSize() == 8));

	xor	eax, eax
	cmp	eax, 1
	je	$LN1441@X86Assembl
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR o0$[rsp]
	call	?isRegType@Operand@asmjit@@QEBA_NI@Z	; asmjit::Operand::isRegType
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1926@X86Assembl
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isRegType@Operand@asmjit@@QEBA_NI@Z	; asmjit::Operand::isRegType
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1926@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isMem@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isMem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1927@X86Assembl
	mov	rcx, QWORD PTR o1$[rsp]
	call	?getSize@Operand@asmjit@@QEBAIXZ	; asmjit::Operand::getSize
	cmp	eax, 8
	je	SHORT $LN1926@X86Assembl
$LN1927@X86Assembl:
	mov	DWORD PTR tv2453[rsp], 0
	jmp	SHORT $LN1928@X86Assembl
$LN1926@X86Assembl:
	mov	DWORD PTR tv2453[rsp], 1
$LN1928@X86Assembl:
	mov	eax, DWORD PTR tv2453[rsp]
	shl	eax, 31
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN1441@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	$LN462@X86Assembl
$LN1442@X86Assembl:

; 2562 :       // ... Fall through ...
; 2563 : 
; 2564 :     case kX86InstEncodingIdExtRm:
; 2565 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1443@X86Assembl

; 2566 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2567 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2568 :         goto _EmitX86R;

	jmp	$LN1444@X86Assembl
	jmp	$_EmitX86R$1953
$LN1443@X86Assembl:

; 2569 :       }
; 2570 : 
; 2571 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1445@X86Assembl

; 2572 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2573 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2574 :         goto _EmitX86M;

	jmp	$LN1446@X86Assembl
	jmp	$_EmitX86M$1954
$LN1445@X86Assembl:

; 2575 :       }
; 2576 :       break;

	jmp	$LN5@X86Assembl
$LN1447@X86Assembl:

; 2577 : 
; 2578 :     case kX86InstEncodingIdExtRm_P:
; 2579 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	$LN1448@X86Assembl
$LN465@X86Assembl:

; 2580 :         ADD_66H_P(static_cast<const X86Reg*>(o0)->isXmm() | static_cast<const X86Reg*>(o1)->isXmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	mov	DWORD PTR tv2486[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	mov	DWORD PTR tv2484[rsp], eax
	mov	eax, DWORD PTR tv2484[rsp]
	mov	ecx, DWORD PTR tv2486[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 20
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN465@X86Assembl

; 2581 : 
; 2582 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2583 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2584 :         goto _EmitX86R;

	jmp	$LN1449@X86Assembl
	jmp	$_EmitX86R$1953
$LN1448@X86Assembl:

; 2585 :       }
; 2586 : 
; 2587 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1450@X86Assembl
$LN468@X86Assembl:

; 2588 :         ADD_66H_P(static_cast<const X86Reg*>(o0)->isXmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	shl	eax, 20
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN468@X86Assembl

; 2589 : 
; 2590 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2591 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2592 :         goto _EmitX86M;

	jmp	$LN1451@X86Assembl
	jmp	$_EmitX86M$1954
$LN1450@X86Assembl:

; 2593 :       }
; 2594 :       break;

	jmp	$LN5@X86Assembl
$LN1452@X86Assembl:

; 2595 : 
; 2596 :     case kX86InstEncodingIdExtRmRi:
; 2597 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1453@X86Assembl

; 2598 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2599 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2600 :         goto _EmitX86R;

	jmp	$LN1454@X86Assembl
	jmp	$_EmitX86R$1953
$LN1453@X86Assembl:

; 2601 :       }
; 2602 : 
; 2603 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1455@X86Assembl

; 2604 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2605 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2606 :         goto _EmitX86M;

	jmp	$LN1456@X86Assembl
	jmp	$_EmitX86M$1954
$LN1455@X86Assembl:

; 2607 :       }
; 2608 : 
; 2609 :       // The following instruction uses the secondary opcode.
; 2610 :       opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 2611 :       opReg  = x86ExtractO(opCode);

	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86ExtractO@asmjit@@YAII@Z		; asmjit::x86ExtractO
	mov	DWORD PTR opReg$[rsp], eax

; 2612 : 
; 2613 :       if (encoded == ENC_OPS(Reg, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 33		; 00000021H
	jne	SHORT $LN1457@X86Assembl

; 2614 :         imVal = static_cast<const Imm*>(o1)->getInt64();

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2615 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2616 : 
; 2617 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2618 :         goto _EmitX86R;

	jmp	$LN1458@X86Assembl
	jmp	$_EmitX86R$1953
$LN1457@X86Assembl:

; 2619 :       }
; 2620 :       break;

	jmp	$LN5@X86Assembl
$LN1459@X86Assembl:

; 2621 : 
; 2622 :     case kX86InstEncodingIdExtRmRi_P:
; 2623 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	$LN1460@X86Assembl
$LN471@X86Assembl:

; 2624 :         ADD_66H_P(static_cast<const X86Reg*>(o0)->isXmm() | static_cast<const X86Reg*>(o1)->isXmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	mov	DWORD PTR tv2554[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	mov	DWORD PTR tv2552[rsp], eax
	mov	eax, DWORD PTR tv2552[rsp]
	mov	ecx, DWORD PTR tv2554[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 20
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN471@X86Assembl

; 2625 : 
; 2626 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2627 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2628 :         goto _EmitX86R;

	jmp	$LN1461@X86Assembl
	jmp	$_EmitX86R$1953
$LN1460@X86Assembl:

; 2629 :       }
; 2630 : 
; 2631 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1462@X86Assembl
$LN474@X86Assembl:

; 2632 :         ADD_66H_P(static_cast<const X86Reg*>(o0)->isXmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	shl	eax, 20
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN474@X86Assembl

; 2633 : 
; 2634 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2635 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2636 :         goto _EmitX86M;

	jmp	$LN1463@X86Assembl
	jmp	$_EmitX86M$1954
$LN1462@X86Assembl:

; 2637 :       }
; 2638 : 
; 2639 :       // The following instruction uses the secondary opcode.
; 2640 :       opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 2641 :       opReg  = x86ExtractO(opCode);

	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86ExtractO@asmjit@@YAII@Z		; asmjit::x86ExtractO
	mov	DWORD PTR opReg$[rsp], eax

; 2642 : 
; 2643 :       if (encoded == ENC_OPS(Reg, Imm, None)) {

	cmp	DWORD PTR encoded$[rsp], 33		; 00000021H
	jne	SHORT $LN1464@X86Assembl
$LN477@X86Assembl:

; 2644 :         ADD_66H_P(static_cast<const X86Reg*>(o0)->isXmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	shl	eax, 20
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN477@X86Assembl

; 2645 : 
; 2646 :         imVal = static_cast<const Imm*>(o1)->getInt64();

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2647 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2648 : 
; 2649 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2650 :         goto _EmitX86R;

	jmp	$LN1465@X86Assembl
	jmp	$_EmitX86R$1953
$LN1464@X86Assembl:

; 2651 :       }
; 2652 :       break;

	jmp	$LN5@X86Assembl
$LN1466@X86Assembl:

; 2653 : 
; 2654 :     case kX86InstEncodingIdExtRmi:
; 2655 :       imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2656 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2657 : 
; 2658 :       if (encoded == ENC_OPS(Reg, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 265		; 00000109H
	jne	SHORT $LN1467@X86Assembl

; 2659 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2660 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2661 :         goto _EmitX86R;

	jmp	$LN1468@X86Assembl
	jmp	$_EmitX86R$1953
$LN1467@X86Assembl:

; 2662 :       }
; 2663 : 
; 2664 :       if (encoded == ENC_OPS(Reg, Mem, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 281		; 00000119H
	jne	SHORT $LN1469@X86Assembl

; 2665 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2666 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2667 :         goto _EmitX86M;

	jmp	$LN1470@X86Assembl
	jmp	$_EmitX86M$1954
$LN1469@X86Assembl:

; 2668 :       }
; 2669 :       break;

	jmp	$LN5@X86Assembl
$LN1471@X86Assembl:

; 2670 : 
; 2671 :     case kX86InstEncodingIdExtRmi_P:
; 2672 :       imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2673 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2674 : 
; 2675 :       if (encoded == ENC_OPS(Reg, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 265		; 00000109H
	jne	$LN1472@X86Assembl
$LN480@X86Assembl:

; 2676 :         ADD_66H_P(static_cast<const X86Reg*>(o0)->isXmm() | static_cast<const X86Reg*>(o1)->isXmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	mov	DWORD PTR tv2644[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	mov	DWORD PTR tv2642[rsp], eax
	mov	eax, DWORD PTR tv2642[rsp]
	mov	ecx, DWORD PTR tv2644[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 20
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN480@X86Assembl

; 2677 : 
; 2678 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2679 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2680 :         goto _EmitX86R;

	jmp	$LN1473@X86Assembl
	jmp	$_EmitX86R$1953
$LN1472@X86Assembl:

; 2681 :       }
; 2682 : 
; 2683 :       if (encoded == ENC_OPS(Reg, Mem, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 281		; 00000119H
	jne	SHORT $LN1474@X86Assembl
$LN483@X86Assembl:

; 2684 :         ADD_66H_P(static_cast<const X86Reg*>(o0)->isXmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	shl	eax, 20
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN483@X86Assembl

; 2685 : 
; 2686 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2687 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2688 :         goto _EmitX86M;

	jmp	$LN1475@X86Assembl
	jmp	$_EmitX86M$1954
$LN1474@X86Assembl:

; 2689 :       }
; 2690 :       break;

	jmp	$LN5@X86Assembl
$LN1476@X86Assembl:

; 2691 : 
; 2692 :     // ------------------------------------------------------------------------
; 2693 :     // [Group - Extrq / Insertq (SSE4a)]
; 2694 :     // ------------------------------------------------------------------------
; 2695 : 
; 2696 :     case kX86InstEncodingIdExtExtrq:
; 2697 :       opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2698 :       rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2699 : 
; 2700 :       if (encoded == ENC_OPS(Reg, Reg, None))

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1477@X86Assembl

; 2701 :         goto _EmitX86R;

	jmp	$LN1478@X86Assembl
	jmp	$_EmitX86R$1953
$LN1477@X86Assembl:

; 2702 : 
; 2703 :       // The following instruction uses the secondary opcode.
; 2704 :       opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 2705 : 
; 2706 :       if (encoded == ENC_OPS(Reg, Imm, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 289		; 00000121H
	jne	SHORT $LN1479@X86Assembl

; 2707 :         imVal = (static_cast<const Imm*>(o1)->getUInt32()     ) +

	mov	rcx, QWORD PTR o1$[rsp]
	call	?getUInt32@Imm@asmjit@@QEBAIXZ		; asmjit::Imm::getUInt32
	mov	DWORD PTR tv2683[rsp], eax
	mov	rcx, QWORD PTR o2$[rsp]
	call	?getUInt32@Imm@asmjit@@QEBAIXZ		; asmjit::Imm::getUInt32
	shl	eax, 8
	mov	ecx, DWORD PTR tv2683[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 2708 :                 (static_cast<const Imm*>(o2)->getUInt32() << 8) ;
; 2709 :         imLen = 2;

	mov	DWORD PTR imLen$[rsp], 2

; 2710 : 
; 2711 :         rmReg = opReg;

	mov	eax, DWORD PTR opReg$[rsp]
	mov	QWORD PTR $S1$[rsp], rax

; 2712 :         opReg  = x86ExtractO(opCode);

	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86ExtractO@asmjit@@YAII@Z		; asmjit::x86ExtractO
	mov	DWORD PTR opReg$[rsp], eax

; 2713 :         goto _EmitX86R;

	jmp	$LN1480@X86Assembl
	jmp	$_EmitX86R$1953
$LN1479@X86Assembl:

; 2714 :       }
; 2715 :       break;

	jmp	$LN5@X86Assembl
$LN1481@X86Assembl:

; 2716 : 
; 2717 :     case kX86InstEncodingIdExtInsertq:
; 2718 :       opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2719 :       rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2720 : 
; 2721 :       if (encoded == ENC_OPS(Reg, Reg, None))

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1482@X86Assembl

; 2722 :         goto _EmitX86R;

	jmp	$LN1483@X86Assembl
	jmp	$_EmitX86R$1953
$LN1482@X86Assembl:

; 2723 : 
; 2724 :       // The following instruction uses the secondary opcode.
; 2725 :       opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 2726 : 
; 2727 :       if (encoded == ENC_OPS(Reg, Reg, Imm) && o3->isImm()) {

	cmp	DWORD PTR encoded$[rsp], 265		; 00000109H
	jne	SHORT $LN1484@X86Assembl
	mov	rcx, QWORD PTR o3$[rsp]
	call	?isImm@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isImm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1484@X86Assembl

; 2728 :         imVal = (static_cast<const Imm*>(o2)->getUInt32()     ) +

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getUInt32@Imm@asmjit@@QEBAIXZ		; asmjit::Imm::getUInt32
	mov	DWORD PTR tv2714[rsp], eax
	mov	rcx, QWORD PTR o3$[rsp]
	call	?getUInt32@Imm@asmjit@@QEBAIXZ		; asmjit::Imm::getUInt32
	shl	eax, 8
	mov	ecx, DWORD PTR tv2714[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 2729 :                 (static_cast<const Imm*>(o3)->getUInt32() << 8) ;
; 2730 :         imLen = 2;

	mov	DWORD PTR imLen$[rsp], 2

; 2731 :         goto _EmitX86R;

	jmp	$LN1485@X86Assembl
	jmp	$_EmitX86R$1953
$LN1484@X86Assembl:

; 2732 :       }
; 2733 :       break;

	jmp	$LN5@X86Assembl
$LN1486@X86Assembl:

; 2734 : 
; 2735 :     // ------------------------------------------------------------------------
; 2736 :     // [Group - 3dNow]
; 2737 :     // ------------------------------------------------------------------------
; 2738 : 
; 2739 :     case kX86InstEncodingId3dNow:
; 2740 :       // Every 3dNow instruction starts with 0x0F0F and the actual opcode is
; 2741 :       // stored as 8-bit immediate.
; 2742 :       imVal = opCode & 0xFF;

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 2743 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2744 : 
; 2745 :       opCode = kX86InstOpCode_MM_0F | 0x0F;

	mov	DWORD PTR opCode$[rsp], 65551		; 0001000fH

; 2746 :       opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2747 : 
; 2748 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1487@X86Assembl

; 2749 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2750 :         goto _EmitX86R;

	jmp	$LN1488@X86Assembl
	jmp	$_EmitX86R$1953
$LN1487@X86Assembl:

; 2751 :       }
; 2752 : 
; 2753 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1489@X86Assembl

; 2754 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2755 :         goto _EmitX86M;

	jmp	$LN1490@X86Assembl
	jmp	$_EmitX86M$1954
$LN1489@X86Assembl:

; 2756 :       }
; 2757 :       break;

	jmp	$LN5@X86Assembl
$LN1491@X86Assembl:

; 2758 : 
; 2759 :     // ------------------------------------------------------------------------
; 2760 :     // [Avx]
; 2761 :     // ------------------------------------------------------------------------
; 2762 : 
; 2763 :     case kX86InstEncodingIdAvxOp:
; 2764 :       goto _EmitAvxOp;

	jmp	$LN1492@X86Assembl
	jmp	$_EmitAvxOp$1964
$LN1493@X86Assembl:

; 2765 : 
; 2766 :     case kX86InstEncodingIdAvxM:
; 2767 :       if (encoded == ENC_OPS(Mem, None, None)) {

	cmp	DWORD PTR encoded$[rsp], 3
	jne	SHORT $LN1494@X86Assembl

; 2768 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2769 :         goto _EmitAvxM;

	jmp	$LN1495@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1494@X86Assembl:

; 2770 :       }
; 2771 :       break;

	jmp	$LN5@X86Assembl
$LN1496@X86Assembl:
$LN486@X86Assembl:

; 2772 : 
; 2773 :     case kX86InstEncodingIdAvxMr_P:
; 2774 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv2755[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv2753[rsp], eax
	mov	eax, DWORD PTR tv2753[rsp]
	mov	ecx, DWORD PTR tv2755[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN486@X86Assembl
$LN1497@X86Assembl:

; 2775 :       // ... Fall through ...
; 2776 : 
; 2777 :     case kX86InstEncodingIdAvxMr:
; 2778 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1498@X86Assembl

; 2779 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2780 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2781 :         goto _EmitAvxR;

	jmp	$LN1499@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1498@X86Assembl:

; 2782 :       }
; 2783 : 
; 2784 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	SHORT $LN1500@X86Assembl

; 2785 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2786 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2787 :         goto _EmitAvxM;

	jmp	$LN1501@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1500@X86Assembl:

; 2788 :       }
; 2789 :       break;

	jmp	$LN5@X86Assembl
$LN1502@X86Assembl:
$LN489@X86Assembl:

; 2790 : 
; 2791 :     case kX86InstEncodingIdAvxMri_P:
; 2792 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv2788[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv2786[rsp], eax
	mov	eax, DWORD PTR tv2786[rsp]
	mov	ecx, DWORD PTR tv2788[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN489@X86Assembl
$LN1503@X86Assembl:

; 2793 :       // ... Fall through ...
; 2794 : 
; 2795 :     case kX86InstEncodingIdAvxMri:
; 2796 :       imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2797 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2798 : 
; 2799 :       if (encoded == ENC_OPS(Reg, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 265		; 00000109H
	jne	SHORT $LN1504@X86Assembl

; 2800 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2801 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2802 :         goto _EmitAvxR;

	jmp	$LN1505@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1504@X86Assembl:

; 2803 :       }
; 2804 : 
; 2805 :       if (encoded == ENC_OPS(Mem, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 267		; 0000010bH
	jne	SHORT $LN1506@X86Assembl

; 2806 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2807 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2808 :         goto _EmitAvxM;

	jmp	$LN1507@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1506@X86Assembl:

; 2809 :       }
; 2810 :       break;

	jmp	$LN5@X86Assembl
$LN1508@X86Assembl:
$LN492@X86Assembl:

; 2811 : 
; 2812 :     case kX86InstEncodingIdAvxRm_P:
; 2813 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv2827[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv2825[rsp], eax
	mov	eax, DWORD PTR tv2825[rsp]
	mov	ecx, DWORD PTR tv2827[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN492@X86Assembl
$LN1509@X86Assembl:

; 2814 :       // ... Fall through ...
; 2815 : 
; 2816 :     case kX86InstEncodingIdAvxRm:
; 2817 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1510@X86Assembl

; 2818 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2819 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2820 :         goto _EmitAvxR;

	jmp	$LN1511@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1510@X86Assembl:

; 2821 :       }
; 2822 : 
; 2823 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1512@X86Assembl

; 2824 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2825 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2826 :         goto _EmitAvxM;

	jmp	$LN1513@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1512@X86Assembl:

; 2827 :       }
; 2828 :       break;

	jmp	$LN5@X86Assembl
$LN1514@X86Assembl:
$LN495@X86Assembl:

; 2829 : 
; 2830 :     case kX86InstEncodingIdAvxRmi_P:
; 2831 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv2860[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv2858[rsp], eax
	mov	eax, DWORD PTR tv2858[rsp]
	mov	ecx, DWORD PTR tv2860[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN495@X86Assembl
$LN1515@X86Assembl:

; 2832 :       // ... Fall through ...
; 2833 : 
; 2834 :     case kX86InstEncodingIdAvxRmi:
; 2835 :       imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2836 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2837 : 
; 2838 :       if (encoded == ENC_OPS(Reg, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 265		; 00000109H
	jne	SHORT $LN1516@X86Assembl

; 2839 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2840 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2841 :         goto _EmitAvxR;

	jmp	$LN1517@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1516@X86Assembl:

; 2842 :       }
; 2843 : 
; 2844 :       if (encoded == ENC_OPS(Reg, Mem, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 281		; 00000119H
	jne	SHORT $LN1518@X86Assembl

; 2845 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2846 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2847 :         goto _EmitAvxM;

	jmp	$LN1519@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1518@X86Assembl:

; 2848 :       }
; 2849 :       break;

	jmp	$LN5@X86Assembl
$LN1520@X86Assembl:
$LN498@X86Assembl:

; 2850 : 
; 2851 :     case kX86InstEncodingIdAvxRvm_P:
; 2852 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv2899[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv2897[rsp], eax
	mov	eax, DWORD PTR tv2897[rsp]
	mov	ecx, DWORD PTR tv2899[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN498@X86Assembl
$LN1521@X86Assembl:

; 2853 :       // ... Fall through ...
; 2854 : 
; 2855 :     case kX86InstEncodingIdAvxRvm:
; 2856 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1522@X86Assembl
$_EmitAvxRvm$1967:

; 2857 : _EmitAvxRvm:
; 2858 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv2915[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv2913[rsp], eax
	mov	edx, DWORD PTR tv2915[rsp]
	mov	ecx, DWORD PTR tv2913[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 2859 :         rmReg = x86OpReg(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2860 :         goto _EmitAvxR;

	jmp	$LN1523@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1522@X86Assembl:

; 2861 :       }
; 2862 : 
; 2863 :       if (encoded == ENC_OPS(Reg, Reg, Mem)) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	SHORT $LN1524@X86Assembl

; 2864 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv2930[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv2928[rsp], eax
	mov	edx, DWORD PTR tv2930[rsp]
	mov	ecx, DWORD PTR tv2928[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 2865 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2866 :         goto _EmitAvxM;

	jmp	$LN1525@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1524@X86Assembl:

; 2867 :       }
; 2868 :       break;

	jmp	$LN5@X86Assembl
$LN1526@X86Assembl:
$LN501@X86Assembl:

; 2869 : 
; 2870 :     case kX86InstEncodingIdAvxRvmr_P:
; 2871 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv2950[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv2948[rsp], eax
	mov	eax, DWORD PTR tv2948[rsp]
	mov	ecx, DWORD PTR tv2950[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN501@X86Assembl
$LN1527@X86Assembl:

; 2872 :       // ... Fall through ...
; 2873 : 
; 2874 :     case kX86InstEncodingIdAvxRvmr:
; 2875 :       if (!o3->isReg())

	mov	rcx, QWORD PTR o3$[rsp]
	call	?isReg@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isReg
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1528@X86Assembl

; 2876 :         goto _IllegalInst;

	jmp	$LN1529@X86Assembl
	jmp	$_IllegalInst$1950
$LN1528@X86Assembl:

; 2877 : 
; 2878 :       imVal = x86OpReg(o3) << 4;

	mov	rcx, QWORD PTR o3$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	shl	eax, 4
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 2879 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2880 : 
; 2881 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1530@X86Assembl

; 2882 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv2974[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv2972[rsp], eax
	mov	edx, DWORD PTR tv2974[rsp]
	mov	ecx, DWORD PTR tv2972[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 2883 :         rmReg = x86OpReg(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2884 :         goto _EmitAvxR;

	jmp	$LN1531@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1530@X86Assembl:

; 2885 :       }
; 2886 : 
; 2887 :       if (encoded == ENC_OPS(Reg, Reg, Mem)) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	SHORT $LN1532@X86Assembl

; 2888 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv2989[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv2987[rsp], eax
	mov	edx, DWORD PTR tv2989[rsp]
	mov	ecx, DWORD PTR tv2987[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 2889 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2890 :         goto _EmitAvxM;

	jmp	$LN1533@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1532@X86Assembl:

; 2891 :       }
; 2892 :       break;

	jmp	$LN5@X86Assembl
$LN1534@X86Assembl:
$LN504@X86Assembl:

; 2893 : 
; 2894 :     case kX86InstEncodingIdAvxRvmi_P:
; 2895 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3009[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3007[rsp], eax
	mov	eax, DWORD PTR tv3007[rsp]
	mov	ecx, DWORD PTR tv3009[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN504@X86Assembl
$LN1535@X86Assembl:

; 2896 :       // ... Fall through ...
; 2897 : 
; 2898 :     case kX86InstEncodingIdAvxRvmi:
; 2899 :       if (!o3->isImm())

	mov	rcx, QWORD PTR o3$[rsp]
	call	?isImm@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isImm
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1536@X86Assembl

; 2900 :         goto _IllegalInst;

	jmp	$LN1537@X86Assembl
	jmp	$_IllegalInst$1950
$LN1536@X86Assembl:

; 2901 : 
; 2902 :       imVal = static_cast<const Imm*>(o3)->getInt64();

	mov	rcx, QWORD PTR o3$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2903 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2904 : 
; 2905 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1538@X86Assembl

; 2906 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3035[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3033[rsp], eax
	mov	edx, DWORD PTR tv3035[rsp]
	mov	ecx, DWORD PTR tv3033[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 2907 :         rmReg = x86OpReg(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2908 :         goto _EmitAvxR;

	jmp	$LN1539@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1538@X86Assembl:

; 2909 :       }
; 2910 : 
; 2911 :       if (encoded == ENC_OPS(Reg, Reg, Mem)) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	SHORT $LN1540@X86Assembl

; 2912 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3050[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3048[rsp], eax
	mov	edx, DWORD PTR tv3050[rsp]
	mov	ecx, DWORD PTR tv3048[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 2913 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2914 :         goto _EmitAvxM;

	jmp	$LN1541@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1540@X86Assembl:

; 2915 :       }
; 2916 :       break;

	jmp	$LN5@X86Assembl
$LN1542@X86Assembl:

; 2917 : 
; 2918 :     case kX86InstEncodingIdAvxRmv:
; 2919 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1543@X86Assembl

; 2920 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o2));

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3064[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3062[rsp], eax
	mov	edx, DWORD PTR tv3064[rsp]
	mov	ecx, DWORD PTR tv3062[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 2921 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2922 :         goto _EmitAvxR;

	jmp	$LN1544@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1543@X86Assembl:

; 2923 :       }
; 2924 : 
; 2925 :       if (encoded == ENC_OPS(Reg, Mem, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 89		; 00000059H
	jne	SHORT $LN1545@X86Assembl

; 2926 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o2));

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3079[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3077[rsp], eax
	mov	edx, DWORD PTR tv3079[rsp]
	mov	ecx, DWORD PTR tv3077[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 2927 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2928 :         goto _EmitAvxM;

	jmp	$LN1546@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1545@X86Assembl:

; 2929 :       }
; 2930 :       break;

	jmp	$LN5@X86Assembl
$LN1547@X86Assembl:

; 2931 : 
; 2932 :     case kX86InstEncodingIdAvxRmvi:
; 2933 :       if (!o3->isImm())

	mov	rcx, QWORD PTR o3$[rsp]
	call	?isImm@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isImm
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1548@X86Assembl

; 2934 :         goto _IllegalInst;

	jmp	$LN1549@X86Assembl
	jmp	$_IllegalInst$1950
$LN1548@X86Assembl:

; 2935 : 
; 2936 :       imVal = static_cast<const Imm*>(o3)->getInt64();

	mov	rcx, QWORD PTR o3$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 2937 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 2938 : 
; 2939 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1550@X86Assembl

; 2940 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o2));

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3103[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3101[rsp], eax
	mov	edx, DWORD PTR tv3103[rsp]
	mov	ecx, DWORD PTR tv3101[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 2941 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2942 :         goto _EmitAvxR;

	jmp	$LN1551@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1550@X86Assembl:

; 2943 :       }
; 2944 : 
; 2945 :       if (encoded == ENC_OPS(Reg, Mem, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 89		; 00000059H
	jne	SHORT $LN1552@X86Assembl

; 2946 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o2));

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3118[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3116[rsp], eax
	mov	edx, DWORD PTR tv3118[rsp]
	mov	ecx, DWORD PTR tv3116[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 2947 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2948 :         goto _EmitAvxM;

	jmp	$LN1553@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1552@X86Assembl:

; 2949 :       }
; 2950 :       break;

	jmp	$LN5@X86Assembl
$LN1554@X86Assembl:
$LN507@X86Assembl:

; 2951 : 
; 2952 :     case kX86InstEncodingIdAvxRmMr_P:
; 2953 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3138[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3136[rsp], eax
	mov	eax, DWORD PTR tv3136[rsp]
	mov	ecx, DWORD PTR tv3138[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN507@X86Assembl
$LN1555@X86Assembl:

; 2954 :       // ... Fall through ...
; 2955 : 
; 2956 :     case kX86InstEncodingIdAvxRmMr:
; 2957 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1556@X86Assembl

; 2958 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2959 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2960 :         goto _EmitAvxR;

	jmp	$LN1557@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1556@X86Assembl:

; 2961 :       }
; 2962 : 
; 2963 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1558@X86Assembl

; 2964 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2965 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2966 :         goto _EmitAvxM;

	jmp	$LN1559@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1558@X86Assembl:

; 2967 :       }
; 2968 : 
; 2969 :       // The following instruction uses the secondary opcode.
; 2970 :       opCode &= kX86InstOpCode_L_Mask;

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 25165824				; 01800000H
	mov	DWORD PTR opCode$[rsp], eax

; 2971 :       opCode |= extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 2972 : 
; 2973 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	SHORT $LN1560@X86Assembl

; 2974 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 2975 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2976 :         goto _EmitAvxM;

	jmp	$LN1561@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1560@X86Assembl:

; 2977 :       }
; 2978 :       break;

	jmp	$LN5@X86Assembl
$LN1562@X86Assembl:
$LN510@X86Assembl:

; 2979 : 
; 2980 :     case kX86InstEncodingIdAvxRvmRmi_P:
; 2981 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3180[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3178[rsp], eax
	mov	eax, DWORD PTR tv3178[rsp]
	mov	ecx, DWORD PTR tv3180[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN510@X86Assembl
$LN1563@X86Assembl:

; 2982 :       // ... Fall through ...
; 2983 : 
; 2984 :     case kX86InstEncodingIdAvxRvmRmi:
; 2985 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1564@X86Assembl

; 2986 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3196[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3194[rsp], eax
	mov	edx, DWORD PTR tv3196[rsp]
	mov	ecx, DWORD PTR tv3194[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 2987 :         rmReg = x86OpReg(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 2988 :         goto _EmitAvxR;

	jmp	$LN1565@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1564@X86Assembl:

; 2989 :       }
; 2990 : 
; 2991 :       if (encoded == ENC_OPS(Reg, Reg, Mem)) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	SHORT $LN1566@X86Assembl

; 2992 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3211[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3209[rsp], eax
	mov	edx, DWORD PTR tv3211[rsp]
	mov	ecx, DWORD PTR tv3209[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 2993 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 2994 :         goto _EmitAvxM;

	jmp	$LN1567@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1566@X86Assembl:

; 2995 :       }
; 2996 : 
; 2997 :       // The following instructions use the secondary opcode.
; 2998 :       opCode &= kX86InstOpCode_L_Mask;

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 25165824				; 01800000H
	mov	DWORD PTR opCode$[rsp], eax

; 2999 :       opCode |= extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 3000 : 
; 3001 :       imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 3002 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3003 : 
; 3004 :       if (encoded == ENC_OPS(Reg, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 265		; 00000109H
	jne	SHORT $LN1568@X86Assembl

; 3005 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 3006 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3007 :         goto _EmitAvxR;

	jmp	$LN1569@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1568@X86Assembl:

; 3008 :       }
; 3009 : 
; 3010 :       if (encoded == ENC_OPS(Reg, Mem, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 281		; 00000119H
	jne	SHORT $LN1570@X86Assembl

; 3011 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 3012 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3013 :         goto _EmitAvxM;

	jmp	$LN1571@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1570@X86Assembl:

; 3014 :       }
; 3015 :       break;

	jmp	$LN5@X86Assembl
$LN1572@X86Assembl:

; 3016 : 
; 3017 :     case kX86InstEncodingIdAvxRvmMr:
; 3018 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1573@X86Assembl

; 3019 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3246[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3244[rsp], eax
	mov	edx, DWORD PTR tv3246[rsp]
	mov	ecx, DWORD PTR tv3244[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3020 :         rmReg = x86OpReg(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3021 :         goto _EmitAvxR;

	jmp	$LN1574@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1573@X86Assembl:

; 3022 :       }
; 3023 : 
; 3024 :       if (encoded == ENC_OPS(Reg, Reg, Mem)) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	SHORT $LN1575@X86Assembl

; 3025 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3261[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3259[rsp], eax
	mov	edx, DWORD PTR tv3261[rsp]
	mov	ecx, DWORD PTR tv3259[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3026 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3027 :         goto _EmitAvxM;

	jmp	$LN1576@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1575@X86Assembl:

; 3028 :       }
; 3029 : 
; 3030 :       // The following instructions use the secondary opcode.
; 3031 :       opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 3032 : 
; 3033 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1577@X86Assembl

; 3034 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 3035 :         rmReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3036 :         goto _EmitAvxR;

	jmp	$LN1578@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1577@X86Assembl:

; 3037 :       }
; 3038 : 
; 3039 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	SHORT $LN1579@X86Assembl

; 3040 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 3041 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3042 :         goto _EmitAvxM;

	jmp	$LN1580@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1579@X86Assembl:

; 3043 :       }
; 3044 :       break;

	jmp	$LN5@X86Assembl
$LN1581@X86Assembl:
$LN513@X86Assembl:

; 3045 : 
; 3046 :     case kX86InstEncodingIdAvxRvmMvr_P:
; 3047 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3294[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3292[rsp], eax
	mov	eax, DWORD PTR tv3292[rsp]
	mov	ecx, DWORD PTR tv3294[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN513@X86Assembl
$LN1582@X86Assembl:

; 3048 :       // ... Fall through ...
; 3049 : 
; 3050 :     case kX86InstEncodingIdAvxRvmMvr:
; 3051 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1583@X86Assembl

; 3052 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3310[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3308[rsp], eax
	mov	edx, DWORD PTR tv3310[rsp]
	mov	ecx, DWORD PTR tv3308[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3053 :         rmReg = x86OpReg(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3054 :         goto _EmitAvxR;

	jmp	$LN1584@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1583@X86Assembl:

; 3055 :       }
; 3056 : 
; 3057 :       if (encoded == ENC_OPS(Reg, Reg, Mem)) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	SHORT $LN1585@X86Assembl

; 3058 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3325[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3323[rsp], eax
	mov	edx, DWORD PTR tv3325[rsp]
	mov	ecx, DWORD PTR tv3323[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3059 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3060 :         goto _EmitAvxM;

	jmp	$LN1586@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1585@X86Assembl:

; 3061 :       }
; 3062 : 
; 3063 :       // The following instruction uses the secondary opcode.
; 3064 :       opCode &= kX86InstOpCode_L_Mask;

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 25165824				; 01800000H
	mov	DWORD PTR opCode$[rsp], eax

; 3065 :       opCode |= extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 3066 : 
; 3067 :       if (encoded == ENC_OPS(Mem, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 75		; 0000004bH
	jne	SHORT $LN1587@X86Assembl

; 3068 :         opReg = x86RegAndVvvv(x86OpReg(o2), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3343[rsp], eax
	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3341[rsp], eax
	mov	edx, DWORD PTR tv3343[rsp]
	mov	ecx, DWORD PTR tv3341[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3069 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3070 :         goto _EmitAvxM;

	jmp	$LN1588@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1587@X86Assembl:

; 3071 :       }
; 3072 :       break;

	jmp	$LN5@X86Assembl
$LN1589@X86Assembl:
$LN516@X86Assembl:

; 3073 : 
; 3074 :     case kX86InstEncodingIdAvxRvmVmi_P:
; 3075 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3363[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3361[rsp], eax
	mov	eax, DWORD PTR tv3361[rsp]
	mov	ecx, DWORD PTR tv3363[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN516@X86Assembl
$LN1590@X86Assembl:

; 3076 :       // ... Fall through ...
; 3077 : 
; 3078 :     case kX86InstEncodingIdAvxRvmVmi:
; 3079 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1591@X86Assembl

; 3080 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3379[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3377[rsp], eax
	mov	edx, DWORD PTR tv3379[rsp]
	mov	ecx, DWORD PTR tv3377[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3081 :         rmReg = x86OpReg(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3082 :         goto _EmitAvxR;

	jmp	$LN1592@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1591@X86Assembl:

; 3083 :       }
; 3084 : 
; 3085 :       if (encoded == ENC_OPS(Reg, Reg, Mem)) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	SHORT $LN1593@X86Assembl

; 3086 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3394[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3392[rsp], eax
	mov	edx, DWORD PTR tv3394[rsp]
	mov	ecx, DWORD PTR tv3392[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3087 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3088 :         goto _EmitAvxM;

	jmp	$LN1594@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1593@X86Assembl:

; 3089 :       }
; 3090 : 
; 3091 :       // The following instruction uses the secondary opcode.
; 3092 :       opCode &= kX86InstOpCode_L_Mask;

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 25165824				; 01800000H
	mov	DWORD PTR opCode$[rsp], eax

; 3093 :       opCode |= extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax

; 3094 :       opReg = x86ExtractO(opCode);

	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86ExtractO@asmjit@@YAII@Z		; asmjit::x86ExtractO
	mov	DWORD PTR opReg$[rsp], eax

; 3095 : 
; 3096 :       imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 3097 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3098 : 
; 3099 :       if (encoded == ENC_OPS(Reg, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 265		; 00000109H
	jne	SHORT $LN1595@X86Assembl

; 3100 :         opReg = x86RegAndVvvv(opReg, x86OpReg(o0));

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	edx, eax
	mov	ecx, DWORD PTR opReg$[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3101 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3102 :         goto _EmitAvxR;

	jmp	$LN1596@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1595@X86Assembl:

; 3103 :       }
; 3104 : 
; 3105 :       if (encoded == ENC_OPS(Reg, Mem, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 281		; 00000119H
	jne	SHORT $LN1597@X86Assembl

; 3106 :         opReg = x86RegAndVvvv(opReg, x86OpReg(o0));

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	edx, eax
	mov	ecx, DWORD PTR opReg$[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3107 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3108 :         goto _EmitAvxM;

	jmp	$LN1598@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1597@X86Assembl:

; 3109 :       }
; 3110 :       break;

	jmp	$LN5@X86Assembl
$LN1599@X86Assembl:

; 3111 : 
; 3112 :     case kX86InstEncodingIdAvxVm:
; 3113 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1600@X86Assembl

; 3114 :         opReg = x86RegAndVvvv(opReg, x86OpReg(o0));

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	edx, eax
	mov	ecx, DWORD PTR opReg$[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3115 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3116 :         goto _EmitAvxR;

	jmp	$LN1601@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1600@X86Assembl:

; 3117 :       }
; 3118 : 
; 3119 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1602@X86Assembl

; 3120 :         opReg = x86RegAndVvvv(opReg, x86OpReg(o0));

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	edx, eax
	mov	ecx, DWORD PTR opReg$[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3121 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3122 :         goto _EmitAvxM;

	jmp	$LN1603@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1602@X86Assembl:

; 3123 :       }
; 3124 :       break;

	jmp	$LN5@X86Assembl
$LN1604@X86Assembl:
$LN519@X86Assembl:

; 3125 : 
; 3126 :     case kX86InstEncodingIdAvxVmi_P:
; 3127 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3460[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3458[rsp], eax
	mov	eax, DWORD PTR tv3458[rsp]
	mov	ecx, DWORD PTR tv3460[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN519@X86Assembl
$LN1605@X86Assembl:

; 3128 :       // ... Fall through ...
; 3129 : 
; 3130 :     case kX86InstEncodingIdAvxVmi:
; 3131 :       imVal = static_cast<const Imm*>(o3)->getInt64();

	mov	rcx, QWORD PTR o3$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 3132 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3133 : 
; 3134 :       if (encoded == ENC_OPS(Reg, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 265		; 00000109H
	jne	SHORT $LN1606@X86Assembl

; 3135 :         opReg = x86RegAndVvvv(opReg, x86OpReg(o0));

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	edx, eax
	mov	ecx, DWORD PTR opReg$[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3136 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3137 :         goto _EmitAvxR;

	jmp	$LN1607@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1606@X86Assembl:

; 3138 :       }
; 3139 : 
; 3140 :       if (encoded == ENC_OPS(Reg, Mem, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 281		; 00000119H
	jne	SHORT $LN1608@X86Assembl

; 3141 :         opReg = x86RegAndVvvv(opReg, x86OpReg(o0));

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	edx, eax
	mov	ecx, DWORD PTR opReg$[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3142 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3143 :         goto _EmitAvxM;

	jmp	$LN1609@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1608@X86Assembl:

; 3144 :       }
; 3145 :       break;

	jmp	$LN5@X86Assembl
$LN1610@X86Assembl:
$LN522@X86Assembl:

; 3146 : 
; 3147 :     case kX86InstEncodingIdAvxRvrmRvmr_P:
; 3148 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3505[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3503[rsp], eax
	mov	eax, DWORD PTR tv3503[rsp]
	mov	ecx, DWORD PTR tv3505[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN522@X86Assembl
$LN1611@X86Assembl:

; 3149 :       // ... Fall through ...
; 3150 : 
; 3151 :     case kX86InstEncodingIdAvxRvrmRvmr:
; 3152 :       if (encoded == ENC_OPS(Reg, Reg, Reg) && o3->isReg()) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	$LN1612@X86Assembl
	mov	rcx, QWORD PTR o3$[rsp]
	call	?isReg@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isReg
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1612@X86Assembl

; 3153 :         imVal = x86OpReg(o3) << 4;

	mov	rcx, QWORD PTR o3$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	shl	eax, 4
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 3154 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3155 : 
; 3156 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3529[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3527[rsp], eax
	mov	edx, DWORD PTR tv3529[rsp]
	mov	ecx, DWORD PTR tv3527[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3157 :         rmReg = x86OpReg(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3158 : 
; 3159 :         goto _EmitAvxR;

	jmp	$LN1613@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1612@X86Assembl:

; 3160 :       }
; 3161 : 
; 3162 :       if (encoded == ENC_OPS(Reg, Reg, Reg) && o3->isMem()) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	$LN1614@X86Assembl
	mov	rcx, QWORD PTR o3$[rsp]
	call	?isMem@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isMem
	movzx	eax, al
	test	eax, eax
	je	$LN1614@X86Assembl

; 3163 :         imVal = x86OpReg(o2) << 4;

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	shl	eax, 4
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 3164 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3165 : 
; 3166 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3552[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3550[rsp], eax
	mov	edx, DWORD PTR tv3552[rsp]
	mov	ecx, DWORD PTR tv3550[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3167 :         rmMem = x86OpMem(o3);

	mov	rcx, QWORD PTR o3$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax
$LN525@X86Assembl:

; 3168 : 
; 3169 :         ADD_VEX_W(true);

	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN525@X86Assembl

; 3170 :         goto _EmitAvxM;

	jmp	$LN1615@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1614@X86Assembl:

; 3171 :       }
; 3172 : 
; 3173 :       if (encoded == ENC_OPS(Reg, Reg, Mem) && o3->isReg()) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	$LN1616@X86Assembl
	mov	rcx, QWORD PTR o3$[rsp]
	call	?isReg@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isReg
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1616@X86Assembl

; 3174 :         imVal = x86OpReg(o3) << 4;

	mov	rcx, QWORD PTR o3$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	shl	eax, 4
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 3175 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3176 : 
; 3177 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3576[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3574[rsp], eax
	mov	edx, DWORD PTR tv3576[rsp]
	mov	ecx, DWORD PTR tv3574[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3178 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3179 : 
; 3180 :         goto _EmitAvxM;

	jmp	$LN1617@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1616@X86Assembl:

; 3181 :       }
; 3182 :       break;

	jmp	$LN5@X86Assembl
$LN1618@X86Assembl:

; 3183 : 
; 3184 :     case kX86InstEncodingIdAvxMovSsSd:
; 3185 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1619@X86Assembl

; 3186 :         goto _EmitAvxRvm;

	jmp	$_EmitAvxRvm$1967
$LN1619@X86Assembl:

; 3187 :       }
; 3188 : 
; 3189 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1620@X86Assembl

; 3190 :         opReg = x86RegAndVvvv(opReg, x86OpReg(o0));

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	edx, eax
	mov	ecx, DWORD PTR opReg$[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3191 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3192 :         goto _EmitAvxM;

	jmp	$LN1621@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1620@X86Assembl:

; 3193 :       }
; 3194 : 
; 3195 :       if (encoded == ENC_OPS(Mem, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 11
	jne	SHORT $LN1622@X86Assembl

; 3196 :         opReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 3197 :         rmMem = x86OpMem(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3198 :         goto _EmitAvxM;

	jmp	$LN1623@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1622@X86Assembl:

; 3199 :       }
; 3200 :       break;

	jmp	$LN5@X86Assembl
$LN1624@X86Assembl:

; 3201 : 
; 3202 :     case kX86InstEncodingIdAvxGatherEx:
; 3203 :       if (encoded == ENC_OPS(Reg, Mem, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 89		; 00000059H
	jne	$LN1625@X86Assembl

; 3204 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o2));

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3604[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3602[rsp], eax
	mov	edx, DWORD PTR tv3604[rsp]
	mov	ecx, DWORD PTR tv3602[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3205 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3206 : 
; 3207 :         uint32_t vSib = rmMem->getVSib();

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getVSib@X86Mem@asmjit@@QEBAIXZ		; asmjit::X86Mem::getVSib
	mov	DWORD PTR vSib$28[rsp], eax

; 3208 :         if (vSib == kX86MemVSibGpz)

	cmp	DWORD PTR vSib$28[rsp], 0
	jne	SHORT $LN1626@X86Assembl

; 3209 :           goto _IllegalInst;

	jmp	$LN1627@X86Assembl
	jmp	$_IllegalInst$1950
$LN1626@X86Assembl:
$LN528@X86Assembl:

; 3210 : 
; 3211 :         ADD_VEX_L(vSib == kX86MemVSibYmm);

	cmp	DWORD PTR vSib$28[rsp], 2
	jne	SHORT $LN1929@X86Assembl
	mov	DWORD PTR tv3611[rsp], 1
	jmp	SHORT $LN1930@X86Assembl
$LN1929@X86Assembl:
	mov	DWORD PTR tv3611[rsp], 0
$LN1930@X86Assembl:
	mov	eax, DWORD PTR tv3611[rsp]
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN528@X86Assembl

; 3212 :         goto _EmitAvxV;

	jmp	$LN1628@X86Assembl
	jmp	$_EmitAvxV$1968
$LN1625@X86Assembl:

; 3213 :       }
; 3214 :       break;

	jmp	$LN5@X86Assembl
$LN1629@X86Assembl:

; 3215 : 
; 3216 :     case kX86InstEncodingIdAvxGather:
; 3217 :       if (encoded == ENC_OPS(Reg, Mem, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 89		; 00000059H
	jne	$LN1630@X86Assembl

; 3218 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o2));

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3626[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3624[rsp], eax
	mov	edx, DWORD PTR tv3626[rsp]
	mov	ecx, DWORD PTR tv3624[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3219 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3220 : 
; 3221 :         uint32_t vSib = rmMem->getVSib();

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getVSib@X86Mem@asmjit@@QEBAIXZ		; asmjit::X86Mem::getVSib
	mov	DWORD PTR vSib$47[rsp], eax

; 3222 :         if (vSib == kX86MemVSibGpz)

	cmp	DWORD PTR vSib$47[rsp], 0
	jne	SHORT $LN1631@X86Assembl

; 3223 :           goto _IllegalInst;

	jmp	$LN1632@X86Assembl
	jmp	$_IllegalInst$1950
$LN1631@X86Assembl:
$LN531@X86Assembl:

; 3224 : 
; 3225 :         ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o2)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3649[rsp], eax
	mov	rcx, QWORD PTR o2$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3647[rsp], eax
	mov	eax, DWORD PTR tv3647[rsp]
	mov	ecx, DWORD PTR tv3649[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN531@X86Assembl

; 3226 :         goto _EmitAvxV;

	jmp	$LN1633@X86Assembl
	jmp	$_EmitAvxV$1968
$LN1630@X86Assembl:

; 3227 :       }
; 3228 :       break;

	jmp	$LN5@X86Assembl
$LN1634@X86Assembl:
$LN534@X86Assembl:

; 3229 : 
; 3230 :     // ------------------------------------------------------------------------
; 3231 :     // [FMA4]
; 3232 :     // ------------------------------------------------------------------------
; 3233 : 
; 3234 :     case kX86InstEncodingIdFma4_P:
; 3235 :       // It's fine to just check the first operand, second is just for sanity.
; 3236 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3671[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3669[rsp], eax
	mov	eax, DWORD PTR tv3669[rsp]
	mov	ecx, DWORD PTR tv3671[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN534@X86Assembl
$LN1635@X86Assembl:

; 3237 :       // ... Fall through ...
; 3238 : 
; 3239 :     case kX86InstEncodingIdFma4:
; 3240 :       if (encoded == ENC_OPS(Reg, Reg, Reg) && o3->isReg()) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	$LN1636@X86Assembl
	mov	rcx, QWORD PTR o3$[rsp]
	call	?isReg@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isReg
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1636@X86Assembl

; 3241 :         imVal = x86OpReg(o3) << 4;

	mov	rcx, QWORD PTR o3$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	shl	eax, 4
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 3242 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3243 : 
; 3244 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3695[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3693[rsp], eax
	mov	edx, DWORD PTR tv3695[rsp]
	mov	ecx, DWORD PTR tv3693[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3245 :         rmReg = x86OpReg(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3246 : 
; 3247 :         goto _EmitAvxR;

	jmp	$LN1637@X86Assembl
	jmp	$_EmitAvxR$1966
$LN1636@X86Assembl:

; 3248 :       }
; 3249 : 
; 3250 :       if (encoded == ENC_OPS(Reg, Reg, Reg) && o3->isMem()) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	$LN1638@X86Assembl
	mov	rcx, QWORD PTR o3$[rsp]
	call	?isMem@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isMem
	movzx	eax, al
	test	eax, eax
	je	$LN1638@X86Assembl

; 3251 :         imVal = x86OpReg(o2) << 4;

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	shl	eax, 4
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 3252 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3253 : 
; 3254 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3718[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3716[rsp], eax
	mov	edx, DWORD PTR tv3718[rsp]
	mov	ecx, DWORD PTR tv3716[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3255 :         rmMem = x86OpMem(o3);

	mov	rcx, QWORD PTR o3$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax
$LN537@X86Assembl:

; 3256 : 
; 3257 :         ADD_VEX_W(true);

	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN537@X86Assembl

; 3258 :         goto _EmitAvxM;

	jmp	$LN1639@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1638@X86Assembl:

; 3259 :       }
; 3260 : 
; 3261 :       if (encoded == ENC_OPS(Reg, Reg, Mem) && o3->isReg()) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	$LN1640@X86Assembl
	mov	rcx, QWORD PTR o3$[rsp]
	call	?isReg@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isReg
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1640@X86Assembl

; 3262 :         imVal = x86OpReg(o3) << 4;

	mov	rcx, QWORD PTR o3$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	shl	eax, 4
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 3263 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3264 : 
; 3265 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3742[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3740[rsp], eax
	mov	edx, DWORD PTR tv3742[rsp]
	mov	ecx, DWORD PTR tv3740[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3266 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3267 : 
; 3268 :         goto _EmitAvxM;

	jmp	$LN1641@X86Assembl
	jmp	$_EmitAvxM$1965
$LN1640@X86Assembl:

; 3269 :       }
; 3270 :       break;

	jmp	$LN5@X86Assembl
$LN1642@X86Assembl:
$LN540@X86Assembl:

; 3271 : 
; 3272 :     // ------------------------------------------------------------------------
; 3273 :     // [XOP]
; 3274 :     // ------------------------------------------------------------------------
; 3275 : 
; 3276 :     case kX86InstEncodingIdXopRm_P:
; 3277 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3762[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3760[rsp], eax
	mov	eax, DWORD PTR tv3760[rsp]
	mov	ecx, DWORD PTR tv3762[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN540@X86Assembl
$LN1643@X86Assembl:

; 3278 :       // ... Fall through ...
; 3279 : 
; 3280 :     case kX86InstEncodingIdXopRm:
; 3281 :       if (encoded == ENC_OPS(Reg, Reg, None)) {

	cmp	DWORD PTR encoded$[rsp], 9
	jne	SHORT $LN1644@X86Assembl

; 3282 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 3283 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3284 :         goto _EmitXopR;

	jmp	$LN1645@X86Assembl
	jmp	$_EmitXopR$1969
$LN1644@X86Assembl:

; 3285 :       }
; 3286 : 
; 3287 :       if (encoded == ENC_OPS(Reg, Mem, None)) {

	cmp	DWORD PTR encoded$[rsp], 25
	jne	SHORT $LN1646@X86Assembl

; 3288 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 3289 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3290 :         goto _EmitXopM;

	jmp	$LN1647@X86Assembl
	jmp	$_EmitXopM$1970
$LN1646@X86Assembl:

; 3291 :       }
; 3292 :       break;

	jmp	$LN5@X86Assembl
$LN1648@X86Assembl:

; 3293 : 
; 3294 :     case kX86InstEncodingIdXopRvmRmv:
; 3295 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1649@X86Assembl

; 3296 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o2));

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3789[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3787[rsp], eax
	mov	edx, DWORD PTR tv3789[rsp]
	mov	ecx, DWORD PTR tv3787[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3297 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3298 : 
; 3299 :         goto _EmitXopR;

	jmp	$LN1650@X86Assembl
	jmp	$_EmitXopR$1969
$LN1649@X86Assembl:

; 3300 :       }
; 3301 : 
; 3302 :       if (encoded == ENC_OPS(Reg, Mem, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 89		; 00000059H
	jne	SHORT $LN1651@X86Assembl

; 3303 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o2));

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3804[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3802[rsp], eax
	mov	edx, DWORD PTR tv3804[rsp]
	mov	ecx, DWORD PTR tv3802[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3304 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3305 : 
; 3306 :         goto _EmitXopM;

	jmp	$LN1652@X86Assembl
	jmp	$_EmitXopM$1970
$LN1651@X86Assembl:

; 3307 :       }
; 3308 : 
; 3309 :       if (encoded == ENC_OPS(Reg, Reg, Mem)) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	SHORT $LN1653@X86Assembl

; 3310 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3818[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3816[rsp], eax
	mov	edx, DWORD PTR tv3818[rsp]
	mov	ecx, DWORD PTR tv3816[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3311 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax
$LN543@X86Assembl:

; 3312 : 
; 3313 :         ADD_VEX_W(true);

	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN543@X86Assembl

; 3314 :         goto _EmitXopM;

	jmp	$LN1654@X86Assembl
	jmp	$_EmitXopM$1970
$LN1653@X86Assembl:

; 3315 :       }
; 3316 : 
; 3317 :       break;

	jmp	$LN5@X86Assembl
$LN1655@X86Assembl:

; 3318 : 
; 3319 :     case kX86InstEncodingIdXopRvmRmi:
; 3320 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1656@X86Assembl

; 3321 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o2));

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3834[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3832[rsp], eax
	mov	edx, DWORD PTR tv3834[rsp]
	mov	ecx, DWORD PTR tv3832[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3322 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3323 :         goto _EmitXopR;

	jmp	$LN1657@X86Assembl
	jmp	$_EmitXopR$1969
$LN1656@X86Assembl:

; 3324 :       }
; 3325 : 
; 3326 :       if (encoded == ENC_OPS(Reg, Mem, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 89		; 00000059H
	jne	SHORT $LN1658@X86Assembl

; 3327 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o2));

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3849[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3847[rsp], eax
	mov	edx, DWORD PTR tv3849[rsp]
	mov	ecx, DWORD PTR tv3847[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3328 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3329 : 
; 3330 :         goto _EmitXopM;

	jmp	$LN1659@X86Assembl
	jmp	$_EmitXopM$1970
$LN1658@X86Assembl:

; 3331 :       }
; 3332 : 
; 3333 :       if (encoded == ENC_OPS(Reg, Reg, Mem)) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	SHORT $LN1660@X86Assembl

; 3334 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3863[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3861[rsp], eax
	mov	edx, DWORD PTR tv3863[rsp]
	mov	ecx, DWORD PTR tv3861[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3335 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax
$LN546@X86Assembl:

; 3336 : 
; 3337 :         ADD_VEX_W(true);

	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN546@X86Assembl

; 3338 :         goto _EmitXopM;

	jmp	$LN1661@X86Assembl
	jmp	$_EmitXopM$1970
$LN1660@X86Assembl:

; 3339 :       }
; 3340 : 
; 3341 :       // The following instructions use the secondary opcode.
; 3342 :       opCode = extendedInfo.getSecondaryOpCode();

	mov	rcx, QWORD PTR extendedInfo$[rsp]
	call	?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
	mov	DWORD PTR opCode$[rsp], eax

; 3343 : 
; 3344 :       imVal = static_cast<const Imm*>(o2)->getInt64();

	mov	rcx, QWORD PTR o2$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 3345 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3346 : 
; 3347 :       if (encoded == ENC_OPS(Reg, Reg, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 265		; 00000109H
	jne	SHORT $LN1662@X86Assembl

; 3348 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 3349 :         rmReg = x86OpReg(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3350 :         goto _EmitXopR;

	jmp	$LN1663@X86Assembl
	jmp	$_EmitXopR$1969
$LN1662@X86Assembl:

; 3351 :       }
; 3352 : 
; 3353 :       if (encoded == ENC_OPS(Reg, Mem, Imm)) {

	cmp	DWORD PTR encoded$[rsp], 281		; 00000119H
	jne	SHORT $LN1664@X86Assembl

; 3354 :         opReg = x86OpReg(o0);

	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR opReg$[rsp], eax

; 3355 :         rmMem = x86OpMem(o1);

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3356 :         goto _EmitXopM;

	jmp	$LN1665@X86Assembl
	jmp	$_EmitXopM$1970
$LN1664@X86Assembl:

; 3357 :       }
; 3358 :       break;

	jmp	$LN5@X86Assembl
$LN1666@X86Assembl:
$LN549@X86Assembl:

; 3359 : 
; 3360 :     case kX86InstEncodingIdXopRvmr_P:
; 3361 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3904[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3902[rsp], eax
	mov	eax, DWORD PTR tv3902[rsp]
	mov	ecx, DWORD PTR tv3904[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN549@X86Assembl
$LN1667@X86Assembl:

; 3362 :       // ... Fall through ...
; 3363 : 
; 3364 :     case kX86InstEncodingIdXopRvmr:
; 3365 :       if (!o3->isReg())

	mov	rcx, QWORD PTR o3$[rsp]
	call	?isReg@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isReg
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1668@X86Assembl

; 3366 :         goto _IllegalInst;

	jmp	$LN1669@X86Assembl
	jmp	$_IllegalInst$1950
$LN1668@X86Assembl:

; 3367 : 
; 3368 :       imVal = x86OpReg(o3) << 4;

	mov	rcx, QWORD PTR o3$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	shl	eax, 4
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 3369 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3370 : 
; 3371 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1670@X86Assembl

; 3372 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3928[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3926[rsp], eax
	mov	edx, DWORD PTR tv3928[rsp]
	mov	ecx, DWORD PTR tv3926[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3373 :         rmReg = x86OpReg(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3374 :         goto _EmitXopR;

	jmp	$LN1671@X86Assembl
	jmp	$_EmitXopR$1969
$LN1670@X86Assembl:

; 3375 :       }
; 3376 : 
; 3377 :       if (encoded == ENC_OPS(Reg, Reg, Mem)) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	SHORT $LN1672@X86Assembl

; 3378 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3943[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3941[rsp], eax
	mov	edx, DWORD PTR tv3943[rsp]
	mov	ecx, DWORD PTR tv3941[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3379 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3380 :         goto _EmitXopM;

	jmp	$LN1673@X86Assembl
	jmp	$_EmitXopM$1970
$LN1672@X86Assembl:

; 3381 :       }
; 3382 :       break;

	jmp	$LN5@X86Assembl
$LN1674@X86Assembl:
$LN552@X86Assembl:

; 3383 : 
; 3384 :     case kX86InstEncodingIdXopRvmi_P:
; 3385 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3963[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv3961[rsp], eax
	mov	eax, DWORD PTR tv3961[rsp]
	mov	ecx, DWORD PTR tv3963[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN552@X86Assembl
$LN1675@X86Assembl:

; 3386 :       // ... Fall through ...
; 3387 : 
; 3388 :     case kX86InstEncodingIdXopRvmi:
; 3389 :       if (!o3->isImm())

	mov	rcx, QWORD PTR o3$[rsp]
	call	?isImm@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isImm
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1676@X86Assembl

; 3390 :         goto _IllegalInst;

	jmp	$LN1677@X86Assembl
	jmp	$_IllegalInst$1950
$LN1676@X86Assembl:

; 3391 : 
; 3392 :       imVal = static_cast<const Imm*>(o3)->getInt64();

	mov	rcx, QWORD PTR o3$[rsp]
	call	?getInt64@Imm@asmjit@@QEBA_JXZ		; asmjit::Imm::getInt64
	mov	QWORD PTR imVal$[rsp], rax

; 3393 :       imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3394 : 
; 3395 :       if (encoded == ENC_OPS(Reg, Reg, Reg)) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	SHORT $LN1678@X86Assembl

; 3396 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3989[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv3987[rsp], eax
	mov	edx, DWORD PTR tv3989[rsp]
	mov	ecx, DWORD PTR tv3987[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3397 :         rmReg = x86OpReg(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3398 :         goto _EmitXopR;

	jmp	$LN1679@X86Assembl
	jmp	$_EmitXopR$1969
$LN1678@X86Assembl:

; 3399 :       }
; 3400 : 
; 3401 :       if (encoded == ENC_OPS(Reg, Reg, Mem)) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	SHORT $LN1680@X86Assembl

; 3402 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv4004[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv4002[rsp], eax
	mov	edx, DWORD PTR tv4004[rsp]
	mov	ecx, DWORD PTR tv4002[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3403 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3404 :         goto _EmitXopM;

	jmp	$LN1681@X86Assembl
	jmp	$_EmitXopM$1970
$LN1680@X86Assembl:

; 3405 :       }
; 3406 :       break;

	jmp	$LN5@X86Assembl
$LN1682@X86Assembl:
$LN555@X86Assembl:

; 3407 : 
; 3408 :     case kX86InstEncodingIdXopRvrmRvmr_P:
; 3409 :       ADD_VEX_L(static_cast<const X86Reg*>(o0)->isYmm() | static_cast<const X86Reg*>(o1)->isYmm());

	mov	rcx, QWORD PTR o0$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv4024[rsp], eax
	mov	rcx, QWORD PTR o1$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	mov	DWORD PTR tv4022[rsp], eax
	mov	eax, DWORD PTR tv4022[rsp]
	mov	ecx, DWORD PTR tv4024[rsp]
	or	ecx, eax
	mov	eax, ecx
	shl	eax, 23
	mov	ecx, DWORD PTR opCode$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN555@X86Assembl
$LN1683@X86Assembl:

; 3410 :       // ... Fall through ...
; 3411 : 
; 3412 :     case kX86InstEncodingIdXopRvrmRvmr:
; 3413 :       if (encoded == ENC_OPS(Reg, Reg, Reg) && o3->isReg()) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	$LN1684@X86Assembl
	mov	rcx, QWORD PTR o3$[rsp]
	call	?isReg@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isReg
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1684@X86Assembl

; 3414 :         imVal = x86OpReg(o3) << 4;

	mov	rcx, QWORD PTR o3$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	shl	eax, 4
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 3415 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3416 : 
; 3417 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv4048[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv4046[rsp], eax
	mov	edx, DWORD PTR tv4048[rsp]
	mov	ecx, DWORD PTR tv4046[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3418 :         rmReg = x86OpReg(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	eax, eax
	mov	QWORD PTR $S1$[rsp], rax

; 3419 : 
; 3420 :         goto _EmitXopR;

	jmp	$LN1685@X86Assembl
	jmp	$_EmitXopR$1969
$LN1684@X86Assembl:

; 3421 :       }
; 3422 : 
; 3423 :       if (encoded == ENC_OPS(Reg, Reg, Reg) && o3->isMem()) {

	cmp	DWORD PTR encoded$[rsp], 73		; 00000049H
	jne	$LN1686@X86Assembl
	mov	rcx, QWORD PTR o3$[rsp]
	call	?isMem@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isMem
	movzx	eax, al
	test	eax, eax
	je	$LN1686@X86Assembl

; 3424 :         imVal = x86OpReg(o2) << 4;

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	shl	eax, 4
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 3425 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3426 : 
; 3427 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv4071[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv4069[rsp], eax
	mov	edx, DWORD PTR tv4071[rsp]
	mov	ecx, DWORD PTR tv4069[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3428 :         rmMem = x86OpMem(o3);

	mov	rcx, QWORD PTR o3$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax
$LN558@X86Assembl:

; 3429 : 
; 3430 :         ADD_VEX_W(true);

	mov	eax, DWORD PTR opCode$[rsp]
	bts	eax, 31
	mov	DWORD PTR opCode$[rsp], eax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN558@X86Assembl

; 3431 :         goto _EmitXopM;

	jmp	$LN1687@X86Assembl
	jmp	$_EmitXopM$1970
$LN1686@X86Assembl:

; 3432 :       }
; 3433 : 
; 3434 :       if (encoded == ENC_OPS(Reg, Reg, Mem) && o3->isReg()) {

	cmp	DWORD PTR encoded$[rsp], 201		; 000000c9H
	jne	$LN1688@X86Assembl
	mov	rcx, QWORD PTR o3$[rsp]
	call	?isReg@Operand@asmjit@@QEBA_NXZ		; asmjit::Operand::isReg
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1688@X86Assembl

; 3435 :         imVal = x86OpReg(o3) << 4;

	mov	rcx, QWORD PTR o3$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	shl	eax, 4
	mov	eax, eax
	mov	QWORD PTR imVal$[rsp], rax

; 3436 :         imLen = 1;

	mov	DWORD PTR imLen$[rsp], 1

; 3437 : 
; 3438 :         opReg = x86RegAndVvvv(x86OpReg(o0), x86OpReg(o1));

	mov	rcx, QWORD PTR o1$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv4095[rsp], eax
	mov	rcx, QWORD PTR o0$[rsp]
	call	?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z	; asmjit::x86OpReg
	mov	DWORD PTR tv4093[rsp], eax
	mov	edx, DWORD PTR tv4095[rsp]
	mov	ecx, DWORD PTR tv4093[rsp]
	call	?x86RegAndVvvv@asmjit@@YAIII@Z		; asmjit::x86RegAndVvvv
	mov	DWORD PTR opReg$[rsp], eax

; 3439 :         rmMem = x86OpMem(o2);

	mov	rcx, QWORD PTR o2$[rsp]
	call	?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ; asmjit::x86OpMem
	mov	QWORD PTR $S1$[rsp], rax

; 3440 : 
; 3441 :         goto _EmitXopM;

	jmp	$LN1689@X86Assembl
	jmp	$_EmitXopM$1970
$LN1688@X86Assembl:
$LN5@X86Assembl:
$LN1011@X86Assembl:
$LN1058@X86Assembl:
$LN1077@X86Assembl:
$LN1149@X86Assembl:
$LN1208@X86Assembl:
$LN1271@X86Assembl:
$LN1306@X86Assembl:
$LN1369@X86Assembl:
$LN1529@X86Assembl:
$LN1537@X86Assembl:
$LN1549@X86Assembl:
$LN1627@X86Assembl:
$LN1632@X86Assembl:
$LN1669@X86Assembl:
$LN1677@X86Assembl:
$_IllegalInst$1950:

; 3442 :       }
; 3443 :       break;
; 3444 :   }
; 3445 : 
; 3446 :   // --------------------------------------------------------------------------
; 3447 :   // [Illegal]
; 3448 :   // --------------------------------------------------------------------------
; 3449 : 
; 3450 : _IllegalInst:
; 3451 :   self->setError(kErrorIllegalInst);

	xor	r8d, r8d
	mov	edx, 9
	mov	rcx, QWORD PTR self$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	npad	1

; 3452 : #if defined(ASMJIT_DEBUG)
; 3453 :   assertIllegal = true;
; 3454 : #endif // ASMJIT_DEBUG
; 3455 :   goto _EmitDone;

	jmp	$LN1690@X86Assembl
	jmp	$_EmitDone$1951
$_IllegalAddr$1971:

; 3456 : 
; 3457 : _IllegalAddr:
; 3458 :   self->setError(kErrorIllegalAddresing);

	xor	r8d, r8d
	mov	edx, 10
	mov	rcx, QWORD PTR self$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	npad	1

; 3459 : #if defined(ASMJIT_DEBUG)
; 3460 :   assertIllegal = true;
; 3461 : #endif // ASMJIT_DEBUG
; 3462 :   goto _EmitDone;

	jmp	$LN1691@X86Assembl
	jmp	$_EmitDone$1951
$_IllegalDisp$1972:

; 3463 : 
; 3464 : _IllegalDisp:
; 3465 :   self->setError(kErrorIllegalDisplacement);

	xor	r8d, r8d
	mov	edx, 11
	mov	rcx, QWORD PTR self$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	npad	1

; 3466 : #if defined(ASMJIT_DEBUG)
; 3467 :   assertIllegal = true;
; 3468 : #endif // ASMJIT_DEBUG
; 3469 :   goto _EmitDone;

	jmp	$LN1692@X86Assembl
	jmp	$_EmitDone$1951
$LN1016@X86Assembl:
$LN1054@X86Assembl:
$LN1118@X86Assembl:
$LN1228@X86Assembl:
$LN1231@X86Assembl:
$LN1251@X86Assembl:
$LN1302@X86Assembl:
$LN1370@X86Assembl:
$_EmitX86Op$1952:
$LN561@X86Assembl:

; 3470 : 
; 3471 :   // --------------------------------------------------------------------------
; 3472 :   // [Emit - X86]
; 3473 :   // --------------------------------------------------------------------------
; 3474 : 
; 3475 : _EmitX86Op:
; 3476 :   // Mandatory instruction prefix.
; 3477 :   EMIT_PP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 20
	and	eax, 7
	mov	DWORD PTR ppIndex$29[rsp], eax
	mov	eax, DWORD PTR ppIndex$29[rsp]
	lea	rcx, OFFSET FLAT:?x86OpCodePP@asmjit@@3QBEB
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR ppCode$19[rsp], al
	cmp	DWORD PTR ppIndex$29[rsp], 0
	jne	SHORT $LN1693@X86Assembl
	jmp	SHORT $LN560@X86Assembl
$LN1693@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR ppCode$19[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN561@X86Assembl
$LN560@X86Assembl:

; 3478 : 
; 3479 :   // Rex prefix (64-bit only).
; 3480 :   if (Arch == kArchX64) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1694@X86Assembl

; 3481 :     uint32_t rex = x86RexFromOpCodeAndOptions(opCode, options);

	mov	edx, DWORD PTR options$[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86RexFromOpCodeAndOptions@asmjit@@YAIII@Z ; asmjit::x86RexFromOpCodeAndOptions
	mov	DWORD PTR rex$23[rsp], eax

; 3482 : 
; 3483 :     if (rex) {

	cmp	DWORD PTR rex$23[rsp], 0
	je	SHORT $LN1695@X86Assembl

; 3484 :       rex |= kX86ByteRex;

	mov	eax, DWORD PTR rex$23[rsp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR rex$23[rsp], eax
$LN564@X86Assembl:

; 3485 :       EMIT_BYTE(rex);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR rex$23[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN564@X86Assembl

; 3486 : 
; 3487 :       if (x86RexIsInvalid(rex))

	mov	ecx, DWORD PTR rex$23[rsp]
	call	?x86RexIsInvalid@asmjit@@YA_NI@Z	; asmjit::x86RexIsInvalid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1696@X86Assembl

; 3488 :         goto _IllegalInst;

	jmp	$_IllegalInst$1950
$LN1696@X86Assembl:
$LN1695@X86Assembl:
$LN1694@X86Assembl:
$LN567@X86Assembl:

; 3489 :     }
; 3490 :   }
; 3491 : 
; 3492 :   // Instruction opcodes.
; 3493 :   EMIT_MM(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 16
	and	eax, 15
	mov	DWORD PTR mmIndex$30[rsp], eax
	mov	eax, DWORD PTR mmIndex$30[rsp]
	lea	rcx, OFFSET FLAT:?x86OpCodeMM@asmjit@@3QBUX86OpCodeMM@1@B
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	QWORD PTR mmCode$60[rsp], rax
	cmp	DWORD PTR mmIndex$30[rsp], 0
	jne	SHORT $LN1697@X86Assembl
	jmp	SHORT $LN566@X86Assembl
$LN1697@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	r8, QWORD PTR mmCode$60[rsp]
	movzx	eax, BYTE PTR [r8+rax+1]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	r8, QWORD PTR mmCode$60[rsp]
	movzx	eax, BYTE PTR [r8+rax+1]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR mmCode$60[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR cursor$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	$LN567@X86Assembl
$LN566@X86Assembl:
$LN570@X86Assembl:
$LN573@X86Assembl:

; 3494 :   EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN573@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN570@X86Assembl

; 3495 : 
; 3496 :   if (imLen != 0)

	cmp	DWORD PTR imLen$[rsp], 0
	je	SHORT $LN1698@X86Assembl

; 3497 :     goto _EmitImm;

	jmp	$LN1700@X86Assembl
	jmp	$_EmitImm$1959
	jmp	SHORT $LN1699@X86Assembl
$LN1698@X86Assembl:

; 3498 :   else
; 3499 :     goto _EmitDone;

	jmp	$LN1701@X86Assembl
	jmp	$_EmitDone$1951
$LN1699@X86Assembl:
$LN1064@X86Assembl:
$LN1205@X86Assembl:
$LN1247@X86Assembl:
$LN1318@X86Assembl:
$_EmitX86OpWithOpReg$1955:
$LN576@X86Assembl:

; 3500 : 
; 3501 : _EmitX86OpWithOpReg:
; 3502 :   // Mandatory instruction prefix.
; 3503 :   EMIT_PP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 20
	and	eax, 7
	mov	DWORD PTR ppIndex$31[rsp], eax
	mov	eax, DWORD PTR ppIndex$31[rsp]
	lea	rcx, OFFSET FLAT:?x86OpCodePP@asmjit@@3QBEB
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR ppCode$18[rsp], al
	cmp	DWORD PTR ppIndex$31[rsp], 0
	jne	SHORT $LN1702@X86Assembl
	jmp	SHORT $LN575@X86Assembl
$LN1702@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR ppCode$18[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN576@X86Assembl
$LN575@X86Assembl:

; 3504 : 
; 3505 :   // Rex prefix (64-bit only).
; 3506 :   if (Arch == kArchX64) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN1703@X86Assembl

; 3507 :     uint32_t rex = x86RexFromOpCodeAndOptions(opCode, options);

	mov	edx, DWORD PTR options$[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86RexFromOpCodeAndOptions@asmjit@@YAIII@Z ; asmjit::x86RexFromOpCodeAndOptions
	mov	DWORD PTR rex$13[rsp], eax

; 3508 : 
; 3509 :     rex += (opReg >> 3); // Rex.B (0x01).

	mov	eax, DWORD PTR opReg$[rsp]
	shr	eax, 3
	mov	ecx, DWORD PTR rex$13[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR rex$13[rsp], eax

; 3510 : 
; 3511 :     if (rex) {

	cmp	DWORD PTR rex$13[rsp], 0
	je	SHORT $LN1704@X86Assembl

; 3512 :       rex |= kX86ByteRex;

	mov	eax, DWORD PTR rex$13[rsp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR rex$13[rsp], eax

; 3513 :       opReg &= 0x7;

	mov	eax, DWORD PTR opReg$[rsp]
	and	eax, 7
	mov	DWORD PTR opReg$[rsp], eax
$LN579@X86Assembl:

; 3514 :       EMIT_BYTE(rex);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR rex$13[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN579@X86Assembl

; 3515 : 
; 3516 :       if (x86RexIsInvalid(rex))

	mov	ecx, DWORD PTR rex$13[rsp]
	call	?x86RexIsInvalid@asmjit@@YA_NI@Z	; asmjit::x86RexIsInvalid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1705@X86Assembl

; 3517 :         goto _IllegalInst;

	jmp	$_IllegalInst$1950
$LN1705@X86Assembl:
$LN1704@X86Assembl:
$LN1703@X86Assembl:

; 3518 :     }
; 3519 :   }
; 3520 : 
; 3521 :   // Instruction opcodes.
; 3522 :   opCode += opReg;

	mov	eax, DWORD PTR opReg$[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR opCode$[rsp], eax
$LN582@X86Assembl:

; 3523 :   EMIT_MM(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 16
	and	eax, 15
	mov	DWORD PTR mmIndex$32[rsp], eax
	mov	eax, DWORD PTR mmIndex$32[rsp]
	lea	rcx, OFFSET FLAT:?x86OpCodeMM@asmjit@@3QBUX86OpCodeMM@1@B
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	QWORD PTR mmCode$61[rsp], rax
	cmp	DWORD PTR mmIndex$32[rsp], 0
	jne	SHORT $LN1706@X86Assembl
	jmp	SHORT $LN581@X86Assembl
$LN1706@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	r8, QWORD PTR mmCode$61[rsp]
	movzx	eax, BYTE PTR [r8+rax+1]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	r8, QWORD PTR mmCode$61[rsp]
	movzx	eax, BYTE PTR [r8+rax+1]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR mmCode$61[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR cursor$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	$LN582@X86Assembl
$LN581@X86Assembl:
$LN585@X86Assembl:
$LN588@X86Assembl:

; 3524 :   EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN588@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN585@X86Assembl

; 3525 : 
; 3526 :   if (imLen != 0)

	cmp	DWORD PTR imLen$[rsp], 0
	je	SHORT $LN1707@X86Assembl

; 3527 :     goto _EmitImm;

	jmp	$LN1709@X86Assembl
	jmp	$_EmitImm$1959
	jmp	SHORT $LN1708@X86Assembl
$LN1707@X86Assembl:

; 3528 :   else
; 3529 :     goto _EmitDone;

	jmp	$LN1710@X86Assembl
	jmp	$_EmitDone$1951
$LN1708@X86Assembl:

; 3530 : 
; 3531 : _EmitX86R:

	jmp	SHORT $_EmitX86R$1953
$LN1021@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1027@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1034@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1043@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1055@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1068@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1074@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1081@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1097@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1101@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1106@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1109@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1119@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1154@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1178@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1182@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1184@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1203@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1214@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1221@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1263@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1268@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1276@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1282@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1288@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1295@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1303@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1319@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1376@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1381@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1392@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1408@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1412@X86Assembl:
	jmp	SHORT $_EmitX86R$1953
$LN1418@X86Assembl:
$LN1420@X86Assembl:
$LN1422@X86Assembl:
$LN1424@X86Assembl:
$LN1444@X86Assembl:
$LN1449@X86Assembl:
$LN1454@X86Assembl:
$LN1458@X86Assembl:
$LN1461@X86Assembl:
$LN1465@X86Assembl:
$LN1468@X86Assembl:
$LN1473@X86Assembl:
$LN1478@X86Assembl:
$LN1480@X86Assembl:
$LN1483@X86Assembl:
$LN1485@X86Assembl:
$LN1488@X86Assembl:
$_EmitX86R$1953:
$LN591@X86Assembl:

; 3532 :   // Mandatory instruction prefix.
; 3533 :   EMIT_PP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 20
	and	eax, 7
	mov	DWORD PTR ppIndex$33[rsp], eax
	mov	eax, DWORD PTR ppIndex$33[rsp]
	lea	rcx, OFFSET FLAT:?x86OpCodePP@asmjit@@3QBEB
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR ppCode$17[rsp], al
	cmp	DWORD PTR ppIndex$33[rsp], 0
	jne	SHORT $LN1711@X86Assembl
	jmp	SHORT $LN590@X86Assembl
$LN1711@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR ppCode$17[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN591@X86Assembl
$LN590@X86Assembl:

; 3534 : 
; 3535 :   // Rex prefix (64-bit only).
; 3536 :   if (Arch == kArchX64) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN1712@X86Assembl

; 3537 :     uint32_t rex = x86RexFromOpCodeAndOptions(opCode, options);

	mov	edx, DWORD PTR options$[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86RexFromOpCodeAndOptions@asmjit@@YAIII@Z ; asmjit::x86RexFromOpCodeAndOptions
	mov	DWORD PTR rex$11[rsp], eax

; 3538 : 
; 3539 :     rex += static_cast<uint32_t>(opReg & 0x08) >> 1; // Rex.R (0x04).

	mov	eax, DWORD PTR opReg$[rsp]
	and	eax, 8
	shr	eax, 1
	mov	ecx, DWORD PTR rex$11[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR rex$11[rsp], eax

; 3540 :     rex += static_cast<uint32_t>(rmReg) >> 3;        // Rex.B (0x01).

	mov	eax, DWORD PTR $S1$[rsp]
	shr	eax, 3
	mov	ecx, DWORD PTR rex$11[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR rex$11[rsp], eax

; 3541 : 
; 3542 :     if (rex) {

	cmp	DWORD PTR rex$11[rsp], 0
	je	SHORT $LN1713@X86Assembl

; 3543 :       rex |= kX86ByteRex;

	mov	eax, DWORD PTR rex$11[rsp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR rex$11[rsp], eax

; 3544 :       opReg &= 0x7;

	mov	eax, DWORD PTR opReg$[rsp]
	and	eax, 7
	mov	DWORD PTR opReg$[rsp], eax

; 3545 :       rmReg &= 0x7;

	mov	rax, QWORD PTR $S1$[rsp]
	and	rax, 7
	mov	QWORD PTR $S1$[rsp], rax
$LN594@X86Assembl:

; 3546 :       EMIT_BYTE(rex);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR rex$11[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN594@X86Assembl

; 3547 : 
; 3548 :       if (x86RexIsInvalid(rex))

	mov	ecx, DWORD PTR rex$11[rsp]
	call	?x86RexIsInvalid@asmjit@@YA_NI@Z	; asmjit::x86RexIsInvalid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1714@X86Assembl

; 3549 :         goto _IllegalInst;

	jmp	$_IllegalInst$1950
$LN1714@X86Assembl:
$LN1713@X86Assembl:
$LN1712@X86Assembl:
$LN597@X86Assembl:

; 3550 :     }
; 3551 :   }
; 3552 : 
; 3553 :   // Instruction opcodes.
; 3554 :   EMIT_MM(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 16
	and	eax, 15
	mov	DWORD PTR mmIndex$34[rsp], eax
	mov	eax, DWORD PTR mmIndex$34[rsp]
	lea	rcx, OFFSET FLAT:?x86OpCodeMM@asmjit@@3QBUX86OpCodeMM@1@B
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	QWORD PTR mmCode$62[rsp], rax
	cmp	DWORD PTR mmIndex$34[rsp], 0
	jne	SHORT $LN1715@X86Assembl
	jmp	SHORT $LN596@X86Assembl
$LN1715@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	r8, QWORD PTR mmCode$62[rsp]
	movzx	eax, BYTE PTR [r8+rax+1]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	r8, QWORD PTR mmCode$62[rsp]
	movzx	eax, BYTE PTR [r8+rax+1]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR mmCode$62[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR cursor$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	$LN597@X86Assembl
$LN596@X86Assembl:
$LN600@X86Assembl:
$LN603@X86Assembl:

; 3555 :   EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN603@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN600@X86Assembl
$LN606@X86Assembl:

; 3556 : 
; 3557 :   // ModR.
; 3558 :   EMIT_BYTE(x86EncodeMod(3, opReg, static_cast<uint32_t>(rmReg)));

	mov	r8d, DWORD PTR $S1$[rsp]
	mov	edx, DWORD PTR opReg$[rsp]
	mov	ecx, 3
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN606@X86Assembl

; 3559 : 
; 3560 :   if (imLen != 0)

	cmp	DWORD PTR imLen$[rsp], 0
	je	SHORT $LN1716@X86Assembl

; 3561 :     goto _EmitImm;

	jmp	$LN1718@X86Assembl
	jmp	$_EmitImm$1959
	jmp	SHORT $LN1717@X86Assembl
$LN1716@X86Assembl:

; 3562 :   else
; 3563 :     goto _EmitDone;

	jmp	$LN1719@X86Assembl
	jmp	$_EmitDone$1951
$LN1717@X86Assembl:

; 3564 : 
; 3565 : _EmitX86M:

	jmp	SHORT $_EmitX86M$1954
$LN1023@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1030@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1036@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1039@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1046@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1049@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1060@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1071@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1078@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1083@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1099@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1103@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1112@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1121@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1156@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1173@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1189@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1191@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1196@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1198@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1210@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1217@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1224@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1249@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1265@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1273@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1278@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1285@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1291@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1298@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1308@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1312@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1322@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1332@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1340@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1342@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1344@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1355@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1357@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1359@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1372@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1378@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1383@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1395@X86Assembl:
	jmp	SHORT $_EmitX86M$1954
$LN1398@X86Assembl:
$LN1402@X86Assembl:
$LN1405@X86Assembl:
$LN1410@X86Assembl:
$LN1414@X86Assembl:
$LN1427@X86Assembl:
$LN1429@X86Assembl:
$LN1432@X86Assembl:
$LN1434@X86Assembl:
$LN1438@X86Assembl:
$LN1446@X86Assembl:
$LN1451@X86Assembl:
$LN1456@X86Assembl:
$LN1463@X86Assembl:
$LN1470@X86Assembl:
$LN1475@X86Assembl:
$LN1490@X86Assembl:
$_EmitX86M$1954:

; 3566 :   ASMJIT_ASSERT(rmMem != NULL);
; 3567 :   ASMJIT_ASSERT(rmMem->getOp() == kOperandTypeMem);
; 3568 : 
; 3569 :   mBase = rmMem->getBase();

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getBase@X86Mem@asmjit@@QEBAIXZ		; asmjit::X86Mem::getBase
	mov	DWORD PTR mBase$[rsp], eax

; 3570 :   mIndex = rmMem->getIndex();

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getIndex@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getIndex
	mov	DWORD PTR mIndex$[rsp], eax

; 3571 : 
; 3572 :   // Size override prefix.
; 3573 :   if (rmMem->hasBaseOrIndex() && rmMem->getMemType() != kMemTypeLabel) {

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?hasBaseOrIndex@X86Mem@asmjit@@QEBA_NXZ	; asmjit::X86Mem::hasBaseOrIndex
	movzx	eax, al
	test	eax, eax
	je	$LN1720@X86Assembl
	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getMemType@BaseMem@asmjit@@QEBAIXZ	; asmjit::BaseMem::getMemType
	cmp	eax, 2
	je	SHORT $LN1720@X86Assembl

; 3574 :     if (Arch == kArchX86) {

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN1721@X86Assembl

; 3575 :       if (!rmMem->hasGpdBase())

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?hasGpdBase@X86Mem@asmjit@@QEBA_NXZ	; asmjit::X86Mem::hasGpdBase
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1723@X86Assembl
$LN609@X86Assembl:

; 3576 :         EMIT_BYTE(0x67);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 103			; 00000067H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN609@X86Assembl
$LN1723@X86Assembl:

; 3577 :     }

	jmp	SHORT $LN1722@X86Assembl
$LN1721@X86Assembl:

; 3578 :     else {
; 3579 :       if (rmMem->hasGpdBase())

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?hasGpdBase@X86Mem@asmjit@@QEBA_NXZ	; asmjit::X86Mem::hasGpdBase
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1724@X86Assembl
$LN612@X86Assembl:

; 3580 :         EMIT_BYTE(0x67);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 103			; 00000067H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN612@X86Assembl
$LN1724@X86Assembl:
$LN1722@X86Assembl:
$LN1720@X86Assembl:

; 3581 :     }
; 3582 :   }
; 3583 : 
; 3584 :   // Segment override prefix.
; 3585 :   if (rmMem->hasSegment()) {

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?hasSegment@X86Mem@asmjit@@QEBA_NXZ	; asmjit::X86Mem::hasSegment
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1725@X86Assembl
$LN615@X86Assembl:

; 3586 :     EMIT_BYTE(x86SegmentPrefix[rmMem->getSegment()]);

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getSegment@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getSegment
	mov	eax, eax
	lea	rcx, OFFSET FLAT:?x86SegmentPrefix@asmjit@@3QBEB
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR cursor$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN615@X86Assembl
$LN1725@X86Assembl:
$LN618@X86Assembl:

; 3587 :   }
; 3588 : 
; 3589 :   // Mandatory instruction prefix.
; 3590 :   EMIT_PP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 20
	and	eax, 7
	mov	DWORD PTR ppIndex$35[rsp], eax
	mov	eax, DWORD PTR ppIndex$35[rsp]
	lea	rcx, OFFSET FLAT:?x86OpCodePP@asmjit@@3QBEB
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR ppCode$16[rsp], al
	cmp	DWORD PTR ppIndex$35[rsp], 0
	jne	SHORT $LN1726@X86Assembl
	jmp	SHORT $LN617@X86Assembl
$LN1726@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR ppCode$16[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN618@X86Assembl
$LN617@X86Assembl:

; 3591 : 
; 3592 :   // Rex prefix (64-bit only).
; 3593 :   if (Arch == kArchX64) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN1727@X86Assembl

; 3594 :     uint32_t rex = x86RexFromOpCodeAndOptions(opCode, options);

	mov	edx, DWORD PTR options$[rsp]
	mov	ecx, DWORD PTR opCode$[rsp]
	call	?x86RexFromOpCodeAndOptions@asmjit@@YAIII@Z ; asmjit::x86RexFromOpCodeAndOptions
	mov	DWORD PTR rex$5[rsp], eax

; 3595 : 
; 3596 :     rex += static_cast<uint32_t>(opReg      & 8) >> 1; // Rex.R (0x04).

	mov	eax, DWORD PTR opReg$[rsp]
	and	eax, 8
	shr	eax, 1
	mov	ecx, DWORD PTR rex$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR rex$5[rsp], eax

; 3597 :     rex += static_cast<uint32_t>(mIndex - 8 < 8) << 1; // Rex.X (0x02).

	mov	eax, DWORD PTR mIndex$[rsp]
	sub	eax, 8
	cmp	eax, 8
	jae	SHORT $LN1931@X86Assembl
	mov	DWORD PTR tv4392[rsp], 1
	jmp	SHORT $LN1932@X86Assembl
$LN1931@X86Assembl:
	mov	DWORD PTR tv4392[rsp], 0
$LN1932@X86Assembl:
	mov	eax, DWORD PTR rex$5[rsp]
	mov	ecx, DWORD PTR tv4392[rsp]
	lea	eax, DWORD PTR [rax+rcx*2]
	mov	DWORD PTR rex$5[rsp], eax

; 3598 :     rex += static_cast<uint32_t>(mBase  - 8 < 8);      // Rex.B (0x01).

	mov	eax, DWORD PTR mBase$[rsp]
	sub	eax, 8
	cmp	eax, 8
	jae	SHORT $LN1933@X86Assembl
	mov	DWORD PTR tv4397[rsp], 1
	jmp	SHORT $LN1934@X86Assembl
$LN1933@X86Assembl:
	mov	DWORD PTR tv4397[rsp], 0
$LN1934@X86Assembl:
	mov	eax, DWORD PTR tv4397[rsp]
	mov	ecx, DWORD PTR rex$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR rex$5[rsp], eax

; 3599 : 
; 3600 :     if (rex) {

	cmp	DWORD PTR rex$5[rsp], 0
	je	SHORT $LN1728@X86Assembl

; 3601 :       rex |= kX86ByteRex;

	mov	eax, DWORD PTR rex$5[rsp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR rex$5[rsp], eax

; 3602 :       opReg &= 0x7;

	mov	eax, DWORD PTR opReg$[rsp]
	and	eax, 7
	mov	DWORD PTR opReg$[rsp], eax
$LN621@X86Assembl:

; 3603 :       EMIT_BYTE(rex);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR rex$5[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN621@X86Assembl

; 3604 : 
; 3605 :       if (x86RexIsInvalid(rex))

	mov	ecx, DWORD PTR rex$5[rsp]
	call	?x86RexIsInvalid@asmjit@@YA_NI@Z	; asmjit::x86RexIsInvalid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1729@X86Assembl

; 3606 :         goto _IllegalInst;

	jmp	$_IllegalInst$1950
$LN1729@X86Assembl:
$LN1728@X86Assembl:

; 3607 :     }
; 3608 : 
; 3609 :     mBase &= 0x7;

	mov	eax, DWORD PTR mBase$[rsp]
	and	eax, 7
	mov	DWORD PTR mBase$[rsp], eax
$LN1727@X86Assembl:
$LN624@X86Assembl:

; 3610 :   }
; 3611 : 
; 3612 :   // Instruction opcodes.
; 3613 :   EMIT_MM(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 16
	and	eax, 15
	mov	DWORD PTR mmIndex$36[rsp], eax
	mov	eax, DWORD PTR mmIndex$36[rsp]
	lea	rcx, OFFSET FLAT:?x86OpCodeMM@asmjit@@3QBUX86OpCodeMM@1@B
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	QWORD PTR mmCode$63[rsp], rax
	cmp	DWORD PTR mmIndex$36[rsp], 0
	jne	SHORT $LN1730@X86Assembl
	jmp	SHORT $LN623@X86Assembl
$LN1730@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	r8, QWORD PTR mmCode$63[rsp]
	movzx	eax, BYTE PTR [r8+rax+1]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	r8, QWORD PTR mmCode$63[rsp]
	movzx	eax, BYTE PTR [r8+rax+1]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR mmCode$63[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR cursor$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	$LN624@X86Assembl
$LN623@X86Assembl:
$LN627@X86Assembl:
$LN630@X86Assembl:

; 3614 :   EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN630@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN627@X86Assembl
$_EmitSib$1973:

; 3615 :   // ... Fall through ...
; 3616 : 
; 3617 :   // --------------------------------------------------------------------------
; 3618 :   // [Emit - SIB]
; 3619 :   // --------------------------------------------------------------------------
; 3620 : 
; 3621 : _EmitSib:
; 3622 :   dispOffset = rmMem->getDisplacement();

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getDisplacement@X86Mem@asmjit@@QEBAHXZ	; asmjit::X86Mem::getDisplacement
	mov	DWORD PTR dispOffset$[rsp], eax

; 3623 :   if (rmMem->isBaseIndexType()) {

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?isBaseIndexType@BaseMem@asmjit@@QEBA_NXZ ; asmjit::BaseMem::isBaseIndexType
	movzx	eax, al
	test	eax, eax
	je	$LN1731@X86Assembl

; 3624 :     if (mIndex >= kInvalidReg) {

	cmp	DWORD PTR mIndex$[rsp], 255		; 000000ffH
	jb	$LN1733@X86Assembl

; 3625 :       if (mBase == kX86RegIndexSp) {

	cmp	DWORD PTR mBase$[rsp], 4
	jne	$LN1735@X86Assembl

; 3626 :         if (dispOffset == 0) {

	cmp	DWORD PTR dispOffset$[rsp], 0
	jne	SHORT $LN1737@X86Assembl
$LN633@X86Assembl:

; 3627 :           // [Esp/Rsp/R12].
; 3628 :           EMIT_BYTE(x86EncodeMod(0, opReg, 4));

	mov	r8d, 4
	mov	edx, DWORD PTR opReg$[rsp]
	xor	ecx, ecx
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN633@X86Assembl
$LN636@X86Assembl:

; 3629 :           EMIT_BYTE(x86EncodeSib(0, 4, 4));

	mov	r8d, 4
	mov	edx, 4
	xor	ecx, ecx
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN636@X86Assembl

; 3630 :         }

	jmp	$LN1738@X86Assembl
$LN1737@X86Assembl:

; 3631 :         else if (IntUtil::isInt8(dispOffset)) {

	mov	ecx, DWORD PTR dispOffset$[rsp]
	call	??$isInt8@H@IntUtil@asmjit@@SA_NH@Z	; asmjit::IntUtil::isInt8<int>
	movzx	eax, al
	test	eax, eax
	je	$LN1739@X86Assembl
$LN639@X86Assembl:

; 3632 :           // [Esp/Rsp/R12 + Disp8].
; 3633 :           EMIT_BYTE(x86EncodeMod(1, opReg, 4));

	mov	r8d, 4
	mov	edx, DWORD PTR opReg$[rsp]
	mov	ecx, 1
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN639@X86Assembl
$LN642@X86Assembl:

; 3634 :           EMIT_BYTE(x86EncodeSib(0, 4, 4));

	mov	r8d, 4
	mov	edx, 4
	xor	ecx, ecx
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN642@X86Assembl
$LN645@X86Assembl:

; 3635 :           EMIT_BYTE(static_cast<int8_t>(dispOffset));

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR dispOffset$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN645@X86Assembl

; 3636 :         }

	jmp	$LN1740@X86Assembl
$LN1739@X86Assembl:
$LN648@X86Assembl:

; 3637 :         else {
; 3638 :           // [Esp/Rsp/R12 + Disp32].
; 3639 :           EMIT_BYTE(x86EncodeMod(2, opReg, 4));

	mov	r8d, 4
	mov	edx, DWORD PTR opReg$[rsp]
	mov	ecx, 2
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN648@X86Assembl
$LN651@X86Assembl:

; 3640 :           EMIT_BYTE(x86EncodeSib(0, 4, 4));

	mov	r8d, 4
	mov	edx, 4
	xor	ecx, ecx
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN651@X86Assembl
$LN654@X86Assembl:

; 3641 :           EMIT_DWORD(static_cast<int32_t>(dispOffset));

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	edx, DWORD PTR dispOffset$[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN654@X86Assembl
$LN1740@X86Assembl:
$LN1738@X86Assembl:

; 3642 :         }
; 3643 :       }

	jmp	$LN1736@X86Assembl
$LN1735@X86Assembl:

; 3644 :       else if (mBase != kX86RegIndexBp && dispOffset == 0) {

	cmp	DWORD PTR mBase$[rsp], 5
	je	SHORT $LN1741@X86Assembl
	cmp	DWORD PTR dispOffset$[rsp], 0
	jne	SHORT $LN1741@X86Assembl
$LN657@X86Assembl:

; 3645 :         // [Base].
; 3646 :         EMIT_BYTE(x86EncodeMod(0, opReg, mBase));

	mov	r8d, DWORD PTR mBase$[rsp]
	mov	edx, DWORD PTR opReg$[rsp]
	xor	ecx, ecx
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN657@X86Assembl

; 3647 :       }

	jmp	$LN1742@X86Assembl
$LN1741@X86Assembl:

; 3648 :       else if (IntUtil::isInt8(dispOffset)) {

	mov	ecx, DWORD PTR dispOffset$[rsp]
	call	??$isInt8@H@IntUtil@asmjit@@SA_NH@Z	; asmjit::IntUtil::isInt8<int>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1743@X86Assembl
$LN660@X86Assembl:

; 3649 :         // [Base + Disp8].
; 3650 :         EMIT_BYTE(x86EncodeMod(1, opReg, mBase));

	mov	r8d, DWORD PTR mBase$[rsp]
	mov	edx, DWORD PTR opReg$[rsp]
	mov	ecx, 1
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN660@X86Assembl
$LN663@X86Assembl:

; 3651 :         EMIT_BYTE(static_cast<int8_t>(dispOffset));

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR dispOffset$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN663@X86Assembl

; 3652 :       }

	jmp	SHORT $LN1744@X86Assembl
$LN1743@X86Assembl:
$LN666@X86Assembl:

; 3653 :       else {
; 3654 :         // [Base + Disp32].
; 3655 :         EMIT_BYTE(x86EncodeMod(2, opReg, mBase));

	mov	r8d, DWORD PTR mBase$[rsp]
	mov	edx, DWORD PTR opReg$[rsp]
	mov	ecx, 2
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN666@X86Assembl
$LN669@X86Assembl:

; 3656 :         EMIT_DWORD(static_cast<int32_t>(dispOffset));

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	edx, DWORD PTR dispOffset$[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN669@X86Assembl
$LN1744@X86Assembl:
$LN1742@X86Assembl:
$LN1736@X86Assembl:

; 3657 :       }
; 3658 :     }

	jmp	$LN1734@X86Assembl
$LN1733@X86Assembl:

; 3659 :     else {
; 3660 :       uint32_t shift = rmMem->getShift();

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getShift@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getShift
	mov	DWORD PTR shift$24[rsp], eax

; 3661 : 
; 3662 :       // Esp/Rsp/R12 register can't be used as an index.
; 3663 :       mIndex &= 0x7;

	mov	eax, DWORD PTR mIndex$[rsp]
	and	eax, 7
	mov	DWORD PTR mIndex$[rsp], eax

; 3664 :       ASMJIT_ASSERT(mIndex != kX86RegIndexSp);
; 3665 : 
; 3666 :       if (mBase != kX86RegIndexBp && dispOffset == 0) {

	cmp	DWORD PTR mBase$[rsp], 5
	je	SHORT $LN1745@X86Assembl
	cmp	DWORD PTR dispOffset$[rsp], 0
	jne	SHORT $LN1745@X86Assembl
$LN672@X86Assembl:

; 3667 :         // [Base + Index * Scale].
; 3668 :         EMIT_BYTE(x86EncodeMod(0, opReg, 4));

	mov	r8d, 4
	mov	edx, DWORD PTR opReg$[rsp]
	xor	ecx, ecx
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN672@X86Assembl
$LN675@X86Assembl:

; 3669 :         EMIT_BYTE(x86EncodeSib(shift, mIndex, mBase));

	mov	r8d, DWORD PTR mBase$[rsp]
	mov	edx, DWORD PTR mIndex$[rsp]
	mov	ecx, DWORD PTR shift$24[rsp]
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN675@X86Assembl

; 3670 :       }

	jmp	$LN1746@X86Assembl
$LN1745@X86Assembl:

; 3671 :       else if (IntUtil::isInt8(dispOffset)) {

	mov	ecx, DWORD PTR dispOffset$[rsp]
	call	??$isInt8@H@IntUtil@asmjit@@SA_NH@Z	; asmjit::IntUtil::isInt8<int>
	movzx	eax, al
	test	eax, eax
	je	$LN1747@X86Assembl
$LN678@X86Assembl:

; 3672 :         // [Base + Index * Scale + Disp8].
; 3673 :         EMIT_BYTE(x86EncodeMod(1, opReg, 4));

	mov	r8d, 4
	mov	edx, DWORD PTR opReg$[rsp]
	mov	ecx, 1
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN678@X86Assembl
$LN681@X86Assembl:

; 3674 :         EMIT_BYTE(x86EncodeSib(shift, mIndex, mBase));

	mov	r8d, DWORD PTR mBase$[rsp]
	mov	edx, DWORD PTR mIndex$[rsp]
	mov	ecx, DWORD PTR shift$24[rsp]
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN681@X86Assembl
$LN684@X86Assembl:

; 3675 :         EMIT_BYTE(static_cast<int8_t>(dispOffset));

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR dispOffset$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN684@X86Assembl

; 3676 :       }

	jmp	$LN1748@X86Assembl
$LN1747@X86Assembl:
$LN687@X86Assembl:

; 3677 :       else {
; 3678 :         // [Base + Index * Scale + Disp32].
; 3679 :         EMIT_BYTE(x86EncodeMod(2, opReg, 4));

	mov	r8d, 4
	mov	edx, DWORD PTR opReg$[rsp]
	mov	ecx, 2
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN687@X86Assembl
$LN690@X86Assembl:

; 3680 :         EMIT_BYTE(x86EncodeSib(shift, mIndex, mBase));

	mov	r8d, DWORD PTR mBase$[rsp]
	mov	edx, DWORD PTR mIndex$[rsp]
	mov	ecx, DWORD PTR shift$24[rsp]
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN690@X86Assembl
$LN693@X86Assembl:

; 3681 :         EMIT_DWORD(static_cast<int32_t>(dispOffset));

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	edx, DWORD PTR dispOffset$[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN693@X86Assembl
$LN1748@X86Assembl:
$LN1746@X86Assembl:
$LN1734@X86Assembl:

; 3682 :       }
; 3683 :     }
; 3684 :   }

	jmp	$LN1732@X86Assembl
$LN1731@X86Assembl:

; 3685 :   else if (Arch == kArchX86) {

	xor	eax, eax
	test	eax, eax
	je	$LN1749@X86Assembl

; 3686 :     if (mIndex >= kInvalidReg) {

	cmp	DWORD PTR mIndex$[rsp], 255		; 000000ffH
	jb	SHORT $LN1751@X86Assembl
$LN696@X86Assembl:

; 3687 :       // [Disp32].
; 3688 :       EMIT_BYTE(x86EncodeMod(0, opReg, 5));

	mov	r8d, 5
	mov	edx, DWORD PTR opReg$[rsp]
	xor	ecx, ecx
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN696@X86Assembl

; 3689 :     }

	jmp	$LN1752@X86Assembl
$LN1751@X86Assembl:

; 3690 :     else {
; 3691 :       // [Index * Scale + Disp32].
; 3692 :       uint32_t shift = rmMem->getShift();

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getShift@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getShift
	mov	DWORD PTR shift$48[rsp], eax
$LN699@X86Assembl:

; 3693 :       ASMJIT_ASSERT(mIndex != kX86RegIndexSp);
; 3694 : 
; 3695 :       EMIT_BYTE(x86EncodeMod(0, opReg, 4));

	mov	r8d, 4
	mov	edx, DWORD PTR opReg$[rsp]
	xor	ecx, ecx
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN699@X86Assembl
$LN702@X86Assembl:

; 3696 :       EMIT_BYTE(x86EncodeSib(shift, mIndex, 5));

	mov	r8d, 5
	mov	edx, DWORD PTR mIndex$[rsp]
	mov	ecx, DWORD PTR shift$48[rsp]
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN702@X86Assembl
$LN1752@X86Assembl:

; 3697 :     }
; 3698 : 
; 3699 :     if (rmMem->getMemType() == kMemTypeLabel) {

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getMemType@BaseMem@asmjit@@QEBAIXZ	; asmjit::BaseMem::getMemType
	cmp	eax, 2
	jne	$LN1753@X86Assembl

; 3700 :       // Relative->Absolute [x86 mode].
; 3701 :       label = self->getLabelData(rmMem->_vmem.base);

	mov	rax, QWORD PTR $S1$[rsp]
	mov	edx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR self$[rsp]
	call	?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ; asmjit::Assembler::getLabelData
	mov	QWORD PTR label$[rsp], rax

; 3702 :       relocId = self->_relocList.getLength();

	mov	rax, QWORD PTR self$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	?getLength@?$PodVector@URelocData@asmjit@@@asmjit@@QEBA_KXZ ; asmjit::PodVector<asmjit::RelocData>::getLength
	mov	QWORD PTR relocId$[rsp], rax

; 3703 : 
; 3704 :       {
; 3705 :         RelocData rd;
; 3706 :         rd.type = kRelocRelToAbs;

	mov	DWORD PTR rd$70[rsp], 1

; 3707 :         rd.size = 4;

	mov	DWORD PTR rd$70[rsp+4], 4

; 3708 :         rd.from = static_cast<Ptr>((uintptr_t)(cursor - self->_buffer));

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR cursor$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR rd$70[rsp+8], rax

; 3709 :         rd.data = static_cast<SignedPtr>(dispOffset);

	movsxd	rax, DWORD PTR dispOffset$[rsp]
	mov	QWORD PTR rd$70[rsp+16], rax

; 3710 : 
; 3711 :         if (self->_relocList.append(rd) != kErrorOk)

	mov	rax, QWORD PTR self$[rsp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR tv4703[rsp], rax
	lea	rdx, QWORD PTR rd$70[rsp]
	mov	rcx, QWORD PTR tv4703[rsp]
	call	?append@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAIAEBURelocData@2@@Z ; asmjit::PodVector<asmjit::RelocData>::append
	test	eax, eax
	je	SHORT $LN1755@X86Assembl

; 3712 :           return self->setError(kErrorNoHeapMemory);

	xor	r8d, r8d
	mov	edx, 1
	mov	rcx, QWORD PTR self$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	$LN1@X86Assembl
$LN1755@X86Assembl:

; 3713 :       }
; 3714 : 
; 3715 :       if (label->offset != -1) {

	mov	rax, QWORD PTR label$[rsp]
	cmp	QWORD PTR [rax], -1
	je	$LN1756@X86Assembl

; 3716 :         // Bound label.
; 3717 :         self->_relocList[relocId].data += static_cast<SignedPtr>(label->offset);

	mov	rax, QWORD PTR label$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv4731[rsp], rax
	mov	rax, QWORD PTR self$[rsp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR tv4724[rsp], rax
	mov	rdx, QWORD PTR relocId$[rsp]
	mov	rcx, QWORD PTR tv4724[rsp]
	call	??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z ; asmjit::PodVector<asmjit::RelocData>::operator[]
	add	rax, 16
	mov	QWORD PTR tv4727[rsp], rax
	mov	rax, QWORD PTR tv4727[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv4729[rsp], rax
	mov	rax, QWORD PTR tv4731[rsp]
	mov	rcx, QWORD PTR tv4729[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR tv4727[rsp]
	mov	QWORD PTR [rcx], rax
$LN705@X86Assembl:

; 3718 :         EMIT_DWORD(0);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	DWORD PTR [rcx+rax], 0
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN705@X86Assembl

; 3719 :       }

	jmp	SHORT $LN1757@X86Assembl
$LN1756@X86Assembl:

; 3720 :       else {
; 3721 :         // Non-bound label.
; 3722 :         dispOffset = -4 - imLen;

	mov	eax, -4					; fffffffcH
	sub	eax, DWORD PTR imLen$[rsp]
	mov	DWORD PTR dispOffset$[rsp], eax

; 3723 :         dispSize = 4;

	mov	DWORD PTR dispSize$[rsp], 4

; 3724 :         goto _EmitDisplacement;

	jmp	$LN1758@X86Assembl
	jmp	$_EmitDisplacement$1957
$LN1757@X86Assembl:

; 3725 :       }
; 3726 :     }

	jmp	SHORT $LN1754@X86Assembl
$LN1753@X86Assembl:
$LN708@X86Assembl:

; 3727 :     else {
; 3728 :       // [Disp32].
; 3729 :       EMIT_DWORD(static_cast<int32_t>(dispOffset));

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	edx, DWORD PTR dispOffset$[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN708@X86Assembl
$LN1754@X86Assembl:

; 3730 :     }
; 3731 :   }

	jmp	$LN1750@X86Assembl
$LN1749@X86Assembl:

; 3732 :   else /* if (Arch === kArchX64) */ {
; 3733 :     if (rmMem->getMemType() == kMemTypeLabel) {

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getMemType@BaseMem@asmjit@@QEBAIXZ	; asmjit::BaseMem::getMemType
	cmp	eax, 2
	jne	$LN1759@X86Assembl

; 3734 :       // [RIP + Disp32].
; 3735 :       label = self->getLabelData(rmMem->_vmem.base);

	mov	rax, QWORD PTR $S1$[rsp]
	mov	edx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR self$[rsp]
	call	?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ; asmjit::Assembler::getLabelData
	mov	QWORD PTR label$[rsp], rax

; 3736 : 
; 3737 :       // Indexing is invalid.
; 3738 :       if (mIndex < kInvalidReg)

	cmp	DWORD PTR mIndex$[rsp], 255		; 000000ffH
	jae	SHORT $LN1761@X86Assembl

; 3739 :         goto _IllegalDisp;

	jmp	$_IllegalDisp$1972
$LN1761@X86Assembl:
$LN711@X86Assembl:

; 3740 : 
; 3741 :       EMIT_BYTE(x86EncodeMod(0, opReg, 5));

	mov	r8d, 5
	mov	edx, DWORD PTR opReg$[rsp]
	xor	ecx, ecx
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN711@X86Assembl

; 3742 :       dispOffset -= (4 + imLen);

	mov	eax, DWORD PTR imLen$[rsp]
	add	eax, 4
	mov	ecx, DWORD PTR dispOffset$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR dispOffset$[rsp], eax

; 3743 : 
; 3744 :       if (label->offset != -1) {

	mov	rax, QWORD PTR label$[rsp]
	cmp	QWORD PTR [rax], -1
	je	SHORT $LN1762@X86Assembl

; 3745 :         // Bound label.
; 3746 :         dispOffset += label->offset - static_cast<int32_t>((intptr_t)(cursor - self->_buffer));

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR cursor$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdqe
	mov	rcx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rcx]
	sub	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR dispOffset$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR dispOffset$[rsp], eax
$LN714@X86Assembl:

; 3747 :         EMIT_DWORD(static_cast<int32_t>(dispOffset));

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	edx, DWORD PTR dispOffset$[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN714@X86Assembl

; 3748 :       }

	jmp	SHORT $LN1763@X86Assembl
$LN1762@X86Assembl:

; 3749 :       else {
; 3750 :         // Non-bound label.
; 3751 :         dispSize = 4;

	mov	DWORD PTR dispSize$[rsp], 4

; 3752 :         relocId = -1;

	mov	QWORD PTR relocId$[rsp], -1

; 3753 :         goto _EmitDisplacement;

	jmp	$LN1764@X86Assembl
	jmp	$_EmitDisplacement$1957
$LN1763@X86Assembl:

; 3754 :       }
; 3755 :     }

	jmp	$LN1760@X86Assembl
$LN1759@X86Assembl:
$LN717@X86Assembl:

; 3756 :     else {
; 3757 :       EMIT_BYTE(x86EncodeMod(0, opReg, 4));

	mov	r8d, 4
	mov	edx, DWORD PTR opReg$[rsp]
	xor	ecx, ecx
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN717@X86Assembl

; 3758 :       if (mIndex >= kInvalidReg) {

	cmp	DWORD PTR mIndex$[rsp], 255		; 000000ffH
	jb	SHORT $LN1765@X86Assembl
$LN720@X86Assembl:

; 3759 :         // [Disp32].
; 3760 :         EMIT_BYTE(x86EncodeSib(0, 4, 5));

	mov	r8d, 5
	mov	edx, 4
	xor	ecx, ecx
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN720@X86Assembl

; 3761 :       }

	jmp	SHORT $LN1766@X86Assembl
$LN1765@X86Assembl:

; 3762 :       else {
; 3763 :         // [Disp32 + Index * Scale].
; 3764 :         mIndex &= 0x7;

	mov	eax, DWORD PTR mIndex$[rsp]
	and	eax, 7
	mov	DWORD PTR mIndex$[rsp], eax

; 3765 :         ASMJIT_ASSERT(mIndex != kX86RegIndexSp);
; 3766 : 
; 3767 :         uint32_t shift = rmMem->getShift();

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getShift@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getShift
	mov	DWORD PTR shift$49[rsp], eax
$LN723@X86Assembl:

; 3768 :         EMIT_BYTE(x86EncodeSib(shift, mIndex, 5));

	mov	r8d, 5
	mov	edx, DWORD PTR mIndex$[rsp]
	mov	ecx, DWORD PTR shift$49[rsp]
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN723@X86Assembl
$LN1766@X86Assembl:
$LN726@X86Assembl:

; 3769 :       }
; 3770 : 
; 3771 :       EMIT_DWORD(static_cast<int32_t>(dispOffset));

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	edx, DWORD PTR dispOffset$[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN726@X86Assembl
$LN1760@X86Assembl:
$LN1750@X86Assembl:
$LN1732@X86Assembl:

; 3772 :     }
; 3773 :   }
; 3774 : 
; 3775 :   if (imLen == 0)

	cmp	DWORD PTR imLen$[rsp], 0
	jne	SHORT $LN1767@X86Assembl

; 3776 :     goto _EmitDone;

	jmp	$LN1768@X86Assembl
	jmp	$_EmitDone$1951
$LN1767@X86Assembl:
$LN1240@X86Assembl:
$LN1259@X86Assembl:
$LN1700@X86Assembl:
$LN1709@X86Assembl:
$LN1718@X86Assembl:
$_EmitImm$1959:

; 3777 : 
; 3778 :   // --------------------------------------------------------------------------
; 3779 :   // [Emit - Imm]
; 3780 :   // --------------------------------------------------------------------------
; 3781 : 
; 3782 : _EmitImm:
; 3783 :   switch (imLen) {

	mov	eax, DWORD PTR imLen$[rsp]
	mov	DWORD PTR tv4829[rsp], eax
	cmp	DWORD PTR tv4829[rsp], 1
	je	SHORT $LN1769@X86Assembl
	cmp	DWORD PTR tv4829[rsp], 2
	je	SHORT $LN1770@X86Assembl
	cmp	DWORD PTR tv4829[rsp], 4
	je	SHORT $LN1771@X86Assembl
	cmp	DWORD PTR tv4829[rsp], 8
	je	$LN1772@X86Assembl
	jmp	$LN1773@X86Assembl
$LN1769@X86Assembl:
$LN731@X86Assembl:

; 3784 :     case 1: EMIT_BYTE (imVal & 0x000000FF); break;

	mov	rax, QWORD PTR imVal$[rsp]
	and	rax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN731@X86Assembl
	jmp	$LN727@X86Assembl
$LN1770@X86Assembl:
$LN734@X86Assembl:

; 3785 :     case 2: EMIT_WORD (imVal & 0x0000FFFF); break;

	mov	rax, QWORD PTR imVal$[rsp]
	and	rax, 65535				; 0000ffffH
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	WORD PTR [rdx+rcx], ax
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 2
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN734@X86Assembl
	jmp	SHORT $LN727@X86Assembl
$LN1771@X86Assembl:
$LN737@X86Assembl:

; 3786 :     case 4: EMIT_DWORD(imVal & 0xFFFFFFFF); break;

	mov	eax, -1
	mov	rcx, QWORD PTR imVal$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	DWORD PTR [rdx+rcx], eax
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN737@X86Assembl
	jmp	SHORT $LN727@X86Assembl
$LN1772@X86Assembl:
$LN740@X86Assembl:

; 3787 :     case 8: EMIT_QWORD(imVal             ); break;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	rdx, QWORD PTR imVal$[rsp]
	mov	QWORD PTR [rcx+rax], rdx
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 8
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN740@X86Assembl
$LN1773@X86Assembl:
$LN727@X86Assembl:

; 3788 : 
; 3789 :     default:
; 3790 :       ASMJIT_ASSERT(!"Reached");
; 3791 :   }
; 3792 :   goto _EmitDone;

	jmp	$LN1774@X86Assembl
	jmp	$_EmitDone$1951
$LN1324@X86Assembl:
$LN1329@X86Assembl:
$LN1330@X86Assembl:
$LN1347@X86Assembl:
$LN1349@X86Assembl:
$LN1351@X86Assembl:
$LN1362@X86Assembl:
$LN1365@X86Assembl:
$_EmitFpuOp$1960:
$LN743@X86Assembl:

; 3793 : 
; 3794 :   // --------------------------------------------------------------------------
; 3795 :   // [Emit - Fpu]
; 3796 :   // --------------------------------------------------------------------------
; 3797 : 
; 3798 : _EmitFpuOp:
; 3799 :   // Mandatory instruction prefix.
; 3800 :   EMIT_PP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 20
	and	eax, 7
	mov	DWORD PTR ppIndex$37[rsp], eax
	mov	eax, DWORD PTR ppIndex$37[rsp]
	lea	rcx, OFFSET FLAT:?x86OpCodePP@asmjit@@3QBEB
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR ppCode$15[rsp], al
	cmp	DWORD PTR ppIndex$37[rsp], 0
	jne	SHORT $LN1775@X86Assembl
	jmp	SHORT $LN742@X86Assembl
$LN1775@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR ppCode$15[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN743@X86Assembl
$LN742@X86Assembl:
$LN746@X86Assembl:
$LN749@X86Assembl:

; 3801 : 
; 3802 :   // Instruction opcodes.
; 3803 :   EMIT_OP(opCode >> 8);

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN749@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN746@X86Assembl
$LN752@X86Assembl:
$LN755@X86Assembl:

; 3804 :   EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN755@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN752@X86Assembl

; 3805 :   goto _EmitDone;

	jmp	$LN1776@X86Assembl
	jmp	$_EmitDone$1951
$LN1492@X86Assembl:
$_EmitAvxOp$1964:

; 3806 : 
; 3807 :   // --------------------------------------------------------------------------
; 3808 :   // [Emit - Avx]
; 3809 :   // --------------------------------------------------------------------------
; 3810 : 
; 3811 : #define EMIT_AVX_M \
; 3812 :   ASMJIT_ASSERT(rmMem != NULL); \
; 3813 :   ASMJIT_ASSERT(rmMem->getOp() == kOperandTypeMem); \
; 3814 :   \
; 3815 :   if (rmMem->hasSegment()) { \
; 3816 :     EMIT_BYTE(x86SegmentPrefix[rmMem->getSegment()]); \
; 3817 :   } \
; 3818 :   \
; 3819 :   mBase = rmMem->getBase(); \
; 3820 :   mIndex = rmMem->getIndex(); \
; 3821 :   \
; 3822 :   { \
; 3823 :     uint32_t vex_XvvvvLpp; \
; 3824 :     uint32_t vex_rxbmmmmm; \
; 3825 :     \
; 3826 :     vex_XvvvvLpp  = (opCode >> (kX86InstOpCode_W_Shift - 7)) & 0x80; \
; 3827 :     vex_XvvvvLpp += (opCode >> (kX86InstOpCode_L_Shift - 2)) & 0x04; \
; 3828 :     vex_XvvvvLpp += (opCode >> (kX86InstOpCode_PP_Shift   )) & 0x03; \
; 3829 :     vex_XvvvvLpp += (opReg  >> (kVexVVVVShift          - 3)); \
; 3830 :     \
; 3831 :     vex_rxbmmmmm  = (opCode >> kX86InstOpCode_MM_Shift) & 0x0F; \
; 3832 :     vex_rxbmmmmm |= static_cast<uint32_t>(mBase  - 8 < 8) << 5; \
; 3833 :     vex_rxbmmmmm |= static_cast<uint32_t>(mIndex - 8 < 8) << 6; \
; 3834 :     \
; 3835 :     if (vex_rxbmmmmm != 0x01 || vex_XvvvvLpp >= 0x80 || (options & kX86InstOptionVex3) != 0) { \
; 3836 :       vex_rxbmmmmm |= static_cast<uint32_t>(opReg << 4) & 0x80; \
; 3837 :       vex_rxbmmmmm ^= 0xE0; \
; 3838 :       vex_XvvvvLpp ^= 0x78; \
; 3839 :       \
; 3840 :       EMIT_BYTE(kX86ByteVex3); \
; 3841 :       EMIT_BYTE(vex_rxbmmmmm); \
; 3842 :       EMIT_BYTE(vex_XvvvvLpp); \
; 3843 :       EMIT_OP(opCode); \
; 3844 :     } \
; 3845 :     else { \
; 3846 :       vex_XvvvvLpp |= static_cast<uint32_t>(opReg << 4) & 0x80; \
; 3847 :       vex_XvvvvLpp ^= 0xF8; \
; 3848 :       \
; 3849 :       EMIT_BYTE(kX86ByteVex2); \
; 3850 :       EMIT_BYTE(vex_XvvvvLpp); \
; 3851 :       EMIT_OP(opCode); \
; 3852 :     } \
; 3853 :   } \
; 3854 :   \
; 3855 :   mBase &= 0x7; \
; 3856 :   opReg &= 0x7;
; 3857 : 
; 3858 : _EmitAvxOp:
; 3859 :   {
; 3860 :     uint32_t vex_XvvvvLpp;
; 3861 : 
; 3862 :     vex_XvvvvLpp  = (opCode >> (kX86InstOpCode_L_Shift - 2)) & 0x04;

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 21
	and	eax, 4
	mov	DWORD PTR vex_XvvvvLpp$20[rsp], eax

; 3863 :     vex_XvvvvLpp |= (opCode >> (kX86InstOpCode_PP_Shift));

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 20
	mov	ecx, DWORD PTR vex_XvvvvLpp$20[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$20[rsp], eax

; 3864 :     vex_XvvvvLpp |= 0xF8;

	mov	eax, DWORD PTR vex_XvvvvLpp$20[rsp]
	or	eax, 248				; 000000f8H
	mov	DWORD PTR vex_XvvvvLpp$20[rsp], eax

; 3865 : 
; 3866 :     // Encode 3-byte VEX prefix only if specified in options.
; 3867 :     if ((options & kX86InstOptionVex3) != 0) {

	mov	eax, DWORD PTR options$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	$LN1777@X86Assembl

; 3868 :       uint32_t vex_rxbmmmmm = (opCode >> kX86InstOpCode_MM_Shift) | 0xE0;

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 16
	or	eax, 224				; 000000e0H
	mov	DWORD PTR vex_rxbmmmmm$50[rsp], eax
$LN758@X86Assembl:

; 3869 : 
; 3870 :       EMIT_BYTE(kX86ByteVex3);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 196			; 000000c4H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN758@X86Assembl
$LN761@X86Assembl:
$LN764@X86Assembl:

; 3871 :       EMIT_OP(vex_rxbmmmmm);

	mov	eax, DWORD PTR vex_rxbmmmmm$50[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN764@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN761@X86Assembl
$LN767@X86Assembl:
$LN770@X86Assembl:

; 3872 :       EMIT_OP(vex_XvvvvLpp);

	mov	eax, DWORD PTR vex_XvvvvLpp$20[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN770@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN767@X86Assembl
$LN773@X86Assembl:
$LN776@X86Assembl:

; 3873 :       EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN776@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN773@X86Assembl

; 3874 :     }

	jmp	$LN1778@X86Assembl
$LN1777@X86Assembl:
$LN779@X86Assembl:

; 3875 :     else {
; 3876 :       EMIT_BYTE(kX86ByteVex2);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 197			; 000000c5H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN779@X86Assembl
$LN782@X86Assembl:
$LN785@X86Assembl:

; 3877 :       EMIT_OP(vex_XvvvvLpp);

	mov	eax, DWORD PTR vex_XvvvvLpp$20[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN785@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN782@X86Assembl
$LN788@X86Assembl:
$LN791@X86Assembl:

; 3878 :       EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN791@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN788@X86Assembl
$LN1778@X86Assembl:

; 3879 :     }
; 3880 :   }
; 3881 :   goto _EmitDone;

	jmp	$LN1779@X86Assembl
	jmp	$_EmitDone$1951

; 3882 : 
; 3883 : _EmitAvxR:

	jmp	SHORT $_EmitAvxR$1966
$LN1499@X86Assembl:
	jmp	SHORT $_EmitAvxR$1966
$LN1505@X86Assembl:
	jmp	SHORT $_EmitAvxR$1966
$LN1511@X86Assembl:
	jmp	SHORT $_EmitAvxR$1966
$LN1517@X86Assembl:
	jmp	SHORT $_EmitAvxR$1966
$LN1523@X86Assembl:
$LN1531@X86Assembl:
$LN1539@X86Assembl:
$LN1544@X86Assembl:
$LN1551@X86Assembl:
$LN1557@X86Assembl:
$LN1565@X86Assembl:
$LN1569@X86Assembl:
$LN1574@X86Assembl:
$LN1578@X86Assembl:
$LN1584@X86Assembl:
$LN1592@X86Assembl:
$LN1596@X86Assembl:
$LN1601@X86Assembl:
$LN1607@X86Assembl:
$LN1613@X86Assembl:
$LN1637@X86Assembl:
$_EmitAvxR$1966:

; 3884 :   {
; 3885 :     uint32_t vex_XvvvvLpp;
; 3886 :     uint32_t vex_rxbmmmmm;
; 3887 : 
; 3888 :     vex_XvvvvLpp  = (opCode >> (kX86InstOpCode_W_Shift - 7)) & 0x80;

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 24
	and	eax, 128				; 00000080H
	mov	DWORD PTR vex_XvvvvLpp$2[rsp], eax

; 3889 :     vex_XvvvvLpp += (opCode >> (kX86InstOpCode_L_Shift - 2)) & 0x04;

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 21
	and	eax, 4
	mov	ecx, DWORD PTR vex_XvvvvLpp$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$2[rsp], eax

; 3890 :     vex_XvvvvLpp += (opCode >> (kX86InstOpCode_PP_Shift   )) & 0x03;

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 20
	and	eax, 3
	mov	ecx, DWORD PTR vex_XvvvvLpp$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$2[rsp], eax

; 3891 :     vex_XvvvvLpp += (opReg  >> (kVexVVVVShift          - 3));

	mov	eax, DWORD PTR opReg$[rsp]
	shr	eax, 9
	mov	ecx, DWORD PTR vex_XvvvvLpp$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$2[rsp], eax

; 3892 : 
; 3893 :     vex_rxbmmmmm  = (opCode >> kX86InstOpCode_MM_Shift) & 0x0F;

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 16
	and	eax, 15
	mov	DWORD PTR vex_rxbmmmmm$12[rsp], eax

; 3894 :     vex_rxbmmmmm |= (rmReg << 2) & 0x20;

	mov	rax, QWORD PTR $S1$[rsp]
	shl	rax, 2
	and	rax, 32					; 00000020H
	mov	ecx, DWORD PTR vex_rxbmmmmm$12[rsp]
	or	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR vex_rxbmmmmm$12[rsp], eax

; 3895 : 
; 3896 :     if (vex_rxbmmmmm != 0x01 || vex_XvvvvLpp >= 0x80 || (options & kX86InstOptionVex3) != 0) {

	cmp	DWORD PTR vex_rxbmmmmm$12[rsp], 1
	jne	SHORT $LN1782@X86Assembl
	cmp	DWORD PTR vex_XvvvvLpp$2[rsp], 128	; 00000080H
	jae	SHORT $LN1782@X86Assembl
	mov	eax, DWORD PTR options$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	$LN1780@X86Assembl
$LN1782@X86Assembl:

; 3897 :       vex_rxbmmmmm |= static_cast<uint32_t>(opReg & 0x08) << 4;

	mov	eax, DWORD PTR opReg$[rsp]
	and	eax, 8
	shl	eax, 4
	mov	ecx, DWORD PTR vex_rxbmmmmm$12[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_rxbmmmmm$12[rsp], eax

; 3898 :       vex_rxbmmmmm ^= 0xE0;

	mov	eax, DWORD PTR vex_rxbmmmmm$12[rsp]
	xor	eax, 224				; 000000e0H
	mov	DWORD PTR vex_rxbmmmmm$12[rsp], eax

; 3899 :       vex_XvvvvLpp ^= 0x78;

	mov	eax, DWORD PTR vex_XvvvvLpp$2[rsp]
	xor	eax, 120				; 00000078H
	mov	DWORD PTR vex_XvvvvLpp$2[rsp], eax
$LN794@X86Assembl:

; 3900 : 
; 3901 :       EMIT_BYTE(kX86ByteVex3);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 196			; 000000c4H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN794@X86Assembl
$LN797@X86Assembl:
$LN800@X86Assembl:

; 3902 :       EMIT_OP(vex_rxbmmmmm);

	mov	eax, DWORD PTR vex_rxbmmmmm$12[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN800@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN797@X86Assembl
$LN803@X86Assembl:
$LN806@X86Assembl:

; 3903 :       EMIT_OP(vex_XvvvvLpp);

	mov	eax, DWORD PTR vex_XvvvvLpp$2[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN806@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN803@X86Assembl
$LN809@X86Assembl:
$LN812@X86Assembl:

; 3904 :       EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN812@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN809@X86Assembl

; 3905 : 
; 3906 :       rmReg &= 0x07;

	mov	rax, QWORD PTR $S1$[rsp]
	and	rax, 7
	mov	QWORD PTR $S1$[rsp], rax

; 3907 :     }

	jmp	$LN1781@X86Assembl
$LN1780@X86Assembl:

; 3908 :     else {
; 3909 :       vex_XvvvvLpp += static_cast<uint32_t>(opReg & 0x08) << 4;

	mov	eax, DWORD PTR opReg$[rsp]
	and	eax, 8
	shl	eax, 4
	mov	ecx, DWORD PTR vex_XvvvvLpp$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$2[rsp], eax

; 3910 :       vex_XvvvvLpp ^= 0xF8;

	mov	eax, DWORD PTR vex_XvvvvLpp$2[rsp]
	xor	eax, 248				; 000000f8H
	mov	DWORD PTR vex_XvvvvLpp$2[rsp], eax
$LN815@X86Assembl:

; 3911 : 
; 3912 :       EMIT_BYTE(kX86ByteVex2);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 197			; 000000c5H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN815@X86Assembl
$LN818@X86Assembl:
$LN821@X86Assembl:

; 3913 :       EMIT_OP(vex_XvvvvLpp);

	mov	eax, DWORD PTR vex_XvvvvLpp$2[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN821@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN818@X86Assembl
$LN824@X86Assembl:
$LN827@X86Assembl:

; 3914 :       EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN827@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN824@X86Assembl
$LN1781@X86Assembl:
$LN830@X86Assembl:

; 3915 :     }
; 3916 :   }
; 3917 : 
; 3918 :   EMIT_BYTE(x86EncodeMod(3, opReg, static_cast<uint32_t>(rmReg)));

	mov	r8d, DWORD PTR $S1$[rsp]
	mov	edx, DWORD PTR opReg$[rsp]
	mov	ecx, 3
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN830@X86Assembl

; 3919 : 
; 3920 :   if (imLen == 0)

	cmp	DWORD PTR imLen$[rsp], 0
	jne	SHORT $LN1783@X86Assembl

; 3921 :     goto _EmitDone;

	jmp	$LN1784@X86Assembl
	jmp	$_EmitDone$1951
$LN1783@X86Assembl:
$LN833@X86Assembl:

; 3922 : 
; 3923 :   EMIT_BYTE(imVal & 0xFF);

	mov	rax, QWORD PTR imVal$[rsp]
	and	rax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN833@X86Assembl

; 3924 :   goto _EmitDone;

	jmp	$LN1785@X86Assembl
	jmp	$_EmitDone$1951

; 3925 : 
; 3926 : _EmitAvxM:

	jmp	SHORT $_EmitAvxM$1965
$LN1495@X86Assembl:
	jmp	SHORT $_EmitAvxM$1965
$LN1501@X86Assembl:
	jmp	SHORT $_EmitAvxM$1965
$LN1507@X86Assembl:
	jmp	SHORT $_EmitAvxM$1965
$LN1513@X86Assembl:
	jmp	SHORT $_EmitAvxM$1965
$LN1519@X86Assembl:
	jmp	SHORT $_EmitAvxM$1965
$LN1525@X86Assembl:
	jmp	SHORT $_EmitAvxM$1965
$LN1533@X86Assembl:
	jmp	SHORT $_EmitAvxM$1965
$LN1541@X86Assembl:
	jmp	SHORT $_EmitAvxM$1965
$LN1546@X86Assembl:
	jmp	SHORT $_EmitAvxM$1965
$LN1553@X86Assembl:
	jmp	SHORT $_EmitAvxM$1965
$LN1559@X86Assembl:
	jmp	SHORT $_EmitAvxM$1965
$LN1561@X86Assembl:
$LN1567@X86Assembl:
$LN1571@X86Assembl:
$LN1576@X86Assembl:
$LN1580@X86Assembl:
$LN1586@X86Assembl:
$LN1588@X86Assembl:
$LN1594@X86Assembl:
$LN1598@X86Assembl:
$LN1603@X86Assembl:
$LN1609@X86Assembl:
$LN1615@X86Assembl:
$LN1617@X86Assembl:
$LN1621@X86Assembl:
$LN1623@X86Assembl:
$LN1639@X86Assembl:
$LN1641@X86Assembl:
$_EmitAvxM$1965:

; 3927 :   EMIT_AVX_M

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?hasSegment@X86Mem@asmjit@@QEBA_NXZ	; asmjit::X86Mem::hasSegment
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1786@X86Assembl
$LN836@X86Assembl:
	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getSegment@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getSegment
	mov	eax, eax
	lea	rcx, OFFSET FLAT:?x86SegmentPrefix@asmjit@@3QBEB
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR cursor$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN836@X86Assembl
$LN1786@X86Assembl:
	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getBase@X86Mem@asmjit@@QEBAIXZ		; asmjit::X86Mem::getBase
	mov	DWORD PTR mBase$[rsp], eax
	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getIndex@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getIndex
	mov	DWORD PTR mIndex$[rsp], eax
	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 24
	and	eax, 128				; 00000080H
	mov	DWORD PTR vex_XvvvvLpp$1[rsp], eax
	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 21
	and	eax, 4
	mov	ecx, DWORD PTR vex_XvvvvLpp$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$1[rsp], eax
	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 20
	and	eax, 3
	mov	ecx, DWORD PTR vex_XvvvvLpp$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$1[rsp], eax
	mov	eax, DWORD PTR opReg$[rsp]
	shr	eax, 9
	mov	ecx, DWORD PTR vex_XvvvvLpp$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$1[rsp], eax
	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 16
	and	eax, 15
	mov	DWORD PTR vex_rxbmmmmm$6[rsp], eax
	mov	eax, DWORD PTR mBase$[rsp]
	sub	eax, 8
	cmp	eax, 8
	jae	SHORT $LN1935@X86Assembl
	mov	DWORD PTR tv5054[rsp], 1
	jmp	SHORT $LN1936@X86Assembl
$LN1935@X86Assembl:
	mov	DWORD PTR tv5054[rsp], 0
$LN1936@X86Assembl:
	mov	eax, DWORD PTR tv5054[rsp]
	shl	eax, 5
	mov	ecx, DWORD PTR vex_rxbmmmmm$6[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_rxbmmmmm$6[rsp], eax
	mov	eax, DWORD PTR mIndex$[rsp]
	sub	eax, 8
	cmp	eax, 8
	jae	SHORT $LN1937@X86Assembl
	mov	DWORD PTR tv5059[rsp], 1
	jmp	SHORT $LN1938@X86Assembl
$LN1937@X86Assembl:
	mov	DWORD PTR tv5059[rsp], 0
$LN1938@X86Assembl:
	mov	eax, DWORD PTR tv5059[rsp]
	shl	eax, 6
	mov	ecx, DWORD PTR vex_rxbmmmmm$6[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_rxbmmmmm$6[rsp], eax
	cmp	DWORD PTR vex_rxbmmmmm$6[rsp], 1
	jne	SHORT $LN1789@X86Assembl
	cmp	DWORD PTR vex_XvvvvLpp$1[rsp], 128	; 00000080H
	jae	SHORT $LN1789@X86Assembl
	mov	eax, DWORD PTR options$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	$LN1787@X86Assembl
$LN1789@X86Assembl:
	mov	eax, DWORD PTR opReg$[rsp]
	shl	eax, 4
	and	eax, 128				; 00000080H
	mov	ecx, DWORD PTR vex_rxbmmmmm$6[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_rxbmmmmm$6[rsp], eax
	mov	eax, DWORD PTR vex_rxbmmmmm$6[rsp]
	xor	eax, 224				; 000000e0H
	mov	DWORD PTR vex_rxbmmmmm$6[rsp], eax
	mov	eax, DWORD PTR vex_XvvvvLpp$1[rsp]
	xor	eax, 120				; 00000078H
	mov	DWORD PTR vex_XvvvvLpp$1[rsp], eax
$LN839@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 196			; 000000c4H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN839@X86Assembl
$LN842@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR vex_rxbmmmmm$6[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN842@X86Assembl
$LN845@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR vex_XvvvvLpp$1[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN845@X86Assembl
$LN848@X86Assembl:
$LN851@X86Assembl:
	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN851@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN848@X86Assembl
	jmp	$LN1788@X86Assembl
$LN1787@X86Assembl:
	mov	eax, DWORD PTR opReg$[rsp]
	shl	eax, 4
	and	eax, 128				; 00000080H
	mov	ecx, DWORD PTR vex_XvvvvLpp$1[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$1[rsp], eax
	mov	eax, DWORD PTR vex_XvvvvLpp$1[rsp]
	xor	eax, 248				; 000000f8H
	mov	DWORD PTR vex_XvvvvLpp$1[rsp], eax
$LN854@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 197			; 000000c5H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN854@X86Assembl
$LN857@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR vex_XvvvvLpp$1[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN857@X86Assembl
$LN860@X86Assembl:
$LN863@X86Assembl:
	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN863@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN860@X86Assembl
$LN1788@X86Assembl:
	mov	eax, DWORD PTR mBase$[rsp]
	and	eax, 7
	mov	DWORD PTR mBase$[rsp], eax
	mov	eax, DWORD PTR opReg$[rsp]
	and	eax, 7
	mov	DWORD PTR opReg$[rsp], eax

; 3928 :   goto _EmitSib;

	jmp	$_EmitSib$1973
$LN1628@X86Assembl:
$LN1633@X86Assembl:
$_EmitAvxV$1968:

; 3929 : 
; 3930 : _EmitAvxV:
; 3931 :   EMIT_AVX_M

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?hasSegment@X86Mem@asmjit@@QEBA_NXZ	; asmjit::X86Mem::hasSegment
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1790@X86Assembl
$LN866@X86Assembl:
	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getSegment@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getSegment
	mov	eax, eax
	lea	rcx, OFFSET FLAT:?x86SegmentPrefix@asmjit@@3QBEB
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR cursor$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN866@X86Assembl
$LN1790@X86Assembl:
	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getBase@X86Mem@asmjit@@QEBAIXZ		; asmjit::X86Mem::getBase
	mov	DWORD PTR mBase$[rsp], eax
	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getIndex@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getIndex
	mov	DWORD PTR mIndex$[rsp], eax
	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 24
	and	eax, 128				; 00000080H
	mov	DWORD PTR vex_XvvvvLpp$3[rsp], eax
	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 21
	and	eax, 4
	mov	ecx, DWORD PTR vex_XvvvvLpp$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$3[rsp], eax
	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 20
	and	eax, 3
	mov	ecx, DWORD PTR vex_XvvvvLpp$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$3[rsp], eax
	mov	eax, DWORD PTR opReg$[rsp]
	shr	eax, 9
	mov	ecx, DWORD PTR vex_XvvvvLpp$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$3[rsp], eax
	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 16
	and	eax, 15
	mov	DWORD PTR vex_rxbmmmmm$7[rsp], eax
	mov	eax, DWORD PTR mBase$[rsp]
	sub	eax, 8
	cmp	eax, 8
	jae	SHORT $LN1939@X86Assembl
	mov	DWORD PTR tv5174[rsp], 1
	jmp	SHORT $LN1940@X86Assembl
$LN1939@X86Assembl:
	mov	DWORD PTR tv5174[rsp], 0
$LN1940@X86Assembl:
	mov	eax, DWORD PTR tv5174[rsp]
	shl	eax, 5
	mov	ecx, DWORD PTR vex_rxbmmmmm$7[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_rxbmmmmm$7[rsp], eax
	mov	eax, DWORD PTR mIndex$[rsp]
	sub	eax, 8
	cmp	eax, 8
	jae	SHORT $LN1941@X86Assembl
	mov	DWORD PTR tv5179[rsp], 1
	jmp	SHORT $LN1942@X86Assembl
$LN1941@X86Assembl:
	mov	DWORD PTR tv5179[rsp], 0
$LN1942@X86Assembl:
	mov	eax, DWORD PTR tv5179[rsp]
	shl	eax, 6
	mov	ecx, DWORD PTR vex_rxbmmmmm$7[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_rxbmmmmm$7[rsp], eax
	cmp	DWORD PTR vex_rxbmmmmm$7[rsp], 1
	jne	SHORT $LN1793@X86Assembl
	cmp	DWORD PTR vex_XvvvvLpp$3[rsp], 128	; 00000080H
	jae	SHORT $LN1793@X86Assembl
	mov	eax, DWORD PTR options$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	$LN1791@X86Assembl
$LN1793@X86Assembl:
	mov	eax, DWORD PTR opReg$[rsp]
	shl	eax, 4
	and	eax, 128				; 00000080H
	mov	ecx, DWORD PTR vex_rxbmmmmm$7[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_rxbmmmmm$7[rsp], eax
	mov	eax, DWORD PTR vex_rxbmmmmm$7[rsp]
	xor	eax, 224				; 000000e0H
	mov	DWORD PTR vex_rxbmmmmm$7[rsp], eax
	mov	eax, DWORD PTR vex_XvvvvLpp$3[rsp]
	xor	eax, 120				; 00000078H
	mov	DWORD PTR vex_XvvvvLpp$3[rsp], eax
$LN869@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 196			; 000000c4H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN869@X86Assembl
$LN872@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR vex_rxbmmmmm$7[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN872@X86Assembl
$LN875@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR vex_XvvvvLpp$3[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN875@X86Assembl
$LN878@X86Assembl:
$LN881@X86Assembl:
	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN881@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN878@X86Assembl
	jmp	$LN1792@X86Assembl
$LN1791@X86Assembl:
	mov	eax, DWORD PTR opReg$[rsp]
	shl	eax, 4
	and	eax, 128				; 00000080H
	mov	ecx, DWORD PTR vex_XvvvvLpp$3[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$3[rsp], eax
	mov	eax, DWORD PTR vex_XvvvvLpp$3[rsp]
	xor	eax, 248				; 000000f8H
	mov	DWORD PTR vex_XvvvvLpp$3[rsp], eax
$LN884@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 197			; 000000c5H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN884@X86Assembl
$LN887@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR vex_XvvvvLpp$3[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN887@X86Assembl
$LN890@X86Assembl:
$LN893@X86Assembl:
	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN893@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN890@X86Assembl
$LN1792@X86Assembl:
	mov	eax, DWORD PTR mBase$[rsp]
	and	eax, 7
	mov	DWORD PTR mBase$[rsp], eax
	mov	eax, DWORD PTR opReg$[rsp]
	and	eax, 7
	mov	DWORD PTR opReg$[rsp], eax

; 3932 : 
; 3933 :   if (mIndex >= kInvalidReg)

	cmp	DWORD PTR mIndex$[rsp], 255		; 000000ffH
	jb	SHORT $LN1794@X86Assembl

; 3934 :     goto _IllegalInst;

	jmp	$_IllegalInst$1950
$LN1794@X86Assembl:

; 3935 : 
; 3936 :   if (Arch == kArchX64)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1795@X86Assembl

; 3937 :     mIndex &= 0x7;

	mov	eax, DWORD PTR mIndex$[rsp]
	and	eax, 7
	mov	DWORD PTR mIndex$[rsp], eax
$LN1795@X86Assembl:

; 3938 : 
; 3939 :   dispOffset = rmMem->getDisplacement();

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getDisplacement@X86Mem@asmjit@@QEBAHXZ	; asmjit::X86Mem::getDisplacement
	mov	DWORD PTR dispOffset$[rsp], eax

; 3940 :   if (rmMem->isBaseIndexType()) {

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?isBaseIndexType@BaseMem@asmjit@@QEBA_NXZ ; asmjit::BaseMem::isBaseIndexType
	movzx	eax, al
	test	eax, eax
	je	$LN1796@X86Assembl

; 3941 :     uint32_t shift = rmMem->getShift();

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getShift@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getShift
	mov	DWORD PTR shift$25[rsp], eax

; 3942 : 
; 3943 :     if (mBase != kX86RegIndexBp && dispOffset == 0) {

	cmp	DWORD PTR mBase$[rsp], 5
	je	SHORT $LN1798@X86Assembl
	cmp	DWORD PTR dispOffset$[rsp], 0
	jne	SHORT $LN1798@X86Assembl
$LN896@X86Assembl:

; 3944 :       // [Base + Index * Scale].
; 3945 :       EMIT_BYTE(x86EncodeMod(0, opReg, 4));

	mov	r8d, 4
	mov	edx, DWORD PTR opReg$[rsp]
	xor	ecx, ecx
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN896@X86Assembl
$LN899@X86Assembl:

; 3946 :       EMIT_BYTE(x86EncodeSib(shift, mIndex, mBase));

	mov	r8d, DWORD PTR mBase$[rsp]
	mov	edx, DWORD PTR mIndex$[rsp]
	mov	ecx, DWORD PTR shift$25[rsp]
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN899@X86Assembl

; 3947 :     }

	jmp	$LN1799@X86Assembl
$LN1798@X86Assembl:

; 3948 :     else if (IntUtil::isInt8(dispOffset)) {

	mov	ecx, DWORD PTR dispOffset$[rsp]
	call	??$isInt8@H@IntUtil@asmjit@@SA_NH@Z	; asmjit::IntUtil::isInt8<int>
	movzx	eax, al
	test	eax, eax
	je	$LN1800@X86Assembl
$LN902@X86Assembl:

; 3949 :       // [Base + Index * Scale + Disp8].
; 3950 :       EMIT_BYTE(x86EncodeMod(1, opReg, 4));

	mov	r8d, 4
	mov	edx, DWORD PTR opReg$[rsp]
	mov	ecx, 1
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN902@X86Assembl
$LN905@X86Assembl:

; 3951 :       EMIT_BYTE(x86EncodeSib(shift, mIndex, mBase));

	mov	r8d, DWORD PTR mBase$[rsp]
	mov	edx, DWORD PTR mIndex$[rsp]
	mov	ecx, DWORD PTR shift$25[rsp]
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN905@X86Assembl
$LN908@X86Assembl:

; 3952 :       EMIT_BYTE(static_cast<int8_t>(dispOffset));

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR dispOffset$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN908@X86Assembl

; 3953 :     }

	jmp	$LN1801@X86Assembl
$LN1800@X86Assembl:
$LN911@X86Assembl:

; 3954 :     else {
; 3955 :       // [Base + Index * Scale + Disp32].
; 3956 :       EMIT_BYTE(x86EncodeMod(2, opReg, 4));

	mov	r8d, 4
	mov	edx, DWORD PTR opReg$[rsp]
	mov	ecx, 2
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN911@X86Assembl
$LN914@X86Assembl:

; 3957 :       EMIT_BYTE(x86EncodeSib(shift, mIndex, mBase));

	mov	r8d, DWORD PTR mBase$[rsp]
	mov	edx, DWORD PTR mIndex$[rsp]
	mov	ecx, DWORD PTR shift$25[rsp]
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN914@X86Assembl
$LN917@X86Assembl:

; 3958 :       EMIT_DWORD(static_cast<int32_t>(dispOffset));

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	edx, DWORD PTR dispOffset$[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN917@X86Assembl
$LN1801@X86Assembl:
$LN1799@X86Assembl:

; 3959 :     }
; 3960 :   }

	jmp	$LN1797@X86Assembl
$LN1796@X86Assembl:

; 3961 :   else {
; 3962 :     // [Index * Scale + Disp32].
; 3963 :     uint32_t shift = rmMem->getShift();

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getShift@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getShift
	mov	DWORD PTR shift$51[rsp], eax
$LN920@X86Assembl:

; 3964 : 
; 3965 :     EMIT_BYTE(x86EncodeMod(0, opReg, 4));

	mov	r8d, 4
	mov	edx, DWORD PTR opReg$[rsp]
	xor	ecx, ecx
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN920@X86Assembl
$LN923@X86Assembl:

; 3966 :     EMIT_BYTE(x86EncodeSib(shift, mIndex, 5));

	mov	r8d, 5
	mov	edx, DWORD PTR mIndex$[rsp]
	mov	ecx, DWORD PTR shift$51[rsp]
	call	?x86EncodeSib@asmjit@@YAIIII@Z		; asmjit::x86EncodeSib
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN923@X86Assembl

; 3967 : 
; 3968 :     if (rmMem->getMemType() == kMemTypeLabel) {

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getMemType@BaseMem@asmjit@@QEBAIXZ	; asmjit::BaseMem::getMemType
	cmp	eax, 2
	jne	$LN1802@X86Assembl

; 3969 :       if (Arch == kArchX64)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1804@X86Assembl

; 3970 :         goto _IllegalAddr;

	jmp	$_IllegalAddr$1971
$LN1804@X86Assembl:

; 3971 : 
; 3972 :       // Relative->Absolute [x86 mode].
; 3973 :       label = self->getLabelData(rmMem->_vmem.base);

	mov	rax, QWORD PTR $S1$[rsp]
	mov	edx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR self$[rsp]
	call	?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ; asmjit::Assembler::getLabelData
	mov	QWORD PTR label$[rsp], rax

; 3974 :       relocId = self->_relocList.getLength();

	mov	rax, QWORD PTR self$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	?getLength@?$PodVector@URelocData@asmjit@@@asmjit@@QEBA_KXZ ; asmjit::PodVector<asmjit::RelocData>::getLength
	mov	QWORD PTR relocId$[rsp], rax

; 3975 : 
; 3976 :       {
; 3977 :         RelocData rd;
; 3978 :         rd.type = kRelocRelToAbs;

	mov	DWORD PTR rd$71[rsp], 1

; 3979 :         rd.size = 4;

	mov	DWORD PTR rd$71[rsp+4], 4

; 3980 :         rd.from = static_cast<Ptr>((uintptr_t)(cursor - self->_buffer));

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR cursor$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR rd$71[rsp+8], rax

; 3981 :         rd.data = static_cast<SignedPtr>(dispOffset);

	movsxd	rax, DWORD PTR dispOffset$[rsp]
	mov	QWORD PTR rd$71[rsp+16], rax

; 3982 : 
; 3983 :         if (self->_relocList.append(rd) != kErrorOk)

	mov	rax, QWORD PTR self$[rsp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR tv5378[rsp], rax
	lea	rdx, QWORD PTR rd$71[rsp]
	mov	rcx, QWORD PTR tv5378[rsp]
	call	?append@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAIAEBURelocData@2@@Z ; asmjit::PodVector<asmjit::RelocData>::append
	test	eax, eax
	je	SHORT $LN1805@X86Assembl

; 3984 :           return self->setError(kErrorNoHeapMemory);

	xor	r8d, r8d
	mov	edx, 1
	mov	rcx, QWORD PTR self$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	$LN1@X86Assembl
$LN1805@X86Assembl:

; 3985 :       }
; 3986 : 
; 3987 :       if (label->offset != -1) {

	mov	rax, QWORD PTR label$[rsp]
	cmp	QWORD PTR [rax], -1
	je	$LN1806@X86Assembl

; 3988 :         // Bound label.
; 3989 :         self->_relocList[relocId].data += static_cast<SignedPtr>(label->offset);

	mov	rax, QWORD PTR label$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv5406[rsp], rax
	mov	rax, QWORD PTR self$[rsp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR tv5399[rsp], rax
	mov	rdx, QWORD PTR relocId$[rsp]
	mov	rcx, QWORD PTR tv5399[rsp]
	call	??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z ; asmjit::PodVector<asmjit::RelocData>::operator[]
	add	rax, 16
	mov	QWORD PTR tv5402[rsp], rax
	mov	rax, QWORD PTR tv5402[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv5404[rsp], rax
	mov	rax, QWORD PTR tv5406[rsp]
	mov	rcx, QWORD PTR tv5404[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR tv5402[rsp]
	mov	QWORD PTR [rcx], rax
$LN926@X86Assembl:

; 3990 :         EMIT_DWORD(0);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	DWORD PTR [rcx+rax], 0
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN926@X86Assembl

; 3991 :       }

	jmp	SHORT $LN1807@X86Assembl
$LN1806@X86Assembl:

; 3992 :       else {
; 3993 :         // Non-bound label.
; 3994 :         dispOffset = -4 - imLen;

	mov	eax, -4					; fffffffcH
	sub	eax, DWORD PTR imLen$[rsp]
	mov	DWORD PTR dispOffset$[rsp], eax

; 3995 :         dispSize = 4;

	mov	DWORD PTR dispSize$[rsp], 4

; 3996 :         goto _EmitDisplacement;

	jmp	$LN1808@X86Assembl
	jmp	$_EmitDisplacement$1957
$LN1807@X86Assembl:

; 3997 :       }
; 3998 :     }

	jmp	SHORT $LN1803@X86Assembl
$LN1802@X86Assembl:
$LN929@X86Assembl:

; 3999 :     else {
; 4000 :       // [Disp32].
; 4001 :       EMIT_DWORD(static_cast<int32_t>(dispOffset));

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	edx, DWORD PTR dispOffset$[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN929@X86Assembl
$LN1803@X86Assembl:
$LN1797@X86Assembl:

; 4002 :     }
; 4003 :   }
; 4004 :   goto _EmitDone;

	jmp	$LN1809@X86Assembl
	jmp	$_EmitDone$1951
$LN1645@X86Assembl:
$LN1650@X86Assembl:
$LN1657@X86Assembl:
$LN1663@X86Assembl:
$LN1671@X86Assembl:
$LN1679@X86Assembl:
$LN1685@X86Assembl:
$_EmitXopR$1969:

; 4005 : 
; 4006 :   // --------------------------------------------------------------------------
; 4007 :   // [Xop]
; 4008 :   // --------------------------------------------------------------------------
; 4009 : 
; 4010 : #define EMIT_XOP_M \
; 4011 :   ASMJIT_ASSERT(rmMem != NULL); \
; 4012 :   ASMJIT_ASSERT(rmMem->getOp() == kOperandTypeMem); \
; 4013 :   \
; 4014 :   if (rmMem->hasSegment()) { \
; 4015 :     EMIT_BYTE(x86SegmentPrefix[rmMem->getSegment()]); \
; 4016 :   } \
; 4017 :   \
; 4018 :   mBase = rmMem->getBase(); \
; 4019 :   mIndex = rmMem->getIndex(); \
; 4020 :   \
; 4021 :   { \
; 4022 :     uint32_t vex_XvvvvLpp; \
; 4023 :     uint32_t vex_rxbmmmmm; \
; 4024 :     \
; 4025 :     vex_XvvvvLpp  = (opCode >> (kX86InstOpCode_W_Shift - 7)) & 0x80; \
; 4026 :     vex_XvvvvLpp += (opCode >> (kX86InstOpCode_L_Shift - 2)) & 0x04; \
; 4027 :     vex_XvvvvLpp += (opCode >> (kX86InstOpCode_PP_Shift   )) & 0x03; \
; 4028 :     vex_XvvvvLpp += (opReg  >> (kVexVVVVShift          - 3)); \
; 4029 :     \
; 4030 :     vex_rxbmmmmm  = (opCode >> kX86InstOpCode_MM_Shift) & 0x0F; \
; 4031 :     vex_rxbmmmmm += static_cast<uint32_t>(mBase  - 8 < 8) << 5; \
; 4032 :     vex_rxbmmmmm += static_cast<uint32_t>(mIndex - 8 < 8) << 6; \
; 4033 :     \
; 4034 :     vex_rxbmmmmm |= static_cast<uint32_t>(opReg << 4) & 0x80; \
; 4035 :     vex_rxbmmmmm ^= 0xE0; \
; 4036 :     vex_XvvvvLpp ^= 0x78; \
; 4037 :     \
; 4038 :     EMIT_BYTE(kX86ByteXop3); \
; 4039 :     EMIT_BYTE(vex_rxbmmmmm); \
; 4040 :     EMIT_BYTE(vex_XvvvvLpp); \
; 4041 :     EMIT_OP(opCode); \
; 4042 :   } \
; 4043 :   \
; 4044 :   mBase &= 0x7; \
; 4045 :   opReg &= 0x7;
; 4046 : 
; 4047 : _EmitXopR:
; 4048 :   {
; 4049 :     uint32_t xop_XvvvvLpp;
; 4050 :     uint32_t xop_rxbmmmmm;
; 4051 : 
; 4052 :     xop_XvvvvLpp  = (opCode >> (kX86InstOpCode_W_Shift - 7)) & 0x80;

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 24
	and	eax, 128				; 00000080H
	mov	DWORD PTR xop_XvvvvLpp$8[rsp], eax

; 4053 :     xop_XvvvvLpp += (opCode >> (kX86InstOpCode_L_Shift - 2)) & 0x04;

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 21
	and	eax, 4
	mov	ecx, DWORD PTR xop_XvvvvLpp$8[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR xop_XvvvvLpp$8[rsp], eax

; 4054 :     xop_XvvvvLpp += (opCode >> (kX86InstOpCode_PP_Shift   )) & 0x03;

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 20
	and	eax, 3
	mov	ecx, DWORD PTR xop_XvvvvLpp$8[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR xop_XvvvvLpp$8[rsp], eax

; 4055 :     xop_XvvvvLpp += (opReg  >> (kVexVVVVShift          - 3));

	mov	eax, DWORD PTR opReg$[rsp]
	shr	eax, 9
	mov	ecx, DWORD PTR xop_XvvvvLpp$8[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR xop_XvvvvLpp$8[rsp], eax

; 4056 : 
; 4057 :     xop_rxbmmmmm  = (opCode >> kX86InstOpCode_MM_Shift) & 0x0F;

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 16
	and	eax, 15
	mov	DWORD PTR xop_rxbmmmmm$14[rsp], eax

; 4058 :     xop_rxbmmmmm |= (rmReg << 2) & 0x20;

	mov	rax, QWORD PTR $S1$[rsp]
	shl	rax, 2
	and	rax, 32					; 00000020H
	mov	ecx, DWORD PTR xop_rxbmmmmm$14[rsp]
	or	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR xop_rxbmmmmm$14[rsp], eax

; 4059 : 
; 4060 :     xop_rxbmmmmm |= static_cast<uint32_t>(opReg & 0x08) << 4;

	mov	eax, DWORD PTR opReg$[rsp]
	and	eax, 8
	shl	eax, 4
	mov	ecx, DWORD PTR xop_rxbmmmmm$14[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR xop_rxbmmmmm$14[rsp], eax

; 4061 :     xop_rxbmmmmm ^= 0xE0;

	mov	eax, DWORD PTR xop_rxbmmmmm$14[rsp]
	xor	eax, 224				; 000000e0H
	mov	DWORD PTR xop_rxbmmmmm$14[rsp], eax

; 4062 :     xop_XvvvvLpp ^= 0x78;

	mov	eax, DWORD PTR xop_XvvvvLpp$8[rsp]
	xor	eax, 120				; 00000078H
	mov	DWORD PTR xop_XvvvvLpp$8[rsp], eax
$LN932@X86Assembl:

; 4063 : 
; 4064 :     EMIT_BYTE(kX86ByteXop3);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 143			; 0000008fH
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN932@X86Assembl
$LN935@X86Assembl:
$LN938@X86Assembl:

; 4065 :     EMIT_OP(xop_rxbmmmmm);

	mov	eax, DWORD PTR xop_rxbmmmmm$14[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN938@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN935@X86Assembl
$LN941@X86Assembl:
$LN944@X86Assembl:

; 4066 :     EMIT_OP(xop_XvvvvLpp);

	mov	eax, DWORD PTR xop_XvvvvLpp$8[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN944@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN941@X86Assembl
$LN947@X86Assembl:
$LN950@X86Assembl:

; 4067 :     EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN950@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN947@X86Assembl

; 4068 : 
; 4069 :     rmReg &= 0x07;

	mov	rax, QWORD PTR $S1$[rsp]
	and	rax, 7
	mov	QWORD PTR $S1$[rsp], rax
$LN953@X86Assembl:

; 4070 :   }
; 4071 : 
; 4072 :   EMIT_BYTE(x86EncodeMod(3, opReg, static_cast<uint32_t>(rmReg)));

	mov	r8d, DWORD PTR $S1$[rsp]
	mov	edx, DWORD PTR opReg$[rsp]
	mov	ecx, 3
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN953@X86Assembl

; 4073 : 
; 4074 :   if (imLen == 0)

	cmp	DWORD PTR imLen$[rsp], 0
	jne	SHORT $LN1810@X86Assembl

; 4075 :     goto _EmitDone;

	jmp	$LN1811@X86Assembl
	jmp	$_EmitDone$1951
$LN1810@X86Assembl:
$LN956@X86Assembl:

; 4076 : 
; 4077 :   EMIT_BYTE(imVal & 0xFF);

	mov	rax, QWORD PTR imVal$[rsp]
	and	rax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN956@X86Assembl

; 4078 :   goto _EmitDone;

	jmp	$LN1812@X86Assembl
	jmp	$_EmitDone$1951
$LN1647@X86Assembl:
$LN1652@X86Assembl:
$LN1654@X86Assembl:
$LN1659@X86Assembl:
$LN1661@X86Assembl:
$LN1665@X86Assembl:
$LN1673@X86Assembl:
$LN1681@X86Assembl:
$LN1687@X86Assembl:
$LN1689@X86Assembl:
$_EmitXopM$1970:

; 4079 : 
; 4080 : _EmitXopM:
; 4081 :   EMIT_XOP_M

	mov	rcx, QWORD PTR $S1$[rsp]
	call	?hasSegment@X86Mem@asmjit@@QEBA_NXZ	; asmjit::X86Mem::hasSegment
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1813@X86Assembl
$LN959@X86Assembl:
	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getSegment@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getSegment
	mov	eax, eax
	lea	rcx, OFFSET FLAT:?x86SegmentPrefix@asmjit@@3QBEB
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR cursor$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN959@X86Assembl
$LN1813@X86Assembl:
	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getBase@X86Mem@asmjit@@QEBAIXZ		; asmjit::X86Mem::getBase
	mov	DWORD PTR mBase$[rsp], eax
	mov	rcx, QWORD PTR $S1$[rsp]
	call	?getIndex@X86Mem@asmjit@@QEBAIXZ	; asmjit::X86Mem::getIndex
	mov	DWORD PTR mIndex$[rsp], eax
	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 24
	and	eax, 128				; 00000080H
	mov	DWORD PTR vex_XvvvvLpp$10[rsp], eax
	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 21
	and	eax, 4
	mov	ecx, DWORD PTR vex_XvvvvLpp$10[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$10[rsp], eax
	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 20
	and	eax, 3
	mov	ecx, DWORD PTR vex_XvvvvLpp$10[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$10[rsp], eax
	mov	eax, DWORD PTR opReg$[rsp]
	shr	eax, 9
	mov	ecx, DWORD PTR vex_XvvvvLpp$10[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_XvvvvLpp$10[rsp], eax
	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 16
	and	eax, 15
	mov	DWORD PTR vex_rxbmmmmm$9[rsp], eax
	mov	eax, DWORD PTR mBase$[rsp]
	sub	eax, 8
	cmp	eax, 8
	jae	SHORT $LN1943@X86Assembl
	mov	DWORD PTR tv5512[rsp], 1
	jmp	SHORT $LN1944@X86Assembl
$LN1943@X86Assembl:
	mov	DWORD PTR tv5512[rsp], 0
$LN1944@X86Assembl:
	mov	eax, DWORD PTR tv5512[rsp]
	shl	eax, 5
	mov	ecx, DWORD PTR vex_rxbmmmmm$9[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_rxbmmmmm$9[rsp], eax
	mov	eax, DWORD PTR mIndex$[rsp]
	sub	eax, 8
	cmp	eax, 8
	jae	SHORT $LN1945@X86Assembl
	mov	DWORD PTR tv5517[rsp], 1
	jmp	SHORT $LN1946@X86Assembl
$LN1945@X86Assembl:
	mov	DWORD PTR tv5517[rsp], 0
$LN1946@X86Assembl:
	mov	eax, DWORD PTR tv5517[rsp]
	shl	eax, 6
	mov	ecx, DWORD PTR vex_rxbmmmmm$9[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_rxbmmmmm$9[rsp], eax
	mov	eax, DWORD PTR opReg$[rsp]
	shl	eax, 4
	and	eax, 128				; 00000080H
	mov	ecx, DWORD PTR vex_rxbmmmmm$9[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR vex_rxbmmmmm$9[rsp], eax
	mov	eax, DWORD PTR vex_rxbmmmmm$9[rsp]
	xor	eax, 224				; 000000e0H
	mov	DWORD PTR vex_rxbmmmmm$9[rsp], eax
	mov	eax, DWORD PTR vex_XvvvvLpp$10[rsp]
	xor	eax, 120				; 00000078H
	mov	DWORD PTR vex_XvvvvLpp$10[rsp], eax
$LN962@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 143			; 0000008fH
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN962@X86Assembl
$LN965@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR vex_rxbmmmmm$9[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN965@X86Assembl
$LN968@X86Assembl:
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR vex_XvvvvLpp$10[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN968@X86Assembl
$LN971@X86Assembl:
$LN974@X86Assembl:
	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN974@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN971@X86Assembl
	mov	eax, DWORD PTR mBase$[rsp]
	and	eax, 7
	mov	DWORD PTR mBase$[rsp], eax
	mov	eax, DWORD PTR opReg$[rsp]
	and	eax, 7
	mov	DWORD PTR opReg$[rsp], eax

; 4082 :   goto _EmitSib;

	jmp	$_EmitSib$1973
$LN1085@X86Assembl:
$LN1158@X86Assembl:
$_EmitJmpOrCallAbs$1956:

; 4083 : 
; 4084 :   // --------------------------------------------------------------------------
; 4085 :   // [Emit - Jump/Call to an Immediate]
; 4086 :   // --------------------------------------------------------------------------
; 4087 : 
; 4088 :   // 64-bit mode requires a trampoline if a relative displacement doesn't fit
; 4089 :   // into a 32-bit address. Old version of AsmJit used to emit jump to a section
; 4090 :   // which contained another jump followed by an address (it worked well for
; 4091 :   // both `jmp` and `call`), but it required to reserve 14-bytes for a possible
; 4092 :   // trampoline.
; 4093 :   //
; 4094 :   // Instead of using 5-byte `jmp/call` and reserving 14 bytes required by the
; 4095 :   // trampoline, it's better to use 6-byte `jmp/call` (prefixing it with REX
; 4096 :   // prefix) and to patch the `jmp/call` instruction to read the address from
; 4097 :   // a memory in case the trampoline is needed.
; 4098 :   //
; 4099 : _EmitJmpOrCallAbs:
; 4100 :   {
; 4101 :     RelocData rd;
; 4102 :     rd.type = kRelocAbsToRel;

	mov	DWORD PTR rd$69[rsp], 2

; 4103 :     rd.size = 4;

	mov	DWORD PTR rd$69[rsp+4], 4

; 4104 :     rd.from = (intptr_t)(cursor - self->_buffer) + 1;

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR cursor$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	inc	rax
	mov	QWORD PTR rd$69[rsp+8], rax

; 4105 :     rd.data = static_cast<SignedPtr>(imVal);

	mov	rax, QWORD PTR imVal$[rsp]
	mov	QWORD PTR rd$69[rsp+16], rax

; 4106 : 
; 4107 :     uint32_t trampolineSize = 0;

	mov	DWORD PTR trampolineSize$38[rsp], 0

; 4108 : 
; 4109 :     if (Arch == kArchX64) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN1814@X86Assembl

; 4110 :       Ptr baseAddress = self->getBaseAddress();

	mov	rcx, QWORD PTR self$[rsp]
	call	?getBaseAddress@CodeGen@asmjit@@QEBA_KXZ ; asmjit::CodeGen::getBaseAddress
	mov	QWORD PTR baseAddress$65[rsp], rax

; 4111 : 
; 4112 :       // If the base address of the output is known, it's possible to determine
; 4113 :       // the need for a trampoline here. This saves possible REX prefix in
; 4114 :       // 64-bit mode and prevents reserving space needed for an absolute address.
; 4115 :       if (baseAddress == kNoBaseAddress || !x64IsRelative(rd.data, baseAddress + rd.from + 4)) {

	cmp	QWORD PTR baseAddress$65[rsp], -1
	je	SHORT $LN1816@X86Assembl
	mov	rax, QWORD PTR baseAddress$65[rsp]
	mov	rcx, QWORD PTR rd$69[rsp+8]
	lea	rax, QWORD PTR [rax+rcx+4]
	mov	rdx, rax
	mov	rcx, QWORD PTR rd$69[rsp+16]
	call	?x64IsRelative@asmjit@@YA_N_K0@Z	; asmjit::x64IsRelative
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1815@X86Assembl
$LN1816@X86Assembl:

; 4116 :         // Emit REX prefix so the instruction can be patched later on. The REX
; 4117 :         // prefix does nothing if not patched after, but allows to patch the
; 4118 :         // instruction in case where the trampoline is needed.
; 4119 :         rd.type = kRelocTrampoline;

	mov	DWORD PTR rd$69[rsp], 3

; 4120 :         rd.from++;

	mov	rax, QWORD PTR rd$69[rsp+8]
	inc	rax
	mov	QWORD PTR rd$69[rsp+8], rax
$LN977@X86Assembl:

; 4121 : 
; 4122 :         EMIT_BYTE(kX86ByteRex);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 64			; 00000040H
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN977@X86Assembl

; 4123 :         trampolineSize = 8;

	mov	DWORD PTR trampolineSize$38[rsp], 8
$LN1815@X86Assembl:
$LN1814@X86Assembl:
$LN980@X86Assembl:
$LN983@X86Assembl:

; 4124 :       }
; 4125 :     }
; 4126 : 
; 4127 :     // Both `jmp` and `call` instructions have a single-byte opcode and are
; 4128 :     // followed by a 32-bit displacement.
; 4129 :     EMIT_OP(opCode);

	mov	eax, DWORD PTR opCode$[rsp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN983@X86Assembl
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN980@X86Assembl
$LN986@X86Assembl:

; 4130 :     EMIT_DWORD(0);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	DWORD PTR [rcx+rax], 0
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN986@X86Assembl

; 4131 : 
; 4132 :     if (self->_relocList.append(rd) != kErrorOk)

	mov	rax, QWORD PTR self$[rsp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR tv5593[rsp], rax
	lea	rdx, QWORD PTR rd$69[rsp]
	mov	rcx, QWORD PTR tv5593[rsp]
	call	?append@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAIAEBURelocData@2@@Z ; asmjit::PodVector<asmjit::RelocData>::append
	test	eax, eax
	je	SHORT $LN1817@X86Assembl

; 4133 :       return self->setError(kErrorNoHeapMemory);

	xor	r8d, r8d
	mov	edx, 1
	mov	rcx, QWORD PTR self$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	$LN1@X86Assembl
$LN1817@X86Assembl:

; 4134 : 
; 4135 :     // Reserve space for a possible trampoline.
; 4136 :     self->_trampolineSize += trampolineSize;

	mov	rax, QWORD PTR self$[rsp]
	mov	eax, DWORD PTR [rax+96]
	add	eax, DWORD PTR trampolineSize$38[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	mov	DWORD PTR [rcx+96], eax

; 4137 :   }
; 4138 :   goto _EmitDone;

	jmp	$LN1818@X86Assembl
	jmp	$_EmitDone$1951
$LN1089@X86Assembl:
$LN1140@X86Assembl:
$LN1141@X86Assembl:
$LN1151@X86Assembl:
$LN1168@X86Assembl:
$LN1169@X86Assembl:
$LN1758@X86Assembl:
$LN1764@X86Assembl:
$LN1808@X86Assembl:
$_EmitDisplacement$1957:

; 4139 : 
; 4140 :   // --------------------------------------------------------------------------
; 4141 :   // [Emit - Displacement]
; 4142 :   // --------------------------------------------------------------------------
; 4143 : 
; 4144 : _EmitDisplacement:
; 4145 :   {
; 4146 :     ASMJIT_ASSERT(label->offset == -1);
; 4147 :     ASMJIT_ASSERT(dispSize == 1 || dispSize == 4);
; 4148 : 
; 4149 :     // Chain with label.
; 4150 :     LabelLink* link = self->_newLabelLink();

	mov	rcx, QWORD PTR self$[rsp]
	call	?_newLabelLink@Assembler@asmjit@@QEAAPEAULabelLink@2@XZ ; asmjit::Assembler::_newLabelLink
	mov	QWORD PTR link$42[rsp], rax

; 4151 :     link->prev = label->links;

	mov	rax, QWORD PTR link$42[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 4152 :     link->offset = (intptr_t)(cursor - self->_buffer);

	mov	rax, QWORD PTR self$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR cursor$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR link$42[rsp]
	mov	QWORD PTR [rcx+8], rax

; 4153 :     link->displacement = dispOffset;

	movsxd	rax, DWORD PTR dispOffset$[rsp]
	mov	rcx, QWORD PTR link$42[rsp]
	mov	QWORD PTR [rcx+16], rax

; 4154 :     link->relocId = relocId;

	mov	rax, QWORD PTR link$42[rsp]
	mov	rcx, QWORD PTR relocId$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 4155 :     label->links = link;

	mov	rax, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR link$42[rsp]
	mov	QWORD PTR [rax+8], rcx

; 4156 : 
; 4157 :     // Emit label size as dummy data.
; 4158 :     if (dispSize == 1)

	cmp	DWORD PTR dispSize$[rsp], 1
	jne	SHORT $LN1819@X86Assembl
$LN989@X86Assembl:

; 4159 :       EMIT_BYTE(0x01);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	BYTE PTR [rcx+rax], 1
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN989@X86Assembl
	jmp	SHORT $LN1820@X86Assembl
$LN1819@X86Assembl:
$LN992@X86Assembl:

; 4160 :     else // if (dispSize == 4)
; 4161 :       EMIT_DWORD(0x04040404);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	DWORD PTR [rcx+rax], 67372036		; 04040404H
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN992@X86Assembl
$LN1820@X86Assembl:

; 4162 : 
; 4163 :     if (imLen != 0)

	cmp	DWORD PTR imLen$[rsp], 0
	je	SHORT $LN1821@X86Assembl

; 4164 :       goto _EmitImm;

	jmp	$_EmitImm$1959
$LN1821@X86Assembl:

; 4165 :   }
; 4166 : 
; 4167 :   // --------------------------------------------------------------------------
; 4168 :   // [Logging]
; 4169 :   // --------------------------------------------------------------------------
; 4170 : 
; 4171 : _EmitDone:

	jmp	SHORT $_EmitDone$1951
$LN1013@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1090@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1093@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1126@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1136@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1137@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1150@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1164@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1165@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1237@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1246@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1254@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1258@X86Assembl:
	jmp	SHORT $_EmitDone$1951
$LN1386@X86Assembl:
$LN1690@X86Assembl:
$LN1691@X86Assembl:
$LN1692@X86Assembl:
$LN1701@X86Assembl:
$LN1710@X86Assembl:
$LN1719@X86Assembl:
$LN1768@X86Assembl:
$LN1774@X86Assembl:
$LN1776@X86Assembl:
$LN1779@X86Assembl:
$LN1784@X86Assembl:
$LN1785@X86Assembl:
$LN1809@X86Assembl:
$LN1811@X86Assembl:
$LN1812@X86Assembl:
$LN1818@X86Assembl:
$_EmitDone$1951:

; 4172 : #if !defined(ASMJIT_DISABLE_LOGGER)
; 4173 : # if defined(ASMJIT_DEBUG)
; 4174 :   if (self->_logger || assertIllegal) {
; 4175 : # else
; 4176 :   if (self->_logger) {
; 4177 : # endif // ASMJIT_DEBUG
; 4178 :     StringBuilderT<512> sb;
; 4179 :     uint32_t loggerOptions = 0;
; 4180 : 
; 4181 :     if (self->_logger) {
; 4182 :       sb.appendString(self->_logger->getIndentation());
; 4183 :       loggerOptions = self->_logger->getOptions();
; 4184 :     }
; 4185 : 
; 4186 :     X86Assembler_dumpInstruction(sb, Arch, code, options, o0, o1, o2, o3, loggerOptions);
; 4187 : 
; 4188 :     if ((loggerOptions & (1 << kLoggerOptionBinaryForm)) != 0)
; 4189 :       X86Assembler_dumpComment(sb, sb.getLength(), self->_cursor, (intptr_t)(cursor - self->_cursor), dispSize, imLen, self->_comment);
; 4190 :     else
; 4191 :       X86Assembler_dumpComment(sb, sb.getLength(), NULL, 0, 0, 0, self->_comment);
; 4192 : 
; 4193 : # if defined(ASMJIT_DEBUG)
; 4194 :     if (self->_logger)
; 4195 : # endif // ASMJIT_DEBUG
; 4196 :       self->_logger->logString(kLoggerStyleDefault, sb.getData(), sb.getLength());
; 4197 : 
; 4198 : # if defined(ASMJIT_DEBUG)
; 4199 :     // Raise an assertion failure, because this situation shouldn't happen.
; 4200 :     if (assertIllegal)
; 4201 :       assertionFailed(sb.getData(), __FILE__, __LINE__);
; 4202 : # endif // ASMJIT_DEBUG
; 4203 :   }
; 4204 : #else
; 4205 : # if defined(ASMJIT_DEBUG)
; 4206 :   ASMJIT_ASSERT(!assertIllegal);
; 4207 : # endif // ASMJIT_DEBUG
; 4208 : #endif // !ASMJIT_DISABLE_LOGGER
; 4209 : 
; 4210 :   self->_comment = NULL;

	mov	rax, QWORD PTR self$[rsp]
	mov	QWORD PTR [rax+104], 0

; 4211 :   self->setCursor(cursor);

	mov	rdx, QWORD PTR cursor$[rsp]
	mov	rcx, QWORD PTR self$[rsp]
	call	?setCursor@Assembler@asmjit@@QEAAXPEAE@Z ; asmjit::Assembler::setCursor

; 4212 : 
; 4213 :   return kErrorOk;

	xor	eax, eax
	jmp	SHORT $LN1@X86Assembl
$LN998@X86Assembl:
$_GrowBuffer$1948:
$LN995@X86Assembl:

; 4214 : 
; 4215 : _GrowBuffer:
; 4216 :   ASMJIT_PROPAGATE_ERROR(self->_grow(16));

	mov	edx, 16
	mov	rcx, QWORD PTR self$[rsp]
	call	?_grow@Assembler@asmjit@@QEAAI_K@Z	; asmjit::Assembler::_grow
	mov	DWORD PTR errval_$39[rsp], eax
	cmp	DWORD PTR errval_$39[rsp], 0
	je	SHORT $LN1822@X86Assembl
	mov	eax, DWORD PTR errval_$39[rsp]
	jmp	SHORT $LN1@X86Assembl
$LN1822@X86Assembl:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN995@X86Assembl

; 4217 : 
; 4218 :   cursor = self->getCursor();

	mov	rcx, QWORD PTR self$[rsp]
	call	?getCursor@Assembler@asmjit@@QEBAPEAEXZ	; asmjit::Assembler::getCursor
	mov	QWORD PTR cursor$[rsp], rax

; 4219 :   goto _Prepare;

	jmp	$_Prepare$1949
$LN1@X86Assembl:

; 4220 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1416				; 00000588H
	ret	0
	npad	3
$LN1947@X86Assembl:
	DD	$LN1012@X86Assembl
	DD	$LN1015@X86Assembl
	DD	$LN1014@X86Assembl
	DD	$LN1018@X86Assembl
	DD	$LN1017@X86Assembl
	DD	$LN1024@X86Assembl
	DD	$LN1031@X86Assembl
	DD	$LN1037@X86Assembl
	DD	$LN1040@X86Assembl
	DD	$LN1061@X86Assembl
	DD	$LN1065@X86Assembl
	DD	$LN1079@X86Assembl
	DD	$LN1091@X86Assembl
	DD	$LN1094@X86Assembl
	DD	$LN1113@X86Assembl
	DD	$LN1122@X86Assembl
	DD	$LN1127@X86Assembl
	DD	$LN1142@X86Assembl
	DD	$LN1152@X86Assembl
	DD	$LN1170@X86Assembl
	DD	$LN1174@X86Assembl
	DD	$LN1211@X86Assembl
	DD	$LN1218@X86Assembl
	DD	$LN1225@X86Assembl
	DD	$LN1232@X86Assembl
	DD	$LN1241@X86Assembl
	DD	$LN1250@X86Assembl
	DD	$LN1252@X86Assembl
	DD	$LN1260@X86Assembl
	DD	$LN1274@X86Assembl
	DD	$LN1279@X86Assembl
	DD	$LN1292@X86Assembl
	DD	$LN1313@X86Assembl
	DD	$LN1309@X86Assembl
	DD	$LN1323@X86Assembl
	DD	$LN1325@X86Assembl
	DD	$LN1333@X86Assembl
	DD	$LN1337@X86Assembl
	DD	$LN1352@X86Assembl
	DD	$LN1363@X86Assembl
	DD	$LN1360@X86Assembl
	DD	$LN1366@X86Assembl
	DD	$LN1442@X86Assembl
	DD	$LN1447@X86Assembl
	DD	$LN1440@X86Assembl
	DD	$LN1439@X86Assembl
	DD	$LN1452@X86Assembl
	DD	$LN1459@X86Assembl
	DD	$LN1466@X86Assembl
	DD	$LN1471@X86Assembl
	DD	$LN1373@X86Assembl
	DD	$LN1379@X86Assembl
	DD	$LN1384@X86Assembl
	DD	$LN1387@X86Assembl
	DD	$LN1388@X86Assembl
	DD	$LN1399@X86Assembl
	DD	$LN1406@X86Assembl
	DD	$LN1415@X86Assembl
	DD	$LN1436@X86Assembl
	DD	$LN1476@X86Assembl
	DD	$LN1481@X86Assembl
	DD	$LN1486@X86Assembl
	DD	$LN1491@X86Assembl
	DD	$LN1493@X86Assembl
	DD	$LN1497@X86Assembl
	DD	$LN1496@X86Assembl
	DD	$LN1503@X86Assembl
	DD	$LN1502@X86Assembl
	DD	$LN1509@X86Assembl
	DD	$LN1508@X86Assembl
	DD	$LN1515@X86Assembl
	DD	$LN1514@X86Assembl
	DD	$LN1521@X86Assembl
	DD	$LN1520@X86Assembl
	DD	$LN1527@X86Assembl
	DD	$LN1526@X86Assembl
	DD	$LN1535@X86Assembl
	DD	$LN1534@X86Assembl
	DD	$LN1542@X86Assembl
	DD	$LN1547@X86Assembl
	DD	$LN1555@X86Assembl
	DD	$LN1554@X86Assembl
	DD	$LN1563@X86Assembl
	DD	$LN1562@X86Assembl
	DD	$LN1572@X86Assembl
	DD	$LN1582@X86Assembl
	DD	$LN1581@X86Assembl
	DD	$LN1590@X86Assembl
	DD	$LN1589@X86Assembl
	DD	$LN1599@X86Assembl
	DD	$LN1605@X86Assembl
	DD	$LN1604@X86Assembl
	DD	$LN1611@X86Assembl
	DD	$LN1610@X86Assembl
	DD	$LN1618@X86Assembl
	DD	$LN1629@X86Assembl
	DD	$LN1624@X86Assembl
	DD	$LN1635@X86Assembl
	DD	$LN1634@X86Assembl
	DD	$LN1643@X86Assembl
	DD	$LN1642@X86Assembl
	DD	$LN1648@X86Assembl
	DD	$LN1655@X86Assembl
	DD	$LN1667@X86Assembl
	DD	$LN1666@X86Assembl
	DD	$LN1675@X86Assembl
	DD	$LN1674@X86Assembl
	DD	$LN1683@X86Assembl
	DD	$LN1682@X86Assembl
??$X86Assembler_emit@$01@asmjit@@YAIPEAUAssembler@0@IPEBUOperand@0@111@Z ENDP ; asmjit::X86Assembler_emit<2>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z
_TEXT	SEGMENT
base$ = 48
alignment$ = 56
??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z PROC		; asmjit::IntUtil::deltaTo<unsigned __int64>, COMDAT

; 434  :   static ASMJIT_INLINE T deltaTo(T base, T alignment) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 435  :     return alignTo(base, alignment) - base;

	mov	rdx, QWORD PTR alignment$[rsp]
	mov	rcx, QWORD PTR base$[rsp]
	call	??$alignTo@_K@IntUtil@asmjit@@SA_K_K0@Z	; asmjit::IntUtil::alignTo<unsigned __int64>
	sub	rax, QWORD PTR base$[rsp]

; 436  :   }

	add	rsp, 40					; 00000028H
	ret	0
??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z ENDP		; asmjit::IntUtil::deltaTo<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$isPowerOf2@I@IntUtil@asmjit@@SA_NI@Z
_TEXT	SEGMENT
tv68 = 0
n$ = 32
??$isPowerOf2@I@IntUtil@asmjit@@SA_NI@Z PROC		; asmjit::IntUtil::isPowerOf2<unsigned int>, COMDAT

; 207  :   static ASMJIT_INLINE bool isPowerOf2(T n) {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 208  :     return n != 0 && (n & (n - 1)) == 0;

	cmp	DWORD PTR n$[rsp], 0
	je	SHORT $LN3@isPowerOf2
	mov	eax, DWORD PTR n$[rsp]
	dec	eax
	mov	ecx, DWORD PTR n$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN3@isPowerOf2
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@isPowerOf2
$LN3@isPowerOf2:
	mov	DWORD PTR tv68[rsp], 0
$LN4@isPowerOf2:
	movzx	eax, BYTE PTR tv68[rsp]

; 209  :   }

	add	rsp, 24
	ret	0
??$isPowerOf2@I@IntUtil@asmjit@@SA_NI@Z ENDP		; asmjit::IntUtil::isPowerOf2<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
opCode$ = 8
?x86ExtractO@asmjit@@YAII@Z PROC			; asmjit::x86ExtractO

; 190  : static ASMJIT_INLINE uint32_t x86ExtractO(uint32_t opCode) {

	mov	DWORD PTR [rsp+8], ecx

; 191  :   return (opCode >> kX86InstOpCode_O_Shift) & 0x7;

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 25
	and	eax, 7

; 192  : }

	ret	0
?x86ExtractO@asmjit@@YAII@Z ENDP			; asmjit::x86ExtractO
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
regIndex$ = 8
vvvvIndex$ = 16
?x86RegAndVvvv@asmjit@@YAIII@Z PROC			; asmjit::x86RegAndVvvv

; 185  : static ASMJIT_INLINE uint32_t x86RegAndVvvv(uint32_t regIndex, uint32_t vvvvIndex) {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 186  :   return regIndex + (vvvvIndex << kVexVVVVShift);

	mov	eax, DWORD PTR vvvvIndex$[rsp]
	shl	eax, 12
	mov	ecx, DWORD PTR regIndex$[rsp]
	add	ecx, eax
	mov	eax, ecx

; 187  : }

	ret	0
?x86RegAndVvvv@asmjit@@YAIII@Z ENDP			; asmjit::x86RegAndVvvv
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
mem$ = 8
?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z PROC	; asmjit::x86OpMem

; 180  : static ASMJIT_INLINE const X86Mem* x86OpMem(const Operand* mem) {

	mov	QWORD PTR [rsp+8], rcx

; 181  :   return static_cast<const X86Mem*>(mem);

	mov	rax, QWORD PTR mem$[rsp]

; 182  : }

	ret	0
?x86OpMem@asmjit@@YAPEBUX86Mem@1@PEBUOperand@1@@Z ENDP	; asmjit::x86OpMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
reg$ = 48
?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z PROC		; asmjit::x86OpReg

; 175  : static ASMJIT_INLINE uint32_t x86OpReg(const Operand* reg) {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 176  :   return static_cast<const X86Reg*>(reg)->getRegIndex();

	mov	rcx, QWORD PTR reg$[rsp]
	call	?getRegIndex@Reg@asmjit@@QEBAIXZ	; asmjit::Reg::getRegIndex

; 177  : }

	add	rsp, 40					; 00000028H
	ret	0
?x86OpReg@asmjit@@YAIPEBUOperand@1@@Z ENDP		; asmjit::x86OpReg
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
diff$ = 32
a$ = 64
b$ = 72
?x64IsRelative@asmjit@@YA_N_K0@Z PROC			; asmjit::x64IsRelative

; 169  : static ASMJIT_INLINE bool x64IsRelative(Ptr a, Ptr b) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 170  :   SignedPtr diff = static_cast<SignedPtr>(a) - static_cast<SignedPtr>(b);

	mov	rax, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR diff$[rsp], rax

; 171  :   return IntUtil::isInt32(diff);

	mov	rcx, QWORD PTR diff$[rsp]
	call	??$isInt32@_J@IntUtil@asmjit@@SA_N_J@Z	; asmjit::IntUtil::isInt32<__int64>

; 172  : }

	add	rsp, 56					; 00000038H
	ret	0
?x64IsRelative@asmjit@@YA_N_K0@Z ENDP			; asmjit::x64IsRelative
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
s$ = 8
i$ = 16
b$ = 24
?x86EncodeSib@asmjit@@YAIIII@Z PROC			; asmjit::x86EncodeSib

; 163  : static ASMJIT_INLINE uint32_t x86EncodeSib(uint32_t s, uint32_t i, uint32_t b) {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 164  :   return (s << 6) + (i << 3) + b;

	mov	eax, DWORD PTR s$[rsp]
	shl	eax, 6
	mov	ecx, DWORD PTR b$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR i$[rsp]
	lea	eax, DWORD PTR [rax+rcx*8]

; 165  : }

	ret	0
?x86EncodeSib@asmjit@@YAIIII@Z ENDP			; asmjit::x86EncodeSib
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
m$ = 8
o$ = 16
rm$ = 24
?x86EncodeMod@asmjit@@YAIIII@Z PROC			; asmjit::x86EncodeMod

; 158  : static ASMJIT_INLINE uint32_t x86EncodeMod(uint32_t m, uint32_t o, uint32_t rm) {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 159  :   return (m << 6) + (o << 3) + rm;

	mov	eax, DWORD PTR m$[rsp]
	shl	eax, 6
	mov	ecx, DWORD PTR rm$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR o$[rsp]
	lea	eax, DWORD PTR [rax+rcx*8]

; 160  : }

	ret	0
?x86EncodeMod@asmjit@@YAIIII@Z ENDP			; asmjit::x86EncodeMod
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
tv65 = 0
rex$ = 32
?x86RexIsInvalid@asmjit@@YA_NI@Z PROC			; asmjit::x86RexIsInvalid

; 153  : static ASMJIT_INLINE bool x86RexIsInvalid(uint32_t rex) {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 154  :   return rex >= _kX86InstOptionNoRex;

	cmp	DWORD PTR rex$[rsp], 128		; 00000080H
	jb	SHORT $LN3@x86RexIsIn
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN4@x86RexIsIn
$LN3@x86RexIsIn:
	mov	DWORD PTR tv65[rsp], 0
$LN4@x86RexIsIn:
	movzx	eax, BYTE PTR tv65[rsp]

; 155  : }

	add	rsp, 24
	ret	0
?x86RexIsInvalid@asmjit@@YA_NI@Z ENDP			; asmjit::x86RexIsInvalid
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
rex$ = 0
opCode$ = 32
options$ = 40
?x86RexFromOpCodeAndOptions@asmjit@@YAIII@Z PROC	; asmjit::x86RexFromOpCodeAndOptions

; 146  : static ASMJIT_INLINE uint32_t x86RexFromOpCodeAndOptions(uint32_t opCode, uint32_t options) {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 147  :   uint32_t rex = (opCode >> (kX86InstOpCode_W_Shift - 3));

	mov	eax, DWORD PTR opCode$[rsp]
	shr	eax, 28
	mov	DWORD PTR rex$[rsp], eax

; 148  :   ASMJIT_ASSERT((rex & ~static_cast<uint32_t>(0x08)) == 0);
; 149  : 
; 150  :   return rex + (options & kX86RexNoRexMask);

	mov	eax, DWORD PTR options$[rsp]
	and	eax, 192				; 000000c0H
	mov	ecx, DWORD PTR rex$[rsp]
	add	ecx, eax
	mov	eax, ecx

; 151  : }

	add	rsp, 24
	ret	0
?x86RexFromOpCodeAndOptions@asmjit@@YAIII@Z ENDP	; asmjit::x86RexFromOpCodeAndOptions
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\cpuinfo.h
;	COMDAT ?getFamily@CpuInfo@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getFamily@CpuInfo@asmjit@@QEBAIXZ PROC			; asmjit::CpuInfo::getFamily, COMDAT

; 76   :   ASMJIT_INLINE uint32_t getFamily() const { return _family; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+88]
	ret	0
?getFamily@CpuInfo@asmjit@@QEBAIXZ ENDP			; asmjit::CpuInfo::getFamily
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\cpuinfo.h
;	COMDAT ?getVendorId@CpuInfo@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getVendorId@CpuInfo@asmjit@@QEBAIXZ PROC		; asmjit::CpuInfo::getVendorId, COMDAT

; 74   :   ASMJIT_INLINE uint32_t getVendorId() const { return _vendorId; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+84]
	ret	0
?getVendorId@CpuInfo@asmjit@@QEBAIXZ ENDP		; asmjit::CpuInfo::getVendorId
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GX86Assembler@asmjit@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GX86Assembler@asmjit@@UEAAPEAXI@Z PROC		; asmjit::X86Assembler::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1X86Assembler@asmjit@@UEAA@XZ		; asmjit::X86Assembler::~X86Assembler
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 272				; 00000110H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GX86Assembler@asmjit@@UEAAPEAXI@Z ENDP		; asmjit::X86Assembler::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
this$ = 64
code$ = 72
o0$ = 80
o1$ = 88
o2$ = 96
o3$ = 104
?_emit@X86Assembler@asmjit@@UEAAIIAEBUOperand@2@000@Z PROC ; asmjit::X86Assembler::_emit

; 4222 : Error X86Assembler::_emit(uint32_t code, const Operand& o0, const Operand& o1, const Operand& o2, const Operand& o3) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4223 : #if defined(ASMJIT_BUILD_X86) && !defined(ASMJIT_BUILD_X64)
; 4224 :   return X86Assembler_emit<kArchX86>(this, code, &o0, &o1, &o2, &o3);
; 4225 : #elif !defined(ASMJIT_BUILD_X86) && defined(ASMJIT_BUILD_X64)
; 4226 :   return X86Assembler_emit<kArchX64>(this, code, &o0, &o1, &o2, &o3);

	mov	rax, QWORD PTR o3$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR o2$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR o1$[rsp]
	mov	r8, QWORD PTR o0$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$X86Assembler_emit@$01@asmjit@@YAIPEAUAssembler@0@IPEBUOperand@0@111@Z ; asmjit::X86Assembler_emit<2>

; 4227 : #else
; 4228 :   if (_arch == kArchX86)
; 4229 :     return X86Assembler_emit<kArchX86>(this, code, &o0, &o1, &o2, &o3);
; 4230 :   else
; 4231 :     return X86Assembler_emit<kArchX64>(this, code, &o0, &o1, &o2, &o3);
; 4232 : #endif
; 4233 : }

	add	rsp, 56					; 00000038H
	ret	0
?_emit@X86Assembler@asmjit@@UEAAIIAEBUOperand@2@000@Z ENDP ; asmjit::X86Assembler::_emit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
useTrampoline$1 = 32
byte1$2 = 36
ptr$3 = 40
rd$4 = 48
dst$ = 56
tv144 = 64
tv166 = 68
offset$5 = 72
tramp$ = 80
i$6 = 88
byte0$7 = 96
arch$ = 100
minCodeSize$ = 104
relocCount$ = 112
rdList$ = 120
maxCodeSize$ = 128
this$ = 160
_dst$ = 168
baseAddress$ = 176
?_relocCode@X86Assembler@asmjit@@UEBA_KPEAX_K@Z PROC	; asmjit::X86Assembler::_relocCode

; 521  : size_t X86Assembler::_relocCode(void* _dst, Ptr baseAddress) const {

$LN25:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 522  :   uint32_t arch = getArch();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getArch@CodeGen@asmjit@@QEBAIXZ	; asmjit::CodeGen::getArch
	mov	DWORD PTR arch$[rsp], eax

; 523  :   uint8_t* dst = static_cast<uint8_t*>(_dst);

	mov	rax, QWORD PTR _dst$[rsp]
	mov	QWORD PTR dst$[rsp], rax

; 524  : 
; 525  : #if !defined(ASMJIT_DISABLE_LOGGER)
; 526  :   Logger* logger = getLogger();
; 527  : #endif // ASMJIT_DISABLE_LOGGER
; 528  : 
; 529  :   size_t minCodeSize = getOffset();   // Current offset is the minimum code size.

	mov	rcx, QWORD PTR this$[rsp]
	call	?getOffset@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getOffset
	mov	QWORD PTR minCodeSize$[rsp], rax

; 530  :   size_t maxCodeSize = getCodeSize(); // Includes all possible trampolines.

	mov	rcx, QWORD PTR this$[rsp]
	call	?getCodeSize@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getCodeSize
	mov	QWORD PTR maxCodeSize$[rsp], rax

; 531  : 
; 532  :   // We will copy the exact size of the generated code. Extra code for trampolines
; 533  :   // is generated on-the-fly by the relocator (this code doesn't exist at the moment).
; 534  :   ::memcpy(dst, _buffer, minCodeSize);

	mov	r8, QWORD PTR minCodeSize$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR dst$[rsp]
	call	memcpy

; 535  : 
; 536  :   // Trampoline pointer.
; 537  :   uint8_t* tramp = dst + minCodeSize;

	mov	rax, QWORD PTR minCodeSize$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tramp$[rsp], rax

; 538  : 
; 539  :   // Relocate all recorded locations.
; 540  :   size_t relocCount = _relocList.getLength();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	?getLength@?$PodVector@URelocData@asmjit@@@asmjit@@QEBA_KXZ ; asmjit::PodVector<asmjit::RelocData>::getLength
	mov	QWORD PTR relocCount$[rsp], rax

; 541  :   const RelocData* rdList = _relocList.getData();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEBAPEBURelocData@2@XZ ; asmjit::PodVector<asmjit::RelocData>::getData
	mov	QWORD PTR rdList$[rsp], rax

; 542  : 
; 543  :   for (size_t i = 0; i < relocCount; i++) {

	mov	QWORD PTR i$6[rsp], 0
	jmp	SHORT $LN4@relocCode
$LN2@relocCode:
	mov	rax, QWORD PTR i$6[rsp]
	inc	rax
	mov	QWORD PTR i$6[rsp], rax
$LN4@relocCode:
	mov	rax, QWORD PTR relocCount$[rsp]
	cmp	QWORD PTR i$6[rsp], rax
	jae	$LN3@relocCode

; 544  :     const RelocData& rd = rdList[i];

	imul	rax, QWORD PTR i$6[rsp], 24
	mov	rcx, QWORD PTR rdList$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR rd$4[rsp], rax

; 545  : 
; 546  :     // Make sure that the `RelocData` is correct.
; 547  :     Ptr ptr = rd.data;

	mov	rax, QWORD PTR rd$4[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR ptr$3[rsp], rax

; 548  : 
; 549  :     size_t offset = static_cast<size_t>(rd.from);

	mov	rax, QWORD PTR rd$4[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR offset$5[rsp], rax

; 550  :     ASMJIT_ASSERT(offset + rd.size <= static_cast<Ptr>(maxCodeSize));
; 551  : 
; 552  :     // Whether to use trampoline, can be only used if relocation type is
; 553  :     // kRelocAbsToRel on 64-bit.
; 554  :     bool useTrampoline = false;

	mov	BYTE PTR useTrampoline$1[rsp], 0

; 555  : 
; 556  :     switch (rd.type) {

	mov	rax, QWORD PTR rd$4[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv144[rsp], eax
	cmp	DWORD PTR tv144[rsp], 1
	je	SHORT $LN10@relocCode
	cmp	DWORD PTR tv144[rsp], 2
	je	SHORT $LN11@relocCode
	cmp	DWORD PTR tv144[rsp], 3
	je	SHORT $LN12@relocCode
	jmp	$LN14@relocCode

; 557  :       case kRelocAbsToAbs:
; 558  :         break;

	jmp	$LN5@relocCode
$LN10@relocCode:

; 559  : 
; 560  :       case kRelocRelToAbs:
; 561  :         ptr += baseAddress;

	mov	rax, QWORD PTR baseAddress$[rsp]
	mov	rcx, QWORD PTR ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$3[rsp], rax

; 562  :         break;

	jmp	$LN5@relocCode
$LN11@relocCode:

; 563  : 
; 564  :       case kRelocAbsToRel:
; 565  :         ptr -= baseAddress + rd.from + 4;

	mov	rax, QWORD PTR rd$4[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR baseAddress$[rsp]
	lea	rax, QWORD PTR [rcx+rax+4]
	mov	rcx, QWORD PTR ptr$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$3[rsp], rax

; 566  :         break;

	jmp	SHORT $LN5@relocCode
$LN12@relocCode:

; 567  : 
; 568  :       case kRelocTrampoline:
; 569  :         ptr -= baseAddress + rd.from + 4;

	mov	rax, QWORD PTR rd$4[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR baseAddress$[rsp]
	lea	rax, QWORD PTR [rcx+rax+4]
	mov	rcx, QWORD PTR ptr$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$3[rsp], rax

; 570  :         if (!IntUtil::isInt32(static_cast<SignedPtr>(ptr))) {

	mov	rcx, QWORD PTR ptr$3[rsp]
	call	??$isInt32@_J@IntUtil@asmjit@@SA_N_J@Z	; asmjit::IntUtil::isInt32<__int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@relocCode

; 571  :           ptr = (Ptr)tramp - (baseAddress + rd.from + 4);

	mov	rax, QWORD PTR rd$4[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR baseAddress$[rsp]
	lea	rax, QWORD PTR [rcx+rax+4]
	mov	rcx, QWORD PTR tramp$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$3[rsp], rax

; 572  :           useTrampoline = true;

	mov	BYTE PTR useTrampoline$1[rsp], 1
$LN13@relocCode:
$LN14@relocCode:
$LN5@relocCode:

; 573  :         }
; 574  :         break;
; 575  : 
; 576  :       default:
; 577  :         ASMJIT_ASSERT(!"Reached");
; 578  :     }
; 579  : 
; 580  :     switch (rd.size) {

	mov	rax, QWORD PTR rd$4[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR tv166[rsp], eax
	cmp	DWORD PTR tv166[rsp], 4
	je	SHORT $LN16@relocCode
	cmp	DWORD PTR tv166[rsp], 8
	je	SHORT $LN15@relocCode
	jmp	SHORT $LN17@relocCode
$LN15@relocCode:

; 581  :       case 8:
; 582  :         *reinterpret_cast<int64_t*>(dst + offset) = static_cast<int64_t>(ptr);

	mov	rax, QWORD PTR offset$5[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR ptr$3[rsp]
	mov	QWORD PTR [rax], rcx

; 583  :         break;

	jmp	SHORT $LN7@relocCode
$LN16@relocCode:

; 584  : 
; 585  :       case 4:
; 586  :         *reinterpret_cast<int32_t*>(dst + offset) = static_cast<int32_t>(static_cast<SignedPtr>(ptr));

	mov	rax, QWORD PTR offset$5[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR ptr$3[rsp]
	mov	DWORD PTR [rax], ecx
$LN17@relocCode:
$LN7@relocCode:

; 587  :         break;
; 588  : 
; 589  :       default:
; 590  :         ASMJIT_ASSERT(!"Reached");
; 591  :     }
; 592  : 
; 593  :     // Handle the trampoline case.
; 594  :     if (useTrampoline) {

	movzx	eax, BYTE PTR useTrampoline$1[rsp]
	test	eax, eax
	je	$LN18@relocCode

; 595  :       // Bytes that replace [REX, OPCODE] bytes.
; 596  :       uint32_t byte0 = 0xFF;

	mov	DWORD PTR byte0$7[rsp], 255		; 000000ffH

; 597  :       uint32_t byte1 = dst[offset - 1];

	mov	rax, QWORD PTR offset$5[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax-1]
	mov	DWORD PTR byte1$2[rsp], eax

; 598  : 
; 599  :       // Call, patch to FF/2 (-> 0x15).
; 600  :       if (byte1 == 0xE8)

	cmp	DWORD PTR byte1$2[rsp], 232		; 000000e8H
	jne	SHORT $LN19@relocCode

; 601  :         byte1 = x86EncodeMod(0, 2, 5);

	mov	r8d, 5
	mov	edx, 2
	xor	ecx, ecx
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	DWORD PTR byte1$2[rsp], eax
	jmp	SHORT $LN20@relocCode
$LN19@relocCode:

; 602  :       // Jmp, patch to FF/4 (-> 0x25).
; 603  :       else if (byte1 == 0xE9)

	cmp	DWORD PTR byte1$2[rsp], 233		; 000000e9H
	jne	SHORT $LN21@relocCode

; 604  :         byte1 = x86EncodeMod(0, 4, 5);

	mov	r8d, 5
	mov	edx, 4
	xor	ecx, ecx
	call	?x86EncodeMod@asmjit@@YAIIII@Z		; asmjit::x86EncodeMod
	mov	DWORD PTR byte1$2[rsp], eax
$LN21@relocCode:
$LN20@relocCode:

; 605  : 
; 606  :       // Patch `jmp/call` instruction.
; 607  :       ASMJIT_ASSERT(offset >= 2);
; 608  :       dst[offset - 2] = byte0;

	mov	rax, QWORD PTR offset$5[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	ecx, BYTE PTR byte0$7[rsp]
	mov	BYTE PTR [rax-2], cl

; 609  :       dst[offset - 1] = byte1;

	mov	rax, QWORD PTR offset$5[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	ecx, BYTE PTR byte1$2[rsp]
	mov	BYTE PTR [rax-1], cl

; 610  : 
; 611  :       // Absolute address.
; 612  :       ((uint64_t*)tramp)[0] = static_cast<uint64_t>(rd.data);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tramp$[rsp]
	mov	rdx, QWORD PTR rd$4[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+rax], rdx

; 613  : 
; 614  :       // Advance trampoline pointer.
; 615  :       tramp += 8;

	mov	rax, QWORD PTR tramp$[rsp]
	add	rax, 8
	mov	QWORD PTR tramp$[rsp], rax
$LN18@relocCode:

; 616  : 
; 617  : #if !defined(ASMJIT_DISABLE_LOGGER)
; 618  :       if (logger)
; 619  :         logger->logFormat(kLoggerStyleComment, "; Trampoline %llX\n", rd.data);
; 620  : #endif // !ASMJIT_DISABLE_LOGGER
; 621  :     }
; 622  :   }

	jmp	$LN2@relocCode
$LN3@relocCode:

; 623  : 
; 624  :   if (arch == kArchX64)

	cmp	DWORD PTR arch$[rsp], 2
	jne	SHORT $LN22@relocCode

; 625  :     return (size_t)(tramp - dst);

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR tramp$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@relocCode
	jmp	SHORT $LN23@relocCode
$LN22@relocCode:

; 626  :   else
; 627  :     return (size_t)(minCodeSize);

	mov	rax, QWORD PTR minCodeSize$[rsp]
$LN23@relocCode:
$LN1@relocCode:

; 628  : }

	add	rsp, 152				; 00000098H
	ret	0
?_relocCode@X86Assembler@asmjit@@UEBA_KPEAX_K@Z ENDP	; asmjit::X86Assembler::_relocCode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
n$1 = 32
i$ = 36
p$2 = 40
alignPattern$ = 48
tv202 = 49
tv230 = 50
cursor$ = 56
tv194 = 64
tv222 = 68
errval_$3 = 72
cpuInfo$4 = 80
tv166 = 88
tv79 = 96
this$ = 128
mode$ = 136
offset$ = 144
?align@X86Assembler@asmjit@@UEAAIII@Z PROC		; asmjit::X86Assembler::align

; 407  : Error X86Assembler::align(uint32_t mode, uint32_t offset) {

$LN66:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 408  : #if !defined(ASMJIT_DISABLE_LOGGER)
; 409  :   if (_logger)
; 410  :     _logger->logFormat(kLoggerStyleDirective,
; 411  :       "%s.align %u\n", _logger->getIndentation(), static_cast<unsigned int>(offset));
; 412  : #endif // !ASMJIT_DISABLE_LOGGER
; 413  : 
; 414  :   if (offset <= 1 || !IntUtil::isPowerOf2(offset) || offset > 64)

	cmp	DWORD PTR offset$[rsp], 1
	jbe	SHORT $LN33@align
	mov	ecx, DWORD PTR offset$[rsp]
	call	??$isPowerOf2@I@IntUtil@asmjit@@SA_NI@Z	; asmjit::IntUtil::isPowerOf2<unsigned int>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@align
	cmp	DWORD PTR offset$[rsp], 64		; 00000040H
	jbe	SHORT $LN32@align
$LN33@align:

; 415  :     return setError(kErrorInvalidArgument);

	xor	r8d, r8d
	mov	edx, 3
	mov	rcx, QWORD PTR this$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	$LN1@align
$LN32@align:

; 416  : 
; 417  :   uint32_t i = static_cast<uint32_t>(IntUtil::deltaTo<size_t>(getOffset(), offset));

	mov	eax, DWORD PTR offset$[rsp]
	mov	QWORD PTR tv79[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?getOffset@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getOffset
	mov	rcx, QWORD PTR tv79[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	??$deltaTo@_K@IntUtil@asmjit@@SA_K_K0@Z	; asmjit::IntUtil::deltaTo<unsigned __int64>
	mov	DWORD PTR i$[rsp], eax

; 418  :   if (i == 0)

	cmp	DWORD PTR i$[rsp], 0
	jne	SHORT $LN34@align

; 419  :     return kErrorOk;

	xor	eax, eax
	jmp	$LN1@align
$LN34@align:

; 420  : 
; 421  :   if (getRemainingSpace() < i)

	mov	rcx, QWORD PTR this$[rsp]
	call	?getRemainingSpace@Assembler@asmjit@@QEBA_KXZ ; asmjit::Assembler::getRemainingSpace
	mov	ecx, DWORD PTR i$[rsp]
	cmp	rax, rcx
	jae	SHORT $LN35@align
$LN4@align:

; 422  :     ASMJIT_PROPAGATE_ERROR(_grow(i));

	mov	eax, DWORD PTR i$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow@Assembler@asmjit@@QEAAI_K@Z	; asmjit::Assembler::_grow
	mov	DWORD PTR errval_$3[rsp], eax
	cmp	DWORD PTR errval_$3[rsp], 0
	je	SHORT $LN36@align
	mov	eax, DWORD PTR errval_$3[rsp]
	jmp	$LN1@align
$LN36@align:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@align
$LN35@align:

; 423  : 
; 424  :   uint8_t* cursor = getCursor();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getCursor@Assembler@asmjit@@QEBAPEAEXZ	; asmjit::Assembler::getCursor
	mov	QWORD PTR cursor$[rsp], rax

; 425  :   uint8_t alignPattern = 0xCC;

	mov	BYTE PTR alignPattern$[rsp], 204	; 000000ccH

; 426  : 
; 427  :   if (mode == kAlignCode) {

	cmp	DWORD PTR mode$[rsp], 0
	jne	$LN37@align

; 428  :     alignPattern = 0x90;

	mov	BYTE PTR alignPattern$[rsp], 144	; 00000090H

; 429  : 
; 430  :     if (hasFeature(kCodeGenOptimizedAlign)) {

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?hasFeature@CodeGen@asmjit@@QEBA_NI@Z	; asmjit::CodeGen::hasFeature
	movzx	eax, al
	test	eax, eax
	je	$LN38@align

; 431  :       const X86CpuInfo* cpuInfo = static_cast<const X86CpuInfo*>(getRuntime()->getCpuInfo());

	mov	rcx, QWORD PTR this$[rsp]
	call	?getRuntime@CodeGen@asmjit@@QEBAPEAURuntime@2@XZ ; asmjit::CodeGen::getRuntime
	mov	QWORD PTR tv166[rsp], rax
	mov	rax, QWORD PTR tv166[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR tv166[rsp]
	call	QWORD PTR [rax+8]
	mov	QWORD PTR cpuInfo$4[rsp], rax

; 432  : 
; 433  :       // NOPs optimized for Intel:
; 434  :       //   Intel 64 and IA-32 Architectures Software Developer's Manual
; 435  :       //   - Volume 2B
; 436  :       //   - Instruction Set Reference N-Z
; 437  :       //     - NOP
; 438  : 
; 439  :       // NOPs optimized for AMD:
; 440  :       //   Software Optimization Guide for AMD Family 10h Processors (Quad-Core)
; 441  :       //   - 4.13 - Code Padding with Operand-Size Override and Multibyte NOP
; 442  : 
; 443  :       // Intel and AMD.
; 444  :       static const uint8_t nop1[] = { 0x90 };
; 445  :       static const uint8_t nop2[] = { 0x66, 0x90 };
; 446  :       static const uint8_t nop3[] = { 0x0F, 0x1F, 0x00 };
; 447  :       static const uint8_t nop4[] = { 0x0F, 0x1F, 0x40, 0x00 };
; 448  :       static const uint8_t nop5[] = { 0x0F, 0x1F, 0x44, 0x00, 0x00 };
; 449  :       static const uint8_t nop6[] = { 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00 };
; 450  :       static const uint8_t nop7[] = { 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00 };
; 451  :       static const uint8_t nop8[] = { 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 };
; 452  :       static const uint8_t nop9[] = { 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 };
; 453  : 
; 454  :       // AMD.
; 455  :       static const uint8_t nop10[] = { 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 };
; 456  :       static const uint8_t nop11[] = { 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 };
; 457  : 
; 458  :       const uint8_t* p;
; 459  :       uint32_t n;
; 460  : 
; 461  :       if (cpuInfo->getVendorId() == kCpuVendorIntel && (

	mov	rcx, QWORD PTR cpuInfo$4[rsp]
	call	?getVendorId@CpuInfo@asmjit@@QEBAIXZ	; asmjit::CpuInfo::getVendorId
	cmp	eax, 1
	jne	$LN39@align
	mov	rcx, QWORD PTR cpuInfo$4[rsp]
	call	?getFamily@CpuInfo@asmjit@@QEBAIXZ	; asmjit::CpuInfo::getFamily
	and	eax, 15
	cmp	eax, 6
	je	SHORT $LN41@align
	mov	rcx, QWORD PTR cpuInfo$4[rsp]
	call	?getFamily@CpuInfo@asmjit@@QEBAIXZ	; asmjit::CpuInfo::getFamily
	and	eax, 15
	cmp	eax, 15
	jne	$LN39@align
$LN41@align:
$LN7@align:

; 462  :           (cpuInfo->getFamily() & 0x0F) == 0x06 ||
; 463  :           (cpuInfo->getFamily() & 0x0F) == 0x0F)) {
; 464  :         do {
; 465  :           switch (i) {

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR tv194[rsp], eax
	mov	eax, DWORD PTR tv194[rsp]
	dec	eax
	mov	DWORD PTR tv194[rsp], eax
	cmp	DWORD PTR tv194[rsp], 7
	ja	$LN50@align
	mov	eax, DWORD PTR tv194[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN65@align[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN42@align:

; 466  :             case  1: p = nop1; n = 1; break;

	lea	rax, OFFSET FLAT:?nop1@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 1
	jmp	$LN8@align
$LN43@align:

; 467  :             case  2: p = nop2; n = 2; break;

	lea	rax, OFFSET FLAT:?nop2@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 2
	jmp	$LN8@align
$LN44@align:

; 468  :             case  3: p = nop3; n = 3; break;

	lea	rax, OFFSET FLAT:?nop3@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 3
	jmp	$LN8@align
$LN45@align:

; 469  :             case  4: p = nop4; n = 4; break;

	lea	rax, OFFSET FLAT:?nop4@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 4
	jmp	SHORT $LN8@align
$LN46@align:

; 470  :             case  5: p = nop5; n = 5; break;

	lea	rax, OFFSET FLAT:?nop5@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 5
	jmp	SHORT $LN8@align
$LN47@align:

; 471  :             case  6: p = nop6; n = 6; break;

	lea	rax, OFFSET FLAT:?nop6@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 6
	jmp	SHORT $LN8@align
$LN48@align:

; 472  :             case  7: p = nop7; n = 7; break;

	lea	rax, OFFSET FLAT:?nop7@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 7
	jmp	SHORT $LN8@align
$LN49@align:

; 473  :             case  8: p = nop8; n = 8; break;

	lea	rax, OFFSET FLAT:?nop8@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 8
	jmp	SHORT $LN8@align
$LN50@align:

; 474  :             default: p = nop9; n = 9; break;

	lea	rax, OFFSET FLAT:?nop9@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 9
$LN8@align:

; 475  :           }
; 476  : 
; 477  :           i -= n;

	mov	eax, DWORD PTR n$1[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax
$LN12@align:
$LN15@align:

; 478  :           do {
; 479  :             EMIT_BYTE(*p++);

	mov	rax, QWORD PTR p$2[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv202[rsp], al
	mov	rax, QWORD PTR p$2[rsp]
	inc	rax
	mov	QWORD PTR p$2[rsp], rax
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR tv202[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN15@align

; 480  :           } while (--n);

	mov	eax, DWORD PTR n$1[rsp]
	dec	eax
	mov	DWORD PTR n$1[rsp], eax
	cmp	DWORD PTR n$1[rsp], 0
	jne	SHORT $LN12@align

; 481  :         } while (i);

	cmp	DWORD PTR i$[rsp], 0
	jne	$LN7@align

; 482  :       }

	jmp	$LN40@align
$LN39@align:

; 483  :       else if (cpuInfo->getVendorId() == kCpuVendorAmd && cpuInfo->getFamily() >= 0x0F) {

	mov	rcx, QWORD PTR cpuInfo$4[rsp]
	call	?getVendorId@CpuInfo@asmjit@@QEBAIXZ	; asmjit::CpuInfo::getVendorId
	cmp	eax, 2
	jne	$LN51@align
	mov	rcx, QWORD PTR cpuInfo$4[rsp]
	call	?getFamily@CpuInfo@asmjit@@QEBAIXZ	; asmjit::CpuInfo::getFamily
	cmp	eax, 15
	jb	$LN51@align
$LN18@align:

; 484  :         do {
; 485  :           switch (i) {

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR tv222[rsp], eax
	mov	eax, DWORD PTR tv222[rsp]
	dec	eax
	mov	DWORD PTR tv222[rsp], eax
	cmp	DWORD PTR tv222[rsp], 9
	ja	$LN62@align
	mov	eax, DWORD PTR tv222[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN64@align[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN52@align:

; 486  :             case  1: p = nop1 ; n =  1; break;

	lea	rax, OFFSET FLAT:?nop1@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 1
	jmp	$LN19@align
$LN53@align:

; 487  :             case  2: p = nop2 ; n =  2; break;

	lea	rax, OFFSET FLAT:?nop2@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 2
	jmp	$LN19@align
$LN54@align:

; 488  :             case  3: p = nop3 ; n =  3; break;

	lea	rax, OFFSET FLAT:?nop3@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 3
	jmp	$LN19@align
$LN55@align:

; 489  :             case  4: p = nop4 ; n =  4; break;

	lea	rax, OFFSET FLAT:?nop4@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 4
	jmp	$LN19@align
$LN56@align:

; 490  :             case  5: p = nop5 ; n =  5; break;

	lea	rax, OFFSET FLAT:?nop5@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 5
	jmp	$LN19@align
$LN57@align:

; 491  :             case  6: p = nop6 ; n =  6; break;

	lea	rax, OFFSET FLAT:?nop6@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 6
	jmp	SHORT $LN19@align
$LN58@align:

; 492  :             case  7: p = nop7 ; n =  7; break;

	lea	rax, OFFSET FLAT:?nop7@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 7
	jmp	SHORT $LN19@align
$LN59@align:

; 493  :             case  8: p = nop8 ; n =  8; break;

	lea	rax, OFFSET FLAT:?nop8@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 8
	jmp	SHORT $LN19@align
$LN60@align:

; 494  :             case  9: p = nop9 ; n =  9; break;

	lea	rax, OFFSET FLAT:?nop9@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 9
	jmp	SHORT $LN19@align
$LN61@align:

; 495  :             case 10: p = nop10; n = 10; break;

	lea	rax, OFFSET FLAT:?nop10@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 10
	jmp	SHORT $LN19@align
$LN62@align:

; 496  :             default: p = nop11; n = 11; break;

	lea	rax, OFFSET FLAT:?nop11@?BC@??align@X86Assembler@asmjit@@UEAAIII@Z@4QBEB
	mov	QWORD PTR p$2[rsp], rax
	mov	DWORD PTR n$1[rsp], 11
$LN19@align:

; 497  :           }
; 498  : 
; 499  :           i -= n;

	mov	eax, DWORD PTR n$1[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR i$[rsp], eax
$LN23@align:
$LN26@align:

; 500  :           do {
; 501  :             EMIT_BYTE(*p++);

	mov	rax, QWORD PTR p$2[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv230[rsp], al
	mov	rax, QWORD PTR p$2[rsp]
	inc	rax
	mov	QWORD PTR p$2[rsp], rax
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR tv230[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN26@align

; 502  :           } while (--n);

	mov	eax, DWORD PTR n$1[rsp]
	dec	eax
	mov	DWORD PTR n$1[rsp], eax
	cmp	DWORD PTR n$1[rsp], 0
	jne	SHORT $LN23@align

; 503  :         } while (i);

	cmp	DWORD PTR i$[rsp], 0
	jne	$LN18@align
$LN51@align:
$LN40@align:
$LN38@align:
$LN37@align:
$LN27@align:

; 504  :       }
; 505  :     }
; 506  :   }
; 507  : 
; 508  :   while (i) {

	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN28@align
$LN31@align:

; 509  :     EMIT_BYTE(alignPattern);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	movzx	edx, BYTE PTR alignPattern$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR cursor$[rsp]
	inc	rax
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN31@align

; 510  :     i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 511  :   }

	jmp	SHORT $LN27@align
$LN28@align:

; 512  : 
; 513  :   setCursor(cursor);

	mov	rdx, QWORD PTR cursor$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setCursor@Assembler@asmjit@@QEAAXPEAE@Z ; asmjit::Assembler::setCursor

; 514  :   return kErrorOk;

	xor	eax, eax
$LN1@align:

; 515  : }

	add	rsp, 120				; 00000078H
	ret	0
	npad	1
$LN65@align:
	DD	$LN42@align
	DD	$LN43@align
	DD	$LN44@align
	DD	$LN45@align
	DD	$LN46@align
	DD	$LN47@align
	DD	$LN48@align
	DD	$LN49@align
$LN64@align:
	DD	$LN52@align
	DD	$LN53@align
	DD	$LN54@align
	DD	$LN55@align
	DD	$LN56@align
	DD	$LN57@align
	DD	$LN58@align
	DD	$LN59@align
	DD	$LN60@align
	DD	$LN61@align
?align@X86Assembler@asmjit@@UEAAIII@Z ENDP		; asmjit::X86Assembler::align
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
regSize$ = 32
cursor$ = 40
errval_$1 = 48
link$2 = 56
label$ = 64
tv182 = 72
rd$ = 80
__$ArrayPad$ = 104
this$ = 128
op$ = 136
?embedLabel@X86Assembler@asmjit@@QEAAIAEBULabel@2@@Z PROC ; asmjit::X86Assembler::embedLabel

; 352  : Error X86Assembler::embedLabel(const Label& op) {

$LN19:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 353  :   ASMJIT_ASSERT(op.getId() != kInvalidValue);
; 354  :   uint32_t regSize = _regSize;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	mov	DWORD PTR regSize$[rsp], eax

; 355  : 
; 356  :   if (getRemainingSpace() < regSize)

	mov	rcx, QWORD PTR this$[rsp]
	call	?getRemainingSpace@Assembler@asmjit@@QEBA_KXZ ; asmjit::Assembler::getRemainingSpace
	mov	ecx, DWORD PTR regSize$[rsp]
	cmp	rax, rcx
	jae	SHORT $LN11@embedLabel
$LN4@embedLabel:

; 357  :     ASMJIT_PROPAGATE_ERROR(_grow(regSize));

	mov	eax, DWORD PTR regSize$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow@Assembler@asmjit@@QEAAI_K@Z	; asmjit::Assembler::_grow
	mov	DWORD PTR errval_$1[rsp], eax
	cmp	DWORD PTR errval_$1[rsp], 0
	je	SHORT $LN12@embedLabel
	mov	eax, DWORD PTR errval_$1[rsp]
	jmp	$LN1@embedLabel
$LN12@embedLabel:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@embedLabel
$LN11@embedLabel:

; 358  : 
; 359  :   uint8_t* cursor = getCursor();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getCursor@Assembler@asmjit@@QEBAPEAEXZ	; asmjit::Assembler::getCursor
	mov	QWORD PTR cursor$[rsp], rax

; 360  : 
; 361  :   LabelData* label = getLabelData(op.getId());

	mov	rcx, QWORD PTR op$[rsp]
	call	?getId@Operand@asmjit@@QEBAIXZ		; asmjit::Operand::getId
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ; asmjit::Assembler::getLabelData
	mov	QWORD PTR label$[rsp], rax

; 362  :   RelocData rd;
; 363  : 
; 364  : #if !defined(ASMJIT_DISABLE_LOGGER)
; 365  :   if (_logger)
; 366  :     _logger->logFormat(kLoggerStyleData, regSize == 4 ? ".dd L%u\n" : ".dq L%u\n", op.getId());
; 367  : #endif // !ASMJIT_DISABLE_LOGGER
; 368  : 
; 369  :   rd.type = kRelocRelToAbs;

	mov	DWORD PTR rd$[rsp], 1

; 370  :   rd.size = regSize;

	mov	eax, DWORD PTR regSize$[rsp]
	mov	DWORD PTR rd$[rsp+4], eax

; 371  :   rd.from = static_cast<Ptr>(getOffset());

	mov	rcx, QWORD PTR this$[rsp]
	call	?getOffset@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getOffset
	mov	QWORD PTR rd$[rsp+8], rax

; 372  :   rd.data = 0;

	mov	QWORD PTR rd$[rsp+16], 0

; 373  : 
; 374  :   if (label->offset != -1) {

	mov	rax, QWORD PTR label$[rsp]
	cmp	QWORD PTR [rax], -1
	je	SHORT $LN13@embedLabel

; 375  :     // Bound label.
; 376  :     rd.data = static_cast<Ptr>(static_cast<SignedPtr>(label->offset));

	mov	rax, QWORD PTR label$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR rd$[rsp+16], rax

; 377  :   }

	jmp	SHORT $LN14@embedLabel
$LN13@embedLabel:

; 378  :   else {
; 379  :     // Non-bound label. Need to chain.
; 380  :     LabelLink* link = _newLabelLink();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_newLabelLink@Assembler@asmjit@@QEAAPEAULabelLink@2@XZ ; asmjit::Assembler::_newLabelLink
	mov	QWORD PTR link$2[rsp], rax

; 381  : 
; 382  :     link->prev = (LabelLink*)label->links;

	mov	rax, QWORD PTR link$2[rsp]
	mov	rcx, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 383  :     link->offset = getOffset();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getOffset@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getOffset
	mov	rcx, QWORD PTR link$2[rsp]
	mov	QWORD PTR [rcx+8], rax

; 384  :     link->displacement = 0;

	mov	rax, QWORD PTR link$2[rsp]
	mov	QWORD PTR [rax+16], 0

; 385  :     link->relocId = _relocList.getLength();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	?getLength@?$PodVector@URelocData@asmjit@@@asmjit@@QEBA_KXZ ; asmjit::PodVector<asmjit::RelocData>::getLength
	mov	rcx, QWORD PTR link$2[rsp]
	mov	QWORD PTR [rcx+24], rax

; 386  : 
; 387  :     label->links = link;

	mov	rax, QWORD PTR label$[rsp]
	mov	rcx, QWORD PTR link$2[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN14@embedLabel:

; 388  :   }
; 389  : 
; 390  :   if (_relocList.append(rd) != kErrorOk)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR tv182[rsp], rax
	lea	rdx, QWORD PTR rd$[rsp]
	mov	rcx, QWORD PTR tv182[rsp]
	call	?append@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAIAEBURelocData@2@@Z ; asmjit::PodVector<asmjit::RelocData>::append
	test	eax, eax
	je	SHORT $LN15@embedLabel

; 391  :     return setError(kErrorNoHeapMemory);

	xor	r8d, r8d
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?setError@CodeGen@asmjit@@QEAAIIPEBD@Z	; asmjit::CodeGen::setError
	jmp	SHORT $LN1@embedLabel
$LN15@embedLabel:

; 392  : 
; 393  :   // Emit dummy intptr_t (4 or 8 bytes; depends on the address size).
; 394  :   if (regSize == 4)

	cmp	DWORD PTR regSize$[rsp], 4
	jne	SHORT $LN16@embedLabel
$LN7@embedLabel:

; 395  :     EMIT_DWORD(0);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	DWORD PTR [rcx+rax], 0
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 4
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@embedLabel
	jmp	SHORT $LN17@embedLabel
$LN16@embedLabel:
$LN10@embedLabel:

; 396  :   else
; 397  :     EMIT_QWORD(0);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	QWORD PTR [rcx+rax], 0
	mov	rax, QWORD PTR cursor$[rsp]
	add	rax, 8
	mov	QWORD PTR cursor$[rsp], rax
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN10@embedLabel
$LN17@embedLabel:

; 398  : 
; 399  :   setCursor(cursor);

	mov	rdx, QWORD PTR cursor$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setCursor@Assembler@asmjit@@QEAAXPEAE@Z ; asmjit::Assembler::setCursor

; 400  :   return kErrorOk;

	xor	eax, eax
$LN1@embedLabel:

; 401  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?embedLabel@X86Assembler@asmjit@@QEAAIAEBULabel@2@@Z ENDP ; asmjit::X86Assembler::embedLabel
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
this$ = 48
arch$ = 56
?setArch@X86Assembler@asmjit@@QEAAII@Z PROC		; asmjit::X86Assembler::setArch

; 311  : Error X86Assembler::setArch(uint32_t arch) {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 312  : #if defined(ASMJIT_BUILD_X86)
; 313  :   if (arch == kArchX86) {
; 314  :     _arch = kArchX86;
; 315  :     _regSize = 4;
; 316  : 
; 317  :     _regCount.reset();
; 318  :     _regCount._gp  = 8;
; 319  :     _regCount._mm  = 8;
; 320  :     _regCount._k   = 8;
; 321  :     _regCount._xyz = 8;
; 322  :     ::memcpy(&zax, &x86RegData.gpd, sizeof(Operand) * 8);
; 323  : 
; 324  :     return kErrorOk;
; 325  :   }
; 326  : #endif // ASMJIT_BUILD_X86
; 327  : 
; 328  : #if defined(ASMJIT_BUILD_X64)
; 329  :   if (arch == kArchX64) {

	cmp	DWORD PTR arch$[rsp], 2
	jne	SHORT $LN2@setArch

; 330  :     _arch = kArchX64;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+40], 2

; 331  :     _regSize = 8;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+41], 8

; 332  : 
; 333  :     _regCount.reset();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 136				; 00000088H
	mov	rcx, rax
	call	?reset@X86RegCount@asmjit@@QEAAXXZ	; asmjit::X86RegCount::reset

; 334  :     _regCount._gp  = 16;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+136], 16

; 335  :     _regCount._mm  = 8;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+137], 8

; 336  :     _regCount._k   = 8;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+138], 8

; 337  :     _regCount._xyz = 16;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+139], 16

; 338  :     ::memcpy(&zax, &x86RegData.gpq, sizeof(Operand) * 8);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 144				; 00000090H
	mov	r8d, 128				; 00000080H
	lea	rdx, OFFSET FLAT:?x86RegData@asmjit@@3UX86RegData@1@B+976
	mov	rcx, rax
	call	memcpy

; 339  : 
; 340  :     return kErrorOk;

	xor	eax, eax
	jmp	SHORT $LN1@setArch
$LN2@setArch:

; 341  :   }
; 342  : #endif // ASMJIT_BUILD_X64
; 343  : 
; 344  :   ASMJIT_ASSERT(!"Reached");
; 345  :   return kErrorInvalidArgument;

	mov	eax, 3
$LN1@setArch:

; 346  : }

	add	rsp, 40					; 00000028H
	ret	0
?setArch@X86Assembler@asmjit@@QEAAII@Z ENDP		; asmjit::X86Assembler::setArch
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
this$ = 48
??1X86Assembler@asmjit@@UEAA@XZ PROC			; asmjit::X86Assembler::~X86Assembler

; 305  : X86Assembler::~X86Assembler() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7X86Assembler@asmjit@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR this$[rsp]
	call	??1Assembler@asmjit@@UEAA@XZ		; asmjit::Assembler::~Assembler
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1X86Assembler@asmjit@@UEAA@XZ ENDP			; asmjit::X86Assembler::~X86Assembler
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1X86Assembler@asmjit@@UEAA@XZ@4HA PROC	; `asmjit::X86Assembler::~X86Assembler'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1Assembler@asmjit@@UEAA@XZ		; asmjit::Assembler::~Assembler
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1X86Assembler@asmjit@@UEAA@XZ@4HA ENDP	; `asmjit::X86Assembler::~X86Assembler'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86assembler.cpp
_TEXT	SEGMENT
tv86 = 32
tv91 = 40
tv128 = 48
tv133 = 56
tv138 = 64
tv143 = 72
tv148 = 80
tv153 = 88
this$ = 112
runtime$ = 120
arch$ = 128
??0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z PROC	; asmjit::X86Assembler::X86Assembler

; 300  :   zdi(NoInit) {

$LN4:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 292  :   Assembler(runtime),

	mov	rdx, QWORD PTR runtime$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0Assembler@asmjit@@QEAA@PEAURuntime@1@@Z ; asmjit::Assembler::Assembler
	npad	1

; 300  :   zdi(NoInit) {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7X86Assembler@asmjit@@6B@
	mov	QWORD PTR [rax], rcx

; 293  :   zax(NoInit),

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 144				; 00000090H
	mov	QWORD PTR tv86[rsp], rax
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR tv86[rsp]
	call	??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::X86GpReg::X86GpReg

; 294  :   zcx(NoInit),

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 160				; 000000a0H
	mov	QWORD PTR tv91[rsp], rax
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR tv91[rsp]
	call	??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::X86GpReg::X86GpReg

; 295  :   zdx(NoInit),

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 176				; 000000b0H
	mov	QWORD PTR tv128[rsp], rax
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR tv128[rsp]
	call	??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::X86GpReg::X86GpReg

; 296  :   zbx(NoInit),

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 192				; 000000c0H
	mov	QWORD PTR tv133[rsp], rax
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR tv133[rsp]
	call	??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::X86GpReg::X86GpReg

; 297  :   zsp(NoInit),

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 208				; 000000d0H
	mov	QWORD PTR tv138[rsp], rax
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR tv138[rsp]
	call	??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::X86GpReg::X86GpReg

; 298  :   zbp(NoInit),

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 224				; 000000e0H
	mov	QWORD PTR tv143[rsp], rax
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR tv143[rsp]
	call	??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::X86GpReg::X86GpReg

; 299  :   zsi(NoInit),

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 240				; 000000f0H
	mov	QWORD PTR tv148[rsp], rax
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR tv148[rsp]
	call	??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::X86GpReg::X86GpReg

; 300  :   zdi(NoInit) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR tv153[rsp], rax
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR tv153[rsp]
	call	??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::X86GpReg::X86GpReg

; 301  : 
; 302  :   setArch(arch);

	mov	edx, DWORD PTR arch$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setArch@X86Assembler@asmjit@@QEAAII@Z	; asmjit::X86Assembler::setArch
	npad	1

; 303  : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 104				; 00000068H
	ret	0
??0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z ENDP	; asmjit::X86Assembler::X86Assembler
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
tv86 = 32
tv91 = 40
tv128 = 48
tv133 = 56
tv138 = 64
tv143 = 72
tv148 = 80
tv153 = 88
this$ = 112
runtime$ = 120
arch$ = 128
?dtor$0@?0???0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z@4HA PROC ; `asmjit::X86Assembler::X86Assembler'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1Assembler@asmjit@@UEAA@XZ		; asmjit::Assembler::~Assembler
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0X86Assembler@asmjit@@QEAA@PEAURuntime@1@I@Z@4HA ENDP ; `asmjit::X86Assembler::X86Assembler'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?getDisplacement@X86Mem@asmjit@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?getDisplacement@X86Mem@asmjit@@QEBAHXZ PROC		; asmjit::X86Mem::getDisplacement, COMDAT

; 1464 :   ASMJIT_INLINE int32_t getDisplacement() const {

	mov	QWORD PTR [rsp+8], rcx

; 1465 :     return _vmem.displacement;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+12]

; 1466 :   }

	ret	0
?getDisplacement@X86Mem@asmjit@@QEBAHXZ ENDP		; asmjit::X86Mem::getDisplacement
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?getShift@X86Mem@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getShift@X86Mem@asmjit@@QEBAIXZ PROC			; asmjit::X86Mem::getShift, COMDAT

; 1448 :   ASMJIT_INLINE uint32_t getShift() const {

	mov	QWORD PTR [rsp+8], rcx

; 1449 :     return _vmem.flags >> kX86MemShiftIndex;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	sar	eax, 6

; 1450 :   }

	ret	0
?getShift@X86Mem@asmjit@@QEBAIXZ ENDP			; asmjit::X86Mem::getShift
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?hasBaseOrIndex@X86Mem@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv78 = 0
this$ = 32
?hasBaseOrIndex@X86Mem@asmjit@@QEBA_NXZ PROC		; asmjit::X86Mem::hasBaseOrIndex, COMDAT

; 1429 :   ASMJIT_INLINE bool hasBaseOrIndex() const {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1430 :     return _vmem.base != kInvalidValue || _vmem.index != kInvalidValue;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], -1			; ffffffffH
	jne	SHORT $LN3@hasBaseOrI
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+8], -1			; ffffffffH
	jne	SHORT $LN3@hasBaseOrI
	mov	DWORD PTR tv78[rsp], 0
	jmp	SHORT $LN4@hasBaseOrI
$LN3@hasBaseOrI:
	mov	DWORD PTR tv78[rsp], 1
$LN4@hasBaseOrI:
	movzx	eax, BYTE PTR tv78[rsp]

; 1431 :   }

	add	rsp, 24
	ret	0
?hasBaseOrIndex@X86Mem@asmjit@@QEBA_NXZ ENDP		; asmjit::X86Mem::hasBaseOrIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?getIndex@X86Mem@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getIndex@X86Mem@asmjit@@QEBAIXZ PROC			; asmjit::X86Mem::getIndex, COMDAT

; 1333 :   ASMJIT_INLINE uint32_t getIndex() const {

	mov	QWORD PTR [rsp+8], rcx

; 1334 :     return _vmem.index;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]

; 1335 :   }

	ret	0
?getIndex@X86Mem@asmjit@@QEBAIXZ ENDP			; asmjit::X86Mem::getIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?getBase@X86Mem@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getBase@X86Mem@asmjit@@QEBAIXZ PROC			; asmjit::X86Mem::getBase, COMDAT

; 1313 :   ASMJIT_INLINE uint32_t getBase() const {

	mov	QWORD PTR [rsp+8], rcx

; 1314 :     return _vmem.base;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]

; 1315 :   }

	ret	0
?getBase@X86Mem@asmjit@@QEBAIXZ ENDP			; asmjit::X86Mem::getBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?getVSib@X86Mem@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getVSib@X86Mem@asmjit@@QEBAIXZ PROC			; asmjit::X86Mem::getVSib, COMDAT

; 1282 :   ASMJIT_INLINE uint32_t getVSib() const {

	mov	QWORD PTR [rsp+8], rcx

; 1283 :     return (static_cast<uint32_t>(_vmem.flags) >> kX86MemVSibIndex) & kX86MemVSibBits;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	shr	eax, 4
	and	eax, 3

; 1284 :   }

	ret	0
?getVSib@X86Mem@asmjit@@QEBAIXZ ENDP			; asmjit::X86Mem::getVSib
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?hasGpdBase@X86Mem@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv85 = 32
tv80 = 36
tv82 = 40
this$ = 64
?hasGpdBase@X86Mem@asmjit@@QEBA_NXZ PROC		; asmjit::X86Mem::hasGpdBase, COMDAT

; 1260 :   ASMJIT_INLINE bool hasGpdBase() const {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1261 :     return (_packed[0].u32[0] & IntUtil::pack32_4x8(0x00, 0x00, 0x00, kX86MemGpdMask)) != 0;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	eax, DWORD PTR [rax+rcx]
	mov	DWORD PTR tv82[rsp], eax
	mov	r9d, 8
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z	; asmjit::IntUtil::pack32_4x8
	mov	DWORD PTR tv80[rsp], eax
	mov	eax, DWORD PTR tv80[rsp]
	mov	ecx, DWORD PTR tv82[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN3@hasGpdBase
	mov	DWORD PTR tv85[rsp], 1
	jmp	SHORT $LN4@hasGpdBase
$LN3@hasGpdBase:
	mov	DWORD PTR tv85[rsp], 0
$LN4@hasGpdBase:
	movzx	eax, BYTE PTR tv85[rsp]

; 1262 :   }

	add	rsp, 56					; 00000038H
	ret	0
?hasGpdBase@X86Mem@asmjit@@QEBA_NXZ ENDP		; asmjit::X86Mem::hasGpdBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?getSegment@X86Mem@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getSegment@X86Mem@asmjit@@QEBAIXZ PROC			; asmjit::X86Mem::getSegment, COMDAT

; 1239 :   ASMJIT_INLINE uint32_t getSegment() const {

	mov	QWORD PTR [rsp+8], rcx

; 1240 :     return (static_cast<uint32_t>(_vmem.flags) >> kX86MemSegIndex) & kX86MemSegBits;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	and	eax, 7

; 1241 :   }

	ret	0
?getSegment@X86Mem@asmjit@@QEBAIXZ ENDP			; asmjit::X86Mem::getSegment
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?hasSegment@X86Mem@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv73 = 0
this$ = 32
?hasSegment@X86Mem@asmjit@@QEBA_NXZ PROC		; asmjit::X86Mem::hasSegment, COMDAT

; 1234 :   ASMJIT_INLINE bool hasSegment() const {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1235 :     return (_vmem.flags & kX86MemSegMask) != (kX86SegDefault << kX86MemSegIndex);

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	and	eax, 7
	test	eax, eax
	je	SHORT $LN3@hasSegment
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN4@hasSegment
$LN3@hasSegment:
	mov	DWORD PTR tv73[rsp], 0
$LN4@hasSegment:
	movzx	eax, BYTE PTR tv73[rsp]

; 1236 :   }

	add	rsp, 24
	ret	0
?hasSegment@X86Mem@asmjit@@QEBA_NXZ ENDP		; asmjit::X86Mem::hasSegment
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z PROC		; asmjit::X86GpReg::X86GpReg, COMDAT

; 785  :   explicit ASMJIT_INLINE X86GpReg(const _NoInit&) : X86Reg(NoInit) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR this$[rsp]
	call	??0X86Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z	; asmjit::X86Reg::X86Reg
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0X86GpReg@asmjit@@QEAA@AEBU_NoInit@1@@Z ENDP		; asmjit::X86GpReg::X86GpReg
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?isGpbReg@X86Reg@asmjit@@SA_NAEBUOperand@2@@Z
_TEXT	SEGMENT
tv80 = 32
mask$ = 36
tv74 = 40
op$ = 64
?isGpbReg@X86Reg@asmjit@@SA_NAEBUOperand@2@@Z PROC	; asmjit::X86Reg::isGpbReg, COMDAT

; 706  :   static ASMJIT_INLINE bool isGpbReg(const Operand& op) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 707  :     const uint32_t mask = IntUtil::pack32_2x8_1x16(

	mov	r8d, 64512				; 0000fc00H
	mov	edx, 255				; 000000ffH
	mov	ecx, 255				; 000000ffH
	call	?pack32_2x8_1x16@IntUtil@asmjit@@SAIIII@Z ; asmjit::IntUtil::pack32_2x8_1x16
	mov	DWORD PTR mask$[rsp], eax

; 708  :       0xFF, 0xFF, ~(_kX86RegTypePatchedGpbHi << 8) & 0xFF00);
; 709  : 
; 710  :     return (op._packed[0].u32[0] & mask) == IntUtil::pack32_2x8_1x16(kOperandTypeReg, 1, 0x0000);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR op$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, DWORD PTR mask$[rsp]
	mov	eax, DWORD PTR [rax+rcx]
	and	eax, edx
	mov	DWORD PTR tv74[rsp], eax
	xor	r8d, r8d
	mov	edx, 1
	mov	ecx, 1
	call	?pack32_2x8_1x16@IntUtil@asmjit@@SAIIII@Z ; asmjit::IntUtil::pack32_2x8_1x16
	mov	ecx, DWORD PTR tv74[rsp]
	cmp	ecx, eax
	jne	SHORT $LN3@isGpbReg
	mov	DWORD PTR tv80[rsp], 1
	jmp	SHORT $LN4@isGpbReg
$LN3@isGpbReg:
	mov	DWORD PTR tv80[rsp], 0
$LN4@isGpbReg:
	movzx	eax, BYTE PTR tv80[rsp]

; 711  :   }

	add	rsp, 56					; 00000038H
	ret	0
?isGpbReg@X86Reg@asmjit@@SA_NAEBUOperand@2@@Z ENDP	; asmjit::X86Reg::isGpbReg
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?isSeg@X86Reg@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 0
this$ = 32
?isSeg@X86Reg@asmjit@@QEBA_NXZ PROC			; asmjit::X86Reg::isSeg, COMDAT

; 699  :   ASMJIT_INLINE bool isSeg() const { return _vreg.type == kX86RegTypeSeg; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	cmp	eax, 240				; 000000f0H
	jne	SHORT $LN3@isSeg
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@isSeg
$LN3@isSeg:
	mov	DWORD PTR tv72[rsp], 0
$LN4@isSeg:
	movzx	eax, BYTE PTR tv72[rsp]
	add	rsp, 24
	ret	0
?isSeg@X86Reg@asmjit@@QEBA_NXZ ENDP			; asmjit::X86Reg::isSeg
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?isYmm@X86Reg@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 0
this$ = 32
?isYmm@X86Reg@asmjit@@QEBA_NXZ PROC			; asmjit::X86Reg::isYmm, COMDAT

; 692  :   ASMJIT_INLINE bool isYmm() const { return _vreg.type == kX86RegTypeYmm; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN3@isYmm
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@isYmm
$LN3@isYmm:
	mov	DWORD PTR tv72[rsp], 0
$LN4@isYmm:
	movzx	eax, BYTE PTR tv72[rsp]
	add	rsp, 24
	ret	0
?isYmm@X86Reg@asmjit@@QEBA_NXZ ENDP			; asmjit::X86Reg::isYmm
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?isXmm@X86Reg@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 0
this$ = 32
?isXmm@X86Reg@asmjit@@QEBA_NXZ PROC			; asmjit::X86Reg::isXmm, COMDAT

; 690  :   ASMJIT_INLINE bool isXmm() const { return _vreg.type == kX86RegTypeXmm; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	cmp	eax, 112				; 00000070H
	jne	SHORT $LN3@isXmm
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@isXmm
$LN3@isXmm:
	mov	DWORD PTR tv72[rsp], 0
$LN4@isXmm:
	movzx	eax, BYTE PTR tv72[rsp]
	add	rsp, 24
	ret	0
?isXmm@X86Reg@asmjit@@QEBA_NXZ ENDP			; asmjit::X86Reg::isXmm
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?isMm@X86Reg@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 0
this$ = 32
?isMm@X86Reg@asmjit@@QEBA_NXZ PROC			; asmjit::X86Reg::isMm, COMDAT

; 684  :   ASMJIT_INLINE bool isMm() const { return _vreg.type == kX86RegTypeMm; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	cmp	eax, 80					; 00000050H
	jne	SHORT $LN3@isMm
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@isMm
$LN3@isMm:
	mov	DWORD PTR tv72[rsp], 0
$LN4@isMm:
	movzx	eax, BYTE PTR tv72[rsp]
	add	rsp, 24
	ret	0
?isMm@X86Reg@asmjit@@QEBA_NXZ ENDP			; asmjit::X86Reg::isMm
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?isGpq@X86Reg@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 0
this$ = 32
?isGpq@X86Reg@asmjit@@QEBA_NXZ PROC			; asmjit::X86Reg::isGpq, COMDAT

; 679  :   ASMJIT_INLINE bool isGpq() const { return _vreg.type == kX86RegTypeGpq; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN3@isGpq
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@isGpq
$LN3@isGpq:
	mov	DWORD PTR tv72[rsp], 0
$LN4@isGpq:
	movzx	eax, BYTE PTR tv72[rsp]
	add	rsp, 24
	ret	0
?isGpq@X86Reg@asmjit@@QEBA_NXZ ENDP			; asmjit::X86Reg::isGpq
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?isGpbLo@X86Reg@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 0
this$ = 32
?isGpbLo@X86Reg@asmjit@@QEBA_NXZ PROC			; asmjit::X86Reg::isGpbLo, COMDAT

; 671  :   ASMJIT_INLINE bool isGpbLo() const { return _vreg.type == kX86RegTypeGpbLo; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	cmp	eax, 1
	jne	SHORT $LN3@isGpbLo
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@isGpbLo
$LN3@isGpbLo:
	mov	DWORD PTR tv72[rsp], 0
$LN4@isGpbLo:
	movzx	eax, BYTE PTR tv72[rsp]
	add	rsp, 24
	ret	0
?isGpbLo@X86Reg@asmjit@@QEBA_NXZ ENDP			; asmjit::X86Reg::isGpbLo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?isGp@X86Reg@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 0
this$ = 32
?isGp@X86Reg@asmjit@@QEBA_NXZ PROC			; asmjit::X86Reg::isGp, COMDAT

; 667  :   ASMJIT_INLINE bool isGp() const { return _vreg.type <= kX86RegTypeGpq; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	cmp	eax, 48					; 00000030H
	ja	SHORT $LN3@isGp
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@isGp
$LN3@isGp:
	mov	DWORD PTR tv72[rsp], 0
$LN4@isGp:
	movzx	eax, BYTE PTR tv72[rsp]
	add	rsp, 24
	ret	0
?isGp@X86Reg@asmjit@@QEBA_NXZ ENDP			; asmjit::X86Reg::isGp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ??0X86Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??0X86Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z PROC		; asmjit::X86Reg::X86Reg, COMDAT

; 658  :   explicit ASMJIT_INLINE X86Reg(const _NoInit&) : Reg(NoInit) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR this$[rsp]
	call	??0Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z	; asmjit::Reg::Reg
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0X86Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z ENDP		; asmjit::X86Reg::X86Reg
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?reset@X86RegCount@asmjit@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?reset@X86RegCount@asmjit@@QEAAXXZ PROC			; asmjit::X86RegCount::reset, COMDAT

; 299  :   ASMJIT_INLINE void reset() {

	mov	QWORD PTR [rsp+8], rcx

; 300  :     _packed = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0

; 301  :   }

	ret	0
?reset@X86RegCount@asmjit@@QEAAXXZ ENDP			; asmjit::X86RegCount::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86inst.h
;	COMDAT ?getPrimaryOpCode@X86InstInfo@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getPrimaryOpCode@X86InstInfo@asmjit@@QEBAIXZ PROC	; asmjit::X86InstInfo::getPrimaryOpCode, COMDAT

; 2279 :   ASMJIT_INLINE uint32_t getPrimaryOpCode() const {

	mov	QWORD PTR [rsp+8], rcx

; 2280 :     return _primaryOpCode;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]

; 2281 :   }

	ret	0
?getPrimaryOpCode@X86InstInfo@asmjit@@QEBAIXZ ENDP	; asmjit::X86InstInfo::getPrimaryOpCode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86inst.h
;	COMDAT ?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z
_TEXT	SEGMENT
tv68 = 32
this$ = 64
flag$ = 72
?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z PROC		; asmjit::X86InstInfo::hasInstFlag, COMDAT

; 2233 :   ASMJIT_INLINE bool hasInstFlag(uint32_t flag) const {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2234 :     return (getInstFlags() & flag) != 0;

	mov	rcx, QWORD PTR this$[rsp]
	call	?getInstFlags@X86InstInfo@asmjit@@QEBAIXZ ; asmjit::X86InstInfo::getInstFlags
	and	eax, DWORD PTR flag$[rsp]
	test	eax, eax
	je	SHORT $LN3@hasInstFla
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@hasInstFla
$LN3@hasInstFla:
	mov	DWORD PTR tv68[rsp], 0
$LN4@hasInstFla:
	movzx	eax, BYTE PTR tv68[rsp]

; 2235 :   }

	add	rsp, 56					; 00000038H
	ret	0
?hasInstFlag@X86InstInfo@asmjit@@QEBA_NI@Z ENDP		; asmjit::X86InstInfo::hasInstFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86inst.h
;	COMDAT ?getInstFlags@X86InstInfo@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 48
?getInstFlags@X86InstInfo@asmjit@@QEBAIXZ PROC		; asmjit::X86InstInfo::getInstFlags, COMDAT

; 2228 :   ASMJIT_INLINE uint32_t getInstFlags() const {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2229 :     return getExtendedInfo().getInstFlags();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getExtendedInfo@X86InstInfo@asmjit@@QEBAAEBUX86InstExtendedInfo@2@XZ ; asmjit::X86InstInfo::getExtendedInfo
	mov	rcx, rax
	call	?getInstFlags@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getInstFlags

; 2230 :   }

	add	rsp, 40					; 00000028H
	ret	0
?getInstFlags@X86InstInfo@asmjit@@QEBAIXZ ENDP		; asmjit::X86InstInfo::getInstFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86inst.h
;	COMDAT ?getEncodingId@X86InstInfo@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 48
?getEncodingId@X86InstInfo@asmjit@@QEBAIXZ PROC		; asmjit::X86InstInfo::getEncodingId, COMDAT

; 2219 :   ASMJIT_INLINE uint32_t getEncodingId() const {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2220 :     return getExtendedInfo().getEncodingId();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getExtendedInfo@X86InstInfo@asmjit@@QEBAAEBUX86InstExtendedInfo@2@XZ ; asmjit::X86InstInfo::getExtendedInfo
	mov	rcx, rax
	call	?getEncodingId@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getEncodingId

; 2221 :   }

	add	rsp, 40					; 00000028H
	ret	0
?getEncodingId@X86InstInfo@asmjit@@QEBAIXZ ENDP		; asmjit::X86InstInfo::getEncodingId
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86inst.h
;	COMDAT ?getExtendedInfo@X86InstInfo@asmjit@@QEBAAEBUX86InstExtendedInfo@2@XZ
_TEXT	SEGMENT
this$ = 8
?getExtendedInfo@X86InstInfo@asmjit@@QEBAAEBUX86InstExtendedInfo@2@XZ PROC ; asmjit::X86InstInfo::getExtendedInfo, COMDAT

; 2205 :   ASMJIT_INLINE const X86InstExtendedInfo& getExtendedInfo() const {

	mov	QWORD PTR [rsp+8], rcx

; 2206 :     return _x86InstExtendedInfo[_extendedIndex];

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rax+2]
	imul	rax, rax, 24
	lea	rcx, OFFSET FLAT:?_x86InstExtendedInfo@asmjit@@3QBUX86InstExtendedInfo@1@B ; asmjit::_x86InstExtendedInfo
	add	rcx, rax
	mov	rax, rcx

; 2207 :   }

	ret	0
?getExtendedInfo@X86InstInfo@asmjit@@QEBAAEBUX86InstExtendedInfo@2@XZ ENDP ; asmjit::X86InstInfo::getExtendedInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86inst.h
;	COMDAT ?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ PROC ; asmjit::X86InstExtendedInfo::getSecondaryOpCode, COMDAT

; 2133 :   ASMJIT_INLINE uint32_t getSecondaryOpCode() const {

	mov	QWORD PTR [rsp+8], rcx

; 2134 :     return _secondaryOpCode;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+20]

; 2135 :   }

	ret	0
?getSecondaryOpCode@X86InstExtendedInfo@asmjit@@QEBAIXZ ENDP ; asmjit::X86InstExtendedInfo::getSecondaryOpCode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86inst.h
;	COMDAT ?isLockable@X86InstExtendedInfo@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv68 = 32
this$ = 64
?isLockable@X86InstExtendedInfo@asmjit@@QEBA_NXZ PROC	; asmjit::X86InstExtendedInfo::isLockable, COMDAT

; 2063 :   ASMJIT_INLINE bool isLockable() const {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2064 :     return (getInstFlags() & kX86InstFlagLock) != 0;

	mov	rcx, QWORD PTR this$[rsp]
	call	?getInstFlags@X86InstExtendedInfo@asmjit@@QEBAIXZ ; asmjit::X86InstExtendedInfo::getInstFlags
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN3@isLockable
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@isLockable
$LN3@isLockable:
	mov	DWORD PTR tv68[rsp], 0
$LN4@isLockable:
	movzx	eax, BYTE PTR tv68[rsp]

; 2065 :   }

	add	rsp, 56					; 00000038H
	ret	0
?isLockable@X86InstExtendedInfo@asmjit@@QEBA_NXZ ENDP	; asmjit::X86InstExtendedInfo::isLockable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86inst.h
;	COMDAT ?getInstFlags@X86InstExtendedInfo@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getInstFlags@X86InstExtendedInfo@asmjit@@QEBAIXZ PROC	; asmjit::X86InstExtendedInfo::getInstFlags, COMDAT

; 2020 :   ASMJIT_INLINE uint32_t getInstFlags() const {

	mov	QWORD PTR [rsp+8], rcx

; 2021 :     return _instFlags;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+16]

; 2022 :   }

	ret	0
?getInstFlags@X86InstExtendedInfo@asmjit@@QEBAIXZ ENDP	; asmjit::X86InstExtendedInfo::getInstFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86inst.h
;	COMDAT ?getEncodingId@X86InstExtendedInfo@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getEncodingId@X86InstExtendedInfo@asmjit@@QEBAIXZ PROC	; asmjit::X86InstExtendedInfo::getEncodingId, COMDAT

; 2006 :   ASMJIT_INLINE uint32_t getEncodingId() const {

	mov	QWORD PTR [rsp+8], rcx

; 2007 :     return _encodingId;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]

; 2008 :   }

	ret	0
?getEncodingId@X86InstExtendedInfo@asmjit@@QEBAIXZ ENDP	; asmjit::X86InstExtendedInfo::getEncodingId
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z PROC ; asmjit::PodVector<asmjit::RelocData>::operator[], COMDAT

; 247  :   ASMJIT_INLINE T& operator[](size_t i) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 248  :     ASMJIT_ASSERT(i < getLength());
; 249  :     return getData()[i];

	mov	rcx, QWORD PTR this$[rsp]
	call	?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ ; asmjit::PodVector<asmjit::RelocData>::getData
	imul	rcx, QWORD PTR i$[rsp], 24
	add	rax, rcx

; 250  :   }

	add	rsp, 40					; 00000028H
	ret	0
??A?$PodVector@URelocData@asmjit@@@asmjit@@QEAAAEAURelocData@1@_K@Z ENDP ; asmjit::PodVector<asmjit::RelocData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?append@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAIAEBURelocData@2@@Z
_TEXT	SEGMENT
errval_$1 = 32
d$ = 40
this$ = 64
item$ = 72
?append@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAIAEBURelocData@2@@Z PROC ; asmjit::PodVector<asmjit::RelocData>::append, COMDAT

; 201  :   Error append(const T& item) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 202  :     PodVectorData* d = _d;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR d$[rsp], rax

; 203  : 
; 204  :     if (d->length == d->capacity) {

	mov	rax, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR d$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN5@append
$LN4@append:

; 205  :       ASMJIT_PROPAGATE_ERROR(_grow(1));

	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAI_K@Z ; asmjit::PodVector<asmjit::RelocData>::_grow
	mov	DWORD PTR errval_$1[rsp], eax
	cmp	DWORD PTR errval_$1[rsp], 0
	je	SHORT $LN6@append
	mov	eax, DWORD PTR errval_$1[rsp]
	jmp	SHORT $LN1@append
$LN6@append:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@append

; 206  :       d = _d;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR d$[rsp], rax
$LN5@append:

; 207  :     }
; 208  : 
; 209  :     ::memcpy(static_cast<T*>(d->getData()) + d->length, &item, sizeof(T));

	mov	rcx, QWORD PTR d$[rsp]
	call	?getData@PodVectorData@asmjit@@QEBAPEAXXZ ; asmjit::PodVectorData::getData
	mov	rcx, QWORD PTR d$[rsp]
	imul	rcx, QWORD PTR [rcx+8], 24
	add	rax, rcx
	mov	r8d, 24
	mov	rdx, QWORD PTR item$[rsp]
	mov	rcx, rax
	call	memcpy

; 210  : 
; 211  :     d->length++;

	mov	rax, QWORD PTR d$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR d$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 212  :     return kErrorOk;

	xor	eax, eax
$LN1@append:

; 213  :   }

	add	rsp, 56					; 00000038H
	ret	0
?append@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAIAEBURelocData@2@@Z ENDP ; asmjit::PodVector<asmjit::RelocData>::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?_grow@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAI_K@Z
_TEXT	SEGMENT
this$ = 48
n$ = 56
?_grow@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAI_K@Z PROC ; asmjit::PodVector<asmjit::RelocData>::_grow, COMDAT

; 153  :   ASMJIT_INLINE Error _grow(size_t n) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 154  :     return PodVectorBase::_grow(n, sizeof(T));

	mov	r8d, 24
	mov	rdx, QWORD PTR n$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_grow@PodVectorBase@asmjit@@IEAAI_K0@Z	; asmjit::PodVectorBase::_grow

; 155  :   }

	add	rsp, 40					; 00000028H
	ret	0
?_grow@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAI_K@Z ENDP ; asmjit::PodVector<asmjit::RelocData>::_grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEBAPEBURelocData@2@XZ
_TEXT	SEGMENT
this$ = 48
?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEBAPEBURelocData@2@XZ PROC ; asmjit::PodVector<asmjit::RelocData>::getData, COMDAT

; 144  :   ASMJIT_INLINE const T* getData() const {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 145  :     return static_cast<const T*>(_d->getData());

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?getData@PodVectorData@asmjit@@QEBAPEAXXZ ; asmjit::PodVectorData::getData

; 146  :   }

	add	rsp, 40					; 00000028H
	ret	0
?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEBAPEBURelocData@2@XZ ENDP ; asmjit::PodVector<asmjit::RelocData>::getData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ
_TEXT	SEGMENT
this$ = 48
?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ PROC ; asmjit::PodVector<asmjit::RelocData>::getData, COMDAT

; 139  :   ASMJIT_INLINE T* getData() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 140  :     return static_cast<T*>(_d->getData());

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?getData@PodVectorData@asmjit@@QEBAPEAXXZ ; asmjit::PodVectorData::getData

; 141  :   }

	add	rsp, 40					; 00000028H
	ret	0
?getData@?$PodVector@URelocData@asmjit@@@asmjit@@QEAAPEAURelocData@2@XZ ENDP ; asmjit::PodVector<asmjit::RelocData>::getData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?getLength@?$PodVector@URelocData@asmjit@@@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getLength@?$PodVector@URelocData@asmjit@@@asmjit@@QEBA_KXZ PROC ; asmjit::PodVector<asmjit::RelocData>::getLength, COMDAT

; 129  :   ASMJIT_INLINE size_t getLength() const {

	mov	QWORD PTR [rsp+8], rcx

; 130  :     return _d->length;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]

; 131  :   }

	ret	0
?getLength@?$PodVector@URelocData@asmjit@@@asmjit@@QEBA_KXZ ENDP ; asmjit::PodVector<asmjit::RelocData>::getLength
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z PROC ; asmjit::PodVector<asmjit::LabelData>::operator[], COMDAT

; 253  :   ASMJIT_INLINE const T& operator[](size_t i) const {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 254  :     ASMJIT_ASSERT(i < getLength());
; 255  :     return getData()[i];

	mov	rcx, QWORD PTR this$[rsp]
	call	?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ ; asmjit::PodVector<asmjit::LabelData>::getData
	imul	rcx, QWORD PTR i$[rsp], 16
	add	rax, rcx

; 256  :   }

	add	rsp, 40					; 00000028H
	ret	0
??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z ENDP ; asmjit::PodVector<asmjit::LabelData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ
_TEXT	SEGMENT
this$ = 48
?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ PROC ; asmjit::PodVector<asmjit::LabelData>::getData, COMDAT

; 144  :   ASMJIT_INLINE const T* getData() const {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 145  :     return static_cast<const T*>(_d->getData());

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?getData@PodVectorData@asmjit@@QEBAPEAXXZ ; asmjit::PodVectorData::getData

; 146  :   }

	add	rsp, 40					; 00000028H
	ret	0
?getData@?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAPEBULabelData@2@XZ ENDP ; asmjit::PodVector<asmjit::LabelData>::getData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z
_TEXT	SEGMENT
tv70 = 32
this$ = 64
id$ = 72
?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z PROC ; asmjit::Assembler::getLabelData, COMDAT

; 375  :   ASMJIT_INLINE LabelData* getLabelData(uint32_t id) const {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 376  :     ASMJIT_ASSERT(isLabelValid(id));
; 377  :     return const_cast<LabelData*>(&_labelList[id]);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 120				; 00000078H
	mov	QWORD PTR tv70[rsp], rax
	mov	eax, DWORD PTR id$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR tv70[rsp]
	call	??A?$PodVector@ULabelData@asmjit@@@asmjit@@QEBAAEBULabelData@1@_K@Z ; asmjit::PodVector<asmjit::LabelData>::operator[]

; 378  :   }

	add	rsp, 56					; 00000038H
	ret	0
?getLabelData@Assembler@asmjit@@QEBAPEAULabelData@2@I@Z ENDP ; asmjit::Assembler::getLabelData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getTrampolineSize@Assembler@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getTrampolineSize@Assembler@asmjit@@QEBA_KXZ PROC	; asmjit::Assembler::getTrampolineSize, COMDAT

; 318  :   ASMJIT_INLINE size_t getTrampolineSize() const {

	mov	QWORD PTR [rsp+8], rcx

; 319  :     return _trampolineSize;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+96]

; 320  :   }

	ret	0
?getTrampolineSize@Assembler@asmjit@@QEBA_KXZ ENDP	; asmjit::Assembler::getTrampolineSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getCodeSize@Assembler@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
tv65 = 32
this$ = 64
?getCodeSize@Assembler@asmjit@@QEBA_KXZ PROC		; asmjit::Assembler::getCodeSize, COMDAT

; 304  :   ASMJIT_INLINE size_t getCodeSize() const {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 305  :     return getOffset() + getTrampolineSize();

	mov	rcx, QWORD PTR this$[rsp]
	call	?getOffset@Assembler@asmjit@@QEBA_KXZ	; asmjit::Assembler::getOffset
	mov	QWORD PTR tv65[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?getTrampolineSize@Assembler@asmjit@@QEBA_KXZ ; asmjit::Assembler::getTrampolineSize
	mov	rcx, QWORD PTR tv65[rsp]
	add	rcx, rax
	mov	rax, rcx

; 306  :   }

	add	rsp, 56					; 00000038H
	ret	0
?getCodeSize@Assembler@asmjit@@QEBA_KXZ ENDP		; asmjit::Assembler::getCodeSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getOffset@Assembler@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getOffset@Assembler@asmjit@@QEBA_KXZ PROC		; asmjit::Assembler::getOffset, COMDAT

; 203  :   ASMJIT_INLINE size_t getOffset() const {

	mov	QWORD PTR [rsp+8], rcx

; 204  :     return (size_t)(_cursor - _buffer);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	mov	rax, QWORD PTR [rax+88]
	sub	rax, rcx

; 205  :   }

	ret	0
?getOffset@Assembler@asmjit@@QEBA_KXZ ENDP		; asmjit::Assembler::getOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?setCursor@Assembler@asmjit@@QEAAXPEAE@Z
_TEXT	SEGMENT
this$ = 8
cursor$ = 16
?setCursor@Assembler@asmjit@@QEAAXPEAE@Z PROC		; asmjit::Assembler::setCursor, COMDAT

; 197  :   ASMJIT_INLINE void setCursor(uint8_t* cursor) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 198  :     ASMJIT_ASSERT(cursor >= _buffer && cursor <= _end);
; 199  :     _cursor = cursor;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR cursor$[rsp]
	mov	QWORD PTR [rax+88], rcx

; 200  :   }

	ret	0
?setCursor@Assembler@asmjit@@QEAAXPEAE@Z ENDP		; asmjit::Assembler::setCursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getCursor@Assembler@asmjit@@QEBAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?getCursor@Assembler@asmjit@@QEBAPEAEXZ PROC		; asmjit::Assembler::getCursor, COMDAT

; 192  :   ASMJIT_INLINE uint8_t* getCursor() const {

	mov	QWORD PTR [rsp+8], rcx

; 193  :     return _cursor;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]

; 194  :   }

	ret	0
?getCursor@Assembler@asmjit@@QEBAPEAEXZ ENDP		; asmjit::Assembler::getCursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\assembler.h
;	COMDAT ?getRemainingSpace@Assembler@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getRemainingSpace@Assembler@asmjit@@QEBA_KXZ PROC	; asmjit::Assembler::getRemainingSpace, COMDAT

; 177  :   ASMJIT_INLINE size_t getRemainingSpace() const {

	mov	QWORD PTR [rsp+8], rcx

; 178  :     return (size_t)(_end - _cursor);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	rax, QWORD PTR [rax+80]
	sub	rax, rcx

; 179  :   }

	ret	0
?getRemainingSpace@Assembler@asmjit@@QEBA_KXZ ENDP	; asmjit::Assembler::getRemainingSpace
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$isInt32@_J@IntUtil@asmjit@@SA_N_J@Z
_TEXT	SEGMENT
tv67 = 0
tv69 = 4
tv73 = 8
tv75 = 12
tv77 = 16
x$ = 48
??$isInt32@_J@IntUtil@asmjit@@SA_N_J@Z PROC		; asmjit::IntUtil::isInt32<__int64>, COMDAT

; 185  :   static ASMJIT_INLINE bool isInt32(T x) {

$LN15:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 186  :     if (IntTraits<T>::kIsSigned)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@isInt32

; 187  :       return sizeof(T) <= sizeof(int32_t) ? true : x >= T(-2147483647) - 1 && x <= T(2147483647);

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN7@isInt32
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN8@isInt32
$LN7@isInt32:
	cmp	QWORD PTR x$[rsp], -2147483648		; ffffffff80000000H
	jl	SHORT $LN5@isInt32
	cmp	QWORD PTR x$[rsp], 2147483647		; 7fffffffH
	jg	SHORT $LN5@isInt32
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN6@isInt32
$LN5@isInt32:
	mov	DWORD PTR tv67[rsp], 0
$LN6@isInt32:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR tv69[rsp], eax
$LN8@isInt32:
	movzx	eax, BYTE PTR tv69[rsp]
	jmp	SHORT $LN1@isInt32
	jmp	SHORT $LN3@isInt32
$LN2@isInt32:

; 188  :     else
; 189  :       return x >= T(0) && (sizeof(T) <= sizeof(int32_t) ? true : x <= T(2147483647));

	cmp	QWORD PTR x$[rsp], 0
	jl	SHORT $LN13@isInt32
	xor	eax, eax
	test	eax, eax
	je	SHORT $LN11@isInt32
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN12@isInt32
$LN11@isInt32:
	cmp	QWORD PTR x$[rsp], 2147483647		; 7fffffffH
	jg	SHORT $LN9@isInt32
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN10@isInt32
$LN9@isInt32:
	mov	DWORD PTR tv73[rsp], 0
$LN10@isInt32:
	mov	eax, DWORD PTR tv73[rsp]
	mov	DWORD PTR tv75[rsp], eax
$LN12@isInt32:
	cmp	DWORD PTR tv75[rsp], 0
	je	SHORT $LN13@isInt32
	mov	DWORD PTR tv77[rsp], 1
	jmp	SHORT $LN14@isInt32
$LN13@isInt32:
	mov	DWORD PTR tv77[rsp], 0
$LN14@isInt32:
	movzx	eax, BYTE PTR tv77[rsp]
$LN3@isInt32:
$LN1@isInt32:

; 190  :   }

	add	rsp, 40					; 00000028H
	ret	0
??$isInt32@_J@IntUtil@asmjit@@SA_N_J@Z ENDP		; asmjit::IntUtil::isInt32<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z
_TEXT	SEGMENT
tv67 = 0
tv69 = 4
tv72 = 8
x$ = 32
??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z PROC		; asmjit::IntUtil::isInt8<__int64>, COMDAT

; 149  :   static ASMJIT_INLINE bool isInt8(T x) {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 150  :     if (IntTraits<T>::kIsSigned)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@isInt8

; 151  :       return sizeof(T) <= sizeof(int8_t) ? true : x >= T(-128) && x <= T(127);

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN7@isInt8
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN8@isInt8
$LN7@isInt8:
	cmp	QWORD PTR x$[rsp], -128			; ffffffffffffff80H
	jl	SHORT $LN5@isInt8
	cmp	QWORD PTR x$[rsp], 127			; 0000007fH
	jg	SHORT $LN5@isInt8
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN6@isInt8
$LN5@isInt8:
	mov	DWORD PTR tv67[rsp], 0
$LN6@isInt8:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR tv69[rsp], eax
$LN8@isInt8:
	movzx	eax, BYTE PTR tv69[rsp]
	jmp	SHORT $LN1@isInt8
	jmp	SHORT $LN3@isInt8
$LN2@isInt8:

; 152  :     else
; 153  :       return x <= T(127);

	cmp	QWORD PTR x$[rsp], 127			; 0000007fH
	jg	SHORT $LN9@isInt8
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN10@isInt8
$LN9@isInt8:
	mov	DWORD PTR tv72[rsp], 0
$LN10@isInt8:
	movzx	eax, BYTE PTR tv72[rsp]
$LN3@isInt8:
$LN1@isInt8:

; 154  :   }

	add	rsp, 24
	ret	0
??$isInt8@_J@IntUtil@asmjit@@SA_N_J@Z ENDP		; asmjit::IntUtil::isInt8<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?getInt64@Imm@asmjit@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?getInt64@Imm@asmjit@@QEBA_JXZ PROC			; asmjit::Imm::getInt64, COMDAT

; 789  :   ASMJIT_INLINE int64_t getInt64() const { return _imm.value._i64[0]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rcx+rax+8]
	ret	0
?getInt64@Imm@asmjit@@QEBA_JXZ ENDP			; asmjit::Imm::getInt64
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?getUInt32@Imm@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getUInt32@Imm@asmjit@@QEBAIXZ PROC			; asmjit::Imm::getUInt32, COMDAT

; 787  :   ASMJIT_INLINE uint32_t getUInt32() const { return _imm.value._u32[_ASMJIT_HOST_INDEX(2, 0)]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rcx+rax+8]
	ret	0
?getUInt32@Imm@asmjit@@QEBAIXZ ENDP			; asmjit::Imm::getUInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?getUInt16@Imm@asmjit@@QEBAGXZ
_TEXT	SEGMENT
this$ = 8
?getUInt16@Imm@asmjit@@QEBAGXZ PROC			; asmjit::Imm::getUInt16, COMDAT

; 783  :   ASMJIT_INLINE uint16_t getUInt16() const { return _imm.value._u16[_ASMJIT_HOST_INDEX(4, 0)]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rcx+rax+8]
	ret	0
?getUInt16@Imm@asmjit@@QEBAGXZ ENDP			; asmjit::Imm::getUInt16
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?getUInt8@Imm@asmjit@@QEBAEXZ
_TEXT	SEGMENT
this$ = 8
?getUInt8@Imm@asmjit@@QEBAEXZ PROC			; asmjit::Imm::getUInt8, COMDAT

; 779  :   ASMJIT_INLINE uint8_t getUInt8() const { return _imm.value._u8[_ASMJIT_HOST_INDEX(8, 0)]; }

	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+8]
	ret	0
?getUInt8@Imm@asmjit@@QEBAEXZ ENDP			; asmjit::Imm::getUInt8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?isBaseIndexType@BaseMem@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 0
this$ = 32
?isBaseIndexType@BaseMem@asmjit@@QEBA_NXZ PROC		; asmjit::BaseMem::isBaseIndexType, COMDAT

; 669  :   ASMJIT_INLINE bool isBaseIndexType() const {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 670  :     return _vmem.type <= kMemTypeStackIndex;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+2]
	cmp	eax, 1
	ja	SHORT $LN3@isBaseInde
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@isBaseInde
$LN3@isBaseInde:
	mov	DWORD PTR tv72[rsp], 0
$LN4@isBaseInde:
	movzx	eax, BYTE PTR tv72[rsp]

; 671  :   }

	add	rsp, 24
	ret	0
?isBaseIndexType@BaseMem@asmjit@@QEBA_NXZ ENDP		; asmjit::BaseMem::isBaseIndexType
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?getMemType@BaseMem@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getMemType@BaseMem@asmjit@@QEBAIXZ PROC		; asmjit::BaseMem::getMemType, COMDAT

; 663  :   ASMJIT_INLINE uint32_t getMemType() const {

	mov	QWORD PTR [rsp+8], rcx

; 664  :     return _vmem.type;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+2]

; 665  :   }

	ret	0
?getMemType@BaseMem@asmjit@@QEBAIXZ ENDP		; asmjit::BaseMem::getMemType
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?getRegIndex@Reg@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getRegIndex@Reg@asmjit@@QEBAIXZ PROC			; asmjit::Reg::getRegIndex, COMDAT

; 584  :   ASMJIT_INLINE uint32_t getRegIndex() const {

	mov	QWORD PTR [rsp+8], rcx

; 585  :     return _vreg.index;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+2]

; 586  :   }

	ret	0
?getRegIndex@Reg@asmjit@@QEBAIXZ ENDP			; asmjit::Reg::getRegIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?isRegType@Reg@asmjit@@QEBA_NI@Z
_TEXT	SEGMENT
tv72 = 0
this$ = 32
type$ = 40
?isRegType@Reg@asmjit@@QEBA_NI@Z PROC			; asmjit::Reg::isRegType, COMDAT

; 559  :   ASMJIT_INLINE bool isRegType(uint32_t type) const {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 560  :     return _vreg.type == type;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	cmp	eax, DWORD PTR type$[rsp]
	jne	SHORT $LN3@isRegType
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@isRegType
$LN3@isRegType:
	mov	DWORD PTR tv72[rsp], 0
$LN4@isRegType:
	movzx	eax, BYTE PTR tv72[rsp]

; 561  :   }

	add	rsp, 24
	ret	0
?isRegType@Reg@asmjit@@QEBA_NI@Z ENDP			; asmjit::Reg::isRegType
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ??0Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??0Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z PROC		; asmjit::Reg::Reg, COMDAT

; 547  :   explicit ASMJIT_INLINE Reg(const _NoInit&) : Operand(NoInit) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR this$[rsp]
	call	??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::Operand::Operand
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z ENDP		; asmjit::Reg::Reg
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?getId@Operand@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getId@Operand@asmjit@@QEBAIXZ PROC			; asmjit::Operand::getId, COMDAT

; 454  :   ASMJIT_INLINE uint32_t getId() const {

	mov	QWORD PTR [rsp+8], rcx

; 455  :     return _base.id;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+4]

; 456  :   }

	ret	0
?getId@Operand@asmjit@@QEBAIXZ ENDP			; asmjit::Operand::getId
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?getSize@Operand@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getSize@Operand@asmjit@@QEBAIXZ PROC			; asmjit::Operand::getSize, COMDAT

; 440  :   ASMJIT_INLINE uint32_t getSize() const {

	mov	QWORD PTR [rsp+8], rcx

; 441  :     return _base.size;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+1]

; 442  :   }

	ret	0
?getSize@Operand@asmjit@@QEBAIXZ ENDP			; asmjit::Operand::getSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?isRegType@Operand@asmjit@@QEBA_NI@Z
_TEXT	SEGMENT
tv85 = 32
tv75 = 36
tv77 = 40
tv78 = 44
this$ = 64
type$ = 72
?isRegType@Operand@asmjit@@QEBA_NI@Z PROC		; asmjit::Operand::isRegType, COMDAT

; 412  :   ASMJIT_INLINE bool isRegType(uint32_t type) const {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 413  :     return (_packed[0].u32[0] & IntUtil::pack32_2x8_1x16(0xFF, 0, 0xFF00)) == IntUtil::pack32_2x8_1x16(kOperandTypeReg, 0, (type << 8));

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	eax, DWORD PTR [rax+rcx]
	mov	DWORD PTR tv77[rsp], eax
	mov	r8d, 65280				; 0000ff00H
	xor	edx, edx
	mov	ecx, 255				; 000000ffH
	call	?pack32_2x8_1x16@IntUtil@asmjit@@SAIIII@Z ; asmjit::IntUtil::pack32_2x8_1x16
	mov	DWORD PTR tv75[rsp], eax
	mov	eax, DWORD PTR tv75[rsp]
	mov	ecx, DWORD PTR tv77[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv78[rsp], eax
	mov	ecx, DWORD PTR type$[rsp]
	shl	ecx, 8
	mov	r8d, ecx
	xor	edx, edx
	mov	ecx, 1
	call	?pack32_2x8_1x16@IntUtil@asmjit@@SAIIII@Z ; asmjit::IntUtil::pack32_2x8_1x16
	mov	ecx, DWORD PTR tv78[rsp]
	cmp	ecx, eax
	jne	SHORT $LN3@isRegType
	mov	DWORD PTR tv85[rsp], 1
	jmp	SHORT $LN4@isRegType
$LN3@isRegType:
	mov	DWORD PTR tv85[rsp], 0
$LN4@isRegType:
	movzx	eax, BYTE PTR tv85[rsp]

; 414  :   }

	add	rsp, 56					; 00000038H
	ret	0
?isRegType@Operand@asmjit@@QEBA_NI@Z ENDP		; asmjit::Operand::isRegType
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?isImm@Operand@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv68 = 0
this$ = 32
?isImm@Operand@asmjit@@QEBA_NXZ PROC			; asmjit::Operand::isImm, COMDAT

; 393  :   ASMJIT_INLINE bool isImm() const { return (_base.op == kOperandTypeImm); }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 4
	jne	SHORT $LN3@isImm
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@isImm
$LN3@isImm:
	mov	DWORD PTR tv68[rsp], 0
$LN4@isImm:
	movzx	eax, BYTE PTR tv68[rsp]
	add	rsp, 24
	ret	0
?isImm@Operand@asmjit@@QEBA_NXZ ENDP			; asmjit::Operand::isImm
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?isMem@Operand@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv68 = 0
this$ = 32
?isMem@Operand@asmjit@@QEBA_NXZ PROC			; asmjit::Operand::isMem, COMDAT

; 391  :   ASMJIT_INLINE bool isMem() const { return (_base.op == kOperandTypeMem); }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 3
	jne	SHORT $LN3@isMem
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@isMem
$LN3@isMem:
	mov	DWORD PTR tv68[rsp], 0
$LN4@isMem:
	movzx	eax, BYTE PTR tv68[rsp]
	add	rsp, 24
	ret	0
?isMem@Operand@asmjit@@QEBA_NXZ ENDP			; asmjit::Operand::isMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?isReg@Operand@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv68 = 0
this$ = 32
?isReg@Operand@asmjit@@QEBA_NXZ PROC			; asmjit::Operand::isReg, COMDAT

; 387  :   ASMJIT_INLINE bool isReg() const { return (_base.op == kOperandTypeReg); }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 1
	jne	SHORT $LN3@isReg
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@isReg
$LN3@isReg:
	mov	DWORD PTR tv68[rsp], 0
$LN4@isReg:
	movzx	eax, BYTE PTR tv68[rsp]
	add	rsp, 24
	ret	0
?isReg@Operand@asmjit@@QEBA_NXZ ENDP			; asmjit::Operand::isReg
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?getOp@Operand@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getOp@Operand@asmjit@@QEBAIXZ PROC			; asmjit::Operand::getOp, COMDAT

; 382  :   ASMJIT_INLINE uint32_t getOp() const { return _base.op; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	ret	0
?getOp@Operand@asmjit@@QEBAIXZ ENDP			; asmjit::Operand::getOp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z PROC		; asmjit::Operand::Operand, COMDAT

; 312  :   explicit ASMJIT_INLINE Operand(const _NoInit&) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z ENDP		; asmjit::Operand::Operand
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\containers.h
;	COMDAT ?getData@PodVectorData@asmjit@@QEBAPEAXXZ
_TEXT	SEGMENT
this$ = 8
?getData@PodVectorData@asmjit@@QEBAPEAXXZ PROC		; asmjit::PodVectorData::getData, COMDAT

; 34   :   ASMJIT_INLINE void* getData() const {

	mov	QWORD PTR [rsp+8], rcx

; 35   :     return (void*)(this + 1);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16

; 36   :   }

	ret	0
?getData@PodVectorData@asmjit@@QEBAPEAXXZ ENDP		; asmjit::PodVectorData::getData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\codegen.h
;	COMDAT ?getInstOptionsAndReset@CodeGen@asmjit@@QEAAIXZ
_TEXT	SEGMENT
instOptions$ = 0
this$ = 32
?getInstOptionsAndReset@CodeGen@asmjit@@QEAAIXZ PROC	; asmjit::CodeGen::getInstOptionsAndReset, COMDAT

; 264  :   ASMJIT_INLINE uint32_t getInstOptionsAndReset() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 265  :     uint32_t instOptions = _instOptions;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	mov	DWORD PTR instOptions$[rsp], eax

; 266  :     _instOptions = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+48], 0

; 267  :     return instOptions;

	mov	eax, DWORD PTR instOptions$[rsp]

; 268  :   };

	add	rsp, 24
	ret	0
?getInstOptionsAndReset@CodeGen@asmjit@@QEAAIXZ ENDP	; asmjit::CodeGen::getInstOptionsAndReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\codegen.h
;	COMDAT ?hasFeature@CodeGen@asmjit@@QEBA_NI@Z
_TEXT	SEGMENT
tv68 = 0
tv72 = 4
this$ = 32
feature$ = 40
?hasFeature@CodeGen@asmjit@@QEBA_NI@Z PROC		; asmjit::CodeGen::hasFeature, COMDAT

; 230  :   ASMJIT_INLINE bool hasFeature(uint32_t feature) const {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 231  :     ASMJIT_ASSERT(feature < 32);
; 232  : 
; 233  :     return (_features & (1 << feature)) != 0;

	mov	eax, DWORD PTR feature$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv72[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv72[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+44]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN3@hasFeature
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@hasFeature
$LN3@hasFeature:
	mov	DWORD PTR tv68[rsp], 0
$LN4@hasFeature:
	movzx	eax, BYTE PTR tv68[rsp]

; 234  :   }

	add	rsp, 24
	ret	0
?hasFeature@CodeGen@asmjit@@QEBA_NI@Z ENDP		; asmjit::CodeGen::hasFeature
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\codegen.h
;	COMDAT ?getBaseAddress@CodeGen@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getBaseAddress@CodeGen@asmjit@@QEBA_KXZ PROC		; asmjit::CodeGen::getBaseAddress, COMDAT

; 181  :   ASMJIT_INLINE Ptr getBaseAddress() const {

	mov	QWORD PTR [rsp+8], rcx

; 182  :     return _baseAddress;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]

; 183  :   }

	ret	0
?getBaseAddress@CodeGen@asmjit@@QEBA_KXZ ENDP		; asmjit::CodeGen::getBaseAddress
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\codegen.h
;	COMDAT ?getArch@CodeGen@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getArch@CodeGen@asmjit@@QEBAIXZ PROC			; asmjit::CodeGen::getArch, COMDAT

; 160  :   ASMJIT_INLINE uint32_t getArch() const {

	mov	QWORD PTR [rsp+8], rcx

; 161  :     return _arch;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]

; 162  :   }

	ret	0
?getArch@CodeGen@asmjit@@QEBAIXZ ENDP			; asmjit::CodeGen::getArch
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\codegen.h
;	COMDAT ?getRuntime@CodeGen@asmjit@@QEBAPEAURuntime@2@XZ
_TEXT	SEGMENT
this$ = 8
?getRuntime@CodeGen@asmjit@@QEBAPEAURuntime@2@XZ PROC	; asmjit::CodeGen::getRuntime, COMDAT

; 132  :   ASMJIT_INLINE Runtime* getRuntime() const {

	mov	QWORD PTR [rsp+8], rcx

; 133  :     return _runtime;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 134  :   }

	ret	0
?getRuntime@CodeGen@asmjit@@QEBAPEAURuntime@2@XZ ENDP	; asmjit::CodeGen::getRuntime
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z
_TEXT	SEGMENT
u0$ = 8
u1$ = 16
u2$ = 24
u3$ = 32
?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z PROC		; asmjit::IntUtil::pack32_4x8, COMDAT

; 93   :   static ASMJIT_INLINE uint32_t pack32_4x8(uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3) {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 94   : #if defined(ASMJIT_HOST_LE)
; 95   :     return u0 + (u1 << 8) + (u2 << 16) + (u3 << 24);

	mov	eax, DWORD PTR u1$[rsp]
	shl	eax, 8
	mov	ecx, DWORD PTR u0$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR u2$[rsp]
	shl	ecx, 16
	add	eax, ecx
	mov	ecx, DWORD PTR u3$[rsp]
	shl	ecx, 24
	add	eax, ecx

; 96   : #else
; 97   :     return (u0 << 24) + (u1 << 16) + (u2 << 8) + u3;
; 98   : #endif // ASMJIT_HOST
; 99   :   }

	ret	0
?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z ENDP		; asmjit::IntUtil::pack32_4x8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ?pack32_2x8_1x16@IntUtil@asmjit@@SAIIII@Z
_TEXT	SEGMENT
u0$ = 8
u1$ = 16
w2$ = 24
?pack32_2x8_1x16@IntUtil@asmjit@@SAIIII@Z PROC		; asmjit::IntUtil::pack32_2x8_1x16, COMDAT

; 84   :   static ASMJIT_INLINE uint32_t pack32_2x8_1x16(uint32_t u0, uint32_t u1, uint32_t w2) {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 85   : #if defined(ASMJIT_HOST_LE)
; 86   :     return u0 + (u1 << 8) + (w2 << 16);

	mov	eax, DWORD PTR u1$[rsp]
	shl	eax, 8
	mov	ecx, DWORD PTR u0$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR w2$[rsp]
	shl	ecx, 16
	add	eax, ecx

; 87   : #else
; 88   :     return (u0 << 24) + (u1 << 16) + (w2);
; 89   : #endif // ASMJIT_HOST
; 90   :   }

	ret	0
?pack32_2x8_1x16@IntUtil@asmjit@@SAIIII@Z ENDP		; asmjit::IntUtil::pack32_2x8_1x16
_TEXT	ENDS
END
