; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?x86CpuVendorList@asmjit@@3QBUX86CpuVendor@1@B DD 01H	; asmjit::x86CpuVendorList
	DB	047H
	DB	065H
	DB	06eH
	DB	075H
	DB	069H
	DB	06eH
	DB	065H
	DB	049H
	DB	06eH
	DB	074H
	DB	065H
	DB	06cH
	DD	02H
	DB	041H
	DB	075H
	DB	074H
	DB	068H
	DB	065H
	DB	06eH
	DB	074H
	DB	069H
	DB	063H
	DB	041H
	DB	04dH
	DB	044H
	DD	03H
	DB	056H
	DB	049H
	DB	041H
	DB	00H
	DB	056H
	DB	049H
	DB	041H
	DB	00H
	DB	056H
	DB	049H
	DB	041H
	DB	00H
	DD	03H
	DB	043H
	DB	065H
	DB	06eH
	DB	074H
	DB	061H
	DB	075H
	DB	072H
	DB	048H
	DB	061H
	DB	075H
	DB	06cH
	DB	073H
CONST	ENDS
PUBLIC	?hasFeature@CpuInfo@asmjit@@QEBA_NI@Z		; asmjit::CpuInfo::hasFeature
PUBLIC	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z	; asmjit::CpuInfo::addFeature
PUBLIC	?callCpuId@X86CpuUtil@asmjit@@SAXIIPEATX86CpuId@2@@Z ; asmjit::X86CpuUtil::callCpuId
PUBLIC	?detect@X86CpuUtil@asmjit@@SAXPEAUX86CpuInfo@2@@Z ; asmjit::X86CpuUtil::detect
PUBLIC	??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z		; asmjit::IntUtil::iMin<unsigned int>
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	?detectHwThreadsCount@CpuInfo@asmjit@@SAIXZ:PROC ; asmjit::CpuInfo::detectHwThreadsCount
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hasFeature@CpuInfo@asmjit@@QEBA_NI@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$?hasFeature@CpuInfo@asmjit@@QEBA_NI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?callCpuId@X86CpuUtil@asmjit@@SAXIIPEATX86CpuId@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?callCpuId@X86CpuUtil@asmjit@@SAXIIPEATX86CpuId@2@@Z
$pdata$?detect@X86CpuUtil@asmjit@@SAXPEAUX86CpuInfo@2@@Z DD imagerel $LN85
	DD	imagerel $LN85+3033
	DD	imagerel $unwind$?detect@X86CpuUtil@asmjit@@SAXPEAUX86CpuInfo@2@@Z
$pdata$?x86CpuVendorEq@asmjit@@YA_NAEBUX86CpuVendor@1@PEBD@Z DD imagerel ?x86CpuVendorEq@asmjit@@YA_NAEBUX86CpuVendor@1@PEBD@Z
	DD	imagerel ?x86CpuVendorEq@asmjit@@YA_NAEBUX86CpuVendor@1@PEBD@Z+233
	DD	imagerel $unwind$?x86CpuVendorEq@asmjit@@YA_NAEBUX86CpuVendor@1@PEBD@Z
$pdata$?x86SimplifyBrandString@asmjit@@YAXPEAD@Z DD imagerel ?x86SimplifyBrandString@asmjit@@YAXPEAD@Z
	DD	imagerel ?x86SimplifyBrandString@asmjit@@YAXPEAD@Z+257
	DD	imagerel $unwind$?x86SimplifyBrandString@asmjit@@YAXPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?detect@X86CpuUtil@asmjit@@SAXPEAUX86CpuInfo@2@@Z
	DD	016H
	DD	0bc4H
voltbl	ENDS
xdata	SEGMENT
$unwind$?callCpuId@X86CpuUtil@asmjit@@SAXIIPEATX86CpuId@2@@Z DD 021201H
	DD	0300e1212H
$unwind$?detect@X86CpuUtil@asmjit@@SAXPEAUX86CpuInfo@2@@Z DD 021b19H
	DD	011010cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$?x86CpuVendorEq@asmjit@@YA_NAEBUX86CpuVendor@1@PEBD@Z DD 010e01H
	DD	0420eH
$unwind$?x86SimplifyBrandString@asmjit@@YAXPEAD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hasFeature@CpuInfo@asmjit@@QEBA_NI@Z DD 010d01H
	DD	0220dH
xdata	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z
_TEXT	SEGMENT
tv65 = 0
a$ = 32
b$ = 40
??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z PROC		; asmjit::IntUtil::iMin<unsigned int>, COMDAT

; 119  :   static ASMJIT_INLINE T iMin(const T& a, const T& b) { return a < b ? a : b; }

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jae	SHORT $LN3@iMin
	mov	rax, QWORD PTR a$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv65[rsp], eax
	jmp	SHORT $LN4@iMin
$LN3@iMin:
	mov	rax, QWORD PTR b$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv65[rsp], eax
$LN4@iMin:
	mov	eax, DWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z ENDP		; asmjit::IntUtil::iMin<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86cpuinfo.cpp
_TEXT	SEGMENT
inEcx$ = 8
result$ = 16
?callXGetBV@asmjit@@YAXIPEATX86XCR@1@@Z PROC		; asmjit::callXGetBV

; 150  : static void callXGetBV(uint32_t inEcx, X86XCR* result) {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx

; 151  : 
; 152  : #if defined(_MSC_VER)
; 153  : 
; 154  : # if (_MSC_FULL_VER >= 160040219) // 2010SP1+
; 155  :   result->value = _xgetbv(inEcx);

	mov	ecx, DWORD PTR inEcx$[rsp]
	xgetbv
	shl	rdx, 32					; 00000020H
	or	rdx, rax
	mov	rax, rdx
	mov	rcx, QWORD PTR result$[rsp]
	mov	QWORD PTR [rcx], rax

; 156  : # else
; 157  :   result->value = 0;
; 158  : # endif
; 159  : 
; 160  : #elif defined(__GNUC__)
; 161  : 
; 162  :   unsigned int eax, edx;
; 163  : # if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)
; 164  :   __asm__ __volatile__("xgetbv" : "=a"(eax), "=d"(edx) : "c"(inEcx));
; 165  : # else
; 166  :   __asm__ __volatile__(".byte 0x0F, 0x01, 0xd0" : "=a"(eax), "=d"(edx) : "c"(inEcx));
; 167  : # endif
; 168  :   result->eax = eax;
; 169  :   result->edx = edx;
; 170  : 
; 171  : #else
; 172  : 
; 173  :   result->value = 0;
; 174  : 
; 175  : #endif // COMPILER
; 176  : }

	ret	0
?callXGetBV@asmjit@@YAXIPEATX86XCR@1@@Z ENDP		; asmjit::callXGetBV
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86cpuinfo.cpp
_TEXT	SEGMENT
curr$ = 0
prev$ = 1
d$ = 8
s$ = 32
?x86SimplifyBrandString@asmjit@@YAXPEAD@Z PROC		; asmjit::x86SimplifyBrandString

; 52   : static ASMJIT_INLINE void x86SimplifyBrandString(char* s) {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 53   :   // Always clear the current character in the buffer. It ensures that there
; 54   :   // is no garbage after the string NULL terminator.
; 55   :   char* d = s;

	mov	rax, QWORD PTR s$[rsp]
	mov	QWORD PTR d$[rsp], rax

; 56   : 
; 57   :   char prev = 0;

	mov	BYTE PTR prev$[rsp], 0

; 58   :   char curr = s[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR s$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR curr$[rsp], al

; 59   :   s[0] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR s$[rsp]
	mov	BYTE PTR [rcx+rax], 0
$LN2@x86Simplif:

; 60   : 
; 61   :   for (;;) {
; 62   :     if (curr == 0)

	movsx	eax, BYTE PTR curr$[rsp]
	test	eax, eax
	jne	SHORT $LN5@x86Simplif

; 63   :       break;

	jmp	$LN3@x86Simplif
$LN5@x86Simplif:

; 64   : 
; 65   :     if (curr == ' ') {

	movsx	eax, BYTE PTR curr$[rsp]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN6@x86Simplif

; 66   :       if (prev == '@' || s[1] == ' ' || s[1] == '@')

	movsx	eax, BYTE PTR prev$[rsp]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN8@x86Simplif
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN8@x86Simplif
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN7@x86Simplif
$LN8@x86Simplif:

; 67   :         goto _Skip;

	jmp	SHORT $LN9@x86Simplif
	jmp	SHORT $_Skip$11
$LN7@x86Simplif:
$LN6@x86Simplif:

; 68   :     }
; 69   : 
; 70   :     d[0] = curr;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR d$[rsp]
	movzx	edx, BYTE PTR curr$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 71   :     d++;

	mov	rax, QWORD PTR d$[rsp]
	inc	rax
	mov	QWORD PTR d$[rsp], rax

; 72   :     prev = curr;

	movzx	eax, BYTE PTR curr$[rsp]
	mov	BYTE PTR prev$[rsp], al
$LN9@x86Simplif:
$_Skip$11:

; 73   : 
; 74   : _Skip:
; 75   :     curr = *++s;

	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax
	mov	rax, QWORD PTR s$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR curr$[rsp], al

; 76   :     s[0] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR s$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 77   :   }

	jmp	$LN2@x86Simplif
$LN3@x86Simplif:

; 78   : 
; 79   :   d[0] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR d$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 80   : }

	add	rsp, 24
	ret	0
?x86SimplifyBrandString@asmjit@@YAXPEAD@Z ENDP		; asmjit::x86SimplifyBrandString
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86cpuinfo.cpp
_TEXT	SEGMENT
tv76 = 0
tv70 = 4
tv83 = 8
tv85 = 12
a$ = 16
b$ = 24
info$ = 48
vendorString$ = 56
?x86CpuVendorEq@asmjit@@YA_NAEBUX86CpuVendor@1@PEBD@Z PROC ; asmjit::x86CpuVendorEq

; 45   : static ASMJIT_INLINE bool x86CpuVendorEq(const X86CpuVendor& info, const char* vendorString) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 46   :   const uint32_t* a = reinterpret_cast<const uint32_t*>(info.text);

	mov	rax, QWORD PTR info$[rsp]
	add	rax, 4
	mov	QWORD PTR a$[rsp], rax

; 47   :   const uint32_t* b = reinterpret_cast<const uint32_t*>(vendorString);

	mov	rax, QWORD PTR vendorString$[rsp]
	mov	QWORD PTR b$[rsp], rax

; 48   : 
; 49   :   return (a[0] == b[0]) & (a[1] == b[1]) & (a[2] == b[2]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR a$[rsp]
	mov	r8, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR [r8+rcx]
	cmp	DWORD PTR [rdx+rax], ecx
	jne	SHORT $LN3@x86CpuVend
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN4@x86CpuVend
$LN3@x86CpuVend:
	mov	DWORD PTR tv70[rsp], 0
$LN4@x86CpuVend:
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR a$[rsp]
	mov	r8, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR [r8+rcx]
	cmp	DWORD PTR [rdx+rax], ecx
	jne	SHORT $LN5@x86CpuVend
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN6@x86CpuVend
$LN5@x86CpuVend:
	mov	DWORD PTR tv76[rsp], 0
$LN6@x86CpuVend:
	mov	eax, DWORD PTR tv76[rsp]
	mov	ecx, DWORD PTR tv70[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv85[rsp], eax
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR a$[rsp]
	mov	r8, QWORD PTR b$[rsp]
	mov	ecx, DWORD PTR [r8+rcx]
	cmp	DWORD PTR [rdx+rax], ecx
	jne	SHORT $LN7@x86CpuVend
	mov	DWORD PTR tv83[rsp], 1
	jmp	SHORT $LN8@x86CpuVend
$LN7@x86CpuVend:
	mov	DWORD PTR tv83[rsp], 0
$LN8@x86CpuVend:
	mov	eax, DWORD PTR tv83[rsp]
	mov	ecx, DWORD PTR tv85[rsp]
	and	ecx, eax
	mov	eax, ecx

; 50   : }

	add	rsp, 40					; 00000028H
	ret	0
?x86CpuVendorEq@asmjit@@YA_NAEBUX86CpuVendor@1@PEBD@Z ENDP ; asmjit::x86CpuVendorEq
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86cpuinfo.cpp
_TEXT	SEGMENT
maybeMPX$ = 32
i$ = 36
brand$ = 40
tv672 = 48
maxBaseId$ = 52
xcr0$ = 56
$T1 = 64
maxExtId$ = 68
tv386 = 72
tv399 = 80
tv758 = 88
regs$ = 96
__$ArrayPad$ = 112
cpuInfo$ = 144
?detect@X86CpuUtil@asmjit@@SAXPEAUX86CpuInfo@2@@Z PROC	; asmjit::X86CpuUtil::detect

; 178  : void X86CpuUtil::detect(X86CpuInfo* cpuInfo) {

$LN85:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 179  :   X86CpuId regs;
; 180  : 
; 181  :   uint32_t i;
; 182  :   uint32_t maxBaseId;
; 183  : 
; 184  :   bool maybeMPX = false;

	mov	BYTE PTR maybeMPX$[rsp], 0

; 185  :   X86XCR xcr0;
; 186  :   xcr0.value = 0;

	mov	QWORD PTR xcr0$[rsp], 0

; 187  : 
; 188  :   // Clear everything except the '_size' member.
; 189  :   ::memset(reinterpret_cast<uint8_t*>(cpuInfo) + sizeof(uint32_t),

	mov	rax, QWORD PTR cpuInfo$[rsp]
	add	rax, 4
	mov	r8d, 116				; 00000074H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 190  :     0, sizeof(CpuInfo) - sizeof(uint32_t));
; 191  : 
; 192  :   // Fill safe defaults.
; 193  :   cpuInfo->_hwThreadsCount = CpuInfo::detectHwThreadsCount();

	call	?detectHwThreadsCount@CpuInfo@asmjit@@SAIXZ ; asmjit::CpuInfo::detectHwThreadsCount
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	mov	DWORD PTR [rcx+100], eax

; 194  : 
; 195  :   // --------------------------------------------------------------------------
; 196  :   // [CPUID EAX=0x0]
; 197  :   // --------------------------------------------------------------------------
; 198  : 
; 199  :   // Get vendor string/id.
; 200  :   callCpuId(0x0, 0x0, &regs);

	lea	r8, QWORD PTR regs$[rsp]
	xor	edx, edx
	xor	ecx, ecx
	call	?callCpuId@X86CpuUtil@asmjit@@SAXIIPEATX86CpuId@2@@Z ; asmjit::X86CpuUtil::callCpuId

; 201  : 
; 202  :   maxBaseId = regs.eax;

	mov	eax, DWORD PTR regs$[rsp]
	mov	DWORD PTR maxBaseId$[rsp], eax

; 203  :   ::memcpy(cpuInfo->_vendorString, &regs.ebx, 4);

	mov	rax, QWORD PTR cpuInfo$[rsp]
	add	rax, 4
	mov	r8d, 4
	lea	rdx, QWORD PTR regs$[rsp+4]
	mov	rcx, rax
	call	memcpy

; 204  :   ::memcpy(cpuInfo->_vendorString + 4, &regs.edx, 4);

	mov	rax, QWORD PTR cpuInfo$[rsp]
	add	rax, 8
	mov	r8d, 4
	lea	rdx, QWORD PTR regs$[rsp+12]
	mov	rcx, rax
	call	memcpy

; 205  :   ::memcpy(cpuInfo->_vendorString + 8, &regs.ecx, 4);

	mov	rax, QWORD PTR cpuInfo$[rsp]
	add	rax, 12
	mov	r8d, 4
	lea	rdx, QWORD PTR regs$[rsp+8]
	mov	rcx, rax
	call	memcpy
	npad	1

; 206  : 
; 207  :   for (i = 0; i < ASMJIT_ARRAY_SIZE(x86CpuVendorList); i++) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@detect
$LN2@detect:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@detect:
	mov	eax, DWORD PTR i$[rsp]
	cmp	rax, 4
	jae	SHORT $LN3@detect

; 208  :     if (x86CpuVendorEq(x86CpuVendorList[i], cpuInfo->_vendorString)) {

	mov	rax, QWORD PTR cpuInfo$[rsp]
	add	rax, 4
	mov	ecx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	lea	rdx, OFFSET FLAT:?x86CpuVendorList@asmjit@@3QBUX86CpuVendor@1@B
	add	rdx, rcx
	mov	rcx, rdx
	mov	rdx, rax
	call	?x86CpuVendorEq@asmjit@@YA_NAEBUX86CpuVendor@1@PEBD@Z ; asmjit::x86CpuVendorEq
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@detect

; 209  :       cpuInfo->_vendorId = x86CpuVendorList[i].id;

	mov	eax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?x86CpuVendorList@asmjit@@3QBUX86CpuVendor@1@B
	mov	rdx, QWORD PTR cpuInfo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR [rdx+84], eax

; 210  :       break;

	jmp	SHORT $LN3@detect
$LN10@detect:

; 211  :     }
; 212  :   }

	jmp	SHORT $LN2@detect
$LN3@detect:

; 213  : 
; 214  :   // --------------------------------------------------------------------------
; 215  :   // [CPUID EAX=0x1]
; 216  :   // --------------------------------------------------------------------------
; 217  : 
; 218  :   if (maxBaseId >= 0x1) {

	cmp	DWORD PTR maxBaseId$[rsp], 1
	jb	$LN11@detect

; 219  :     // Get feature flags in ECX/EDX and family/model in EAX.
; 220  :     callCpuId(0x1, 0x0, &regs);

	lea	r8, QWORD PTR regs$[rsp]
	xor	edx, edx
	mov	ecx, 1
	call	?callCpuId@X86CpuUtil@asmjit@@SAXIIPEATX86CpuId@2@@Z ; asmjit::X86CpuUtil::callCpuId

; 221  : 
; 222  :     // Fill family and model fields.
; 223  :     cpuInfo->_family   = (regs.eax >> 8) & 0x0F;

	mov	eax, DWORD PTR regs$[rsp]
	shr	eax, 8
	and	eax, 15
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	mov	DWORD PTR [rcx+88], eax

; 224  :     cpuInfo->_model    = (regs.eax >> 4) & 0x0F;

	mov	eax, DWORD PTR regs$[rsp]
	shr	eax, 4
	and	eax, 15
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	mov	DWORD PTR [rcx+92], eax

; 225  :     cpuInfo->_stepping = (regs.eax     ) & 0x0F;

	mov	eax, DWORD PTR regs$[rsp]
	and	eax, 15
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	mov	DWORD PTR [rcx+96], eax

; 226  : 
; 227  :     // Use extended family and model fields.
; 228  :     if (cpuInfo->_family == 0x0F) {

	mov	rax, QWORD PTR cpuInfo$[rsp]
	cmp	DWORD PTR [rax+88], 15
	jne	SHORT $LN12@detect

; 229  :       cpuInfo->_family += ((regs.eax >> 20) & 0xFF);

	mov	eax, DWORD PTR regs$[rsp]
	shr	eax, 20
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	add	eax, DWORD PTR [rcx+88]
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	mov	DWORD PTR [rcx+88], eax

; 230  :       cpuInfo->_model  += ((regs.eax >> 16) & 0x0F) << 4;

	mov	eax, DWORD PTR regs$[rsp]
	shr	eax, 16
	and	eax, 15
	shl	eax, 4
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	add	eax, DWORD PTR [rcx+92]
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	mov	DWORD PTR [rcx+92], eax
$LN12@detect:

; 231  :     }
; 232  : 
; 233  :     cpuInfo->_processorType        = ((regs.eax >> 12) & 0x03);

	mov	eax, DWORD PTR regs$[rsp]
	shr	eax, 12
	and	eax, 3
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	mov	DWORD PTR [rcx+120], eax

; 234  :     cpuInfo->_brandIndex           = ((regs.ebx      ) & 0xFF);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	mov	DWORD PTR [rcx+124], eax

; 235  :     cpuInfo->_flushCacheLineSize   = ((regs.ebx >>  8) & 0xFF) * 8;

	mov	eax, DWORD PTR regs$[rsp+4]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	shl	eax, 3
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	mov	DWORD PTR [rcx+128], eax

; 236  :     cpuInfo->_maxLogicalProcessors = ((regs.ebx >> 16) & 0xFF);

	mov	eax, DWORD PTR regs$[rsp+4]
	shr	eax, 16
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	mov	DWORD PTR [rcx+132], eax

; 237  : 
; 238  :     if (regs.ecx & 0x00000001U) cpuInfo->addFeature(kX86CpuFeatureSSE3);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN13@detect
	mov	edx, 20
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN13@detect:

; 239  :     if (regs.ecx & 0x00000002U) cpuInfo->addFeature(kX86CpuFeaturePCLMULQDQ);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN14@detect
	mov	edx, 31
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN14@detect:

; 240  :     if (regs.ecx & 0x00000008U) cpuInfo->addFeature(kX86CpuFeatureMONITOR);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN15@detect
	mov	edx, 26
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN15@detect:

; 241  :     if (regs.ecx & 0x00000200U) cpuInfo->addFeature(kX86CpuFeatureSSSE3);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN16@detect
	mov	edx, 21
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN16@detect:

; 242  :     if (regs.ecx & 0x00002000U) cpuInfo->addFeature(kX86CpuFeatureCMPXCHG16B);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 8192				; 00002000H
	test	eax, eax
	je	SHORT $LN17@detect
	mov	edx, 6
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN17@detect:

; 243  :     if (regs.ecx & 0x00080000U) cpuInfo->addFeature(kX86CpuFeatureSSE4_1);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 524288				; 00080000H
	test	eax, eax
	je	SHORT $LN18@detect
	mov	edx, 23
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN18@detect:

; 244  :     if (regs.ecx & 0x00100000U) cpuInfo->addFeature(kX86CpuFeatureSSE4_2);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	je	SHORT $LN19@detect
	mov	edx, 24
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN19@detect:

; 245  :     if (regs.ecx & 0x00400000U) cpuInfo->addFeature(kX86CpuFeatureMOVBE);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 4194304				; 00400000H
	test	eax, eax
	je	SHORT $LN20@detect
	mov	edx, 27
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN20@detect:

; 246  :     if (regs.ecx & 0x00800000U) cpuInfo->addFeature(kX86CpuFeaturePOPCNT);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 8388608				; 00800000H
	test	eax, eax
	je	SHORT $LN21@detect
	mov	edx, 28
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN21@detect:

; 247  :     if (regs.ecx & 0x02000000U) cpuInfo->addFeature(kX86CpuFeatureAESNI);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	SHORT $LN22@detect
	mov	edx, 30
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN22@detect:

; 248  :     if (regs.ecx & 0x04000000U) cpuInfo->addFeature(kX86CpuFeatureXSave);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN23@detect
	mov	edx, 35					; 00000023H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN23@detect:

; 249  :     if (regs.ecx & 0x08000000U) cpuInfo->addFeature(kX86CpuFeatureXSaveOS);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	SHORT $LN24@detect
	mov	edx, 36					; 00000024H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN24@detect:

; 250  :     if (regs.ecx & 0x40000000U) cpuInfo->addFeature(kX86CpuFeatureRDRAND);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $LN25@detect
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN25@detect:

; 251  : 
; 252  :     if (regs.edx & 0x00000010U) cpuInfo->addFeature(kX86CpuFeatureRDTSC);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN26@detect
	mov	edx, 2
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN26@detect:

; 253  :     if (regs.edx & 0x00000100U) cpuInfo->addFeature(kX86CpuFeatureCMPXCHG8B);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN27@detect
	mov	edx, 5
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN27@detect:

; 254  :     if (regs.edx & 0x00008000U) cpuInfo->addFeature(kX86CpuFeatureCMOV);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 32768				; 00008000H
	test	eax, eax
	je	SHORT $LN28@detect
	mov	edx, 4
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN28@detect:

; 255  :     if (regs.edx & 0x00080000U) cpuInfo->addFeature(kX86CpuFeatureCLFLUSH);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 524288				; 00080000H
	test	eax, eax
	je	SHORT $LN29@detect
	mov	edx, 7
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN29@detect:

; 256  :     if (regs.edx & 0x00800000U) cpuInfo->addFeature(kX86CpuFeatureMMX);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 8388608				; 00800000H
	test	eax, eax
	je	SHORT $LN30@detect
	mov	edx, 14
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN30@detect:

; 257  :     if (regs.edx & 0x01000000U) cpuInfo->addFeature(kX86CpuFeatureFXSR);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 16777216				; 01000000H
	test	eax, eax
	je	SHORT $LN31@detect
	mov	edx, 12
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN31@detect:

; 258  :     if (regs.edx & 0x02000000U) cpuInfo->addFeature(kX86CpuFeatureSSE).addFeature(kX86CpuFeatureMMX2);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	SHORT $LN32@detect
	mov	edx, 18
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	mov	QWORD PTR tv386[rsp], rax
	mov	edx, 15
	mov	rcx, QWORD PTR tv386[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN32@detect:

; 259  :     if (regs.edx & 0x04000000U) cpuInfo->addFeature(kX86CpuFeatureSSE).addFeature(kX86CpuFeatureSSE2);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN33@detect
	mov	edx, 18
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	mov	QWORD PTR tv399[rsp], rax
	mov	edx, 19
	mov	rcx, QWORD PTR tv399[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN33@detect:

; 260  :     if (regs.edx & 0x10000000U) cpuInfo->addFeature(kX86CpuFeatureMT);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $LN34@detect
	mov	edx, 1
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN34@detect:

; 261  : 
; 262  :     // AMD sets Multithreading to ON if it has two or more cores.
; 263  :     if (cpuInfo->_hwThreadsCount == 1 && cpuInfo->_vendorId == kCpuVendorAmd && (regs.edx & 0x10000000U)) {

	mov	rax, QWORD PTR cpuInfo$[rsp]
	cmp	DWORD PTR [rax+100], 1
	jne	SHORT $LN35@detect
	mov	rax, QWORD PTR cpuInfo$[rsp]
	cmp	DWORD PTR [rax+84], 2
	jne	SHORT $LN35@detect
	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $LN35@detect

; 264  :       cpuInfo->_hwThreadsCount = 2;

	mov	rax, QWORD PTR cpuInfo$[rsp]
	mov	DWORD PTR [rax+100], 2
$LN35@detect:

; 265  :     }
; 266  : 
; 267  :     // Get the content of XCR0 if supported by CPU and enabled by OS.
; 268  :     if ((regs.ecx & 0x0C000000U) == 0x0C000000U) {

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 201326592				; 0c000000H
	cmp	eax, 201326592				; 0c000000H
	jne	SHORT $LN36@detect

; 269  :       callXGetBV(0, &xcr0);

	lea	rdx, QWORD PTR xcr0$[rsp]
	xor	ecx, ecx
	call	?callXGetBV@asmjit@@YAXIPEATX86XCR@1@@Z	; asmjit::callXGetBV
	npad	1
$LN36@detect:

; 270  :     }
; 271  : 
; 272  :     // Detect AVX+.
; 273  :     if (regs.ecx & 0x10000000U) {

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	$LN37@detect

; 274  :       // - XCR0[2:1] == 11b
; 275  :       //   XMM & YMM states are enabled by OS.
; 276  :       if ((xcr0.eax & 0x00000006U) == 0x00000006U) {

	mov	eax, DWORD PTR xcr0$[rsp]
	and	eax, 6
	cmp	eax, 6
	jne	$LN38@detect

; 277  :         cpuInfo->addFeature(kX86CpuFeatureAVX);

	mov	edx, 37					; 00000025H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1

; 278  : 
; 279  :         if (regs.ecx & 0x00000800U) cpuInfo->addFeature(kX86CpuFeatureXOP);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $LN39@detect
	mov	edx, 42					; 0000002aH
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN39@detect:

; 280  :         if (regs.ecx & 0x00004000U) cpuInfo->addFeature(kX86CpuFeatureFMA3);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 16384				; 00004000H
	test	eax, eax
	je	SHORT $LN40@detect
	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN40@detect:

; 281  :         if (regs.ecx & 0x00010000U) cpuInfo->addFeature(kX86CpuFeatureFMA4);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	SHORT $LN41@detect
	mov	edx, 41					; 00000029H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN41@detect:

; 282  :         if (regs.ecx & 0x20000000U) cpuInfo->addFeature(kX86CpuFeatureF16C);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 536870912				; 20000000H
	test	eax, eax
	je	SHORT $LN42@detect
	mov	edx, 39					; 00000027H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN42@detect:
$LN38@detect:
$LN37@detect:
$LN11@detect:

; 283  :       }
; 284  :     }
; 285  :   }
; 286  : 
; 287  :   // --------------------------------------------------------------------------
; 288  :   // [CPUID EAX=0x7 ECX=0x0]
; 289  :   // --------------------------------------------------------------------------
; 290  : 
; 291  :   // Detect new features if the processor supports CPUID-07.
; 292  :   if (maxBaseId >= 0x7) {

	cmp	DWORD PTR maxBaseId$[rsp], 7
	jb	$LN43@detect

; 293  :     callCpuId(0x7, 0x0, &regs);

	lea	r8, QWORD PTR regs$[rsp]
	xor	edx, edx
	mov	ecx, 7
	call	?callCpuId@X86CpuUtil@asmjit@@SAXIIPEATX86CpuId@2@@Z ; asmjit::X86CpuUtil::callCpuId
	npad	1

; 294  : 
; 295  :     if (regs.ebx & 0x00000001U) cpuInfo->addFeature(kX86CpuFeatureFSGSBase);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN44@detect
	mov	edx, 49					; 00000031H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN44@detect:

; 296  :     if (regs.ebx & 0x00000008U) cpuInfo->addFeature(kX86CpuFeatureBMI);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN45@detect
	mov	edx, 43					; 0000002bH
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN45@detect:

; 297  :     if (regs.ebx & 0x00000010U) cpuInfo->addFeature(kX86CpuFeatureHLE);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN46@detect
	mov	edx, 45					; 0000002dH
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN46@detect:

; 298  :     if (regs.ebx & 0x00000100U) cpuInfo->addFeature(kX86CpuFeatureBMI2);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN47@detect
	mov	edx, 44					; 0000002cH
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN47@detect:

; 299  :     if (regs.ebx & 0x00000200U) cpuInfo->addFeature(kX86CpuFeatureMOVSBSTOSBOpt);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN48@detect
	mov	edx, 50					; 00000032H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN48@detect:

; 300  :     if (regs.ebx & 0x00000800U) cpuInfo->addFeature(kX86CpuFeatureRTM);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $LN49@detect
	mov	edx, 46					; 0000002eH
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN49@detect:

; 301  :     if (regs.ebx & 0x00004000U) maybeMPX = true;

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 16384				; 00004000H
	test	eax, eax
	je	SHORT $LN50@detect
	mov	BYTE PTR maybeMPX$[rsp], 1
$LN50@detect:

; 302  :     if (regs.ebx & 0x00040000U) cpuInfo->addFeature(kX86CpuFeatureRDSEED);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN51@detect
	mov	edx, 33					; 00000021H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN51@detect:

; 303  :     if (regs.ebx & 0x00080000U) cpuInfo->addFeature(kX86CpuFeatureADX);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 524288				; 00080000H
	test	eax, eax
	je	SHORT $LN52@detect
	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN52@detect:

; 304  :     if (regs.ebx & 0x00800000U) cpuInfo->addFeature(kX86CpuFeatureCLFLUSHOpt);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 8388608				; 00800000H
	test	eax, eax
	je	SHORT $LN53@detect
	mov	edx, 8
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN53@detect:

; 305  :     if (regs.ebx & 0x20000000U) cpuInfo->addFeature(kX86CpuFeatureSHA);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 536870912				; 20000000H
	test	eax, eax
	je	SHORT $LN54@detect
	mov	edx, 34					; 00000022H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN54@detect:

; 306  : 
; 307  :     if (regs.ecx & 0x00000001U) cpuInfo->addFeature(kX86CpuFeaturePREFETCHWT1);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN55@detect
	mov	edx, 10
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN55@detect:

; 308  : 
; 309  :     // Detect AVX2.
; 310  :     if (cpuInfo->hasFeature(kX86CpuFeatureAVX)) {

	mov	edx, 37					; 00000025H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?hasFeature@CpuInfo@asmjit@@QEBA_NI@Z	; asmjit::CpuInfo::hasFeature
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN56@detect

; 311  :       if (regs.ebx & 0x00000020U) cpuInfo->addFeature(kX86CpuFeatureAVX2);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN57@detect
	mov	edx, 38					; 00000026H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN57@detect:
$LN56@detect:

; 312  :     }
; 313  : 
; 314  :     // Detect AVX-512+.
; 315  :     if (regs.ebx & 0x00010000U) {

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	$LN58@detect

; 316  :       // - XCR0[2:1] == 11b
; 317  :       //   XMM & YMM states are enabled by OS.
; 318  :       // - XCR0[7:5] == 111b
; 319  :       //   Upper 256-bit of ZMM0-XMM15 and ZMM16-ZMM31 state are enabled by OS.
; 320  :       if ((xcr0.eax & 0x00000076U) == 0x00000076U) {

	mov	eax, DWORD PTR xcr0$[rsp]
	and	eax, 118				; 00000076H
	cmp	eax, 118				; 00000076H
	jne	$LN59@detect

; 321  :         cpuInfo->addFeature(kX86CpuFeatureAVX512F);

	mov	edx, 51					; 00000033H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1

; 322  : 
; 323  :         if (regs.ebx & 0x00020000U) cpuInfo->addFeature(kX86CpuFeatureAVX512DQ);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $LN60@detect
	mov	edx, 55					; 00000037H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN60@detect:

; 324  :         if (regs.ebx & 0x04000000U) cpuInfo->addFeature(kX86CpuFeatureAVX512PF);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $LN61@detect
	mov	edx, 53					; 00000035H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN61@detect:

; 325  :         if (regs.ebx & 0x08000000U) cpuInfo->addFeature(kX86CpuFeatureAVX512ER);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	SHORT $LN62@detect
	mov	edx, 54					; 00000036H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN62@detect:

; 326  :         if (regs.ebx & 0x10000000U) cpuInfo->addFeature(kX86CpuFeatureAVX512CD);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $LN63@detect
	mov	edx, 52					; 00000034H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN63@detect:

; 327  :         if (regs.ebx & 0x40000000U) cpuInfo->addFeature(kX86CpuFeatureAVX512BW);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $LN64@detect
	mov	edx, 56					; 00000038H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN64@detect:

; 328  :         if (regs.ebx & 0x80000000U) cpuInfo->addFeature(kX86CpuFeatureAVX512VL);

	mov	eax, DWORD PTR regs$[rsp+4]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	je	SHORT $LN65@detect
	mov	edx, 57					; 00000039H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN65@detect:
$LN59@detect:
$LN58@detect:
$LN43@detect:

; 329  :       }
; 330  :     }
; 331  :   }
; 332  : 
; 333  :   // --------------------------------------------------------------------------
; 334  :   // [CPUID EAX=0xD, ECX=0x0]
; 335  :   // --------------------------------------------------------------------------
; 336  : 
; 337  :   if (maxBaseId >= 0xD && maybeMPX) {

	cmp	DWORD PTR maxBaseId$[rsp], 13
	jb	SHORT $LN66@detect
	movzx	eax, BYTE PTR maybeMPX$[rsp]
	test	eax, eax
	je	SHORT $LN66@detect

; 338  :     callCpuId(0xD, 0x0, &regs);

	lea	r8, QWORD PTR regs$[rsp]
	xor	edx, edx
	mov	ecx, 13
	call	?callCpuId@X86CpuUtil@asmjit@@SAXIIPEATX86CpuId@2@@Z ; asmjit::X86CpuUtil::callCpuId
	npad	1

; 339  : 
; 340  :     // Both CPUID result and XCR0 has to be enabled to have support for MPX.
; 341  :     if (((regs.eax & xcr0.eax) & 0x00000018U) == 0x00000018U) {

	mov	eax, DWORD PTR xcr0$[rsp]
	mov	ecx, DWORD PTR regs$[rsp]
	and	ecx, eax
	mov	eax, ecx
	and	eax, 24
	cmp	eax, 24
	jne	SHORT $LN67@detect

; 342  :       cpuInfo->addFeature(kX86CpuFeatureMPX);

	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN67@detect:
$LN66@detect:

; 343  :     }
; 344  :   }
; 345  : 
; 346  :   // --------------------------------------------------------------------------
; 347  :   // [CPUID EAX=0x80000000]
; 348  :   // --------------------------------------------------------------------------
; 349  : 
; 350  :   // Calling cpuid with 0x80000000 as the in argument gets the number of valid
; 351  :   // extended IDs.
; 352  :   callCpuId(0x80000000, 0x0, &regs);

	lea	r8, QWORD PTR regs$[rsp]
	xor	edx, edx
	mov	ecx, -2147483648			; 80000000H
	call	?callCpuId@X86CpuUtil@asmjit@@SAXIIPEATX86CpuId@2@@Z ; asmjit::X86CpuUtil::callCpuId
	npad	1

; 353  : 
; 354  :   uint32_t maxExtId = IntUtil::iMin<uint32_t>(regs.eax, 0x80000004);

	mov	DWORD PTR $T1[rsp], -2147483644		; 80000004H
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR regs$[rsp]
	call	??$iMin@I@IntUtil@asmjit@@SAIAEBI0@Z	; asmjit::IntUtil::iMin<unsigned int>
	mov	DWORD PTR maxExtId$[rsp], eax

; 355  :   uint32_t* brand = reinterpret_cast<uint32_t*>(cpuInfo->_brandString);

	mov	rax, QWORD PTR cpuInfo$[rsp]
	add	rax, 20
	mov	QWORD PTR brand$[rsp], rax

; 356  : 
; 357  :   for (i = 0x80000001; i <= maxExtId; i++) {

	mov	DWORD PTR i$[rsp], -2147483647		; 80000001H
	jmp	SHORT $LN7@detect
$LN5@detect:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@detect:
	mov	eax, DWORD PTR maxExtId$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	ja	$LN6@detect

; 358  :     callCpuId(i, 0x0, &regs);

	lea	r8, QWORD PTR regs$[rsp]
	xor	edx, edx
	mov	ecx, DWORD PTR i$[rsp]
	call	?callCpuId@X86CpuUtil@asmjit@@SAXIIPEATX86CpuId@2@@Z ; asmjit::X86CpuUtil::callCpuId
	npad	1

; 359  : 
; 360  :     switch (i) {

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR tv672[rsp], eax
	cmp	DWORD PTR tv672[rsp], -2147483647	; 80000001H
	je	SHORT $LN68@detect
	cmp	DWORD PTR tv672[rsp], -2147483646	; 80000002H
	je	$LN80@detect
	cmp	DWORD PTR tv672[rsp], -2147483645	; 80000003H
	je	$LN81@detect
	cmp	DWORD PTR tv672[rsp], -2147483644	; 80000004H
	je	$LN82@detect
	jmp	$LN83@detect
$LN68@detect:

; 361  :       case 0x80000001:
; 362  :         if (regs.ecx & 0x00000001U) cpuInfo->addFeature(kX86CpuFeatureLahfSahf);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN69@detect
	mov	edx, 11
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN69@detect:

; 363  :         if (regs.ecx & 0x00000020U) cpuInfo->addFeature(kX86CpuFeatureLZCNT);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN70@detect
	mov	edx, 29
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN70@detect:

; 364  :         if (regs.ecx & 0x00000040U) cpuInfo->addFeature(kX86CpuFeatureSSE4A);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN71@detect
	mov	edx, 22
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN71@detect:

; 365  :         if (regs.ecx & 0x00000080U) cpuInfo->addFeature(kX86CpuFeatureMSSE);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN72@detect
	mov	edx, 25
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN72@detect:

; 366  :         if (regs.ecx & 0x00000100U) cpuInfo->addFeature(kX86CpuFeaturePREFETCH);

	mov	eax, DWORD PTR regs$[rsp+8]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN73@detect
	mov	edx, 9
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN73@detect:

; 367  : 
; 368  :         if (regs.edx & 0x00100000U) cpuInfo->addFeature(kX86CpuFeatureNX);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	je	SHORT $LN74@detect
	xor	edx, edx
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN74@detect:

; 369  :         if (regs.edx & 0x00200000U) cpuInfo->addFeature(kX86CpuFeatureFXSROpt);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 2097152				; 00200000H
	test	eax, eax
	je	SHORT $LN75@detect
	mov	edx, 13
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN75@detect:

; 370  :         if (regs.edx & 0x00400000U) cpuInfo->addFeature(kX86CpuFeatureMMX2);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 4194304				; 00400000H
	test	eax, eax
	je	SHORT $LN76@detect
	mov	edx, 15
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN76@detect:

; 371  :         if (regs.edx & 0x08000000U) cpuInfo->addFeature(kX86CpuFeatureRDTSCP);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	SHORT $LN77@detect
	mov	edx, 3
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN77@detect:

; 372  :         if (regs.edx & 0x40000000U) cpuInfo->addFeature(kX86CpuFeature3DNOW2).addFeature(kX86CpuFeatureMMX2);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $LN78@detect
	mov	edx, 17
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	mov	QWORD PTR tv758[rsp], rax
	mov	edx, 15
	mov	rcx, QWORD PTR tv758[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN78@detect:

; 373  :         if (regs.edx & 0x80000000U) cpuInfo->addFeature(kX86CpuFeature3DNOW);

	mov	eax, DWORD PTR regs$[rsp+12]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	je	SHORT $LN79@detect
	mov	edx, 16
	mov	rcx, QWORD PTR cpuInfo$[rsp]
	call	?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ; asmjit::CpuInfo::addFeature
	npad	1
$LN79@detect:

; 374  :         break;

	jmp	SHORT $LN8@detect
$LN80@detect:
$LN81@detect:
$LN82@detect:

; 375  : 
; 376  :       case 0x80000002:
; 377  :       case 0x80000003:
; 378  :       case 0x80000004:
; 379  :         *brand++ = regs.eax;

	mov	rax, QWORD PTR brand$[rsp]
	mov	ecx, DWORD PTR regs$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR brand$[rsp]
	add	rax, 4
	mov	QWORD PTR brand$[rsp], rax

; 380  :         *brand++ = regs.ebx;

	mov	rax, QWORD PTR brand$[rsp]
	mov	ecx, DWORD PTR regs$[rsp+4]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR brand$[rsp]
	add	rax, 4
	mov	QWORD PTR brand$[rsp], rax

; 381  :         *brand++ = regs.ecx;

	mov	rax, QWORD PTR brand$[rsp]
	mov	ecx, DWORD PTR regs$[rsp+8]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR brand$[rsp]
	add	rax, 4
	mov	QWORD PTR brand$[rsp], rax

; 382  :         *brand++ = regs.edx;

	mov	rax, QWORD PTR brand$[rsp]
	mov	ecx, DWORD PTR regs$[rsp+12]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR brand$[rsp]
	add	rax, 4
	mov	QWORD PTR brand$[rsp], rax
$LN83@detect:
$LN8@detect:

; 383  :         break;
; 384  : 
; 385  :       default:
; 386  :         // Additional features can be detected in the future.
; 387  :         break;
; 388  :     }
; 389  :   }

	jmp	$LN5@detect
$LN6@detect:

; 390  : 
; 391  :   // Simplify the brand string (remove unnecessary spaces to make printing nicer).
; 392  :   x86SimplifyBrandString(cpuInfo->_brandString);

	mov	rax, QWORD PTR cpuInfo$[rsp]
	add	rax, 20
	mov	rcx, rax
	call	?x86SimplifyBrandString@asmjit@@YAXPEAD@Z ; asmjit::x86SimplifyBrandString
	npad	1

; 393  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
?detect@X86CpuUtil@asmjit@@SAXPEAUX86CpuInfo@2@@Z ENDP	; asmjit::X86CpuUtil::detect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86cpuinfo.cpp
_TEXT	SEGMENT
tv66 = 0
inEax$ = 32
inEcx$ = 40
result$ = 48
?callCpuId@X86CpuUtil@asmjit@@SAXIIPEATX86CpuId@2@@Z PROC ; asmjit::X86CpuUtil::callCpuId

; 102  : void X86CpuUtil::callCpuId(uint32_t inEax, uint32_t inEcx, X86CpuId* result) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbx
	sub	rsp, 16

; 103  : 
; 104  : #if defined(_MSC_VER)
; 105  : // 2009-02-05: Thanks to Mike Tajmajer for supporting VC7.1 compiler.
; 106  : // ASMJIT_HOST_X64 is here only for readibility, only VS2005 can compile 64-bit code.
; 107  : # if _MSC_VER >= 1400 || defined(ASMJIT_HOST_X64)
; 108  :   // Done by intrinsics.
; 109  :   __cpuidex(reinterpret_cast<int*>(result->i), inEax, inEcx);

	mov	rax, QWORD PTR result$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	eax, DWORD PTR inEax$[rsp]
	mov	ecx, DWORD PTR inEcx$[rsp]
	cpuid
	mov	r8, QWORD PTR tv66[rsp]
	mov	DWORD PTR [r8], eax
	mov	DWORD PTR [r8+4], ebx
	mov	DWORD PTR [r8+8], ecx
	mov	DWORD PTR [r8+12], edx

; 110  : # else // _MSC_VER < 1400
; 111  :   uint32_t cpuid_eax = inEax;
; 112  :   uint32_t cpuid_ecx = inCax;
; 113  :   uint32_t* cpuid_out = result->i;
; 114  : 
; 115  :   __asm {
; 116  :     mov     eax, cpuid_eax
; 117  :     mov     ecx, cpuid_ecx
; 118  :     mov     edi, cpuid_out
; 119  :     cpuid
; 120  :     mov     dword ptr[edi +  0], eax
; 121  :     mov     dword ptr[edi +  4], ebx
; 122  :     mov     dword ptr[edi +  8], ecx
; 123  :     mov     dword ptr[edi + 12], edx
; 124  :   }
; 125  : # endif // _MSC_VER < 1400
; 126  : 
; 127  : #elif defined(__GNUC__)
; 128  : // Note, patched to preserve ebx/rbx register which is used by GCC.
; 129  : # if defined(ASMJIT_HOST_X86)
; 130  : #  define __myCpuId(inEax, inEcx, outEax, outEbx, outEcx, outEdx) \
; 131  :   __asm__ __volatile__( \
; 132  :     "mov %%ebx, %%edi\n"  \
; 133  :     "cpuid\n"             \
; 134  :     "xchg %%edi, %%ebx\n" \
; 135  :       : "=a" (outEax), "=D" (outEbx), "=c" (outEcx), "=d" (outEdx) \
; 136  :       : "a" (inEax), "c" (inEcx))
; 137  : # else
; 138  : #  define __myCpuId(inEax, inEcx, outEax, outEbx, outEcx, outEdx) \
; 139  :   __asm__ __volatile__( \
; 140  :     "mov %%rbx, %%rdi\n"  \
; 141  :     "cpuid\n"             \
; 142  :     "xchg %%rdi, %%rbx\n" \
; 143  :       : "=a" (outEax), "=D" (outEbx), "=c" (outEcx), "=d" (outEdx) \
; 144  :       : "a" (inEax), "c" (inEcx))
; 145  : # endif
; 146  :   __myCpuId(inEax, inEcx, result->eax, result->ebx, result->ecx, result->edx);
; 147  : #endif // COMPILER
; 148  : }

	add	rsp, 16
	pop	rbx
	ret	0
?callCpuId@X86CpuUtil@asmjit@@SAXIIPEATX86CpuId@2@@Z ENDP ; asmjit::X86CpuUtil::callCpuId
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\cpuinfo.h
;	COMDAT ?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z
_TEXT	SEGMENT
tv90 = 0
tv70 = 4
tv76 = 8
this$ = 32
feature$ = 40
?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z PROC		; asmjit::CpuInfo::addFeature, COMDAT

; 94   :   ASMJIT_INLINE CpuInfo& addFeature(uint32_t feature) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 95   :     ASMJIT_ASSERT(feature < sizeof(_features) * 8);
; 96   : 
; 97   :     _features[feature / kFeaturesPerUInt32] |= (1U << (feature % kFeaturesPerUInt32));

	xor	edx, edx
	mov	eax, DWORD PTR feature$[rsp]
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, edx
	mov	ecx, 1
	mov	DWORD PTR tv90[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv90[rsp]
	shl	eax, cl
	mov	DWORD PTR tv70[rsp], eax
	xor	edx, edx
	mov	eax, DWORD PTR feature$[rsp]
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4+104]
	mov	ecx, DWORD PTR tv70[rsp]
	or	eax, ecx
	mov	DWORD PTR tv76[rsp], eax
	xor	edx, edx
	mov	eax, DWORD PTR feature$[rsp]
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR tv76[rsp]
	mov	DWORD PTR [rcx+rax*4+104], edx

; 98   :     return *this;

	mov	rax, QWORD PTR this$[rsp]

; 99   :   }

	add	rsp, 24
	ret	0
?addFeature@CpuInfo@asmjit@@QEAAAEAU12@I@Z ENDP		; asmjit::CpuInfo::addFeature
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\cpuinfo.h
;	COMDAT ?hasFeature@CpuInfo@asmjit@@QEBA_NI@Z
_TEXT	SEGMENT
tv85 = 0
tv66 = 8
this$ = 32
feature$ = 40
?hasFeature@CpuInfo@asmjit@@QEBA_NI@Z PROC		; asmjit::CpuInfo::hasFeature, COMDAT

; 86   :   ASMJIT_INLINE bool hasFeature(uint32_t feature) const {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 87   :     ASMJIT_ASSERT(feature < sizeof(_features) * 8);
; 88   : 
; 89   :     return static_cast<bool>(

	xor	edx, edx
	mov	eax, DWORD PTR feature$[rsp]
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, eax
	mov	QWORD PTR tv66[rsp], rax
	xor	edx, edx
	mov	eax, DWORD PTR feature$[rsp]
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, edx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR tv85[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv85[rsp]
	mov	rdx, QWORD PTR tv66[rsp]
	mov	eax, DWORD PTR [rax+rdx*4+104]
	shr	eax, cl
	and	eax, 1

; 90   :       (_features[feature / kFeaturesPerUInt32] >> (feature % kFeaturesPerUInt32)) & 0x1);
; 91   :   }

	add	rsp, 24
	ret	0
?hasFeature@CpuInfo@asmjit@@QEBA_NI@Z ENDP		; asmjit::CpuInfo::hasFeature
_TEXT	ENDS
END
