; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

EXTRN	?x86RegData@asmjit@@3UX86RegData@1@B:BYTE	; asmjit::x86RegData
CONST	SEGMENT
?NoInit@asmjit@@3U_NoInit@1@B	ORG $+1			; asmjit::NoInit
CONST	ENDS
PUBLIC	?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z		; asmjit::IntUtil::pack32_4x8
PUBLIC	?pack64_2x32@IntUtil@asmjit@@SA_KII@Z		; asmjit::IntUtil::pack64_2x32
PUBLIC	?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z	; asmjit::UInt64::setPacked_2x32
PUBLIC	??0Operand@asmjit@@QEAA@AEBU01@@Z		; asmjit::Operand::Operand
PUBLIC	??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z	; asmjit::Operand::Operand
PUBLIC	?_init@Operand@asmjit@@QEAAXAEBU12@@Z		; asmjit::Operand::_init
PUBLIC	?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z ; asmjit::Operand::_init_packed_op_sz_b0_b1_id
PUBLIC	?getRegIndex@Reg@asmjit@@QEBAIXZ		; asmjit::Reg::getRegIndex
PUBLIC	??0BaseMem@asmjit@@QEAA@AEBU01@@Z		; asmjit::BaseMem::BaseMem
PUBLIC	??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z	; asmjit::BaseMem::BaseMem
PUBLIC	?isGp@X86Reg@asmjit@@QEBA_NXZ			; asmjit::X86Reg::isGp
PUBLIC	?isXmm@X86Reg@asmjit@@QEBA_NXZ			; asmjit::X86Reg::isXmm
PUBLIC	?isYmm@X86Reg@asmjit@@QEBA_NXZ			; asmjit::X86Reg::isYmm
PUBLIC	??0X86Mem@asmjit@@QEAA@AEBU01@@Z		; asmjit::X86Mem::X86Mem
PUBLIC	??0X86Mem@asmjit@@QEAA@AEBU_NoInit@1@@Z		; asmjit::X86Mem::X86Mem
PUBLIC	?_getGpdFlags@X86Mem@asmjit@@SAIAEBUOperand@2@@Z ; asmjit::X86Mem::_getGpdFlags
PUBLIC	?ptr_abs@x86@asmjit@@YA?AUX86Mem@2@_KHI@Z	; asmjit::x86::ptr_abs
PUBLIC	?ptr_abs@x86@asmjit@@YA?AUX86Mem@2@_KAEBUX86Reg@2@IHI@Z ; asmjit::x86::ptr_abs
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Operand@asmjit@@QEAA@AEBU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??0Operand@asmjit@@QEAA@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_init@Operand@asmjit@@QEAAXAEBU12@@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?_init@Operand@asmjit@@QEAAXAEBU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0BaseMem@asmjit@@QEAA@AEBU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??0BaseMem@asmjit@@QEAA@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isGp@X86Reg@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$?isGp@X86Reg@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isXmm@X86Reg@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$?isXmm@X86Reg@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isYmm@X86Reg@asmjit@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$?isYmm@X86Reg@asmjit@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0X86Mem@asmjit@@QEAA@AEBU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??0X86Mem@asmjit@@QEAA@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0X86Mem@asmjit@@QEAA@AEBU_NoInit@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??0X86Mem@asmjit@@QEAA@AEBU_NoInit@1@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?ptr_abs@x86@asmjit@@YA?AUX86Mem@2@_KHI@Z DD imagerel $LN3
	DD	imagerel $LN3+136
	DD	imagerel $unwind$?ptr_abs@x86@asmjit@@YA?AUX86Mem@2@_KHI@Z
$pdata$?ptr_abs@x86@asmjit@@YA?AUX86Mem@2@_KAEBUX86Reg@2@IHI@Z DD imagerel $LN8
	DD	imagerel $LN8+258
	DD	imagerel $unwind$?ptr_abs@x86@asmjit@@YA?AUX86Mem@2@_KAEBUX86Reg@2@IHI@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?ptr_abs@x86@asmjit@@YA?AUX86Mem@2@_KHI@Z DD 011801H
	DD	08218H
$unwind$?ptr_abs@x86@asmjit@@YA?AUX86Mem@2@_KAEBUX86Reg@2@IHI@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0X86Mem@asmjit@@QEAA@AEBU_NoInit@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0X86Mem@asmjit@@QEAA@AEBU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isYmm@X86Reg@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isXmm@X86Reg@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isGp@X86Reg@asmjit@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0BaseMem@asmjit@@QEAA@AEBU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_init@Operand@asmjit@@QEAAXAEBU12@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Operand@asmjit@@QEAA@AEBU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z DD 011201H
	DD	04212H
xdata	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.cpp
_TEXT	SEGMENT
flags$ = 48
m$ = 56
__$ReturnUdt$ = 96
pAbs$ = 104
index$ = 112
shift$ = 120
disp$ = 128
size$ = 136
?ptr_abs@x86@asmjit@@YA?AUX86Mem@2@_KAEBUX86Reg@2@IHI@Z PROC ; asmjit::x86::ptr_abs

; 37   : X86Mem ptr_abs(Ptr pAbs, const X86Reg& index, uint32_t shift, int32_t disp, uint32_t size) {

$LN8:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 38   :   X86Mem m(NoInit);

	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	lea	rcx, QWORD PTR m$[rsp]
	call	??0X86Mem@asmjit@@QEAA@AEBU_NoInit@1@@Z	; asmjit::X86Mem::X86Mem

; 39   :   uint32_t flags = shift << kX86MemShiftIndex;

	mov	eax, DWORD PTR shift$[rsp]
	shl	eax, 6
	mov	DWORD PTR flags$[rsp], eax

; 40   : 
; 41   :   if (index.isGp())

	mov	rcx, QWORD PTR index$[rsp]
	call	?isGp@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isGp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@ptr_abs

; 42   :     flags |= X86Mem::_getGpdFlags(index);

	mov	rcx, QWORD PTR index$[rsp]
	call	?_getGpdFlags@X86Mem@asmjit@@SAIAEBUOperand@2@@Z ; asmjit::X86Mem::_getGpdFlags
	mov	ecx, DWORD PTR flags$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR flags$[rsp], eax
	jmp	SHORT $LN3@ptr_abs
$LN2@ptr_abs:

; 43   :   else if (index.isXmm())

	mov	rcx, QWORD PTR index$[rsp]
	call	?isXmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isXmm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@ptr_abs

; 44   :     flags |= kX86MemVSibXmm << kX86MemVSibIndex;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 16
	mov	DWORD PTR flags$[rsp], eax
	jmp	SHORT $LN5@ptr_abs
$LN4@ptr_abs:

; 45   :   else if (index.isYmm())

	mov	rcx, QWORD PTR index$[rsp]
	call	?isYmm@X86Reg@asmjit@@QEBA_NXZ		; asmjit::X86Reg::isYmm
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@ptr_abs

; 46   :     flags |= kX86MemVSibYmm << kX86MemVSibIndex;

	mov	eax, DWORD PTR flags$[rsp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR flags$[rsp], eax
$LN6@ptr_abs:
$LN5@ptr_abs:
$LN3@ptr_abs:

; 47   : 
; 48   :   m._init_packed_op_sz_b0_b1_id(kOperandTypeMem, size, kMemTypeAbsolute, flags, kInvalidValue);

	mov	DWORD PTR [rsp+40], -1			; ffffffffH
	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, 3
	mov	r8d, DWORD PTR size$[rsp]
	mov	edx, 3
	lea	rcx, QWORD PTR m$[rsp]
	call	?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z ; asmjit::Operand::_init_packed_op_sz_b0_b1_id

; 49   :   m._vmem.index = index.getRegIndex();

	mov	rcx, QWORD PTR index$[rsp]
	call	?getRegIndex@Reg@asmjit@@QEBAIXZ	; asmjit::Reg::getRegIndex
	mov	DWORD PTR m$[rsp+8], eax

; 50   :   m._vmem.displacement = static_cast<int32_t>((intptr_t)(pAbs + disp));

	movsxd	rax, DWORD PTR disp$[rsp]
	mov	rcx, QWORD PTR pAbs$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR m$[rsp+12], eax

; 51   : 
; 52   :   return m;

	lea	rdx, QWORD PTR m$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0X86Mem@asmjit@@QEAA@AEBU01@@Z	; asmjit::X86Mem::X86Mem
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 53   : }

	add	rsp, 88					; 00000058H
	ret	0
?ptr_abs@x86@asmjit@@YA?AUX86Mem@2@_KAEBUX86Reg@2@IHI@Z ENDP ; asmjit::x86::ptr_abs
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.cpp
_TEXT	SEGMENT
m$ = 48
__$ReturnUdt$ = 80
pAbs$ = 88
disp$ = 96
size$ = 104
?ptr_abs@x86@asmjit@@YA?AUX86Mem@2@_KHI@Z PROC		; asmjit::x86::ptr_abs

; 27   : X86Mem ptr_abs(Ptr pAbs, int32_t disp, uint32_t size) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 28   :   X86Mem m(NoInit);

	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	lea	rcx, QWORD PTR m$[rsp]
	call	??0X86Mem@asmjit@@QEAA@AEBU_NoInit@1@@Z	; asmjit::X86Mem::X86Mem

; 29   : 
; 30   :   m._init_packed_op_sz_b0_b1_id(kOperandTypeMem, size, kMemTypeAbsolute, 0, kInvalidValue);

	mov	DWORD PTR [rsp+40], -1			; ffffffffH
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 3
	mov	r8d, DWORD PTR size$[rsp]
	mov	edx, 3
	lea	rcx, QWORD PTR m$[rsp]
	call	?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z ; asmjit::Operand::_init_packed_op_sz_b0_b1_id

; 31   :   m._vmem.index = kInvalidValue;

	mov	DWORD PTR m$[rsp+8], -1			; ffffffffH

; 32   :   m._vmem.displacement = static_cast<int32_t>((intptr_t)(pAbs + disp));

	movsxd	rax, DWORD PTR disp$[rsp]
	mov	rcx, QWORD PTR pAbs$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR m$[rsp+12], eax

; 33   : 
; 34   :   return m;

	lea	rdx, QWORD PTR m$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0X86Mem@asmjit@@QEAA@AEBU01@@Z	; asmjit::X86Mem::X86Mem
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 35   : }

	add	rsp, 72					; 00000048H
	ret	0
?ptr_abs@x86@asmjit@@YA?AUX86Mem@2@_KHI@Z ENDP		; asmjit::x86::ptr_abs
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?_getGpdFlags@X86Mem@asmjit@@SAIAEBUOperand@2@@Z
_TEXT	SEGMENT
base$ = 8
?_getGpdFlags@X86Mem@asmjit@@SAIAEBUOperand@2@@Z PROC	; asmjit::X86Mem::_getGpdFlags, COMDAT

; 1514 :   static ASMJIT_INLINE uint32_t _getGpdFlags(const Operand& base) {

	mov	QWORD PTR [rsp+8], rcx

; 1515 :     return (base._vreg.size & 0x4) << (kX86MemGpdIndex - 2);

	mov	rax, QWORD PTR base$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	and	eax, 4
	shl	eax, 1

; 1516 :   }

	ret	0
?_getGpdFlags@X86Mem@asmjit@@SAIAEBUOperand@2@@Z ENDP	; asmjit::X86Mem::_getGpdFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ??0X86Mem@asmjit@@QEAA@AEBU_NoInit@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??0X86Mem@asmjit@@QEAA@AEBU_NoInit@1@@Z PROC		; asmjit::X86Mem::X86Mem, COMDAT

; 1205 :   explicit ASMJIT_INLINE X86Mem(const _NoInit&) : BaseMem(NoInit) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR this$[rsp]
	call	??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::BaseMem::BaseMem
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0X86Mem@asmjit@@QEAA@AEBU_NoInit@1@@Z ENDP		; asmjit::X86Mem::X86Mem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ??0X86Mem@asmjit@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??0X86Mem@asmjit@@QEAA@AEBU01@@Z PROC			; asmjit::X86Mem::X86Mem, COMDAT

; 1204 :   ASMJIT_INLINE X86Mem(const X86Mem& other) : BaseMem(other) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR other$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0BaseMem@asmjit@@QEAA@AEBU01@@Z	; asmjit::BaseMem::BaseMem
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0X86Mem@asmjit@@QEAA@AEBU01@@Z ENDP			; asmjit::X86Mem::X86Mem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?isYmm@X86Reg@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 0
this$ = 32
?isYmm@X86Reg@asmjit@@QEBA_NXZ PROC			; asmjit::X86Reg::isYmm, COMDAT

; 692  :   ASMJIT_INLINE bool isYmm() const { return _vreg.type == kX86RegTypeYmm; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN3@isYmm
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@isYmm
$LN3@isYmm:
	mov	DWORD PTR tv72[rsp], 0
$LN4@isYmm:
	movzx	eax, BYTE PTR tv72[rsp]
	add	rsp, 24
	ret	0
?isYmm@X86Reg@asmjit@@QEBA_NXZ ENDP			; asmjit::X86Reg::isYmm
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?isXmm@X86Reg@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 0
this$ = 32
?isXmm@X86Reg@asmjit@@QEBA_NXZ PROC			; asmjit::X86Reg::isXmm, COMDAT

; 690  :   ASMJIT_INLINE bool isXmm() const { return _vreg.type == kX86RegTypeXmm; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	cmp	eax, 112				; 00000070H
	jne	SHORT $LN3@isXmm
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@isXmm
$LN3@isXmm:
	mov	DWORD PTR tv72[rsp], 0
$LN4@isXmm:
	movzx	eax, BYTE PTR tv72[rsp]
	add	rsp, 24
	ret	0
?isXmm@X86Reg@asmjit@@QEBA_NXZ ENDP			; asmjit::X86Reg::isXmm
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\x86\x86operand.h
;	COMDAT ?isGp@X86Reg@asmjit@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 0
this$ = 32
?isGp@X86Reg@asmjit@@QEBA_NXZ PROC			; asmjit::X86Reg::isGp, COMDAT

; 667  :   ASMJIT_INLINE bool isGp() const { return _vreg.type <= kX86RegTypeGpq; }

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+3]
	cmp	eax, 48					; 00000030H
	ja	SHORT $LN3@isGp
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@isGp
$LN3@isGp:
	mov	DWORD PTR tv72[rsp], 0
$LN4@isGp:
	movzx	eax, BYTE PTR tv72[rsp]
	add	rsp, 24
	ret	0
?isGp@X86Reg@asmjit@@QEBA_NXZ ENDP			; asmjit::X86Reg::isGp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z PROC		; asmjit::BaseMem::BaseMem, COMDAT

; 645  :   explicit ASMJIT_INLINE BaseMem(const _NoInit&) : Operand(NoInit) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	lea	rdx, OFFSET FLAT:?NoInit@asmjit@@3U_NoInit@1@B
	mov	rcx, QWORD PTR this$[rsp]
	call	??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z ; asmjit::Operand::Operand
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0BaseMem@asmjit@@QEAA@AEBU_NoInit@1@@Z ENDP		; asmjit::BaseMem::BaseMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ??0BaseMem@asmjit@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??0BaseMem@asmjit@@QEAA@AEBU01@@Z PROC			; asmjit::BaseMem::BaseMem, COMDAT

; 644  :   ASMJIT_INLINE BaseMem(const BaseMem& other) : Operand(other) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR other$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0Operand@asmjit@@QEAA@AEBU01@@Z	; asmjit::Operand::Operand
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0BaseMem@asmjit@@QEAA@AEBU01@@Z ENDP			; asmjit::BaseMem::BaseMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?getRegIndex@Reg@asmjit@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getRegIndex@Reg@asmjit@@QEBAIXZ PROC			; asmjit::Reg::getRegIndex, COMDAT

; 584  :   ASMJIT_INLINE uint32_t getRegIndex() const {

	mov	QWORD PTR [rsp+8], rcx

; 585  :     return _vreg.index;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+2]

; 586  :   }

	ret	0
?getRegIndex@Reg@asmjit@@QEBAIXZ ENDP			; asmjit::Reg::getRegIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z
_TEXT	SEGMENT
tv77 = 32
this$ = 64
op$ = 72
sz$ = 80
r0$ = 88
r1$ = 96
id$ = 104
?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z PROC ; asmjit::Operand::_init_packed_op_sz_b0_b1_id, COMDAT

; 334  :   ASMJIT_INLINE void _init_packed_op_sz_b0_b1_id(uint32_t op, uint32_t sz, uint32_t r0, uint32_t r1, uint32_t id) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 335  :     // This hack is not for performance, but to decrease the size of the binary
; 336  :     // generated when constructing AsmJit operands (mostly for third parties).
; 337  :     // Some compilers are not able to join four BYTE writes to a single DWORD
; 338  :     // write. Because the 'a', 'b', 'c' and 'd' variables are usually compile
; 339  :     // time constants the compiler can do a really nice job if they are joined
; 340  :     // by using bitwise operations.
; 341  :     _packed[0].setPacked_2x32(IntUtil::pack32_4x8(op, sz, r0, r1), id);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv77[rsp], rax
	mov	r9d, DWORD PTR r1$[rsp]
	mov	r8d, DWORD PTR r0$[rsp]
	mov	edx, DWORD PTR sz$[rsp]
	mov	ecx, DWORD PTR op$[rsp]
	call	?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z	; asmjit::IntUtil::pack32_4x8
	mov	r8d, DWORD PTR id$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR tv77[rsp]
	call	?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z ; asmjit::UInt64::setPacked_2x32
	npad	1

; 342  :   }

	add	rsp, 56					; 00000038H
	ret	0
?_init_packed_op_sz_b0_b1_id@Operand@asmjit@@QEAAXIIIII@Z ENDP ; asmjit::Operand::_init_packed_op_sz_b0_b1_id
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ?_init@Operand@asmjit@@QEAAXAEBU12@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
?_init@Operand@asmjit@@QEAAXAEBU12@@Z PROC		; asmjit::Operand::_init, COMDAT

; 330  :   ASMJIT_INLINE void _init(const Operand& other) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 331  :     ::memcpy(this, &other, sizeof(Operand));

	mov	r8d, 16
	mov	rdx, QWORD PTR other$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	memcpy
	npad	1

; 332  :   }

	add	rsp, 40					; 00000028H
	ret	0
?_init@Operand@asmjit@@QEAAXAEBU12@@Z ENDP		; asmjit::Operand::_init
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z PROC		; asmjit::Operand::Operand, COMDAT

; 312  :   explicit ASMJIT_INLINE Operand(const _NoInit&) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z ENDP		; asmjit::Operand::Operand
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\operand.h
;	COMDAT ??0Operand@asmjit@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??0Operand@asmjit@@QEAA@AEBU01@@Z PROC			; asmjit::Operand::Operand, COMDAT

; 308  :   ASMJIT_INLINE Operand(const Operand& other) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 309  :     _init(other);

	mov	rdx, QWORD PTR other$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_init@Operand@asmjit@@QEAAXAEBU12@@Z	; asmjit::Operand::_init
	npad	1

; 310  :   }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0Operand@asmjit@@QEAA@AEBU01@@Z ENDP			; asmjit::Operand::Operand
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z
_TEXT	SEGMENT
this$ = 48
u0$ = 56
u1$ = 64
?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z PROC	; asmjit::UInt64::setPacked_2x32, COMDAT

; 498  :   ASMJIT_INLINE UInt64& setPacked_2x32(uint32_t u0, uint32_t u1) {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 499  :     if (kArchHost64Bit) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@setPacked_

; 500  :       u64 = IntUtil::pack64_2x32(u0, u1);

	mov	edx, DWORD PTR u1$[rsp]
	mov	ecx, DWORD PTR u0$[rsp]
	call	?pack64_2x32@IntUtil@asmjit@@SA_KII@Z	; asmjit::IntUtil::pack64_2x32
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax

; 501  :     }

	jmp	SHORT $LN3@setPacked_
$LN2@setPacked_:

; 502  :     else {
; 503  :       u32[0] = u0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR u0$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 504  :       u32[1] = u1;

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR u1$[rsp]
	mov	DWORD PTR [rcx+rax], edx
$LN3@setPacked_:

; 505  :     }
; 506  :     return *this;

	mov	rax, QWORD PTR this$[rsp]

; 507  :   }

	add	rsp, 40					; 00000028H
	ret	0
?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z ENDP	; asmjit::UInt64::setPacked_2x32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ?pack64_2x32@IntUtil@asmjit@@SA_KII@Z
_TEXT	SEGMENT
u0$ = 8
u1$ = 16
?pack64_2x32@IntUtil@asmjit@@SA_KII@Z PROC		; asmjit::IntUtil::pack64_2x32, COMDAT

; 102  :   static ASMJIT_INLINE uint64_t pack64_2x32(uint32_t u0, uint32_t u1) {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 103  : #if defined(ASMJIT_HOST_LE)
; 104  :     return (static_cast<uint64_t>(u1) << 32) + u0;

	mov	eax, DWORD PTR u1$[rsp]
	shl	rax, 32					; 00000020H
	mov	ecx, DWORD PTR u0$[rsp]
	add	rax, rcx

; 105  : #else
; 106  :     return (static_cast<uint64_t>(u0) << 32) + u1;
; 107  : #endif // ASMJIT_HOST
; 108  :   }

	ret	0
?pack64_2x32@IntUtil@asmjit@@SA_KII@Z ENDP		; asmjit::IntUtil::pack64_2x32
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z
_TEXT	SEGMENT
u0$ = 8
u1$ = 16
u2$ = 24
u3$ = 32
?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z PROC		; asmjit::IntUtil::pack32_4x8, COMDAT

; 93   :   static ASMJIT_INLINE uint32_t pack32_4x8(uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3) {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 94   : #if defined(ASMJIT_HOST_LE)
; 95   :     return u0 + (u1 << 8) + (u2 << 16) + (u3 << 24);

	mov	eax, DWORD PTR u1$[rsp]
	shl	eax, 8
	mov	ecx, DWORD PTR u0$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR u2$[rsp]
	shl	ecx, 16
	add	eax, ecx
	mov	ecx, DWORD PTR u3$[rsp]
	shl	ecx, 24
	add	eax, ecx

; 96   : #else
; 97   :     return (u0 << 24) + (u1 << 16) + (u2 << 8) + u3;
; 98   : #endif // ASMJIT_HOST
; 99   :   }

	ret	0
?pack32_4x8@IntUtil@asmjit@@SAIIIII@Z ENDP		; asmjit::IntUtil::pack32_4x8
_TEXT	ENDS
END
