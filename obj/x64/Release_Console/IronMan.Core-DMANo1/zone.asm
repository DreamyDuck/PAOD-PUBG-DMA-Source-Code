; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?Zone_zeroBlock@asmjit@@3UBlock@Zone@1@B DQ 0000000000000000H ; asmjit::Zone_zeroBlock
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsnprintf
PUBLIC	?getBlockSize@Block@Zone@asmjit@@QEBA_KXZ	; asmjit::Zone::Block::getBlockSize
PUBLIC	??0Zone@asmjit@@QEAA@_K@Z			; asmjit::Zone::Zone
PUBLIC	??1Zone@asmjit@@QEAA@XZ				; asmjit::Zone::~Zone
PUBLIC	?reset@Zone@asmjit@@QEAAX_N@Z			; asmjit::Zone::reset
PUBLIC	?alloc@Zone@asmjit@@QEAAPEAX_K@Z		; asmjit::Zone::alloc
PUBLIC	?allocZeroed@Zone@asmjit@@QEAAPEAX_K@Z		; asmjit::Zone::allocZeroed
PUBLIC	?_alloc@Zone@asmjit@@QEAAPEAX_K@Z		; asmjit::Zone::_alloc
PUBLIC	?dup@Zone@asmjit@@QEAAPEAXPEBX_K@Z		; asmjit::Zone::dup
PUBLIC	?sdup@Zone@asmjit@@QEAAPEADPEBD@Z		; asmjit::Zone::sdup
PUBLIC	?sformat@Zone@asmjit@@QEAAPEADPEBDZZ		; asmjit::Zone::sformat
PUBLIC	??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z		; asmjit::IntUtil::iMax<unsigned __int64>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strlen:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$_vsnprintf
pdata	ENDS
pdata	SEGMENT
$pdata$??1Zone@asmjit@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??1Zone@asmjit@@QEAA@XZ
$pdata$?reset@Zone@asmjit@@QEAAX_N@Z DD imagerel $LN13
	DD	imagerel $LN13+244
	DD	imagerel $unwind$?reset@Zone@asmjit@@QEAAX_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@Zone@asmjit@@QEAAPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+122
	DD	imagerel $unwind$?alloc@Zone@asmjit@@QEAAPEAX_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?allocZeroed@Zone@asmjit@@QEAAPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?allocZeroed@Zone@asmjit@@QEAAPEAX_K@Z
$pdata$?_alloc@Zone@asmjit@@QEAAPEAX_K@Z DD imagerel $LN8
	DD	imagerel $LN8+373
	DD	imagerel $unwind$?_alloc@Zone@asmjit@@QEAAPEAX_K@Z
$pdata$?dup@Zone@asmjit@@QEAAPEAXPEBX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+105
	DD	imagerel $unwind$?dup@Zone@asmjit@@QEAAPEAXPEBX_K@Z
$pdata$?sdup@Zone@asmjit@@QEAAPEADPEBD@Z DD imagerel $LN7
	DD	imagerel $LN7+171
	DD	imagerel $unwind$?sdup@Zone@asmjit@@QEAAPEADPEBD@Z
$pdata$?sformat@Zone@asmjit@@QEAAPEADPEBDZZ DD imagerel $LN6
	DD	imagerel $LN6+229
	DD	imagerel $unwind$?sformat@Zone@asmjit@@QEAAPEADPEBDZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+67
	DD	imagerel $unwind$??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?sformat@Zone@asmjit@@QEAAPEADPEBDZZ
	DD	025H
	DD	0cdH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@Zone@asmjit@@QEAAPEAX_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
xdata	SEGMENT
$unwind$??1Zone@asmjit@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1Zone@asmjit@@QEAA@XZ
$cppxdata$??1Zone@asmjit@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1Zone@asmjit@@QEAA@XZ
$ip2state$??1Zone@asmjit@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
$unwind$?reset@Zone@asmjit@@QEAAX_N@Z DD 010d01H
	DD	0820dH
$unwind$?allocZeroed@Zone@asmjit@@QEAAPEAX_K@Z DD 010e01H
	DD	0620eH
$unwind$?_alloc@Zone@asmjit@@QEAAPEAX_K@Z DD 010e01H
	DD	0820eH
$unwind$?dup@Zone@asmjit@@QEAAPEAXPEBX_K@Z DD 011301H
	DD	06213H
$unwind$?sdup@Zone@asmjit@@QEAAPEADPEBD@Z DD 010e01H
	DD	0620eH
$unwind$?sformat@Zone@asmjit@@QEAAPEADPEBDZZ DD 022d19H
	DD	04b011bH
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\intutil.h
;	COMDAT ??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
a$ = 32
b$ = 40
??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z PROC		; asmjit::IntUtil::iMax<unsigned __int64>, COMDAT

; 123  :   static ASMJIT_INLINE T iMax(const T& a, const T& b) { return a > b ? a : b; }

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jbe	SHORT $LN3@iMax
	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@iMax
$LN3@iMax:
	mov	rax, QWORD PTR b$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv65[rsp], rax
$LN4@iMax:
	mov	rax, QWORD PTR tv65[rsp]
	add	rsp, 24
	ret	0
??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z ENDP		; asmjit::IntUtil::iMax<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.cpp
_TEXT	SEGMENT
len$ = 32
$T1 = 40
ap$ = 48
tv77 = 56
buf$ = 64
__$ArrayPad$ = 576
this$ = 608
fmt$ = 616
?sformat@Zone@asmjit@@QEAAPEADPEBDZZ PROC		; asmjit::Zone::sformat

; 175  : char* Zone::sformat(const char* fmt, ...) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 600				; 00000258H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 176  :   if (fmt == NULL)

	cmp	QWORD PTR fmt$[rsp], 0
	jne	SHORT $LN2@sformat

; 177  :     return NULL;

	xor	eax, eax
	jmp	$LN1@sformat
$LN2@sformat:

; 178  : 
; 179  :   char buf[512];
; 180  :   size_t len;
; 181  : 
; 182  :   va_list ap;
; 183  :   va_start(ap, fmt);

	lea	rax, QWORD PTR fmt$[rsp+8]
	mov	QWORD PTR ap$[rsp], rax

; 184  : 
; 185  :   len = vsnprintf(buf, ASMJIT_ARRAY_SIZE(buf) - 1, fmt, ap);

	mov	r9, QWORD PTR ap$[rsp]
	mov	r8, QWORD PTR fmt$[rsp]
	mov	edx, 511				; 000001ffH
	lea	rcx, QWORD PTR buf$[rsp]
	call	_vsnprintf
	cdqe
	mov	QWORD PTR len$[rsp], rax

; 186  :   buf[len++] = 0;

	mov	rax, QWORD PTR len$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	rax, QWORD PTR len$[rsp]
	inc	rax
	mov	QWORD PTR len$[rsp], rax
	mov	rax, QWORD PTR tv77[rsp]
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 512			; 00000200H
	jae	SHORT $LN4@sformat
	jmp	SHORT $LN5@sformat
$LN4@sformat:
	call	__report_rangecheckfailure
	npad	1
$LN5@sformat:
	mov	rax, QWORD PTR $T1[rsp]
	mov	BYTE PTR buf$[rsp+rax], 0

; 187  : 
; 188  :   va_end(ap);

	mov	QWORD PTR ap$[rsp], 0

; 189  :   return static_cast<char*>(dup(buf, len));

	mov	r8, QWORD PTR len$[rsp]
	lea	rdx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?dup@Zone@asmjit@@QEAAPEAXPEBX_K@Z	; asmjit::Zone::dup
$LN1@sformat:
$LN3@sformat:

; 190  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 600				; 00000258H
	ret	0
?sformat@Zone@asmjit@@QEAAPEADPEBDZZ ENDP		; asmjit::Zone::sformat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.cpp
_TEXT	SEGMENT
len$ = 32
m$ = 40
this$ = 64
str$ = 72
?sdup@Zone@asmjit@@QEAAPEADPEBD@Z PROC			; asmjit::Zone::sdup

; 154  : char* Zone::sdup(const char* str) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 155  :   if (str == NULL)

	cmp	QWORD PTR str$[rsp], 0
	jne	SHORT $LN2@sdup

; 156  :     return NULL;

	xor	eax, eax
	jmp	$LN1@sdup
$LN2@sdup:

; 157  : 
; 158  :   size_t len = ::strlen(str);

	mov	rcx, QWORD PTR str$[rsp]
	call	strlen
	mov	QWORD PTR len$[rsp], rax

; 159  :   if (len == 0)

	cmp	QWORD PTR len$[rsp], 0
	jne	SHORT $LN3@sdup

; 160  :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@sdup
$LN3@sdup:

; 161  : 
; 162  :   // Include NULL terminator and limit string length.
; 163  :   if (++len > 256)

	mov	rax, QWORD PTR len$[rsp]
	inc	rax
	mov	QWORD PTR len$[rsp], rax
	cmp	QWORD PTR len$[rsp], 256		; 00000100H
	jbe	SHORT $LN4@sdup

; 164  :     len = 256;

	mov	QWORD PTR len$[rsp], 256		; 00000100H
$LN4@sdup:

; 165  : 
; 166  :   char* m = static_cast<char*>(alloc(len));

	mov	rdx, QWORD PTR len$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?alloc@Zone@asmjit@@QEAAPEAX_K@Z	; asmjit::Zone::alloc
	mov	QWORD PTR m$[rsp], rax

; 167  :   if (m == NULL)

	cmp	QWORD PTR m$[rsp], 0
	jne	SHORT $LN5@sdup

; 168  :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@sdup
$LN5@sdup:

; 169  : 
; 170  :   ::memcpy(m, str, len);

	mov	r8, QWORD PTR len$[rsp]
	mov	rdx, QWORD PTR str$[rsp]
	mov	rcx, QWORD PTR m$[rsp]
	call	memcpy

; 171  :   m[len - 1] = '\0';

	mov	rax, QWORD PTR len$[rsp]
	mov	rcx, QWORD PTR m$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rax-1], 0

; 172  :   return m;

	mov	rax, QWORD PTR m$[rsp]
$LN1@sdup:

; 173  : }

	add	rsp, 56					; 00000038H
	ret	0
?sdup@Zone@asmjit@@QEAAPEADPEBD@Z ENDP			; asmjit::Zone::sdup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.cpp
_TEXT	SEGMENT
m$ = 32
this$ = 64
data$ = 72
size$ = 80
?dup@Zone@asmjit@@QEAAPEAXPEBX_K@Z PROC			; asmjit::Zone::dup

; 139  : void* Zone::dup(const void* data, size_t size) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 140  :   if (data == NULL)

	cmp	QWORD PTR data$[rsp], 0
	jne	SHORT $LN2@dup

; 141  :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@dup
$LN2@dup:

; 142  : 
; 143  :   if (size == 0)

	cmp	QWORD PTR size$[rsp], 0
	jne	SHORT $LN3@dup

; 144  :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@dup
$LN3@dup:

; 145  : 
; 146  :   void* m = alloc(size);

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?alloc@Zone@asmjit@@QEAAPEAX_K@Z	; asmjit::Zone::alloc
	mov	QWORD PTR m$[rsp], rax

; 147  :   if (m == NULL)

	cmp	QWORD PTR m$[rsp], 0
	jne	SHORT $LN4@dup

; 148  :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@dup
$LN4@dup:

; 149  : 
; 150  :   ::memcpy(m, data, size);

	mov	r8, QWORD PTR size$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR m$[rsp]
	call	memcpy

; 151  :   return m;

	mov	rax, QWORD PTR m$[rsp]
$LN1@dup:

; 152  : }

	add	rsp, 56					; 00000038H
	ret	0
?dup@Zone@asmjit@@QEAAPEAXPEBX_K@Z ENDP			; asmjit::Zone::dup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.cpp
_TEXT	SEGMENT
newBlock$ = 32
next$ = 40
curBlock$ = 48
blockSize$ = 56
this$ = 80
size$ = 88
?_alloc@Zone@asmjit@@QEAAPEAX_K@Z PROC			; asmjit::Zone::_alloc

; 83   : void* Zone::_alloc(size_t size) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 84   :   Block* curBlock = _block;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curBlock$[rsp], rax

; 85   :   size_t blockSize = IntUtil::iMax<size_t>(_blockSize, size);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR size$[rsp]
	mov	rcx, rax
	call	??$iMax@_K@IntUtil@asmjit@@SA_KAEB_K0@Z	; asmjit::IntUtil::iMax<unsigned __int64>
	mov	QWORD PTR blockSize$[rsp], rax

; 86   : 
; 87   :   // The `_alloc()` method can only be called if there is not enough space
; 88   :   // in the current block, see `alloc()` implementation for more details.
; 89   :   ASMJIT_ASSERT(curBlock == &Zone_zeroBlock || curBlock->getRemainingSize() < size);
; 90   : 
; 91   :   // If the `Zone` has been reset the current block doesn't have to be the
; 92   :   // last one. Check if there is a block that can be used instead of allocating
; 93   :   // a new one. If there is a `next` block it's completely unused, we don't have
; 94   :   // to check for remaining bytes.
; 95   :   Block* next = curBlock->next;

	mov	rax, QWORD PTR curBlock$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR next$[rsp], rax

; 96   :   if (next != NULL && next->getBlockSize() >= size) {

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN2@alloc
	mov	rcx, QWORD PTR next$[rsp]
	call	?getBlockSize@Block@Zone@asmjit@@QEBA_KXZ ; asmjit::Zone::Block::getBlockSize
	cmp	rax, QWORD PTR size$[rsp]
	jb	SHORT $LN2@alloc

; 97   :     next->pos = next->data + size;

	mov	rax, QWORD PTR next$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	lea	rax, QWORD PTR [rax+rcx+32]
	mov	rcx, QWORD PTR next$[rsp]
	mov	QWORD PTR [rcx], rax

; 98   :     _block = next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	mov	QWORD PTR [rax], rcx

; 99   :     return static_cast<void*>(next->data);

	mov	rax, QWORD PTR next$[rsp]
	add	rax, 32					; 00000020H
	jmp	$LN1@alloc
$LN2@alloc:

; 100  :   }
; 101  : 
; 102  :   // Prevent arithmetic overflow.
; 103  :   if (blockSize > ~static_cast<size_t>(0) - sizeof(Block))

	cmp	QWORD PTR blockSize$[rsp], -41		; ffffffffffffffd7H
	jbe	SHORT $LN3@alloc

; 104  :     return NULL;

	xor	eax, eax
	jmp	$LN1@alloc
$LN3@alloc:

; 105  : 
; 106  :   Block* newBlock = static_cast<Block*>(ASMJIT_ALLOC(sizeof(Block) - sizeof(void*) + blockSize));

	mov	rax, QWORD PTR blockSize$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	malloc
	mov	QWORD PTR newBlock$[rsp], rax

; 107  :   if (newBlock == NULL)

	cmp	QWORD PTR newBlock$[rsp], 0
	jne	SHORT $LN4@alloc

; 108  :     return NULL;

	xor	eax, eax
	jmp	$LN1@alloc
$LN4@alloc:

; 109  : 
; 110  :   newBlock->pos = newBlock->data + size;

	mov	rax, QWORD PTR newBlock$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	lea	rax, QWORD PTR [rax+rcx+32]
	mov	rcx, QWORD PTR newBlock$[rsp]
	mov	QWORD PTR [rcx], rax

; 111  :   newBlock->end = newBlock->data + blockSize;

	mov	rax, QWORD PTR newBlock$[rsp]
	mov	rcx, QWORD PTR blockSize$[rsp]
	lea	rax, QWORD PTR [rax+rcx+32]
	mov	rcx, QWORD PTR newBlock$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 112  :   newBlock->prev = NULL;

	mov	rax, QWORD PTR newBlock$[rsp]
	mov	QWORD PTR [rax+16], 0

; 113  :   newBlock->next = NULL;

	mov	rax, QWORD PTR newBlock$[rsp]
	mov	QWORD PTR [rax+24], 0

; 114  : 
; 115  :   if (curBlock != &Zone_zeroBlock) {

	lea	rax, OFFSET FLAT:?Zone_zeroBlock@asmjit@@3UBlock@Zone@1@B
	cmp	QWORD PTR curBlock$[rsp], rax
	je	SHORT $LN5@alloc

; 116  :     newBlock->prev = curBlock;

	mov	rax, QWORD PTR newBlock$[rsp]
	mov	rcx, QWORD PTR curBlock$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 117  :     curBlock->next = newBlock;

	mov	rax, QWORD PTR curBlock$[rsp]
	mov	rcx, QWORD PTR newBlock$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 118  : 
; 119  :     // Does only happen if there is a next block, but the requested memory
; 120  :     // can't fit into it. In this case a new buffer is allocated and inserted
; 121  :     // between the current block and the next one.
; 122  :     if (next != NULL) {

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN6@alloc

; 123  :       newBlock->next = next;

	mov	rax, QWORD PTR newBlock$[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 124  :       next->prev = newBlock;

	mov	rax, QWORD PTR next$[rsp]
	mov	rcx, QWORD PTR newBlock$[rsp]
	mov	QWORD PTR [rax+16], rcx
$LN6@alloc:
$LN5@alloc:

; 125  :     }
; 126  :   }
; 127  : 
; 128  :   _block = newBlock;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR newBlock$[rsp]
	mov	QWORD PTR [rax], rcx

; 129  :   return static_cast<void*>(newBlock->data);

	mov	rax, QWORD PTR newBlock$[rsp]
	add	rax, 32					; 00000020H
$LN1@alloc:

; 130  : }

	add	rsp, 72					; 00000048H
	ret	0
?_alloc@Zone@asmjit@@QEAAPEAX_K@Z ENDP			; asmjit::Zone::_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.cpp
_TEXT	SEGMENT
p$ = 32
this$ = 64
size$ = 72
?allocZeroed@Zone@asmjit@@QEAAPEAX_K@Z PROC		; asmjit::Zone::allocZeroed

; 132  : void* Zone::allocZeroed(size_t size) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 133  :   void* p = alloc(size);

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?alloc@Zone@asmjit@@QEAAPEAX_K@Z	; asmjit::Zone::alloc
	mov	QWORD PTR p$[rsp], rax

; 134  :   if (p != NULL)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN2@allocZeroe

; 135  :     ::memset(p, 0, size);

	mov	r8, QWORD PTR size$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR p$[rsp]
	call	memset
	npad	1
$LN2@allocZeroe:

; 136  :   return p;

	mov	rax, QWORD PTR p$[rsp]

; 137  : }

	add	rsp, 56					; 00000038H
	ret	0
?allocZeroed@Zone@asmjit@@QEAAPEAX_K@Z ENDP		; asmjit::Zone::allocZeroed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.h
;	COMDAT ?alloc@Zone@asmjit@@QEAAPEAX_K@Z
_TEXT	SEGMENT
cur$ = 32
ptr$ = 40
remainingBytes$ = 48
this$ = 80
size$ = 88
?alloc@Zone@asmjit@@QEAAPEAX_K@Z PROC			; asmjit::Zone::alloc, COMDAT

; 154  :   ASMJIT_INLINE void* alloc(size_t size) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 155  :     Block* cur = _block;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR cur$[rsp], rax

; 156  : 
; 157  :     uint8_t* ptr = cur->pos;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ptr$[rsp], rax

; 158  :     size_t remainingBytes = (size_t)(cur->end - ptr);

	mov	rax, QWORD PTR cur$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	mov	QWORD PTR remainingBytes$[rsp], rax

; 159  : 
; 160  :     if (remainingBytes < size)

	mov	rax, QWORD PTR size$[rsp]
	cmp	QWORD PTR remainingBytes$[rsp], rax
	jae	SHORT $LN2@alloc

; 161  :       return _alloc(size);

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_alloc@Zone@asmjit@@QEAAPEAX_K@Z	; asmjit::Zone::_alloc
	jmp	SHORT $LN1@alloc
$LN2@alloc:

; 162  : 
; 163  :     cur->pos += size;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR cur$[rsp]
	mov	QWORD PTR [rcx], rax

; 164  :     ASMJIT_ASSERT(cur->pos <= cur->end);
; 165  : 
; 166  :     return (void*)ptr;

	mov	rax, QWORD PTR ptr$[rsp]
$LN1@alloc:

; 167  :   }

	add	rsp, 72					; 00000048H
	ret	0
?alloc@Zone@asmjit@@QEAAPEAX_K@Z ENDP			; asmjit::Zone::alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.cpp
_TEXT	SEGMENT
cur$ = 32
next$1 = 40
prev$2 = 48
this$ = 80
releaseMemory$ = 88
?reset@Zone@asmjit@@QEAAX_N@Z PROC			; asmjit::Zone::reset

; 44   : void Zone::reset(bool releaseMemory) {

$LN13:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 45   :   Block* cur = _block;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR cur$[rsp], rax

; 46   : 
; 47   :   // Can't be altered.
; 48   :   if (cur == &Zone_zeroBlock)

	lea	rax, OFFSET FLAT:?Zone_zeroBlock@asmjit@@3UBlock@Zone@1@B
	cmp	QWORD PTR cur$[rsp], rax
	jne	SHORT $LN9@reset

; 49   :     return;

	jmp	$LN1@reset
$LN9@reset:

; 50   : 
; 51   :   if (releaseMemory) {

	movzx	eax, BYTE PTR releaseMemory$[rsp]
	test	eax, eax
	je	SHORT $LN10@reset

; 52   :     // Since cur can be in the middle of the double-linked list, we have to
; 53   :     // traverse to both directions `prev` and `next` separately.
; 54   :     Block* next = cur->next;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR next$1[rsp], rax
$LN4@reset:

; 55   :     do {
; 56   :       Block* prev = cur->prev;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR prev$2[rsp], rax

; 57   :       ASMJIT_FREE(cur);

	mov	rcx, QWORD PTR cur$[rsp]
	call	free

; 58   :       cur = prev;

	mov	rax, QWORD PTR prev$2[rsp]
	mov	QWORD PTR cur$[rsp], rax

; 59   :     } while (cur != NULL);

	cmp	QWORD PTR cur$[rsp], 0
	jne	SHORT $LN4@reset

; 60   : 
; 61   :     cur = next;

	mov	rax, QWORD PTR next$1[rsp]
	mov	QWORD PTR cur$[rsp], rax
$LN5@reset:

; 62   :     while (cur != NULL) {

	cmp	QWORD PTR cur$[rsp], 0
	je	SHORT $LN6@reset

; 63   :       next = cur->next;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR next$1[rsp], rax

; 64   :       ASMJIT_FREE(cur);

	mov	rcx, QWORD PTR cur$[rsp]
	call	free

; 65   :       cur = next;

	mov	rax, QWORD PTR next$1[rsp]
	mov	QWORD PTR cur$[rsp], rax

; 66   :     }

	jmp	SHORT $LN5@reset
$LN6@reset:

; 67   : 
; 68   :     _block = const_cast<Zone::Block*>(&Zone_zeroBlock);

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:?Zone_zeroBlock@asmjit@@3UBlock@Zone@1@B
	mov	QWORD PTR [rax], rcx

; 69   :   }

	jmp	SHORT $LN11@reset
$LN10@reset:
$LN7@reset:

; 70   :   else {
; 71   :     while (cur->prev != NULL)

	mov	rax, QWORD PTR cur$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN8@reset

; 72   :       cur = cur->prev;

	mov	rax, QWORD PTR cur$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR cur$[rsp], rax
	jmp	SHORT $LN7@reset
$LN8@reset:

; 73   : 
; 74   :     cur->pos = cur->data;

	mov	rax, QWORD PTR cur$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, QWORD PTR cur$[rsp]
	mov	QWORD PTR [rcx], rax

; 75   :     _block = cur;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR cur$[rsp]
	mov	QWORD PTR [rax], rcx
$LN11@reset:
$LN1@reset:

; 76   :   }
; 77   : }

	add	rsp, 72					; 00000048H
	ret	0
?reset@Zone@asmjit@@QEAAX_N@Z ENDP			; asmjit::Zone::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.cpp
_TEXT	SEGMENT
this$ = 48
??1Zone@asmjit@@QEAA@XZ PROC				; asmjit::Zone::~Zone

; 36   : Zone::~Zone() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 37   :   reset(true);

	mov	dl, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?reset@Zone@asmjit@@QEAAX_N@Z		; asmjit::Zone::reset
	npad	1

; 38   : }

	add	rsp, 40					; 00000028H
	ret	0
??1Zone@asmjit@@QEAA@XZ ENDP				; asmjit::Zone::~Zone
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.cpp
_TEXT	SEGMENT
this$ = 8
blockSize$ = 16
??0Zone@asmjit@@QEAA@_K@Z PROC				; asmjit::Zone::Zone

; 31   : Zone::Zone(size_t blockSize) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 32   :   _block = const_cast<Zone::Block*>(&Zone_zeroBlock);

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:?Zone_zeroBlock@asmjit@@3UBlock@Zone@1@B
	mov	QWORD PTR [rax], rcx

; 33   :   _blockSize = blockSize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR blockSize$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 34   : }

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0Zone@asmjit@@QEAA@_K@Z ENDP				; asmjit::Zone::Zone
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\AsmJit\base\zone.h
;	COMDAT ?getBlockSize@Block@Zone@asmjit@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?getBlockSize@Block@Zone@asmjit@@QEBA_KXZ PROC		; asmjit::Zone::Block::getBlockSize, COMDAT

; 51   :     ASMJIT_INLINE size_t getBlockSize() const {

	mov	QWORD PTR [rsp+8], rcx

; 52   :       return (size_t)(end - data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	sub	rcx, rax
	mov	rax, rcx

; 53   :     }

	ret	0
?getBlockSize@Block@Zone@asmjit@@QEBA_KXZ ENDP		; asmjit::Zone::Block::getBlockSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
_vsnprintf PROC						; COMDAT

; 1411 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _BufferCount$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1413 :     }

	add	rsp, 56					; 00000038H
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	__stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1397 :     }

	add	rsp, 72					; 00000048H
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
